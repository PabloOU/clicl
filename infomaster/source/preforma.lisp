;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; (c) Copyright 1999-2006 Michael Genesereth.  All rights reserved.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; conforma.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(eval-when (compile load eval)
  (proclaim '(special  *home* *homedir* *bgcolor* *border* *buttons* *cells*)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Sample Data Structure:
;;; (object class
;;;         (slot1 object)
;;;         (slot1 (object class (slot3 object) ... (slot3 object)))
;;;         (slot1 (oneof object ... object))
;;;         (slot1 (taxonomy item ... item))
;;;         (slot1 (between object object))
;;;         (slot1 (substring object))
;;;         ...
;;;         (slot4 object))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; view
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defmethod process (s (command (eql 'view)) postlines)
  (let (obj class structure (*buttons* 0))
    (setq obj (read-value-string (cdr (pop postlines))))
    (setq class (or (read-value-string (cdr (pop postlines))) (classify obj *gui*)))
    (setq structure (reviseitem obj class))
    (output-inspect-page s obj class structure)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; inspect
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; makedoor
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defmethod process (s (file (eql 'makedoor)) postlines)
  (cond ((null (cdr postlines)) (output-makedoor s))
        (t (reissue-makedoor s postlines))))

(defun output-makedoor (s)
  (declare (ignore postlines))
  (let (tree)
    (setq tree (cons 'top (find-classes *gui*)))
    (format-html s) (crlf s)
    (output-head s "Select Class") (crlf s)
    (format-body s *bgcolor*) (crlf s)
    (output-header s)
    (format s "<FORM ACTION=\"Makedoor?\" METHOD=\"POST\">")
    (format-hidden s "Tree" tree)
    (format s "<DL>")
    (dolist (item (cdr tree))
      (format s "<DD>")
      (output-make s item)
      (format s "</DD>"))
    (format s "</DL>")
    (format s "</FORM>")
    (output-footer s)
    (finish-body s) (crlf s)
    (finish-html s) (crlf s)))

(defun reissue-makedoor (s postlines)
  (let (tree command)
    (setq tree (read-user-string (cdr (pop postlines))))
    (setq command (caar postlines))
    (setq command (read-user-string (subseq command 0 (- (length command) 2))))
    (setq tree (make-toggle command tree))
    (format-html s) (crlf s)
    (output-head s "Select Class") (crlf s)
    (format-body s *bgcolor*) (crlf s)
    (output-header s)
    (format s "<FORM ACTION=\"Makedoor?\" METHOD=\"POST\">")
    (format-hidden s "Tree" tree)
    (format s "<DL>")
    (dolist (item (cdr tree))
      (format s "<DD>")
      (output-make s item)
      (format s "</DD>"))
    (format s "</DL>")
    (format s "</FORM>")
    (output-footer s)
    (finish-body s) (crlf s)
    (finish-html s) (crlf s)))

(defun output-make (s tree)
  (cond ((atom tree)
         (cond ((find-make-subclass tree) (output-make-closed s tree))
               ((find-subclass tree) (output-make-empty s tree))
               (t (output-make-bottom s tree))))
        (t (format s "<DL>")
           (format s "<DT>")
           (output-make-open s (car tree))
           (format s "</DT>")
           (dolist (item (cdr tree))
             (format s "<DD>")
             (output-make s item)
             (format s "</DD>"))
           (format s "</DL>"))))

(defun output-make-open (s class)
  (format s "<INPUT TYPE=IMAGE NAME=~A SRC=\"~Aimages/green.gif\" BORDER=\"0\"/>" class *home*)
  (format s "&nbsp;~A" (iconify class)))

(defun output-make-closed (s class)
  (format s "<INPUT TYPE=IMAGE NAME=~A SRC=\"~Aimages/red.gif\" BORDER=\"0\"/>" class *home*)
  (format s "&nbsp;~A" (iconify class)))

(defun output-make-empty (s class)
  (format s "<IMG SRC=\"~Aimages/grey.gif\">" *home*)
  (format s "&nbsp;~A" (iconify class)))

(defun output-make-bottom (s class)
  (format s "<IMG SRC=\"~Aimages/grey.gif\">" *home*)
  (format s "&nbsp;<A HREF=\"Create?Class=~A\">~A</A>"
          (addressify class) (iconify class)))

(defun make-toggle (class tree)
  (cond ((eq class tree) (cons class (find-make-subclasses class)))
        ((atom tree) tree)
        ((eq class (car tree)) class)
        (t (do ((l tree (cdr l)) (nl))
               ((null l) (nreverse nl))
             (setq nl (cons (make-toggle class (car l)) nl))))))

(defun find-make-subclass (class)
  (do ((l (find-subclasses class) (cdr l)))
      ((null l) nil)
    (when (createablep (car l) *gui*) (return (car l)))))

(defun find-make-subclasses (class)
  (do ((l (find-subclasses class) (cdr l)) (nl))
      ((null l) (nreverse nl))
    (when (createablep (car l) *gui*) (setq nl (cons (car l) nl)))))

(defun createablep (class gui)
  (cond ((findp `(nocommand ,gui create) *interface*) nil)
        ((subcreateablep class gui))))

(defun subcreateablep (class agent)
  (let (subclasses)
    (setq subclasses (find-subclasses class))
    (cond (subclasses (some #'(lambda (x) (subcreateablep x agent)) subclasses))
          ((not (findp `(nocreate ,*gui* ,class) *interface*))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; topdoor
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defmethod process (s (file (eql 'topdoor)) postlines)
  (cond ((null (cdr postlines)) (output-topdoor s))
        (t (reissue-topdoor s postlines))))

(defun output-topdoor (s)
  (declare (ignore postlines))
  (let (tree)
    (setq tree (cons 'top (find-classes *gui*)))
    (format-html s) (crlf s)
    (output-head s "Select Class") (crlf s)
    (format-body s *bgcolor*) (crlf s)
    (output-header s)
    (format s "<FORM ACTION=\"TOPDOOR?\" METHOD=\"POST\">")
    (format-hidden s "Tree" tree)
    (format s "<DL>")
    (dolist (item (cdr tree))
      (format s "<DD>")
      (output-top s item)
      (format s "</DD>"))
    (format s "</DL>")
    (format s "</FORM>")
    (output-apropos s)
    (output-footer s)
    (finish-body s) (crlf s)
    (finish-html s) (crlf s)))

(defun reissue-topdoor (s postlines)
  (let (tree command)
    (setq tree (read-user-string (cdr (pop postlines))))
    (setq command (caar postlines))
    (setq command (read-user-string (subseq command 0 (- (length command) 2))))
    (setq tree (front-toggle command tree))
    (format-html s) (crlf s)
    (output-head s "Select Class") (crlf s)
    (format-body s *bgcolor*) (crlf s)
    (output-header s)
    (format s "<FORM ACTION=\"TOPDOOR?\" METHOD=\"POST\">")
    (format-hidden s "Tree" tree)
    (format s "<DL>")
    (dolist (item (cdr tree))
      (format s "<DD>")
      (output-top s item)
      (format s "</DD>"))
    (format s "</DL>")
    (format s "</FORM>")
    (output-apropos s)
    (output-footer s)
    (finish-body s) (crlf s)
    (finish-html s) (crlf s)))

(defun output-top (s tree)
  (cond ((atom tree)
         (if (find-subclass tree) (output-top-closed s tree)
             (output-top-lone s tree)))
        (t (format s "<DL>")
           (format s "<DT>")
           (output-top-open s (car tree))
           (format s "</DT>")
           (dolist (item (cdr tree))
             (format s "<DD>")
             (output-top s item)
             (format s "</DD>"))
           (format s "</DL>"))))

(defun output-top-open (s class)
  (format s "<INPUT TYPE=IMAGE NAME=~A SRC=\"~Aimages/green.gif\" BORDER=\"0\"/>" class *home*)
  (format s "&nbsp;<A HREF=\"SEARCH?Class=~A\">~A</A>"
          (addressify class) (iconify class)))

(defun output-top-closed (s class)
  (format s "<INPUT TYPE=IMAGE NAME=~A SRC=\"~Aimages/red.gif\" BORDER=\"0\"/>" class *home*)
  (format s "&nbsp;<A HREF=\"SEARCH?Class=~A\">~A</A>"
          (addressify class) (iconify class)))

(defun output-top-lone (s class)
  (format s "<IMG SRC=\"~Aimages/grey.gif\">" *home*)
  (format s "&nbsp;<A HREF=\"SEARCH?Class=~A\">~A</A>"
          (addressify class) (iconify class))
  (cond ((findp `(nocommand ,*gui* create) *interface*))
        ((findp `(nocreate ,*gui* ,class) *interface*))
        (*inspector*
         (format s "<NOBR><A HREF=\"CREATOR?Class=~A\"><IMG SRC=\"~Aimages/snowflake.gif\" BORDER=\"0\"/></A>" class *home*))
        (t (format s "<NOBR><A HREF=\"CREATE?Class=~A\"><IMG SRC=\"~Aimages/snowflake.gif\" BORDER=\"0\"/></A>" class *home*))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Search
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defmethod process (s (command (eql 'search)) postlines)
  (cond ((null (cdr postlines)) (process-search-start s postlines))
        ((and (setq command (getf-post "Command" postlines)) nil))
        ((equalp command "Find") (process-search-start s postlines))
        ((equalp command "Expand") (process-search-revision s postlines))
        ((equalp command "Display") (process-search-display s postlines))
        ((equalp command "Textual Searcher") (process-search-textual s postlines))
        ((equalp command "Convert Content") (process-search-content s postlines))
        ((equalp command "Save") (process-search-save s postlines))
        ((equalp command "Drop") (process-search-drop s postlines))
        (t (process-search-revision s postlines))))

(defun process-search-start (s postlines)
  (let (class structure (*buttons* 0) (*cells* 0))
    (setq class (read-user-string (cdar postlines)))
    (setq structure (maksearchstructure (gentemp "?") class))
    (output-search-page s class structure)))

(defun process-search-display (s postlines)
  (let (structure class aspect kif slots objects selections start end count)
    (multiple-value-setq (structure postlines) (parsestructure postlines))
    (setq class (cadr structure))
    (setq aspect (car structure))
    (setq kif (maksand (reconverter structure)))
    (setq start (or (read-value-string (getf-post "Start" postlines)) 1))
    (setq end (or (read-value-string (getf-post "Solutions" postlines)) 20))
    (setq objects (request `(ask-all ,aspect ,kif) *client* *agent*))
    (multiple-value-setq (objects count start end) (trim objects start end))
    (setq selections (find-selections *client* objects))
    (setq slots (displayable-slots class))
    (output-display-page s class aspect kif slots objects selections count start end)))

(defun process-search-textual (s postlines)
  (let (structure (*buttons* 0) (*cells* 0))
    (multiple-value-setq (structure postlines) (parsestructure postlines))
    (output-searcher-page s (cadr structure) structure)))

(defun process-search-content (s postlines)
  (let (structure)
    (multiple-value-setq (structure postlines) (parsestructure postlines))
    (format-html s) (crlf s)
    (output-head s (format nil "Inspector ~A" (prettify (car structure)))) (crlf s)
    (format-body s *bgcolor*) (crlf s)
    (output-header s)
    (format s "<XMP>")
    (print-acl s `(ask-all ,(car structure) ,(maksand (reconverter structure))))
    (format s "</XMP>")
    (output-footer s)
    (finish-body s) (crlf s)
    (finish-html s) (crlf s)))

(defun process-search-save (s postlines)
  (let (structure class items aspect kif target)
    (multiple-value-setq (structure postlines) (parsestructure postlines))
    (setq class (cadr structure))
    (setq aspect (car structure))
    (setq kif (maksand (reconverter structure)))
    (setq target (read-user-string (getf-post "Target" postlines)))
    (setq items (request `(ask-all ,aspect ,kif) *client* *gui*))
    (dolist (x items)
      (save (makpred x (cadr structure) *gui*) (symbol-value target)))
    (dolist (slot (attributes class))
      (dolist (datum (request `(ask-all (,slot ?x ?y) (and (oneof ?x . ,items) (,slot ?x ?y))) *client* *gui*))
        (save datum (symbol-value target))))
    (format-html s) (crlf s)
    (output-head s "Save Data") (crlf s)
    (format-body s *bgcolor*) (crlf s)
    (output-header s)
    (format s "<P>Data saved in ~A.</P>" (prettify target))
    (output-footer s)
    (finish-body s) (crlf s)
    (finish-html s) (crlf s)))

(defun process-search-drop (s postlines)
  (let (structure class items aspect kif target)
    (multiple-value-setq (structure postlines) (parsestructure postlines))
    (setq class (cadr structure))
    (setq aspect (car structure))
    (setq kif (maksand (reconverter structure)))
    (setq target (or (read-user-string (getf-post "Target" postlines)) *warehouse*))
    (setq items (request `(ask-all ,aspect ,kif) *client* *gui*))
    (dolist (x items) (drop (makpred x class target) (symbol-value target)))
    (dolist (slot (attributes class))
      (dolist (datum (request `(ask-all (,slot ?x ?y) (and (oneof ?x . ,items) (,slot ?x ?y))) *client* *gui*))
        (drop datum (symbol-value target))))
    (format-html s) (crlf s)
    (output-head s "Save Data") (crlf s)
    (format-body s *bgcolor*) (crlf s)
    (output-header s)
    (format s "<P>Data dropped from ~A.</P>" (prettify target))
    (output-footer s)
    (finish-body s) (crlf s)
    (finish-html s) (crlf s)))

(defun process-search-revision (s postlines)
  (let (structure class revision (*buttons* 0) (*cells* 0))
    (setq revision (getrevision postlines))
    (setq postlines (remrevision postlines))
    (multiple-value-setq (structure postlines) (parsestructure postlines))
    (setq class (cadr structure))
    (setq structure (revisesearch structure revision))
    (output-search-page s class structure)))


(defun output-search-page (s class structure)
  (format-html s) (crlf s)
  (output-head s "Search") (crlf s)
  (format-body s *bgcolor*) (crlf s)
  (output-header s)
  (format s "<FORM ACTION=\"SEARCH?\" METHOD=\"POST\" NAME=\"form1\">")
  (format s "Find every <B>")
  (output-classlink s class)
  (format s "</B> that satisfies the following criteria.")
  (output-search-structure s structure)
  (format s "<TABLE WIDTH=\"100%\"><TR><TD WIDTH=\"25%\" VALIGN=\"TOP\">")
  (format-button s "Command" "Display")
  (format s "</TD><TD WIDTH=\"25%\" VALIGN=\"TOP\">")
  (unless (findp `(nocommand ,*gui* inspector) *interface*)   
    (format-button s "Command" "Textual Searcher"))
  (format s "</TD><TD WIDTH=\"25%\" VALIGN=\"TOP\">")
  (unless (findp `(nocommand ,*gui* convert) *interface*)
    (format-button s "Command" "Convert Content"))
  (format s "</TD><TD WIDTH=\"25%\" VALIGN=\"TOP\">")
  (unless (findp `(nocommand ,*gui* memory) *interface*)
    (format s "<DL><DT>")
    (format-top-button s "Command" "Save")
    (format-top-button s "Command" "Drop")
    (format s "</DT><DT>")
    (format s "<SELECT NAME=\"Target\">")
    (dolist (option (getbaskets))
      (format s "<OPTION>~A</OPTION>" (stringize option)))
    (format s "</SELECT>")
    (format s "</DT></DL>"))
  (format s "</TD></TR></TABLE>")
  (format s "</FORM>")
  (output-footer s)
  (finish-body s) (crlf s)
  (finish-html s) (crlf s))

(defun output-search-structure (s x)
  (let (flat)
    (setq flat (findp `(nocommand ,*gui* subframe) *interface*))
    (format-hidden s "Start" "")
    (format-hidden s "Object" (stringize (car x)))
    (format-hidden s "Class" (stringize (cadr x)))
    (format s "<P><TABLE CELLSPACING=\"3\">")
    (do ((l (cddr x) (cdr l)) (multivalued) (multiple) (style) (flag))
        ((null l))
      (format s "<TR><TH ALIGN=\"LEFT\" VALIGN=\"TOP\">")
      (unless (eq (caar l) flag)
        (setq multivalued (find-multivalued (caar l)))
        (setq style (find-searchstyle (caar l)))
        (output-slotlink s (caar l)))
      (setq multiple (or (eq (caar l) flag) (eq (caar l) (caadr l))))
      (setq flag (caar l))
      (cond ((null (cdar l))
             (format s "</TH><TD VALIGN=\"TOP\">")
             (output-another-button s (incf *buttons*) multivalued)
             (output-removal-button s (incf *buttons*) multiple)
             (if flat (incf *buttons*) (output-plus-button s (incf *buttons*)))
             (format s "</TD><TD>")
             (output-search-cell s style (caar l) 'unknown (cadr x))
             (incf *cells*))
            ((or (atom (cadar l)) (find (caadar l) '(oneof taxonomy between substring)))
             (format s "</TH><TD VALIGN=\"TOP\">")
             (output-another-button s (incf *buttons*) multivalued)
             (output-removal-button s (incf *buttons*) multiple)
             (if flat (incf *buttons*) (output-plus-button s (incf *buttons*)))
             (format s "</TD><TD>")
             (output-search-cell s style (caar l) (cadar l) (cadr x))
             (incf *cells*))
            (t (format s "</TH><TD VALIGN=\"TOP\">")
               (output-snow-button s (incf *buttons*))
               (output-trash-button s (incf *buttons*))
               (output-minus-button s (incf *buttons*))
               (format s "</TD><TD>")
               (format s "<TABLE BORDER><TR><TD>")
               (format-hidden s "Start" "")
               (format-hidden s "Style" "Subframe")
               (format-hidden s "Slot" (stringize (caar l)))
               (format s "~A <B>" (article (cadr (cadar l))))
               (output-classlink s (cadr (cadar l)))
               (format s "</B> that satisfies the following criteria<BR/>")
               (output-search-structure s (cadar l))
               (format s "</TD></TR></TABLE>")))
      (format s "</TD></TR>")
      (crlf s))
    (format s "</TABLE>")
    (format-hidden s "End" "")))


(defun output-search-cell (s style slot value class)
  (cond ((eq style 'menu) (output-search-menu s slot value))
        ((eq style 'multichoicelist) (output-search-menu s slot value))
        ((eq style 'selector) (output-search-selector s slot value class))
        ((eq style 'dropdownlist) (output-search-selector s slot value class))
        ((eq style 'hierarchicalselector) (output-search-multiselector s slot value))
        ((eq style 'checkbox) (output-search-checkbox s slot value))
        ((eq style 'radiobutton) (output-search-radiobutton s slot value))
        ((eq style 'interval) (output-search-typein s slot value))
        ((eq style 'textarea) (output-search-textarea s slot value))
        ((eq style 'stringfield) (output-search-text s slot value))
        ((eq style 'text) (output-search-text s slot value))
        ((eq style 'urlstyle) (output-search-text s slot value))
        ((eq style 'password) (output-search-password s slot value))
        ((eq style 'glyph) (output-search-glyph s slot value))
        (t (output-search-typein s slot value))))

(defun output-search-menu (s slot value)
  (format-hidden s "Start" (stringize *cells*))
  (format-hidden s "Style" "Menu")
  (format-hidden s "Slot" (stringize slot))
  (output-menu s *cells* (find-values slot) (list value))
  (format-hidden s "End" ""))

(defun output-search-selector (s slot value class)
  (format-hidden s "Start" (stringize *cells*))
  (format-hidden s "Style" "Selector")
  (format-hidden s "Slot" (stringize slot))
  (output-selector s *cells* (find-possibilities slot class) value)
  (format-hidden s "End" ""))

(defun output-search-multiselector (s slot value)
  (let (references options)
    (format-hidden s "Start" (stringize *cells*))
    (format-hidden s "Style" "Multiselector")
    (format-hidden s "Slot" (stringize slot))
    (cond ((atom value) (setq references (find-references slot value)))
          (t (setq references (cdr value) value (car (last value)))))
    (cond ((null references) (setq options (find-options slot)))
          (t (setq options (find-components slot (car (last references)) references))))
    (dolist (ref references) (format-hidden s "Reference" (stringize ref)))
    (output-selector s *cells* (nconc references (cons 'unknown options)) value)
    (format-button s "Command" "Expand")
    (format-hidden s "End" "")))

(defun output-search-checkbox (s slot value)
  (format-hidden s "Start" (stringize *cells*))
  (format-hidden s "Style" "Checkbox")
  (format-hidden s "Slot" (stringize slot))
  (output-checkboxes s *cells* (find-values slot) (list value))
  (format-hidden s "End" ""))

(defun output-search-radiobutton (s slot value)
  (format-hidden s "Start" (stringize *cells*))
  (format-hidden s "Style" "Radiobutton")
  (format-hidden s "Slot" (stringize slot))
  (output-radiobuttons s *cells* (find-values slot) value)
  (format-hidden s "End" ""))

(defun output-search-textarea (s slot value)
  (when (eq value 'unknown) (setq value ""))
  (format-hidden s "Start" (stringize *cells*))
  (format-hidden s "Style" "Textarea")
  (format-hidden s "Slot" (stringize slot))
  (format-textarea s (stringize *cells*) (htmlify value) 8 60)
  (format-hidden s "End" ""))

(defun output-search-text (s slot value)
  (when (eq value 'unknown) (setq value ""))
  (format-hidden s "Start" (stringize *cells*))
  (format-hidden s "Style" "Text")
  (format-hidden s "Slot" (stringize slot))
  (format-text s (stringize *cells*) (htmlify value) 40)
  (format-hidden s "End" ""))

(defun output-search-password (s slot value)
  (format-hidden s "Start" (stringize *cells*))
  (format-hidden s "Style" "Password")
  (format-hidden s "Slot" (stringize slot))
  (format-password s (stringize *cells*) (htmlify value) 40)
  (format-hidden s "End" ""))

(defun output-search-typein (s slot value)
  (format-hidden s "Start" (stringize *cells*))
  (format-hidden s "Style" "Typein")
  (format-hidden s "Slot" (stringize slot))
  (format-text s (stringize *cells*) (stringize value) 40)
  (format-hidden s "End" ""))

(defun output-search-glyph (s slot value)
  (format-hidden s "Start" (stringize *cells*))
  (format-hidden s "Style" "Glyph")
  (format-hidden s "Slot" (stringize slot))
  (format-hidden s "Value" (stringize value))
  (output-value s value)
  (format-hidden s "End" ""))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Frontdoor
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defmethod process (s (file (eql 'frontdoor)) postlines)
  (cond ((null (cdr postlines)) (output-frontdoor s))
        (t (reissue-frontdoor s postlines))))

(defun output-frontdoor (s)
  (declare (ignore postlines))
  (let (tree)
    (setq tree (cons 'top (find-classes *gui*)))
    (format-html s) (crlf s)
    (output-head s "Select Class") (crlf s)
    (format-body s *bgcolor*) (crlf s)
    (output-header s)
    (format s "<FORM ACTION=\"Frontdoor?\" METHOD=\"POST\">")
    (format-hidden s "Tree" tree)
    (format s "<DL>")
    (dolist (item (cdr tree))
      (format s "<DD>")
      (output-front s item)
      (format s "</DD>"))
    (format s "</DL>")
    (format s "</FORM>")
    (output-apropos s)
    (output-footer s)
    (finish-body s) (crlf s)
    (finish-html s) (crlf s)))

(defun reissue-frontdoor (s postlines)
  (let (tree command)
    (setq tree (read-user-string (cdr (pop postlines))))
    (setq command (caar postlines))
    (setq command (read-user-string (subseq command 0 (- (length command) 2))))
    (setq tree (front-toggle command tree))
    (format-html s) (crlf s)
    (output-head s "Select Class") (crlf s)
    (format-body s *bgcolor*) (crlf s)
    (output-header s)
    (format s "<FORM ACTION=\"Frontdoor?\" METHOD=\"POST\">")
    (format-hidden s "Tree" tree)
    (format s "<DL>")
    (dolist (item (cdr tree))
      (format s "<DD>")
      (output-front s item)
      (format s "</DD>"))
    (format s "</DL>")
    (format s "</FORM>")
    (output-apropos s)
    (output-footer s)
    (finish-body s) (crlf s)
    (finish-html s) (crlf s)))

(defun output-front (s tree)
  (cond ((atom tree)
         (if (find-subclass tree) (output-front-closed s tree)
             (output-front-lone s tree)))
        (t (format s "<DL>")
           (format s "<DT>")
           (output-front-open s (car tree))
           (format s "</DT>")
           (dolist (item (cdr tree))
             (format s "<DD>")
             (output-front s item)
             (format s "</DD>"))
           (format s "</DL>"))))

(defun output-front-open (s class)
  (format s "<INPUT TYPE=IMAGE NAME=~A SRC=\"~Aimages/green.gif\" BORDER=\"0\"/>" class *home*)
  (format s "&nbsp;<A HREF=\"Front?Class=~A\">~A</A>"
          (addressify class) (iconify class)))

(defun output-front-closed (s class)
  (format s "<INPUT TYPE=IMAGE NAME=~A SRC=\"~Aimages/red.gif\" BORDER=\"0\"/>" class *home*)
  (format s "&nbsp;<A HREF=\"Front?Class=~A\">~A</A>"
          (addressify class) (iconify class)))

(defun output-front-lone (s class)
  (format s "<IMG SRC=\"~Aimages/grey.gif\">" *home*)
  (format s "&nbsp;<A HREF=\"Front?Class=~A\">~A</A>"
          (addressify class) (iconify class)))

(defun front-toggle (class tree)
  (cond ((eq class tree) (cons class (find-subclasses class)))
        ((atom tree) tree)
        ((eq class (car tree)) class)
        (t (do ((l tree (cdr l)) (nl))
               ((null l) (nreverse nl))
             (setq nl (cons (front-toggle class (car l)) nl))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Front
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defmethod process (s (action (eql 'front)) postlines)
  (format s "<HTML>
<HEAD>
<TITLE>~A - Search</TITLE>
</HEAD>
<FRAMESET COLS=\"*\" ROWS=\"97,*,36\" NAME=\"outer\" FRAMESPACING=\"0\" FRAMEBORDER=\"0\">
<FRAME SRC=\"Header?\" NAME=\"header\" SCROLLING=\"no\" MARGINHEIGHT=\"0\" MARGINWIDTH=\"0\">
<FRAMESET COLS=\"190,*,190\" ROWS=\"*\" NAME=\"inner\" FRAMESPACING=\"0\" FRAMEBORDER=\"4\"> 
<FRAME SRC=\"Fronttree?\" NAME=\"tree\" SCROLLING=\"auto\">
<FRAME SRC=\"~A\" NAME=\"query\" SCROLLING=\"auto\">
<FRAME SRC=\"~Apages/empty.html\" NAME=\"result\" SCROLLING=\"auto\">
</FRAMESET> 
<FRAME SRC=\"Footer?\" NAME=\"footer\" SCROLLING=\"no\" MARGINHEIGHT=\"0\" MARGINWIDTH=\"0\">
</FRAMESET>
</HTML>"
          (prettify *gui*)
          (if postlines (stringappend "refind?Class=" (cdar postlines))
              (stringappend *home* "pages/search.html"))
          *home*))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Header
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defmethod process (s (action (eql 'header)) postlines)
  (declare (ignore postlines))
  (format s "<BODY BGCOLOR=\"WHITE\">")
  (format s (find-header *gui*))
  (format s "</BODY>")
  (crlf s))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Footer
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defmethod process (s (action (eql 'footer)) postlines)
  (declare (ignore postlines))
  (format s "<BODY BGCOLOR=\"WHITE\">")
  (format s (find-footer *gui*))
  (format s "</BODY>")
  (crlf s))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Fronttree
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defmethod process (s (action (eql 'fronttree)) postlines)
  (cond ((null (cdr postlines)) (process-fronttree-taxonomy s))
        (t (process-fronttree-revision s postlines))))

(defun process-fronttree-taxonomy (s)
  (let (tree)
    (setq tree (cons 'top (find-classes *gui*)))
    (format s "<BODY BGCOLOR=\"WHITE\">")
    (format s "<FORM ACTION=Fronttree? METHOD=POST NAME=formtree>")
    (format-hidden s "Tree" tree)
    (format s "<CENTER>")
    (cond ((findp `(nocommand ,*gui* metalevel) *interface*))
          ((findp `(nocommand ,(name *interface*) inspect) *interface*)
           (format s "<A HREF=\"/~A/UPDATER?Object=~A\" target=\"_blank\"><IMG SRC=\"~Aimages/pencil.gif\" BORDER=\"0\"/></A>"
                   (addressify (name *interface*)) (addressify *gui*) *home*))
          (t (format s "<A HREF=\"/~A/CHANGE?Object=~A\" target=\"_blank\"><IMG SRC=\"~Aimages/pencil.gif\" BORDER=\"0\"/></A>"
                     (addressify (name *interface*)) (addressify *gui*) *home*)))
    (format s "<B>~A</B></CENTER><BR/>" (prettify *gui*))
    (dolist (item (cdr tree))
      (format s "<DT>")
      (output-front-narrow s item))
    (format s "</FORM>")
    (format s "</BODY>")
    (crlf s)))

(defun process-fronttree-revision (s postlines)
  (let (tree command)
    (setq tree (read-user-string (cdr (pop postlines))))
    (setq command (caar postlines))
    (setq command (read-user-string (subseq command 0 (- (length command) 2))))
    (setq tree (front-toggle command tree))
    (format s "<BODY BGCOLOR=\"WHITE\">")
    (format s "<FORM ACTION=fronttree? METHOD=POST NAME=formtree>")
    (format-hidden s "Tree" tree)
    (format s "<CENTER>")
    (cond ((findp `(nocommand ,*gui* metalevel) *interface*))
          ((findp `(nocommand ,(name *interface*) inspect) *interface*)
           (format s "<A HREF=\"/~A/UPDATER?Object=~A\" target=\"_blank\"><IMG SRC=\"~Aimages/pencil.gif\" BORDER=\"0\"/></A>"
                   (addressify (name *interface*)) (addressify *gui*) *home*))
          (t (format s "<A HREF=\"/~A/CHANGE?Object=~A\" target=\"_blank\"><IMG SRC=\"~Aimages/pencil.gif\" BORDER=\"0\"/></A>"
                     (addressify (name *interface*)) (addressify *gui*) *home*)))
    (format s "<B>~A</B></CENTER><BR/>" (prettify *gui*))
    (dolist (item (cdr tree))
      (format s "<DT>")
      (output-front-narrow s item))
    (format s "</FORM>")
    (format s "</BODY>")))

(defun output-front-narrow (s tree)
  (cond ((atom tree)
         (if (find-subclass tree) (output-narrow-closed s tree)
             (output-narrow-lone s tree)))
        (t (format s "<DL>")
           (format s "<DT>")
           (output-narrow-open s (car tree))
           (dolist (item (cdr tree))
             (format s "<DD>")
             (output-front-narrow s item))
           (format s "</DL>"))))

(defun output-narrow-open (s class)
  (format s "<INPUT TYPE=IMAGE NAME=~A SRC=\"~Aimages/green.gif\" BORDER=\"0\"/>" class *home*)
  (format s "&nbsp;<A HREF=\"REFIND?Class=~A\" TARGET=\"query\">~A</A>"
          (addressify class) (shortify class)))

(defun output-narrow-closed (s class)
  (format s "<INPUT TYPE=IMAGE NAME=~A SRC=\"~Aimages/red.gif\" BORDER=\"0\"/>" class *home*)
  (format s "&nbsp;<A HREF=\"REFIND?Class=~A\" TARGET=\"query\">~A</A>"
          (addressify class) (shortify class)))

(defun output-narrow-lone (s class)
  (format s "<IMG SRC=\"~Aimages/grey.gif\">" *home*)
  (format s "&nbsp;<A HREF=\"REFIND?Class=~A\" TARGET=\"query\">~A</A>"
          (addressify class) (shortify class)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Sidedoor
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defmethod process (s (file (eql 'sidedoor)) postlines)
  (cond ((null (cdr postlines)) (output-sidedoor s))
        (t (reissue-sidedoor s postlines))))

(defun output-sidedoor (s)
  (declare (ignore postlines))
  (let (tree)
    (setq tree (cons 'top (find-classes *gui*)))
    (format-html s) (crlf s)
    (output-head s "Select Class") (crlf s)
    (format-body s *bgcolor*) (crlf s)
    (output-header s)
    (format s "<FORM ACTION=\"SIDEDOOR?\" METHOD=\"POST\">")
    (format-hidden s "Tree" tree)
    (format s "<DL>")
    (dolist (item (cdr tree))
      (format s "<DD>")
      (output-side s item)
      (format s "</DD>"))
    (format s "</DL>")
    (format s "</FORM>")
    (output-apropos s)
    (output-footer s)
    (finish-body s) (crlf s)
    (finish-html s) (crlf s)))

(defun reissue-sidedoor (s postlines)
  (let (tree command)
    (setq tree (read-user-string (cdr (pop postlines))))
    (setq command (caar postlines))
    (setq command (read-user-string (subseq command 0 (- (length command) 2))))
    (setq tree (side-toggle command tree))
    (format-html s) (crlf s)
    (output-head s "Select Class") (crlf s)
    (format-body s *bgcolor*) (crlf s)
    (output-header s)
    (format s "<FORM ACTION=\"SIDEDOOR?\" METHOD=\"POST\">")
    (format-hidden s "Tree" tree)
    (format s "<DL>")
    (dolist (item (cdr tree))
      (format s "<DD>")
      (output-side s item)
      (format s "</DD>"))
    (format s "</DL>")
    (format s "</FORM>")
    (output-apropos s)
    (output-footer s)
    (finish-body s) (crlf s)
    (finish-html s) (crlf s)))

(defun output-side (s tree)
  (cond ((atom tree)
         (cond ((find-side-subclass tree) (output-side-closed s tree))
               ((find-subclass tree) (output-side-empty s tree))
               ((nonemptyp tree *gui*) (output-side-search s tree))
               (t (output-side-bottom s tree))))
        (t (format s "<DL>")
           (format s "<DT>")
           (output-side-open s (car tree))
           (format s "</DT>")
           (dolist (item (cdr tree))
             (format s "<DD>")
             (output-side s item)
             (format s "</DD>"))
           (format s "</DL>"))))

(defun output-side-open (s class)
  (format s "<INPUT TYPE=IMAGE NAME=~A SRC=\"~Aimages/green.gif\" BORDER=\"0\"/>" class *home*)
  (format s "&nbsp;~A" (iconify class)))

(defun output-side-closed (s class)
  (format s "<INPUT TYPE=IMAGE NAME=~A SRC=\"~Aimages/red.gif\" BORDER=\"0\"/>" class *home*)
  (format s "&nbsp;~A" (iconify class)))

(defun output-side-empty (s class)
  (format s "<IMG SRC=\"~Aimages/grey.gif\">" *home*)
  (format s "&nbsp;~A" (iconify class)))

(defun output-side-search (s class)
  (format s "<IMG SRC=\"~Aimages/grey.gif\">" *home*)
  (format s "&nbsp;<A HREF=\"SIDE?Class=~A\">~A</A>"
          (addressify class) (iconify class)))

(defun output-side-bottom (s class)
  (format s "<IMG SRC=\"~Aimages/grey.gif\">" *home*)
  (format s "&nbsp;~A" (iconify class)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun side-toggle (class tree)
  (cond ((eq class tree) (cons class (find-side-subclasses class)))
        ((atom tree) tree)
        ((eq class (car tree)) class)
        (t (do ((l tree (cdr l)) (nl))
               ((null l) (nreverse nl))
             (setq nl (cons (side-toggle class (car l)) nl))))))

(defun find-side-subclass (class)
  (do ((l (find-subclasses class) (cdr l)))
      ((null l) nil)
    (when (usablep (car l) *gui*) (return (car l)))))

(defun find-side-subclasses (class)
  (do ((l (find-subclasses class) (cdr l)) (nl))
      ((null l) (nreverse nl))
    (when (usablep (car l) *gui*) (setq nl (cons (car l) nl)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defmethod usablep (class agent)
  (let (classes)
    (cond ((setq classes (find-subclasses class))
           (some #'(lambda (x) (usablep x agent)) classes))
          (t (nonemptyp class agent)))))

(defmethod usablep (class (agent symbol))
  (cond ((and (boundp agent) (not (symbolp (symbol-value agent))))
         (usablep class (symbol-value agent)))
        (t (call-next-method class agent))))

(defmethod usablep (class (agent translator))
  (let (target)
    (setq target (find-target (name agent)))
    (cond ((usablep class target))
          (t (usableviewp class agent (get-rulebase agent))))))

(defmethod usablep (class (agent transformer))
  (let (target)
    (setq target (find-target (name agent)))
    (cond ((usablep class target))
          (t (usableviewp class agent (get-rulebase agent))))))

(defmethod usablep (class (agent interface))
  (usablep class (find-target (name agent))))

(defun usableviewp (class agent rulebase)
  (let (classes predicate)
    (cond ((setq classes (find-subclasses class))
           (some #'(lambda (x) (usableviewp x agent rulebase)) classes))
          ((and (setq predicate (find-predicate class))
                (rulep predicate rulebase))
           (request `(ask-if ,(list predicate '?x)) nil agent)))))

(defun doubleviewp (class agent upper lower)
  (let (classes predicate)
    (cond ((setq classes (find-subclasses class))
           (some #'(lambda (x) (doubleviewp x agent upper lower)) classes))
          ((and (setq predicate (find-predicate class))
                (or (rulep predicate upper) (rulep predicate lower)))
           (request `(ask-if ,(list predicate '?x)) nil agent)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun find-visible-subclasses (class)
  (do ((l (find-subclasses class) (cdr l)) (nl))
      ((null l) (nreverse nl))
    (when (visiblep (car l) *gui*) (setq nl (cons (car l) nl)))))

(defmethod visiblep (class agent)
  (let (classes)
    (cond ((setq classes (find-subclasses class))
           (some #'(lambda (x) (visiblep x agent)) classes))
          (t (nonemptyp class agent)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defmethod nonemptyp (class agent)
  (nonemptytablep (find-predicate class) agent))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defmethod nonemptytablep (table agent)
  (request `(ask-if ,(list table '@l)) nil agent))

(defmethod nonemptytablep (table (agent symbol))
  (cond ((and (boundp agent) (not (symbolp (symbol-value agent))))
         (nonemptytablep table (symbol-value agent)))
        (t (call-next-method table agent))))

(defmethod nonemptytablep (table (agent fastserver))
  (tablep table agent))

(defmethod nonemptytablep (table (agent dataserver))
  (tablep table agent))

(defmethod nonemptytablep (table (agent ruleserver))
  (cond ((tablep table agent))
        ((rulep table agent) (findp (list table '@l) agent))))

(defmethod nonemptytablep (table (agent fullserver))
  (cond ((tablep table agent))
        ((rulep table agent) (findp (list table '@l) agent))))

(defmethod nonemptytablep (table (agent translator))
  (cond ((rulep table (find-rulebase (name agent)))
         (request `(ask-if ,(list table '@l)) nil agent))
        (t (nonemptytablep table (find-target (name agent))))))

(defmethod nonemptytablep (table (agent transformer))
  (let (target)
    (setq target (find-target (name agent)))
    (cond ((specialishp target table)
           (nonemptytablep table target))
          ((rulep table (find-rulebase (name agent)))
           (request `(ask-if ,(list table '@l)) nil agent)))))

(defmethod nonemptytablep (table (agent facilitator))
  (let (target)
    (cond ((setq target (findx '?a `(specialty ?a ,table) *manager*))
           (nonemptytablep table target))
          ((rulep table (find-rulebase (name agent)))
           (request `(ask-if ,(list table '@l)) nil agent)))))

(defmethod nonemptytablep (table (agent interface))
  (nonemptytablep table (find-target (name agent))))

(defun pivotishp (agent table)
  (let ((*order* nil))
    (findp `(and (pivot ?a ,table) (same ?a ,agent)) *manager*)))

(defun specialishp (agent table)
  (let ((*order* nil))
    (findp `(and (specialty ?a ,table) (same ?a ,agent)) *manager*)))

(defun rulep (table agent)
  (do ((l (indexees table agent) (cdr l)))
      ((null l) nil)
    (when (and (listp (car l)) (eq (caar l) '<=)
               (listp (cadar l)) (eq (caadar l) table))
      (return t))))

(defun tablep (table agent)
  (do ((l (indexees table agent) (cdr l)))
      ((null l) nil)
    (when (and (listp (car l)) (eq (caar l) table)) (return t))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Side
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defmethod process (s (action (eql 'side)) postlines)
  (format s "<HTML>
<HEAD>
<TITLE>~A - Search</TITLE>
</HEAD>
<FRAMESET COLS=\"*\" ROWS=\"97,*,36\" NAME=\"outer\" FRAMESPACING=\"0\" FRAMEBORDER=\"0\">
<FRAME SRC=\"header?\" NAME=\"header\" SCROLLING=\"no\" MARGINHEIGHT=\"0\" MARGINWIDTH=\"0\">
<FRAMESET COLS=\"190,*,190\" ROWS=\"*\" NAME=\"inner\" FRAMESPACING=\"0\" FRAMEBORDER=\"4\"> 
<FRAME SRC=\"Sidetree?\" NAME=\"tree\" SCROLLING=\"auto\">
<FRAME SRC=\"~A\" NAME=\"query\" SCROLLING=\"auto\">
<FRAME SRC=\"~Apages/empty.html\" NAME=\"result\" SCROLLING=\"auto\">
</FRAMESET> 
<FRAME SRC=\"footer?\" NAME=\"footer\" SCROLLING=\"no\" MARGINHEIGHT=\"0\" MARGINWIDTH=\"0\">
</FRAMESET>
</HTML>"
          (prettify *gui*)
          (if postlines (stringappend "refind?Class=" (cdar postlines))
              (stringappend *home* "pages/search.html"))
          *home*))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Sidetree
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defmethod process (s (action (eql 'sidetree)) postlines)
  (cond ((null (cdr postlines)) (process-sidetree-taxonomy s))
        (t (process-sidetree-revision s postlines))))

(defun process-sidetree-taxonomy (s)
  (let (tree)
    (setq tree (cons 'top (find-classes *gui*)))
    (format s "<BODY BGCOLOR=\"WHITE\">")
    (format s "<FORM ACTION=Sidetree? METHOD=POST NAME=formtree>")
    (format-hidden s "Tree" tree)
    (format s "<CENTER>")
    (cond ((findp `(nocommand ,*gui* metalevel) *interface*))
          ((findp `(nocommand ,(name *interface*) inspect) *interface*)
           (format s "<A HREF=\"/~A/UPDATER?Object=~A\" target=\"_blank\"><IMG SRC=\"~Aimages/pencil.gif\" BORDER=\"0\"/></A>"
                   (addressify (name *interface*)) (addressify *gui*) *home*))
          (t (format s "<A HREF=\"/~A/CHANGE?Object=~A\" target=\"_blank\"><IMG SRC=\"~Aimages/pencil.gif\" BORDER=\"0\"/></A>"
                     (addressify (name *interface*)) (addressify *gui*) *home*)))
    (format s "<B>~A</B></CENTER><BR/>" (prettify *gui*))
    (dolist (item (cdr tree))
      (format s "<DT>")
      (output-side-narrow s item))
    (format s "</FORM>")
    (format s "</BODY>")
    (crlf s)))

(defun process-sidetree-revision (s postlines)
  (let (tree command)
    (setq tree (read-user-string (cdr (pop postlines))))
    (setq command (caar postlines))
    (setq command (read-user-string (subseq command 0 (- (length command) 2))))
    (setq tree (side-toggle command tree))
    (format s "<BODY BGCOLOR=\"WHITE\">")
    (format s "<FORM ACTION=Sidetree? METHOD=POST NAME=formtree>")
    (format-hidden s "Tree" tree)
    (format s "<CENTER>")
    (cond ((findp `(nocommand ,*gui* metalevel) *interface*))
          ((findp `(nocommand ,(name *interface*) inspect) *interface*)
           (format s "<A HREF=\"/~A/UPDATER?Object=~A\" target=\"_blank\"><IMG SRC=\"~Aimages/pencil.gif\" BORDER=\"0\"/></A>"
                   (addressify (name *interface*)) (addressify *gui*) *home*))
          (t (format s "<A HREF=\"/~A/CHANGE?Object=~A\" target=\"_blank\"><IMG SRC=\"~Aimages/pencil.gif\" BORDER=\"0\"/></A>"
                     (addressify (name *interface*)) (addressify *gui*) *home*)))
    (format s "<B>~A</B></CENTER><BR/>" (prettify *gui*))
    (dolist (item (cdr tree))
      (format s "<DT>")
      (output-side-narrow s item))
    (format s "</FORM>")
    (format s "</BODY>")))

(defun output-side-narrow (s tree)
  (cond ((atom tree)
         (cond ((find-side-subclass tree) (output-side-narrow-closed s tree))
               ((find-subclass tree) (output-side-narrow-empty s tree))
               (t (output-side-narrow-bottom s tree))))
        (t (format s "<DL>")
           (format s "<DT>")
           (output-side-narrow-open s (car tree))
           (dolist (item (cdr tree))
             (format s "<DD>")
             (output-side-narrow s item))
           (format s "</DL>"))))

(defun output-side-narrow-open (s class)
  (format s "<INPUT TYPE=IMAGE NAME=~A SRC=\"~Aimages/green.gif\" BORDER=\"0\"/>" class *home*)
  (format s "&nbsp;~A" (shortify class)))

(defun output-side-narrow-closed (s class)
  (format s "<INPUT TYPE=IMAGE NAME=~A SRC=\"~Aimages/red.gif\" BORDER=\"0\"/>" class *home*)
  (format s "&nbsp;~A" (shortify class)))

(defun output-side-narrow-empty (s class)
  (format s "<IMG SRC=\"~Aimages/grey.gif\">" *home*)
  (format s "&nbsp;~A" (shortify class)))

(defun output-side-narrow-bottom (s class)
  (format s "<IMG SRC=\"~Aimages/grey.gif\">" *home*)
  (format s "&nbsp;<A HREF=\"REFIND?Class=~A\" TARGET=\"query\">~A</A>"
          (addressify class) (shortify class)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Backdoor
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defmethod process (s (file (eql 'backdoor)) postlines)
  (cond ((null (cdr postlines)) (output-backdoor s))
        (t (reissue-backdoor s postlines))))

(defun output-backdoor (s)
  (declare (ignore postlines))
  (let (tree)
    (setq tree (cons 'top (find-classes *gui*)))
    (format-html s) (crlf s)
    (output-head s "Select Class") (crlf s)
    (format-body s *bgcolor*) (crlf s)
    (output-header s)
    (format s "<FORM ACTION=\"Backdoor?\" METHOD=\"POST\">")
    (format-hidden s "Tree" tree)
    (format s "<DL>")
    (dolist (item (cdr tree))
      (format s "<DD>")
      (output-back s item)
      (format s "</DD>"))
    (format s "</DL>")
    (format s "</FORM>")
    (output-apropos s)
    (output-footer s)
    (finish-body s) (crlf s)
    (finish-html s) (crlf s)))

(defun reissue-backdoor (s postlines)
  (let (tree command)
    (setq tree (read-user-string (cdr (pop postlines))))
    (setq command (caar postlines))
    (setq command (read-user-string (subseq command 0 (- (length command) 2))))
    (setq tree (back-toggle command tree))
    (format-html s) (crlf s)
    (output-head s "Select Class") (crlf s)
    (format-body s *bgcolor*) (crlf s)
    (output-header s)
    (format s "<FORM ACTION=\"Backdoor?\" METHOD=\"POST\">")
    (format-hidden s "Tree" tree)
    (format s "<DL>")
    (dolist (item (cdr tree))
      (format s "<DD>")
      (output-back s item)
      (format s "</DD>"))
    (format s "</DL>")
    (format s "</FORM>")
    (output-apropos s)
    (output-footer s)
    (finish-body s) (crlf s)
    (finish-html s) (crlf s)))

(defun output-back (s tree)
  (cond ((atom tree)
         (if (find-back-subclass tree) (output-back-closed s tree)
             (output-back-lone s tree)))
        (t (format s "<DL>")
           (format s "<DT>")
           (output-back-open s (car tree))
           (format s "</DT>")
           (dolist (item (cdr tree))
             (format s "<DD>")
             (output-back s item)
             (format s "</DD>"))
           (format s "</DL>"))))

(defun output-back-open (s class)
  (format s "<INPUT TYPE=IMAGE NAME=~A SRC=\"~Aimages/green.gif\" BORDER=\"0\"/>" class *home*)
  (format s "&nbsp;<A HREF=\"conSEEK?Class=~A\">~A</A>"
          (addressify class) (iconify class)))

(defun output-back-closed (s class)
  (format s "<INPUT TYPE=IMAGE NAME=~A SRC=\"~Aimages/red.gif\" BORDER=\"0\"/>" class *home*)
  (format s "&nbsp;<A HREF=\"conSEEK?Class=~A\">~A</A>"
          (addressify class) (iconify class)))

(defun output-back-lone (s class)
  (format s "<IMG SRC=\"~Aimages/grey.gif\">" *home*)
  (format s "&nbsp;<A HREF=\"conSEEK?Class=~A\">~A</A>"
          (addressify class) (iconify class)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun back-toggle (class tree)
  (cond ((eq class tree) (cons class (find-back-subclasses class)))
        ((atom tree) tree)
        ((eq class (car tree)) class)
        (t (do ((l tree (cdr l)) (nl))
               ((null l) (nreverse nl))
             (setq nl (cons (back-toggle class (car l)) nl))))))

(defun find-back-subclass (class)
  (do ((l (find-subclasses class) (cdr l)))
      ((null l) nil)
    (when (searchablep (car l) *gui*) (return (car l)))))

(defun find-back-subclasses (class)
  (do ((l (find-subclasses class) (cdr l)) (nl))
      ((null l) (nreverse nl))
    (when (searchablep (car l) *gui*) (setq nl (cons (car l) nl)))))

(defun searchablep (class gui)
  (request `(ask-one t ,(makpred '?x class gui)) nil gui))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun find-classes (interface)
  (finds '?c `(rootclass ,interface ?c) *interface*))

(defun find-tables (interface)
  (finds '?c `(rootrelation ,interface ?c) *interface*))

(defun find-selections (client objects)
  (viewfinds '?x `(and (oneof ?x . ,objects) (interested ,client ?x)) *manager*))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Seek
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defmethod process (s (action (eql 'conseek)) postlines)
  (format s "<HTML>
<HEAD>
<TITLE>~A - Search</TITLE>
</HEAD>
<FRAMESET COLS=\"*\" ROWS=\"97,*,36\" NAME=\"outer\" FRAMESPACING=\"0\" FRAMEBORDER=\"0\">
<FRAME SRC=\"header?\" NAME=\"header\" SCROLLING=\"no\" MARGINHEIGHT=\"0\" MARGINWIDTH=\"0\">
<FRAMESET COLS=\"190,*,190\" ROWS=\"*\" NAME=\"inner\" FRAMESPACING=\"0\" FRAMEBORDER=\"4\"> 
<FRAME SRC=\"tree?\" NAME=\"tree\" SCROLLING=\"auto\">
<FRAME SRC=\"~A\" NAME=\"query\" SCROLLING=\"auto\">
<FRAME SRC=\"/pages/empty.html\" NAME=\"result\" SCROLLING=\"auto\">
</FRAMESET> 
<FRAME SRC=\"footer?\" NAME=\"footer\" SCROLLING=\"no\" MARGINHEIGHT=\"0\" MARGINWIDTH=\"0\">
</FRAMESET>
</HTML>"
          (prettify *gui*)
          (if postlines (stringappend "refind?Class=" (cdar postlines))
              (stringappend *home* "pages/search.html"))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Tree
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defmethod process (s (action (eql 'contree)) postlines)
  (cond ((null (cdr postlines)) (process-contree-taxonomy s))
        (t (process-contree-revision s postlines))))

(defun process-contree-taxonomy (s)
  (let (tree)
    (setq tree (cons 'top (find-classes *gui*)))
    (format s "<BODY BGCOLOR=\"WHITE\">")
    (format s "<FORM ACTION=conTREE? METHOD=POST NAME=formtree>")
    (format-hidden s "Tree" tree)
    (format s "<CENTER>")
    (cond ((findp `(nocommand ,*gui* metalevel) *interface*))
          ((findp `(nocommand ,(name *interface*) inspect) *interface*)
           (format s "<A HREF=\"/~A/UPDATER?Object=~A\" target=\"_blank\"><IMG SRC=\"~Aimages/pencil.gif\" BORDER=\"0\"/></A>"
                   (addressify (name *interface*)) (addressify *gui*) *home*))
          (t (format s "<A HREF=\"/~A/CHANGE?Object=~A\" target=\"_blank\"><IMG SRC=\"~Aimages/pencil.gif\" BORDER=\"0\"/></A>"
                     (addressify (name *interface*)) (addressify *gui*) *home*)))
    (format s "<B>~A</B></CENTER><BR/>" (prettify *gui*))
    (dolist (item (cdr tree))
      (format s "<DT>")
      (output-back-narrow s item))
    (format s "</FORM>")
    (format s "</BODY>")
    (crlf s)))

(defun process-contree-revision (s postlines)
  (let (tree command)
    (setq tree (read-user-string (cdr (pop postlines))))
    (setq command (caar postlines))
    (setq command (read-user-string (subseq command 0 (- (length command) 2))))
    (setq tree (back-toggle command tree))
    (format s "<BODY BGCOLOR=\"WHITE\">")
    (format s "<FORM ACTION=conTREE? METHOD=POST NAME=formtree>")
    (format-hidden s "Tree" tree)
    (format s "<CENTER>")
    (cond ((findp `(nocommand ,*gui* metalevel) *interface*))
          ((findp `(nocommand ,(name *interface*) inspect) *interface*)
           (format s "<A HREF=\"/~A/UPDATER?Object=~A\" target=\"_blank\"><IMG SRC=\"~Aimages/pencil.gif\" BORDER=\"0\"/></A>"
                   (addressify (name *interface*)) (addressify *gui*) *home*))
          (t (format s "<A HREF=\"/~A/CHANGE?Object=~A\" target=\"_blank\"><IMG SRC=\"~Aimages/pencil.gif\" BORDER=\"0\"/></A>"
                     (addressify (name *interface*)) (addressify *gui*) *home*)))
    (format s "<B>~A</B></CENTER><BR/>" (prettify *gui*))
    (dolist (item (cdr tree))
      (format s "<DT>")
      (output-back-narrow s item))
    (format s "</FORM>")
    (format s "</BODY>")))

(defun output-back-narrow (s tree)
  (cond ((atom tree)
         (if (find-back-subclass tree) (output-narrow-closed s tree)
             (output-narrow-lone s tree)))
        (t (format s "<DL>")
           (format s "<DT>")
           (output-narrow-open s (car tree))
           (dolist (item (cdr tree))
             (format s "<DD>")
             (output-back-narrow s item))
           (format s "</DL>"))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; refind
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defmethod process (s (command (eql 'refind)) postlines)
  (cond ((null (cdr postlines)) (process-refind-start s postlines))
        ((assoc ".x" postlines :test #'substringp)
         (process-refind-revision s postlines))
        ((and (setq command (getf-post "Command" postlines)) nil))
        ((equalp command "Expand") (process-refind-revision s postlines))
        ((equalp command "Save") (process-search-save s postlines))
        ((equalp command "Drop") (process-search-drop s postlines))
        (t (process-refind-display s postlines))))

(defun process-refind-start (s postlines)
  (let (class structure (*buttons* 0) (*cells* 1))
    (setq class (read-user-string (cdar postlines)))
    (setq structure (maksearchstructure (gentemp "?") class))
    (output-refind-page s structure)))

(defun process-refind-convert (s postlines)
  (let (structure)
    (multiple-value-setq (structure postlines) (parsestructure postlines))
    (format-html s) (crlf s)
    (output-head s (format nil "Inspector ~A" (prettify (car structure)))) (crlf s)
    (format-body s *bgcolor*) (crlf s)
    (output-header s)
    (format s "<XMP>")
    (print-acl s `(ask-all ,(car structure) ,(maksand (reconverter structure))))
    (format s "</XMP>")
    (output-footer s)
    (finish-body s) (crlf s)
    (finish-html s) (crlf s)))

(defun process-refind-display (s postlines)
  (let (structure class aspect kif)
    (multiple-value-setq (structure postlines) (parsestructure postlines))
    (setq class (cadr structure))
    (setq aspect (car structure))
    (setq kif (maksand (reconverter structure)))
    (format s "<BODY BGCOLOR=\"WHITE\" onLoad='window.top.frames[2].document.form1.target=\"query\"'>")
    (output-enumerate-page s class aspect kif 1 20)
    (format s "</BODY>")))

(defun process-refind-revision (s postlines)
  (let (structure revision (*buttons* 0) (*cells* 1))
    (setq revision (getrevision postlines))
    (setq postlines (remrevision postlines))
    (multiple-value-setq (structure postlines) (parsestructure postlines))
    (setq structure (revisesearch structure revision))
    (output-refind-page s structure)))

(defun output-refind-page (s structure)
  (format s "<BODY BGCOLOR=WHITE onLoad='window.document.form1.submit();'>")
  (format s "<FORM ACTION=REFIND? METHOD=POST NAME=\"form1\" TARGET=\"result\">")
  (when (cddr structure)
    (format s "<P>Find every <B>")
    (output-classlink s (cadr structure))
    (format s "</B> that satisfies the following criteria."))
  (output-refind-structure s structure)
  (format s "<TABLE WIDTH=100%><TR><TD VALIGN=TOP>")
  (unless (or (null (cddr structure)) (findp `(nocommand ,*gui* display) *interface*))
    (output-result-button s "Command" "Refresh"))
  (format s "</TD><TD VALIGN=TOP>")
  (unless (findp `(nocommand ,*gui* memory) *interface*)
    (format s "<DL><DT>")
    (format-top-button s "Command" "Save")
    (format-top-button s "Command" "Drop")
    (format s "</DT><DT>")
    (format s "<SELECT NAME=\"Target\">")
    (dolist (option (getbaskets))
      (format s "<OPTION>~A</OPTION>" (stringize option)))
    (format s "</SELECT>")
    (format s "</DT></DL>"))
  (format s "</TD><TD VALIGN=TOP>")
  ;(format-button s "Command" "Convert Content")
  (format s "</TD></TR></TABLE>")
  (format s "</FORM>"))

(defun output-refind-structure (s x)
  (let (flat)
    (setq flat (findp `(nocommand ,*gui* subframe) *interface*))
    (format-hidden s "Start" "")
    (format-hidden s "Object" (stringize (car x)))
    (format-hidden s "Class" (stringize (cadr x)))
    (format s "<P><TABLE CELLSPACING=3>")
    (do ((l (cddr x) (cdr l)) (multivalued) (multiple) (style) (flag))
        ((null l))
      (format s "<TR><TH ALIGN=LEFT VALIGN=TOP>")
      (unless (eq (caar l) flag)
        (setq multivalued (find-multivalued (caar l)))
        (setq style (find-searchstyle (caar l)))
        (output-slotlink s (caar l)))
      (setq multiple (or (eq (caar l) flag) (eq (caar l) (caadr l))))
      (setq flag (caar l))
      (cond ((null (cdar l))
             (format s "</TH><TD VALIGN=TOP>")
             (output-another-button s (incf *buttons*) multivalued)
             (output-removal-button s (incf *buttons*) multiple)
             (if flat (incf *buttons*) (output-plus-button s (incf *buttons*)))
             (format s "</TD><TD>")
             (output-refind-cell s style (caar l) 'unknown (cadr x))
             (incf *cells*))
            ((or (atom (cadar l)) (find (caadar l) '(oneof taxonomy between substring)))
             (format s "</TH><TD VALIGN=TOP>")
             (output-another-button s (incf *buttons*) multivalued)
             (output-removal-button s (incf *buttons*) multiple)
             (if flat (incf *buttons*) (output-plus-button s (incf *buttons*)))
             (format s "</TD><TD>")
             (output-refind-cell s style (caar l) (cadar l) (cadr x))
             (incf *cells*))
            (t (format s "</TH><TD VALIGN=TOP>")
               (output-snow-button s (incf *buttons*))
               (output-trash-button s (incf *buttons*))
               (output-minus-button s (incf *buttons*))
               (format s "</TD><TD>")
               (format s "<TABLE BORDER><TR><TD>")
               (format-hidden s "Start" "")
               (format-hidden s "Style" "Subframe")
               (format-hidden s "Slot" (stringize (caar l)))
               (format s "~A <B>" (article (cadr (cadar l))))
               (output-classlink s (cadr (cadar l)))
               (format s "</B> that satisfies the following criteria<BR/>")
               (output-refind-structure s (cadar l))
               (format s "</TD></TR></TABLE>")))
      (format s "</TD></TR>")
      (crlf s))
    (format s "</TABLE>")
    (format-hidden s "End" "")))


(defun output-refind-cell (s style slot value class)
  (cond ((eq style 'menu) (output-refind-menu s slot value))
        ((eq style 'multichoicelist) (output-refind-menu s slot value))
        ((eq style 'selector) (output-refind-selector s slot value class))
        ((eq style 'dropdownlist) (output-refind-selector s slot value class))
        ((eq style 'hierarchicalselector) (output-refind-multiselector s slot value))
        ((eq style 'checkbox) (output-refind-checkbox s slot value))
        ((eq style 'radiobutton) (output-refind-radiobutton s slot value))
        ((eq style 'interval) (output-refind-interval s slot value))
        ((eq style 'textarea) (output-refind-textarea s slot value))
        ((eq style 'stringfield) (output-refind-stringfield s slot value))
        ((eq style 'text) (output-refind-text s slot value))
        ((eq style 'password) (output-refind-password s slot value))
        ((eq style 'urlstyle) (output-refind-text s slot value))
        ((eq style 'glyph) (output-refind-glyph s slot value))
        (t (output-refind-typein s slot value))))

(defun output-refind-menu (s slot value)
  (format-hidden s "Start" (stringize *cells*))
  (format-hidden s "Style" "Menu")
  (format-hidden s "Slot" (stringize slot))
  (output-refind-menu-result s *cells* (find-values slot) (list value))
  (format-hidden s "End" ""))

(defun output-refind-selector (s slot value class)
  (format-hidden s "Start" (stringize *cells*))
  (format-hidden s "Style" "Selector")
  (format-hidden s "Slot" (stringize slot))
  (output-refind-selector-result s *cells* (find-possibilities slot class) value)
  (format-hidden s "End" ""))

(defun output-refind-multiselector (s slot value)
  (let (references options)
    (format-hidden s "Start" (stringize *cells*))
    (format-hidden s "Style" "Multiselector")
    (format-hidden s "Slot" (stringize slot))
    (cond ((atom value) (setq references (find-references slot value)))
          (t (setq references (cdr value) value (car (last value)))))
    (cond ((null references) (setq options (find-options slot)))
          (t (setq options (find-components slot (car (last references)) references))))
    (dolist (ref references) (format-hidden s "Reference" (stringize ref)))
    (output-refind-selector-result s *cells* (nconc references (cons 'unknown options)) value)
    (output-refind-button s "Command" "Expand")
    (format-hidden s "End" "")))

(defun output-refind-checkbox (s slot value)
  (format-hidden s "Start" (stringize *cells*))
  (format-hidden s "Style" "Checkbox")
  (format-hidden s "Slot" (stringize slot))
  (output-checkbox-result s *cells* (find-values slot) (list value))
  (format-hidden s "End" ""))

(defun output-refind-radiobutton (s slot value)
  (format-hidden s "Start" (stringize *cells*))
  (format-hidden s "Style" "Radiobutton")
  (format-hidden s "Slot" (stringize slot))
  (output-radiobutton-result s *cells* (find-values slot) (list value))
  (format-hidden s "End" ""))

(defun output-refind-interval (s slot value)
  (let (min max)
    (cond ((and (listp value) (eq 'between (car value)))
           (setq min (cadr value) max (caddr value)))
          (t (setq min 'unknown max 'unknown)))
    (format-hidden s "Start" (stringize *cells*))
    (format-hidden s "Style" "Interval")
    (format-hidden s "Slot" (stringize slot))
    (format s "At least ")
    (format-text s "Min" (stringize min) 10)
    (format s " and at most ")
    (format-text s "Max" (stringize max) 10)
    (format-hidden s "End" "")))

(defun output-refind-stringfield (s slot value)
  (let (match)
    (cond ((and (listp value) (eq 'substring (car value)))
           (setq value (cadr value) match t))
          (t (setq value "" match nil)))
    (format-hidden s "Start" (stringize *cells*))
    (format-hidden s "Style" "Stringfield")
    (format-hidden s "Slot" (stringize slot))
    (format-text s (stringize *cells*) value 30)
    (format-checkbox s "Match" "Exact?" match)
    (format-hidden s "End" "")))

(defun output-refind-textarea (s slot value)
  (when (eq value 'unknown) (setq value ""))
  (format-hidden s "Start" (stringize *cells*))
  (format-hidden s "Style" "Textarea")
  (format-hidden s "Slot" (stringize slot))
  (output-text-result s (stringize *cells*) (htmlify value) 40)
  (format-hidden s "End" ""))

(defun output-refind-text (s slot value)
  (when (eq value 'unknown) (setq value ""))
  (format-hidden s "Start" (stringize *cells*))
  (format-hidden s "Style" "Text")
  (format-hidden s "Slot" (stringize slot))
  (output-text-result s (stringize *cells*) (htmlify value) 40)
  (format-hidden s "End" ""))

(defun output-refind-password (s slot value)
  (format-hidden s "Start" (stringize *cells*))
  (format-hidden s "Style" "Password")
  (format-hidden s "Slot" (stringize slot))
  (output-text-result s (stringize *cells*) (htmlify value) 40)
  (format-hidden s "End" ""))

(defun output-refind-glyph (s slot value)
  (format-hidden s "Start" (stringize *cells*))
  (format-hidden s "Style" "Glyph")
  (format-hidden s "Slot" (stringize slot))
  (output-value s value)
  (format-hidden s "End" ""))

(defun output-refind-typein (s slot value)
  (format-hidden s "Start" (stringize *cells*))
  (format-hidden s "Style" "Typein")
  (format-hidden s "Slot" (stringize slot))
  (output-text-result s (stringize *cells*) (stringize value) 40)
  (format-hidden s "End" ""))


(defun output-refind-menu-result (s slot options values)
  (when options
    (format s "<SELECT NAME=\"~A\" SIZE=~D MULTIPLE onChange='{window.document.form1.target=\"result\"; window.document.form1.submit()}'>"
            (stringize slot) (menu-size (length options)))
    (dolist (option options)
      (if (member option values :test #'equalp)
        (format s "<OPTION SELECTED>~A~%" (stringize option))
        (format s "<OPTION>~A~%" (stringize option))))
    (format s "</SELECT>")))

(defun output-refind-selector-result (s slot options value)
  (when options
    (format s "<SELECT NAME=\"~A\" onChange='{window.document.form1.target=\"result\"; window.document.form1.submit()}'>"
            (stringize slot))
    (dolist (option options)
      (if (equalp option value)
        (format s "<OPTION SELECTED>~A~%" (stringize option))
        (format s "<OPTION>~A~%" (stringize option))))
    (format s "</SELECT>")))

(defun output-checkbox-result (s slot options values)
  (let (slotname optionname)
    (setq slotname (stringize slot))
    (format s "<DL>")
    (dolist (option options)
      (setq optionname (stringize option))
      (format s "<DT>")
      (format s "<INPUT TYPE=CHECKBOX NAME=\"~A\" VALUE=\"~A\" " slotname optionname)
      (when (find option values :test #'equalp) (format s "CHECKED "))
      (format s "onClick='{window.document.form1.target=\"result\"; window.document.form1.submit()}'>~A"
              optionname))
    (format s "</DL>")))

(defun output-radiobutton-result (s slot options values)
  (let (slotname optionname)
    (setq slotname (stringize slot))
    (format s "<DL>")
    (dolist (option options)
      (setq optionname (stringize option))
      (format s "<DT>")
      (format s "<INPUT TYPE=RADIO NAME=\"~A\" VALUE=\"~A\" " slotname optionname)
      (when (find option values :test #'equalp) (format s "CHECKED "))
      (format s "onClick='{window.document.form1.target=\"result\"; window.document.form1.submit()}'>~A"
              optionname))
    (format s "</DL>")))

(defun output-text-result (s name value size)
  (format s "<INPUT TYPE=TEXT NAME=\"~A\" " name)
  (unless (string= value "") (format s  "VALUE=\"~A\" " value))
  (format s "SIZE=~A onChange='{window.document.form1.target=\"result\"; window.document.form1.submit()}'>"
          size))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; enumerate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defmethod process (s (action (eql 'enumerate)) postlines)
  (cond ((string= (getf-post "Command" postlines) "Display")
         (process-enumerate-display s postlines))
        ((string= (getf-post "Command" postlines) " Back ")
         (output-previous s postlines))
        ((string= (getf-post "Command" postlines) " Next ")
         (output-next s postlines))
        (t (http-problem s "Obsolete form."))))

(defun process-enumerate-display (s *postlines*)
  (let (class slots aspect kif start end objects selections sorter count)
    (setq class (read-value-string (cdr (pop *postlines*))))
    (setq aspect (read-value-string (cdr (pop *postlines*))))
    (setq kif (read-from-string (cdr (pop *postlines*))))
    (setq start (read-value-string (getf-post "Start" *postlines*)))
    (setq end (read-value-string (getf-post "End" *postlines*)))
    (setq objects (request `(ask-all ,aspect ,kif) *client* *agent*))
    (when (setq sorter (find-sorter class))
      (setq objects (sortem objects sorter 'ascending)))
    (multiple-value-setq (objects count start end) (trim objects start end))
    (setq selections (find-selections *client* objects))
    (setq slots (displayable-slots class))
    (cond ((= count 0)   (format s "<P>There are no viewable answers."))
          ((and (= count 1) (= (length slots) 1) (uniquep (car slots)))
           (output-display-page s class aspect kif slots objects selections count start end))
          (t (output-display-page s class aspect kif slots objects selections count start end)))))

(defun output-previous (s postlines)
  (let (class aspect kif start end)
    (setq class (read-value-string (cdr (pop postlines))))
    (setq aspect (read-value-string (cdr (pop postlines))))
    (setq kif (read-from-string (cdr (pop postlines))))
    (setq start (read-value-string (getf-post "Start" postlines)))
    (setq end (read-value-string (getf-post "End" postlines)))
    (multiple-value-setq (start end) (keechunk start end))
    (format s "<BODY BGCOLOR=\"WHITE\">")
    (output-enumerate-page s class aspect kif start end)
    (format s "</BODY>")))

(defun output-next (s postlines)
  (let (class aspect kif start end)
    (setq class (read-value-string (cdr (pop postlines))))
    (setq aspect (read-value-string (cdr (pop postlines))))
    (setq kif (read-from-string (cdr (pop postlines))))
    (setq start (read-value-string (getf-post "Start" postlines)))
    (setq end (read-value-string (getf-post "End" postlines)))
    (format s "<BODY BGCOLOR=\"WHITE\">")
    (output-enumerate-page s class aspect kif (+ start 20) (+ end 20))
    (format s "</BODY>")))

(defun output-enumerate-page (s class aspect kif start end)
  (let (items count sorter)
    (setq items (request `(ask-all ,aspect ,kif) *client* *agent*))
    (when (setq sorter (find-sorter class))
      (setq items (sortem items sorter 'ascending)))
    (multiple-value-setq (items count start end) (trim items start end))
    (format s "<FORM ACTION=ENUMERATE? METHOD=POST TARGET='_blank'>" (addressify class))
    (format-hidden s "Class" (stringize class))
    (format-hidden s "Aspect" (stringize aspect))
    (format-hidden s "Kif" (htmlify (prin1-to-string (decolonize kif))))
    (format-hidden s "Start" (stringize start))
    (format-hidden s "End" (stringize end))
    (cond ((= count 1)
           (format s "<P><CENTER>")
           (format-button s "Command" "Display")
           (format s "</CENTER></P>")
           (format s "<CENTER><B>1 item</B></CENTER><P>"))
          ((> count 20)
           (format s "<P><CENTER>")
           (format-button s "Command" "Display")
           (format s "</CENTER></P>")
           (format s "<CENTER><B>~A - ~A of ~A items</B></CENTER><P>" start end count))
          (t (format s "<P><CENTER>")
             (format-button s "Command" "Display")
             (format s "</CENTER></P>")
             (format s "<CENTER><B>~A items</B></CENTER><P>" count)))
    (format s "</FORM>")
    (format s "<DL>")
    (do ((l items (cdr l)) (i 1 (1+ i)))
        ((or (null l) (> i 20)))
      (format s "<DT>")
      (output-enumvalue s (car l))   ;;; (output-view s (car l) class)
      (format s "</DT>")
      (crlf s))
    (format s "</DL>")
    (when (> count 20)
      (format s "<FORM ACTION=ENUMERATE? METHOD=POST>" (addressify class))
      (format-hidden s "Class" (stringize class))
      (format-hidden s "Aspect" (stringize aspect))
      (format-hidden s "Kif" (htmlify (prin1-to-string kif)))
      (format-hidden s "Start" (stringize start))
      (format-hidden s "End" (stringize end))
      (format s "<P><CENTER>")
      (format-button s "Command" " Back ")
      (format-button s "Command" " Next ")
      (format s "</CENTER></P>")
      (format s "</FORM>"))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; display
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; updateclass
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defmethod process (s (file (eql 'conupdateclass)) postlines)
  (let (command)
    (setq command (getf-post "Command" postlines))
    (cond ((null command) (process-conupdateclass-start s postlines))
          ((string-equal command "   Edit   ") (process-conupdateclass-kerchunk s postlines))
          (t (process-conupdateclass-update s postlines)))))

(defun process-conupdateclass-start (s postlines)
  (let (class attributes objects count start end)
    (setq class (read-value-string (cdr (pop postlines))))
    (setq attributes (modifiable-slots class))
    (setq objects (prorequest `(ask-all ?x ,(makpred '?x class *gui*))))
    (multiple-value-setq (objects count start end) (trim objects 1 20))
    (format-html s) (crlf s)
    (output-head s "Update Class") (crlf s)
    (format-body s *bgcolor*) (crlf s)
    (output-header s)
    (output-conupdateclass-table s class attributes objects count start end)
    (output-footer s)
    (finish-body s) (crlf s)
    (finish-html s) (crlf s)))

(defun process-conupdateclass-kerchunk (s postlines)
  (let (class attributes objects count start end)
    (setq class (read-value-string (getf-post "Class" postlines)))
    (setq start (read-value-string (getf-post "Start" postlines)))
    (setq end (read-value-string (getf-post "End" postlines)))
    (setq attributes (modifiable-slots class))
    (setq objects (prorequest `(ask-all ?x ,(makpred '?x class *gui*))))
    (multiple-value-setq (objects count start end) (trim objects start end))
    (format-html s) (crlf s)
    (output-head s "Update Class") (crlf s)
    (format-body s *bgcolor*) (crlf s)
    (output-header s)
    (output-conupdateclass-table s class attributes objects count start end)
    (output-footer s)
    (finish-body s) (crlf s)
    (finish-html s) (crlf s)))

(defun process-conupdateclass-update (s postlines)
  (let (class attributes objects selections results rows tells answer count start end)
    (setq class (read-value-string (cdr (pop postlines))))
    (setq attributes (read-user-string (cdr (pop postlines))))
    (setq objects (read-user-string (cdr (pop postlines))))
    (setq results (read-user-string (cdr (pop postlines))))
    (setq rows (read-updateclass-table postlines))
    (setq count (length rows))
    (setq start (read-value-string (getf-post "Start" postlines)))
    (setq end (read-value-string (getf-post "End" postlines)))
    (setq tells (get-updateclass-differences objects attributes results rows))
    (setq selections (find-selections *client* objects))
    (setq answer (prorequest `(tell ,(maksand (nreverse tells)))))
    (cond ((stringp answer) (http-problem s answer))
          (t (format-html s) (crlf s)
             (output-head s "Display Class") (crlf s)
             (format-body s *bgcolor*) (crlf s)
             (output-header s)
             (output-displayclass s class attributes objects selections count start end)
             (output-footer s)
             (finish-body s) (crlf s)
             (finish-html s) (crlf s)))))


(defun output-conupdateclass-table (s class attributes objects count start end)
  (cond ((and (= start 1) (geqp end count)))
        ((= count 1) (format s "<P>There is 1 viewable answer.<P>"))
        (t (format s "<P>There are ~D viewable answers  The following table shows answers ~A through ~A.<P>"
                   count start end)))
  (force-output s)
  (format s "<FORM ACTION=UPDATECLASS? METHOD=POST>")
  (output-conupdateclass-rowtable s class attributes objects)
  (output-conupdateclass-next s count start end)
  (format s "</FORM>"))

(defun output-conupdateclass-rowtable (s class attributes items)
  (let ((results (request `(ask-table ,items ,attributes) *client* *agent*)))
    (format-hidden s "Class" (stringize class))
    (format-hidden s "Attributes" (stringize-kif attributes))
    (format-hidden s "Objects" (stringize-kif items))
    (format-hidden s "Results" (stringize-kif results))
    (format s "<CENTER><TABLE BORDER>")
    (format s "<TR>")
    (format s "<TH>ID</TH>")
    (dolist (slot attributes)
      (format s "<TH>")
      (output-slotlink s slot)
      (format s "</TH>"))
    (format s "</TR>")
    (do ((l items (cdr l)) (m results (cdr m)))
        ((null l))
      (format s "<TR>")
      (format s "<TH ALIGN=LEFT>")
      (format-hidden s "Row" "")
      (output-value s (car l))
      (format s "</TH>")
      (dolist (vals (car m))
        (format s "<TD>")
        (format-text s "Entry" (make-list-string vals) 20)
        (format s "<BR/></TD>"))
      (format s "</TR>"))
    (format s "</TABLE></CENTER><BR/>") (crlf s)
    (format-button s "Command" "Update")
    (format s "<BR/>") (crlf s)
    (force-output s)))

(defun output-conupdateclass-next (s count start end)
  (multiple-value-setq (start end) (kerchunk count start end))
  (format-button s "Command" "   Edit   ")
  (format s "answers ")
  (format-text s "Start" (princ-to-string start) 5)
  (format s " through ")
  (format-text s "End" (princ-to-string end) 5))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; miscellaneous
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun maksearchstructure (variable class)
  (cons variable (cons class (mapcar #'list (queryable-slots class)))))

(defun maksearchstructure (variable class)
  (let (values dum)
    (dolist (slot (queryable-slots class))
      (setq dum (find-searchdefault slot))
      (if dum (setq values (cons (list slot dum) values))
          (setq values (cons (list slot) values))))
    (cons variable (cons class (nreverse values)))))

(defun revisesearch (*tree* n)
  (revisesearchtree *tree* 1 n)
  *tree*)

(defun revisesearchtree (tree m n)
  (do ((l (cddr tree) (cdr l)) (range))
      ((null l) m)
    (cond ((> m n) (return m))
          ((= m n)
           (rplacd l (cons (list (caar l)) (cdr l)))
           (setq m (+ m 3)))
          ((= (+ m 1) n)
           (rplacd (rdc tree l) (cdr l))
           (setq m (+ m 3)))
          ((= (+ m 2) n)
           (cond ((atom (cadar l))
                  (setq range (find-range (caar l)))
                  (rplacd (car l) (list (maksearchstructure (gentemp "?") range))))
                 (t (rplacd (car l) nil)))
           (return (+ m 3)))
          ((atom (cadar l)) (setq m (+ m 3)))
          ((find (caadar l) '(oneof taxonomy between substring)) (setq m (+ m 3)))
          (t (setq m (revisesearchtree (cadar l) (+ m 3) n))))))


(defun revnew (tree n)
  (do ((l (cdr tree) (cdr l)) (i 1 (+ i 2)))
      ((null (cdr l)) tree)
    (cond ((= i n)
           (rplacd (cdr l) (cons (list (caadr l)) (cddr l)))
           (return tree))
          ((= (1+ i) n) (rplacd l (cddr l)) (return tree)))))

(defun upthrough (x items)
  (do ((l items (cdr l)))
      ((null l) items)
    (when (eq (car l) x) (rplacd l nil) (return items))))

(defun find-expanders (x)
  (finds '?x `(expander ,x ?x) *manager*))

(defun find-intension (client gui)
  (cond ((findx '?y `(intension ,client ?y) *interface*))
        ((findx '?y `(intension ,gui ?y) *interface*))
        (t 'intension)))

(defun find-selection (client gui)
  (cond ((findx '?x `(selection ,client ?x) *interface*))
        ((findx '?x `(selection ,gui ?x) *interface*))
        (t 'selection)))

(defun output-plus-button (s x)
  (format s "<INPUT TYPE=IMAGE SRC=\"~Aimages/plus.gif\" NAME=\"~A\" BORDER=\"0\"/>" *home* (addressify x)))

(defun output-minus-button (s x)
  (format s "<INPUT TYPE=IMAGE SRC=\"~Aimages/minus.gif\" NAME=\"~A\" BORDER=\"0\"/>" *home* (addressify x)))

(defun output-blank-button (s x)
  (declare (ignore x))
  (format s "<IMAGE SRC=\"~Aimages/maggie.gif\" BORDER=\"0\"/>" *home*))

(defun output-refind-button (s name value)
  (format s "<INPUT TYPE=SUBMIT NAME=\"~A\" VALUE=\"~A\">"
          name value))   ;;;; onClick='window.document.form1.submit()'

(defun output-result-button (s name value)
  (format s "<INPUT TYPE=SUBMIT NAME=\"~A\" VALUE=\"~A\" onClick='window.document.form1.target=\"result\"'>"
          name value))   ;;;; window.document.form1.submit();


(defun newcase (item)
  (intern (strappend (symbol-name item) (princ-to-string (get-universal-time)))))

(defun make-list-string (vals)
  (with-output-to-string (s)
    (loop for val in vals
          for first-time = t then nil
          unless first-time
          do (format s ", ")
          do (format s (stringize val)))))

(defun read-list-string (s)
  (do ((old 0) (pos (position #\, s) (position #\, s :start old)) (nl))
      ((null pos) (nreverse (cons (read-user-string (subseq s old)) nl)))
    (setq nl (cons (read-user-string (subseq s old pos)) nl))
    (setq old (1+ pos))))

(defun read-updateclass-table (postlines)
  (do ((row) (nl))
      ((not (string= (caar postlines) "Row")) (nreverse nl))
    (multiple-value-setq (row postlines) (get-class-row postlines))
    (setq nl (cons row nl))))

(defun get-class-row (postlines)
  (pop postlines)
  (get-class-entries postlines))

(defun get-class-entries (postlines)
  (do ((l postlines (cdr l)) (nl))
      ((or (null l) (not (string= (caar l) "Entry"))) (values (nreverse nl) l))
    (setq nl (cons (delete nil (read-list-string (cdar l))) nl))))

(defun get-updateclass-differences (objects attributes results rows)
  (do ((ol objects (cdr ol)) (tl results (cdr tl)) (rl rows (cdr rl)) (nl))
      ((null ol) (nreverse nl))
    (do ((al attributes (cdr al)) (vl (car tl) (cdr vl)) (cl (car rl) (cdr cl)))
        ((null al))
      (do ((il (car vl)) (jl (car cl)))
          ((null il) (dolist (j jl) (setq nl (cons (list (car al) (car ol) j) nl))))
        (cond ((equalp (car il) (car jl)) (setq il (cdr il) jl (cdr jl)))
              (t (setq nl (cons `(not ,(list (car al) (car ol) (car il))) nl))
                 (setq il (cdr il))))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
