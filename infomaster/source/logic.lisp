;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; (c) Copyright 1999-2006 by Michael Genesereth.  All rights reserved.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; logic.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(eval-when (compile load eval)
  (proclaim '(special *string*)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; parse
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun readlogic (s)
  (parse (scan s)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun scan (*string*)
  (do ((n 0) (char) (lexeme) (nl))
      ((>= n (length *string*)) (nreverse nl))
      (setq char (elt *string* n))
      (cond ((whitep char) (setq n (1+ n)))
            ((idcharp char)
             (multiple-value-setq (lexeme n) (scansymbol n))
             (setq nl (cons lexeme nl)))
            ((char-equal char #\")
             (multiple-value-setq (lexeme n) (scanstring (1+ n)))
             (setq nl (cons lexeme nl)))
            ((char-equal char #\=)
             (cond ((char-equal (elt *string* (1+ n)) #\<)
                    (setq nl (cons '=< nl) n (+ n 2)))
                   ((char-equal (elt *string* (1+ n)) #\>)
                    (setq nl (cons '=> nl) n (+ n 2)))
                   (t (setq nl (cons '= nl) n (1+ n)))))
            ((char-equal char #\<)
             (cond ((char-equal (elt *string* (1+ n)) #\=)
                    (setq nl (cons '<= nl) n (+ n 2)))
                   (t (setq nl (cons '< nl) n (1+ n)))))
            ((char-equal char #\>)
             (cond ((char-equal (elt *string* (1+ n)) #\=)
                    (setq nl (cons '>= nl) n (+ n 2)))
                   (t (setq nl (cons '> nl) n (1+ n)))))
            ((char-equal char #\.)
	     (setq nl (cons '\. nl) n (1+ n)))
            ((char-equal char #\() (setq nl (cons 'lparen nl) n (1+ n)))
            ((char-equal char #\)) (setq nl (cons 'rparen nl) n (1+ n)))
            (t (setq nl (cons (intern (make-string 1 :initial-element char)) nl)
                     n (1+ n))))))

(defun scanstring (n)
  (values (with-output-to-string (s)
            (do ((char))
                ((or (= n (length *string*))
                     (char= #\" (setq char (elt *string* n)))))
                (write-char char s)
                (setq n (1+ n))))
          (1+ n)))

(defun scansymbol (n)
  (values (read-from-string
           (with-output-to-string (s)
             (do ((char))
                 ((or (= n (length *string*))
                      (not (idcharp (setq char (elt *string* n))))))
                 (write-char char s)
                 (setq n (1+ n)))))
          n))

(defun idcharp (char)
  (or (alphanumericp char) (find char '(#\: #\_ #\-))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun parse (*string*)
  (parsexp *string* 'lparen 'rparen))

(defun parsexp (s lop rop)
  (declare (ignore s))
  (do ((left (parseprefix *string* rop)))
      ((null *string*) left)
      (cond ((precedencep lop (car *string*)) (return left))
            (t (setq left (parseinfix *string* left (car *string*) rop))))))

(defun parseprefix (s rop)
  (declare (ignore s))
  (let (left)
    (setq left (pop *string*))
    (cond ((eq left 'lparen)
           (prog1 (parsexp *string* 'lparen 'rparen) (pop *string*)))
          ((eq (car *string*) 'lparen) (cons left (parseparenlist *string*)))
          ((eq left '~) (parsenot *string* rop))
          ((prefixp left) (list left (parsexp *string* left rop)))
          (t left))))

(defun parseinfix (s left op rop)
  (declare (ignore s))
  (cond ((eq op '&) (parseand *string* left rop))
        ((eq op '\|) (parseor *string* left rop))
        ((eq op '\.) (parsequantifier *string* left rop))
        (t (pop *string*) (list op left (parsexp *string* op rop)))))

(defun parseparenlist (s)
  (declare (ignore s))
  (pop *string*)
  (do ((nl))
      ((null *string*) (error "Bad parentheses."))
      (setq nl (cons (parsexp *string* '\, 'rparen) nl))
      (cond ((eq '\, (car *string*)) (pop *string*))
            ((eq 'rparen (car *string*))
             (pop *string*)
             (return (nreverse nl)))
            (t (error "Bad parentheses.")))))

(defun parsenot (s rop)
  (declare (ignore s))
  (list 'not (parsexp *string* '~ rop)))

(defun parseand (s left rop)
  (declare (ignore s))
  (do ((nl))
      ((not (eq '& (car *string*))) (list* 'and left (nreverse nl)))
      (pop *string*)
      (setq nl (cons (parsexp *string* '& rop) nl))))

(defun parseor (s left rop)
  (declare (ignore s))
  (do ((nl))
      ((not (eq '\| (car *string*))) (list* 'or left (nreverse nl)))
      (pop *string*)
      (setq nl (cons (parsexp *string* '\| rop) nl))))

(defun parsequantifier (s left rop)
  (declare (ignore s))
  (pop *string*)
  (cond ((not (symbolp left)) (error "Bad quantifier."))
        ((char-equal (elt (symbol-name left) 0) #\A)
         (setq left (intern (subseq (symbol-name left) 1)))
         (list 'forall left (parsexp *string* '\. rop)))
        ((char-equal (elt (symbol-name left) 0) #\E)
         (setq left (intern (subseq (symbol-name left) 1)))
         (list 'exists left (parsexp *string* '\. rop)))
        (t (error "Bad quantifier."))))

(defun parsenary (s left op rop)
  (declare (ignore s))
  (do ((nl))
      ((not (eq op (car *string*))) (list* op left (nreverse nl)))
      (pop *string*)
      (setq nl (cons (parsexp *string* op rop) nl))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; grind
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun grind (p)
  (with-output-to-string (s)
    (grindexp s p 'lparen 'rparen)))

(defun grindexp (s p lop rop)
  (cond ((atom p) (grind-atom s p))
        ((eq 'not (car p)) (grind-not s p rop))
        ((eq 'and (car p)) (grind-and s p lop rop))
        ((eq 'or (car p)) (grind-or s p lop rop))
        ((eq '<= (car p)) (grind-<= s p lop rop))
        ((eq '=> (car p)) (grind-=> s p lop rop))
        ((eq 'forall (car p)) (grind-forall s p lop rop))
        ((eq 'exists (car p)) (grind-exists s p lop rop))
        ((eq 'same (car p)) (grind-= s p lop rop))
        ((eq 'distinct (car p)) (grind-\# s p lop rop))
        ((eq '\^ (car p)) (grind-\^ s p lop rop))
        ((eq '* (car p)) (grind-* s p lop rop))
        ((eq '+ (car p)) (grind-+ s p lop rop))
        ((eq '> (car p)) (grind-> s p lop rop))
        ((eq '>= (car p)) (grind->= s p lop rop))
        ((eq '= (car p)) (grind-= s p lop rop))
        ((eq '\# (car p)) (grind-\# s p lop rop))
        ((eq '=< (car p)) (grind-=< s p lop rop))
        ((eq '< (car p)) (grind-< s p lop rop))
        ((null (cdr p)) (grindexp s (car p) 'paren 'paren) (format s "()"))
        (t (grind-complex s p))))

(defun grind-atom (s p)
  (cond ((numberp p) (princ p s))
        ((characterp p) (if (char= p #\') (format s "''") (format s "'")))
        ((stringp p) (prin1 p s))
        ((symbolp p) (princ (string-downcase (symbol-name p)) s))))

(defun grind-not (s p rop)
  (format s "~~")
  (grindexp s (cadr p) 'not rop))

(defun grind-and (s p lop rop)
  (cond ((null (cdr p)) (grindexp s 'true 'paren 'paren))
        ((null (cddr p)) (grindexp s (cadr p) lop rop))
        (t (grindleft s lop '& rop)
           (grindexp s (cadr p) lop '&)
           (do ((l (cddr p) (cdr l)))
               ((null (cdr l)) (format s " & ")
                (grindexp s (car l) '& rop))
               (format s " & ")
               (grindexp s (car l) '& '&))
           (grindright s lop '& rop))))

(defun grind-or (s p lop rop)
  (cond ((null (cdr p)) (grindexp s 'false 'paren 'paren))
        ((null (cddr p)) (grindexp s (cadr p) lop rop))
        (t (grindleft s lop '\| rop)
           (grindexp s (cadr p) lop '\|)
           (do ((l (cddr p) (cdr l)))
               ((null (cdr l)) (format s " | ")
                (grindexp s (car l) '\| rop))
               (format s " | ")
               (grindexp s (car l) '\| '\|))
           (grindright s lop '\| rop))))

(defun grind-=> (s p lop rop)
  (cond ((null (cdr p)) (grindexp s 'false 'paren 'paren))
        ((null (cddr p)) (grindexp s (cadr p) lop rop))
        (t (grindleft s lop '=> rop)
           (grindexp s (cadr p) lop '=>)
           (format s " => ")
           (grindexp s (caddr p) '=> rop)
           (grindright s lop '=> rop))))

(defun grind-<= (s p lop rop)
  (cond ((null (cdr p)) (grindexp s 'false 'paren 'paren))
        ((null (cddr p)) (grindexp s (cadr p) lop rop))
        (t (grindleft s lop '<= rop)
           (grindexp s (cadr p) lop '<=)
           (format s " <= ")
           (grindexp s (caddr p) '<= rop)
           (grindright s lop '<= rop))))

(defun grind-forall (s p lop rop)
  (format s "A")
  (grindleft s lop '\. rop)
  (grindexp s (cadr p) lop '\.)
  (format s ".")
  (grindexp s (caddr p) '\. rop)
  (grindright s lop '\. rop))

(defun grind-exists (s p lop rop)
  (format s "E")
  (grindleft s lop '\. rop)
  (grindexp s (cadr p) lop '\.)
  (format s ".")
  (grindexp s (caddr p) '\. rop)
  (grindright s lop '\. rop))

(defun grind-complex (s p)
  (grindexp s (car p) 'paren 'paren)
  (format s "(")
  (grindexp s (cadr p) 'paren 'paren)
  (dolist (arg (cddr p))
    (format s ",")
    (grindexp s arg 'paren 'paren))
  (format s ")"))

(defun grind-\^ (s p lop rop)
  (grindleft s lop '\^ rop)
  (grindexp s (cadr p) lop '\^)
  (format s "^")
  (grindexp s (caddr p) '\^ rop)
  (grindright s lop '\^ rop))

(defun grind-* (s p lop rop)
  (cond ((null (cdr p)) (grindexp s 1 'paren 'paren))
        ((null (cddr p)) (grindexp s (cadr p) lop rop))
        (t (grindleft s lop '* rop)
           (grindexp s (cadr p) lop '*)
           (do ((l (cddr p) (cdr l)))
               ((null (cdr l)) (format s "*") (grindexp s (car l) '* rop))
               (format s "*")
               (grindexp s (car l) '* '*))
           (grindright s lop '* rop))))

(defun grind-+ (s p lop rop)
  (cond ((null (cdr p)) (grindexp s 0 'paren 'paren))
        ((null (cddr p)) (grindexp s (cadr p) lop rop))
        (t (grindleft s lop '+ rop)
           (grindexp s (cadr p) lop '+)
           (do ((l (cddr p) (cdr l)))
               ((null (cdr l)) (format s "+") (grindexp s (car l) '+ rop))
               (format s "+")
               (grindexp s (car l) '+ '+))
           (grindright s lop '+ rop))))

(defun grind-> (s p lop rop)
  (grindleft s lop '> rop)
  (grindexp s (cadr p) lop '>)
  (format s ">")
  (grindexp s (caddr p) '> rop)
  (grindright s lop '> rop))

(defun grind->= (s p lop rop)
  (grindleft s lop '>= rop)
  (grindexp s (cadr p) lop '>=)
  (format s ">=")
  (grindexp s (caddr p) '>= rop)
  (grindright s lop '>= rop))

(defun grind-= (s p lop rop)
  (grindleft s lop '= rop)
  (grindexp s (cadr p) lop '=)
  (format s "=")
  (grindexp s (caddr p) '= rop)
  (grindright s lop '= rop))

(defun grind-\# (s p lop rop)
  (grindleft s lop '\# rop)
  (grindexp s (cadr p) lop '\#)
  (format s "<>")
  (grindexp s (caddr p) '\# rop)
  (grindright s lop '\# rop))

(defun grind-=< (s p lop rop)
  (grindleft s lop '=< rop)
  (grindexp s (cadr p) lop '=<)
  (format s "<=")
  (grindexp s (caddr p) '<= rop)
  (grindright s lop '=< rop))

(defun grind-< (s p lop rop)
  (grindleft s lop '< rop)
  (grindexp s (cadr p) lop '<)
  (format s "<")
  (grindexp s (caddr p) '< rop)
  (grindright s lop '< rop))

(defun grind-variable (s p)
  (format s (symbol-name p)))

(defun grind-list (s p)
  (format s "(")
  (grind-atom s (car p))
  (dolist (item (cdr p))
    (format s ", ")
    (grind-atom s item))
  (format s ")"))

(defun grind-parens (s p)
  (format s "(")
  (grindexp s p 'paren 'paren)
  (format s ")"))

(defun grindleft (s lop op rop)
  (if (or (precedencep lop op) (precedencep rop op)) (format s "(")))

(defun grindright (s lop op rop)
  (if (or (precedencep lop op) (precedencep rop op)) (format s ")")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Precedence stuff
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun prefixp (x)
  (and (symbolp x) (get x 'prefix)))

(defun infixp (x)
  (and (symbolp x) (get x 'infix)))

(defun precedencep (lop rop)
  (and (symbolp lop) (find rop (get lop 'subordinates))))

(setf (get '* 'subordinates) '(+ - < > = >= =< ~ & \| <= => <=> \, rparen))
(setf (get '/ 'subordinates) '(+ - < > = >= =< ~ & \| <= => <=> \, rparen))
(setf (get '+ 'subordinates) '(< > = >= =< ~ & \| <= => <=> \, rparen))
(setf (get '- 'subordinates) '(< > = >= =< ~ & \| <= => <=> \, rparen))
(setf (get '< 'subordinates) '(~ & \| <= => <=> \, rparen))
(setf (get '> 'subordinates) '(~ & \| <= => <=> \, rparen))
(setf (get '= 'subordinates) '(~ & \| <= => <=> \, rparen))
(setf (get '=< 'subordinates) '(~ & \| <= => <=> \, rparen))
(setf (get '>= 'subordinates) '(~ & \| <= => <=> \, rparen))
(setf (get '\. 'subordinates) '(~ & \| <= => <=> \, rparen))
(setf (get '~ 'subordinates) '(& \| <= => <=> \, rparen))
(setf (get '& 'subordinates) '(& \| <= => <=> \, rparen))
(setf (get '\| 'subordinates) '(\| <= => <=> \, rparen))
(setf (get '\, 'subordinates) '(\, rparen))
(setf (get '<= 'subordinates) '(rparen))
(setf (get '=> 'subordinates) '(rparen))
(setf (get '<=> 'subordinates) '(rparen))
(setf (get 'lparen 'subordinates) '(rparen))

(setf (get '~ 'prefix) t)
(setf (get '\. 'infix) t)
(setf (get '/ 'infix) t)
(setf (get '+ 'infix) t)
(setf (get '- 'infix) t)
(setf (get '< 'infix) t)
(setf (get '> 'infix) t)
(setf (get '=< 'infix) t)
(setf (get '>= 'infix) t)
(setf (get '<=> 'infix) t)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
