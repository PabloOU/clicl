;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; (c) Copyright 1999-2007 by Michael Genesereth.  All rights reserved.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; htmlhandler.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(eval-when (compile load eval)
  (proclaim '(special *postlines*)))

(defmethod process (s (command (eql 'rules)) postlines)
  (declare (ignore postlines))
  (format-html s) (crlf s)
  (output-head s "Rules") (crlf s)
  (format-body s *bgcolor*) (crlf s)
  (output-header s)
  (output-sentence-dispatch s '(kif qbe))
  (output-footer s)
  (finish-body s) (crlf s)
  (finish-html s) (crlf s))

(defun output-sentence-dispatch (s editors)
  (format s "<P><CENTER><TABLE BORDER>")
  (format s "<TR><TH></TH><TH>Examine</TH><TH>Edit</TH></TR>")
  (when (find 'kif editors)
    (format s "<TR><TH>~A</TH>" (prettify 'kif))
    (format s "<TD><A HREF=EXAMINE?>Examine in KIF</A></TD>")
    (format s "<TD><A HREF=ASSERT?>Edit in KIF</A></TD>")
    (format s "</TR>"))
  (when (find 'qbe editors)
    (format s "<TR><TH>~A</TH>" (prettify 'qbe))
    (format s "<TD><A HREF=QBEVIEW?>Examine in QBE</A></TD>")
    (format s "<TD><A HREF=QBE?>Edit in QBE</A></TD>")
    (format s "</TR>"))
  (format s "</TABLE></CENTER><P>"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Qbeview
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defparameter *editor* t)

(defmethod process (s (action (eql 'qbeview)) postlines)
  (let (command (*editor* nil) (*cells* 0))
    (cond ((null postlines) (qbeview-empty s))
          ((and (setq command (getf-post "Command" postlines)) nil))
          ((null command) (qbeview-examine s (cdar postlines)))
          ((string= command "View") (process-qbeview-view s postlines))
          ((string= command "Examine") (qbeview-examine s (cdar postlines)))
          ((string= command "Edit") (qbeview-edit s postlines))
          ((string= command "Create") (qbe-empty s))
          (t (http-problem s "Obsolete form.")))))

(defun qbeview-empty (s)
  (format-html s) (crlf s)
  (output-head s "Retrieve") (crlf s)
  (format-body s *bgcolor*) (crlf s)
  (output-header s)
  (format s "Please enter a word contained in the sentences you wish to examine:<BR>")
  (format s "<FORM ACTION=QBEVIEW? METHOD=POST>")
  (format-text s "Object" "" 40)
  (format-button s "Command" "Examine")
  (format s "</FORM>")
  (output-footer s)
  (finish-body s) (crlf s)
  (finish-html s) (crlf s))

(defun qbeview-examine (s name)
  (let (obj sentences (*cells* 0))
    (setq obj (read-value-string name))
    (setq sentences (request `(ask-about ,obj) *client* *agent*))
    (output-qbeview-examine s name sentences)))

(defun qbeview-edit (s *postlines*)
  (let (rule (*editor* t) (*var-count* 0))
    (format-html s) (crlf s)
    (output-head s "Edit Rule in QBE") (crlf s)
    (format-body s *bgcolor*) (crlf s)
    (output-header s)
    (format s "<FORM ACTION=QBE? METHOD=POST>")
    (setq rule (convert-rule))
    (output-qbe-sentence s rule)
    (format-hidden s "Old" (htmlify (format nil "~S" rule)))
    (format s "<P>")
    (output-qbe-commands s)
    (format s "</FORM>")
    (output-footer s)
    (finish-body s) (crlf s)
    (finish-html s) (crlf s)))

(defun process-qbeview-view (s postlines)
  (let (obj sentences (*cells* 0))
    (setq obj (read-value-string (cdar postlines)))
    (setq sentences (request `(ask-rules ,obj) *client* *agent*))
    (output-qbeview-examine s obj sentences)))

(defun output-qbeview-examine (s obj sentences)
  (format-html s) (crlf s)
  (output-head s (format nil "Examine ~A" obj)) (crlf s)
  (format-body s *bgcolor*) (crlf s)
  (output-header s)
  (when sentences (output-qbe-view s (car sentences)))
  (dolist (sentence (cdr sentences))
    (format s "<BR>") (crlf s)
    (output-qbe-view s sentence))
  (format s "<FORM ACTION=QBEVIEW? METHOD=POST>")
  (format-button s "Command" "Create")
  (format s " a rule.")
  (format s "</FORM>") (crlf s)
  (output-footer s)
  (finish-body s) (crlf s)
  (finish-html s) (crlf s))

(defun output-qbe-view (s sentence)
  (format s "<FORM ACTION=QBEVIEW? METHOD=POST>")
  (output-qbe-sentence s sentence)
  (format-button s "Command" "Edit")
  (format s " this rule.")
  (format s "</FORM>") (crlf s))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Qbe
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defmethod process (s (action (eql 'qbe)) postlines)
  (let (command (*cells* 0))
    (cond ((null postlines) (qbe-empty s))
          ((and (setq command (getf-post "Command" postlines)) nil))
          ((string= command "Save Rule") (qbe-save s postlines))
          ((string= command "Drop Rule") (qbe-drop s postlines))
          ((string= command "Update Rule") (qbe-update s postlines))
          ((string= command "Convert to SQL") (qbe-sql s postlines))
          ((string= command "Convert to KIF") (qbe-kif s postlines))
          ((string= command "Add Conclusion") (qbe-conclusion s postlines))
          ((string= command " Add Condition ") (qbe-condition s postlines))
          ((string= command "Delete Selection") (qbe-delete s postlines))
          ((string= command " Reverse Rule ") (qbe-reversal s postlines))
          (t (http-problem s "Obsolete form.")))))

(defun qbe-empty (s)
  (let ((*var-count* 0))
    (format-html s) (crlf s)
    (output-head s "QBE Query") (crlf s)
    (format-body s *bgcolor*) (crlf s)
    (output-header s)
    (format s "<FORM ACTION=QBE? METHOD=POST>")
    (format-hidden s "Begingroup" "Backward")
    (format-hidden s "Begingroup" "OR")
    (format-hidden s "Endgroup" "")
    (format-hidden s "Begingroup" "AND")
    (format-hidden s "Endgroup" "")
    (format-hidden s "Endgroup" "")
    (format-hidden s "Old" "")
    (format s "<P>")
    (output-qbe-starter s)
    (format s "</FORM>")
    (output-footer s)
    (finish-body s) (crlf s)
    (finish-html s) (crlf s)))

(defun qbe-save (s *postlines*)
  (let (rule (*var-count* 0))
    (format-html s) (crlf s)
    (output-head s "Save Rule") (crlf s)
    (format-body s *bgcolor*) (crlf s)
    (output-header s)
    (setq rule (rectify (deselect (convert-rule))))
    (cond ((not rule) (format s "<P>Bad rule.<P>"))
          (t (request `(tell ,rule) *client* *gui*)
             (format s "<P>Rule added to library.<P>")))
    (output-footer s)
    (finish-body s) (crlf s)
    (finish-html s) (crlf s)))

(defun qbe-drop (s *postlines*)
  (let (rule (*var-count* 0))
    (format-html s) (crlf s)
    (output-head s "Drop Rule") (crlf s)
    (format-body s *bgcolor*) (crlf s)
    (output-header s)
    (setq rule (rectify (deselect (convert-rule))))
    (cond ((not rule) (format s "<P>Bad rule.<P>"))
          (t (request `(untell ,rule) *client* *gui*)
             (format s "<P>Rule dropped from library.<P>")))
    (output-footer s)
    (finish-body s) (crlf s)
    (finish-html s) (crlf s)))

(defun qbe-update (s *postlines*)
  (let (old new (*var-count* 0) (*cells* 0))
    (format-html s) (crlf s)
    (output-head s "Update Rule") (crlf s)
    (format-body s *bgcolor*) (crlf s)
    (output-header s)
    (setq new (rectify (deselect (convert-rule))))
    (setq old (read-user-string (getf-post "Old" *postlines*)))
    (cond ((not new) (format s "<P>Bad rule.<P>"))
          (t (drop old (referent *gui*))
             (save new (referent *gui*))
             (format s "<P>Rule updated in library.<P>")))
    (output-footer s)
    (finish-body s) (crlf s)
    (finish-html s) (crlf s)))

(defun qbe-sql (s *postlines*)
  (let (rule (*var-count* 0) (*cells* 0))
    (format-html s) (crlf s)
    (output-head s "SQL Request") (crlf s)
    (format-body s *bgcolor*) (crlf s)
    (output-header s)
    (setq rule (rectify (convert-rule)))
    (format s "<FORM ACTION=SQL? METHOD=POST>~%")
    (format s "<TEXTAREA NAME=\"Message\" ROWS=10 COLS=70>")
    (format s "CREATE VIEW ~A AS" (stringize (caadr rule))) (crlf s)
    (format s "~A" (sql `(ask-all ,(cdadr rule) ,(maksand (cddr rule)))))
    (format s "</TEXTAREA><P>~%")
    (format s "<HR>")
    (format s "<P><INPUT TYPE=SUBMIT VALUE=Submit> this SQL request")
    (format s "</FORM>")
    (format s "<P>")
    (output-footer s)
    (finish-body s) (crlf s)
    (finish-html s) (crlf s)))

(defun qbe-kif (s *postlines*)
  (let ((*var-count* 0) (*cells* 0))
    (format-html s) (crlf s)
    (output-head s "KIF Request") (crlf s)
    (format-body s *bgcolor*) (crlf s)
    (output-header s)
    (format s "<FORM ACTION=ASSERT? METHOD=POST>")
    (format s "<TEXTAREA NAME=Message ROWS=10 COLS=70>")
    (print-string s (rectify (deselect (convert-rule))))
    (format s "</TEXTAREA><P>~%")
    (format s "<P><INPUT TYPE=SUBMIT NAME=Command VALUE=Assert> these sentences.<BR>")
    (format s "<P><INPUT TYPE=SUBMIT NAME=Command VALUE=Retract> these sentences.")
    (format s "</FORM>")
    (output-footer s)
    (finish-body s) (crlf s)
    (finish-html s) (crlf s)))

(defun qbe-conclusion (s *postlines*)
  (let (rule old relation args (*var-count* 0) (*cells* 0))
    (format-html s) (crlf s)
    (output-head s "Edit Rule in QBE") (crlf s)
    (format-body s *bgcolor*) (crlf s)
    (output-header s)
    (format s "<FORM ACTION=QBE? METHOD=POST>")
    (setq rule (convert-rule))
    (setq old (read-user-string (getf-post "Old" *postlines*)))
    (setq relation (read-value-string (getf-post "Conclusion" *postlines*)))
    (setq args (make-list (arity-of-relation relation) :initial-element 'unknown))
    (cond ((eq '<= (car rule)) (setq rule `(<= ,(cons relation args) . ,(cddr rule))))
          ((eq '=> (car rule)) (setq rule (nconc (butlast rule) (list (cons relation args))))))
    (output-qbe-sentence s rule)
    (format-hidden s "old" (htmlify (format nil "~S" old)))
    (format s "<P>")
    (output-qbe-commands s)
    (format s "</FORM>")
    (output-footer s)
    (finish-body s) (crlf s)
    (finish-html s) (crlf s)))

(defun qbe-condition (s *postlines*)
  (let (rule old relation args (*var-count* 0) (*cells* 0))
    (format-html s) (crlf s)
    (output-head s "Edit Rule in QBE") (crlf s)
    (format-body s *bgcolor*) (crlf s)
    (output-header s)
    (format s "<FORM ACTION=QBE? METHOD=POST>")
    (setq rule (convert-rule))
    (setq old (read-user-string (getf-post "Old" *postlines*)))
    (setq relation (read-value-string (getf-post "Condition" *postlines*)))
    (setq args (make-list (arity-of-relation relation) :initial-element 'unknown))
    (output-qbe-sentence s (addition (cons relation args) rule))
    (format-hidden s "old" (htmlify (format nil "~S" old)))
    (format s "<P>")
    (if (eq 'false (head rule)) (output-qbe-starter s) (output-qbe-commands s))
    (format s "</FORM>")
    (output-footer s)
    (finish-body s) (crlf s)
    (finish-html s) (crlf s)))

(defun qbe-delete (s *postlines*)
  (let (rule old (*var-count* 0) (*cells* 0))
    (format-html s) (crlf s)
    (output-head s "Edit Rule in QBE") (crlf s)
    (format-body s *bgcolor*) (crlf s)
    (output-header s)
    (format s "<FORM ACTION=QBE? METHOD=POST>")
    (setq rule (deletion (convert-rule)))
    (setq old (read-user-string (getf-post "Old" *postlines*)))
    (output-qbe-sentence s rule)
    (format-hidden s "old" (htmlify (format nil "~S" old)))
    (format s "<P>")
    (if (eq 'false (head rule)) (output-qbe-starter s) (output-qbe-commands s))
    (format s "</FORM>")
    (output-footer s)
    (finish-body s) (crlf s)
    (finish-html s) (crlf s)))

(defun qbe-reversal (s *postlines*)
  (let (rule old (*var-count* 0) (*cells* 0))
    (format-html s) (crlf s)
    (output-head s "Edit Rule in QBE") (crlf s)
    (format-body s *bgcolor*) (crlf s)
    (output-header s)
    (format s "<FORM ACTION=QBE? METHOD=POST>")
    (setq rule (reversal (convert-rule)))
    (setq old (read-user-string (getf-post "Old" *postlines*)))
    (output-qbe-sentence s rule)
    (format-hidden s "old" (htmlify (format nil "~S" old)))
    (format s "<P>")
    (output-qbe-commands s)
    (format s "</FORM>")
    (output-footer s)
    (finish-body s) (crlf s)
    (finish-html s) (crlf s)))

(defun output-qbe-sentence (s sentence)
  (cond ((atom sentence))
        ((eq '=> (car sentence)) (output-forward s sentence))
        ((eq '<= (car sentence)) (output-backward s sentence))
        (t (qbe-table s sentence))))

(defun output-forward (s sentence)
  (format-hidden s "Begingroup" "Forward")
  (format-hidden s "Begingroup" "And")
  (format s "<BLOCKQUOTE>") (crlf s)
  (dolist (conjunct (butlast (cdr sentence))) (qbe-table s conjunct))
  (format s "</BLOCKQUOTE>") (crlf s)
  (format-hidden s "Endgroup" "") (crlf s)
  (format-hidden s "Begingroup" "Or")
  (qbe-table s (car (last sentence)))
  (format-hidden s "Endgroup" "") (crlf s)
  (format-hidden s "Endgroup" "") (crlf s))

(defun output-backward (s sentence)
  (format-hidden s "Begingroup" "Backward")
  (format-hidden s "Begingroup" "Or")
  (qbe-table s (cadr sentence))
  (format-hidden s "Endgroup" "") (crlf s)
  (format-hidden s "Begingroup" "And")
  (format s "<BLOCKQUOTE>") (crlf s)
  (dolist (conjunct (cddr sentence)) (qbe-table s conjunct))
  (format s "</BLOCKQUOTE>") (crlf s)
  (format-hidden s "Endgroup" "") (crlf s)
  (format-hidden s "Endgroup" "") (crlf s))

(defun qbe-table (s x)
  (cond ((atom x))
        ((and (eq 'and (car x)) (cddr x)) (qbe-and s x))
        ((and (eq 'or (car x)) (cddr x)) (qbe-or s x))
        ((eq 'selected (car x)) (qbe-selection s (cadr x) t))
        ((eq 'unprovable (car x)) (qbe-selection s x nil))
        ((eq 'not (car x)) (qbe-selection s x nil))
        (t (qbe-selection s x nil))))

(defun qbe-selection (s x selected)
  (cond ((atom x))
        ((eq 'unprovable (car x)) (qbe-atom s (cadr x) nil selected))
        ((eq 'not (car x)) (qbe-atom s (cadr x) nil selected))
        (t (qbe-atom s x t selected))))

(defun qbe-atom (s x positive selected)
  (qbe-row-table s x positive selected))

(defun qbe-column-table (s x positive selected)
  (format-hidden s "Start" (stringize (incf *cells*)))
  (format-hidden s "Style" "Table")
  (format-hidden s "Relation" (stringize (car x)))
  (format s "<TABLE>")
  (format s "<TR>")
  (format s "<TD></TD><TD>")
  (format-checkbox s "Not" "" (not positive))
  (format s "<A HREF=Qbeview?Concept=~A><B>~A</B></A><BR>"
          (stringize (car x)) (prettify (car x)))
  (format s "</TD></TR><TR><TD>")
  (when *editor* (format-radiobutton s "Select" "" selected))
  (format s "</TD><TD>")
  (format s "<TABLE BORDER>")
  (do ((l (cdr x) (cdr l)) (columns (columns (car x)) (cdr columns)))
      ((null l))
      (format s "<TR><TH ALIGN=LEFT>")
      (format s (prettify (or (car columns) "")))
      (format s "</TH>")
      (format s "<TD>")
      (format-text s "Val" (stringize (car l)) 30)
      (format s "</TD></TR>"))
  (format s "</TABLE>")
  (format s "</TD></TR></TABLE>")
  (format-hidden s "End" ""))

(defun qbe-row-table (s x positive selected)
  (format-hidden s "Start" (stringize (incf *cells*)))
  (format-hidden s "Style" "Table")
  (format-hidden s "Relation" (stringize (car x)))
  (format s "<TABLE>")
  (format s "<TR>")
  (format s "<TD></TD><TD>")
  (format s "<A HREF=Qbeview?Concept=~A><B>~A</B></A><BR>"
          (stringize (car x)) (prettify (car x)))
  (format s "</TD></TR><TR><TD>")
  (when *editor* (format-radiobutton s "Select" "" selected))
  (format s "</TD><TD>")
  (format s "<TABLE BORDER>")
  (format s "<TR>")
  (format s "<TD></TD>")
  (do ((l (cdr x) (cdr l)) (columns (columns (car x)) (cdr columns)))
      ((null l))
      (format s "<TH>")
      (format s (prettify (or (car columns) "")))
      (format s "</TH>"))
  (format s "</TR>")
  (format s "<TR>")
  (format s "<TD>")
  (format-checkbox s "Not" "" (not positive))
  (format s "</TD>")
  (do ((l (cdr x) (cdr l)))
      ((null l))
      (format s "<TD>")
      (format-text s "Val" (stringize (car l)) 15)
      (format s "</TD>"))
  (format s "</TR>")
  (format s "</TABLE>")
  (format s "</TD></TR></TABLE>")
  (format-hidden s "End" ""))

(defun qbe-and (s x)
  (format s "<P>")
  (output-selector s 'begingroup '(and or) 'and)
  (format s "<B>Group</B><BR>")
  (format s "<BLOCKQUOTE>") (crlf s)
  (dolist (conjunct (cdr x))
    (format s "<P>")
    (qbe-table s conjunct))
  (format-hidden s "Endgroup" "")
  (format s "</BLOCKQUOTE>") (crlf s))

(defun qbe-or (s x)
  (format s "<P>")
  (output-selector s 'begingroup '(and or) 'or)
  (format s "<B>Group</B><BR>")
  (format s "<BLOCKQUOTE>") (crlf s)
  (dolist (disjunct (cdr x))
    (format s "<P>")
    (qbe-table s disjunct))
  (format-hidden s "Endgroup" "")
  (format s "</BLOCKQUOTE>") (crlf s)
  (format s "<P>"))


(defun convert-rule ()
  (let (op left right)
    (setq op (read-user-string (cdr (pop *postlines*))))
    (setq left (convert-boolean))
    (setq right (convert-boolean))
    (pop *postlines*)
    (cond ((eq 'forward op) (makforward left right))
          ((eq 'backward op) (makbackward left right))
          (t 'true))))

(defun convert-boolean ()
  (do ((operator (read-user-string (cdr (pop *postlines*)))) (nl))
      ((or (null *postlines*) (string= (caar *postlines*) "Endgroup"))
       (pop *postlines*)
       (cond ((eq operator 'and) (maksand (nreverse nl)))
             ((eq operator 'or) (maksor (nreverse nl)))
             (t (cons operator (nreverse nl)))))
      (cond ((string= (caar *postlines*) "Begingroup")
             (setq nl (cons (convert-boolean) nl)))
            ((string= (caar *postlines*) "Start")
             (setq nl (cons (convert-atom) nl)))
            (t (pop *postlines*)))))

(defun convert-atom ()
  (let (relation selected negative)
    (pop *postlines*)
    (pop *postlines*)
    (setq relation (read-user-string (cdr (pop *postlines*))))
    (when (string-equal (caar *postlines*) "Select")
      (pop *postlines*)
      (setq selected t))
    (when (string-equal (caar *postlines*) "Not")
      (pop *postlines*)
      (setq negative t))
    (do ((nl) (out))
        ((or (null *postlines*) (string= (caar *postlines*) "End"))
         (pop *postlines*)
         (setq out (cons relation (nreverse nl)))
         (when negative (setq out `(not ,out)))
         (when selected (setq out `(selected ,out)))
         out)
        (setq nl (cons (convert-value (cdr (pop *postlines*))) nl)))))

(defun convert-value (x)
  (if (string= x "") '?* (read-user-string x)))


(defun deselect (x)
  (cond ((atom x) x)
        ((eq 'selected (car x)) (deselect (cadr x)))
        (t (mapcar #'deselect x))))

(defun addition (literal rule)
  (cond ((eq '<= (car rule))
         (do ((l (cdr rule) (cdr l)))
             ((null l) (nconc (deselect rule) (list `(selected ,literal))))
             (when (and (listp (car l)) (eq 'selected (caar l)))
               (rplaca l (cadar l))
               (rplacd l (cons `(selected ,literal) (mapcar #'deselect (cdr l))))
               (return rule))))
        ((eq '=> (car rule))
         (do ((l (cdr rule) (cdr l)))
             ((null (cdr l))
              (cond ((and (listp (car l)) (eq 'selected (caar l)))
                     (rplaca l (cadar l))
                    `(=> (selected ,literal) . ,(cdr rule)))
                    (t (rplacd l (list (deselect (car l))))
                       (rplaca l `(selected ,literal))
                       rule)))
             (when (and (listp (car l)) (eq 'selected (caar l)))
               (rplaca l (cadar l))
               (rplacd l (cons `(selected ,literal) (mapcar #'deselect (cdr l))))
               (return rule))))))

(defun deletion (rule)
  (let (head)
    (cond ((eq '<= (car rule))
           (cond ((and (listp (cadr rule)) (eq 'selected (caadr rule)))
                  (setq head 'false))
                 (t (setq head (cadr rule))))
           `(<= ,head . ,(deletions (cddr rule))))
          ((eq '=> (car rule))
           (setq head (car (last rule)))
           (when (and (listp head) (eq 'selected (car head))) (setq head 'false))
           (cons '=> (nconc (deletions (butlast (cdr rule))) (list head)))))))

(defun deletions (literals)
  (do ((l literals (cdr l)) (nl))
      ((null l) (nreverse nl))
      (unless (and (listp (car l)) (eq 'selected (caar l)))
        (setq nl (cons (car l) nl)))))

(defun reversal (rule)
  (cond ((eq '<= (car rule)) (cons '=> (append (cddr rule) (list (cadr rule)))))
        ((eq '=> (car rule)) `(<= ,(car (last rule)) . ,(butlast (cdr rule))))
        (t rule)))


(defun output-qbe-starter (s)
  (let ((relations (sort (find-relations) #'lessp)))
    (format s "<BR>")
    (format-hidden s "== Commands ==" "")
    (format s "<TABLE WIDTH=100%>")
    (format s "<TR><TD WIDTH=25% VALIGN=TOP>")
    (format s "</TD><TD WIDTH=25%>")
    (format s "</TD><TD WIDTH=50%>")
    (format-button s "Command" "Add Conclusion")
    (format s "<SELECT NAME=Conclusion>")
    (format s "<OPTION SELECTED>~A~%" (stringize (car relations)))
    (dolist (relation (cdr relations))
      (format s "<OPTION>~A~%" (stringize relation)))
    (format s "</SELECT>")
    (format s "</TD></TR></TABLE>")))

(defun output-qbe-commands (s)
  (let ((relations (sort (find-relations) #'lessp)))
    (format s "<BR>")
    (format-hidden s "== Commands ==" "")
    (format s "<TABLE WIDTH=100%>")
    (format s "<TR><TD WIDTH=25% VALIGN=TOP>")
    (format-button s "Command" "Save Rule")
    (format s "</TD><TD WIDTH=25%>")
    (format-button s "Command" "Convert to SQL")
    (format s "</TD><TD WIDTH=50%>")
    (format-button s "Command" " Add Condition ")
    (format s "<SELECT NAME=Condition>")
    (format s "<OPTION SELECTED>~A~%" (stringize (car relations)))
    (dolist (relation (cdr relations))
      (format s "<OPTION>~A~%" (stringize relation)))
    (format s "</SELECT>")
    (format s "</TD></TR><TR><TD>")
    (format-button s "Command" "Drop Rule")
    (format s "</TD><TD>")
    (format-button s "Command" "Convert to KIF")
    (format s "</TD><TD>")
    (format-button s "Command" "Delete Selection")
    (format s "</TD></TR><TR><TD>")
    (format-button s "Command" "Update Rule")
    (format s "</TD><TD></TD><TD>")
    (format-button s "Command" " Reverse Rule ")
    (format s "</TD></TR></TABLE>")))

(defun find-relations ()
  (finds '?r '(isa ?r relation) *interface*))

(defun makforward (ante cons)
  (cond ((atom ante) `(=> ,ante ,cons))
        ((eq 'and (car ante)) (cons '=> (append (cdr ante) (list cons))))
        (t `(=> ,ante ,cons))))

(defun makbackward (cons ante)
  (cond ((atom ante) `(<= ,cons ,ante))
        ((eq 'and (car ante)) `(<= ,cons . ,(cdr ante)))
        (t `(<= ,cons ,ante))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
