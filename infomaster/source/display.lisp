;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; (c) Copyright 1999-2001 by Michael R. Genesereth.  All rights reserved.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; display
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defmethod process (s (command (eql 'display)) postlines)
  (cond ((and (setq command (getf-post "Command" postlines)) nil))
        ((equalp command "Display") (process-display-display s postlines))
        ((equalp command "Update") (process-display-select s postlines))
        (t (html-message s "Obsolete form."))))

(defun process-display-display (s *postlines*)
  (let (class slots aspect kif start end objects count)
    (setq class (read-user-string (getf-post "Class" *postlines*)))
    (setq aspect (read-user-string (getf-post "Aspect" *postlines*)))
    (setq kif (read-user-string (getf-post "Kif" *postlines*)))
    (setq start (read-user-string (getf-post "Start" *postlines*)))
    (setq end (read-user-string (getf-post "Solutions" *postlines*)))
    (setq objects (prorequest `(ask-all ,aspect ,kif)))
    (multiple-value-setq (objects count start end) (trim objects start end))
    (setq slots (displayable-slots class))
    (output-display-page s class aspect kif slots objects count start end)))

(defun process-display-select (s postlines)
  (let (items selections)
    (output-prolog s 200)
    (output-header s "Save")
    (multiple-value-setq (selections postlines) (getslots "Class" postlines))
    (setq selections (mapcar #'read-value-string selections))
    (setq items (read-user-string (getf-post "Items" postlines)))
    (do ((l items (cdr l)) (nl))
        ((null l) (prorequest `(update . ,(nreverse nl))))
        (cond ((equal (car l) (car selections))
               (setq selections (cdr selections))
               (setq nl (cons `(good ,*client* ,(car l)) nl)))
              (t (setq nl (cons `(bad ,*client* ,(car l)) nl)))))
    (format s "<P>Done.<P>")
    (output-footer s)))


(defun output-display-page (s class aspect kif slots objects count start end)
  (output-prolog s 200)
  (output-header s "Display")
  (format s "<CENTER><TABLE><TR><TD>")
  (cond ((and (= start 1) (geqp end count)))
        ((= count 1) (format s "<P>There is 1 viewable answer.<P>"))
        (t (format s "<P>There are ~D viewable answers  The following table shows answers ~A through ~A.<P>"
                   count start end)))
  (format s "</TD></TR><TR><TD>")
  (format s "<FORM ACTION=display? METHOD=POST>")
  (output-display-table s class objects slots)
  (format s "</TD></TR><TR><TD>")
  (output-display-commands s class aspect kif objects count start end)
  (format s "</TD></TR></TABLE></CENTER>")
  (format s "</FORM>")
  (output-footer s))

(defun output-display-table (s class items slots)
  (let ((results (request `(ask-table ,items ,slots) *client* *agent*))
        (nohandle (findp `(nodisplay ,class handle) *interface*))
        (nobasket (or (null items) (findp `(nocommand ,*gui* save) *interface*))))
    (format s "<TABLE BGCOLOR=WHITE BORDER>")
    (format s "<TR>")
    (unless nobasket (format s "<TH></TH>"))
    (unless nohandle (format s "<TH>ID</TH>"))
    (dolist (slot slots)
      (format s "<TH>")
      (output-slotlink s slot)
      (format s "</TH>"))
    (format s "</TR>")
    (do ((l items (cdr l)) (m results (cdr m)) (flag nil (not flag)))
        ((null l))
        (if flag (format s "<TR>") (format s "<TR BGCOLOR=#EEEEEE>"))
        (unless nobasket
          (format s "<TH>")
          (format-checkbox s (prettify (car l)) "" t)
          (format s "</TH>"))
        (unless nohandle
          (format s "<TH ALIGN=LEFT>")
          (output-value s (car l))  ;;; (output-view s (car l) class)
          (format s "</TH>"))
        (loop for vals in (car m)
              ;;; for class in classes
	      do (setq vals (remove 'unknown vals))
              (if (every #'(lambda (val) (numberp val)) vals)
                (format s "<TD ALIGN=RIGHT>")
                (format s "<TD>") )
              (loop
                for val in vals
                for first-time = t then nil
                unless first-time
                do (format s ", ")
                do (output-value s val))   ;;; (output-view s val class)
              (format s "<BR></TD>"))
        (format s "</TR>")
        (crlf s))
    (format s "</TABLE>")))

(defun output-display-commands (s class aspect kif objects count start end)
  (format-hidden s "Class" (stringify class))
  (format-hidden s "Aspect" (stringify aspect))
  (format-hidden s "Kif" (htmlify (prin1-to-string kif)))
  (format s "<TABLE WIDTH=100%><TR><TD WIDTH=50% VALIGN=TOP>")
  (multiple-value-setq (start end) (kerchunk count start end))
  (format-button s "Command" "Display")
  (format s "answers ")
  (format-text s "Start" (princ-to-string start) 5)
  (format s " through ")
  (format-text s "Solutions" (princ-to-string end) 5)
  (format s "</TD><TD WIDTH=50% VALIGN=TOP>")
  (unless (or (null objects) (findp `(nocommand ,*gui* save) *interface*))
    (format-hidden s "Items" (format nil "~S" objects))
    (format-button s "Command" "Copy")
    (format s "selected results."))
  (format s "</TD></TR></TABLE>"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; displayclass
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defmethod process (s (command (eql 'displayclass)) postlines)
  (cond ((null postlines) (html-message s "No class specified."))
        ((null (cdr postlines)) (process-displayclass-start s postlines))
        ((and (setq command (getf-post "Command" postlines)) nil))
        ((equalp command "   Edit   ") (process-displayclass-edit s postlines))
        ((equalp command "Display") (process-displayclass-display s postlines))
        ((equalp command "Copy") (process-display-update s postlines))
        (t (html-message s "Obsolete form."))))

(defun process-displayclass-start (s postlines)
  (let (class attributes objects count start end)
    (setq class (read-value-string (cdr (pop postlines))))
    (setq attributes (displayable-slots class))
    (setq objects (prorequest `(ask-all ?x ,(makpred '?x class *gui*))))
    (multiple-value-setq (objects count start end) (trim objects 1 20))
    (output-prolog s 200)
    (output-header s "DisplayClass")
    (output-displayclass s class attributes objects count start end)
    (output-footer s)))

(defun process-displayclass-display (s postlines)
  (let (class attributes objects count start end)
    (setq class (read-value-string (getf-post "Class" postlines)))
    (setq start (read-value-string (getf-post "Start" postlines)))
    (setq end (read-value-string (getf-post "End" postlines)))
    (setq attributes (displayable-slots class))
    (setq objects (prorequest `(ask-all ?x ,(makpred '?x class *gui*))))
    (multiple-value-setq (objects count start end) (trim objects start end))
    (output-prolog s 200)
    (output-header s "DisplayClass")
    (output-displayclass s class attributes objects count start end)
    (output-footer s)))

(defun process-displayclass-edit (s postlines)
  (let (class attributes objects count start end)
    (setq class (read-value-string (getf-post "Class" postlines)))
    (setq start (read-value-string (getf-post "Startedit" postlines)))
    (setq end (read-value-string (getf-post "Endedit" postlines)))
    (setq attributes (modifiable-slots class))
    (setq objects (prorequest `(ask-all ?x ,(makpred '?x class *gui*))))
    (multiple-value-setq (objects count start end) (trim objects start end))
    (output-prolog s 200)
    (output-header s "UpdateClass")
    (output-updateclass-table s class attributes objects count start end)
    (output-updateclass-next s class count start end)
    (output-footer s)))

(defun process-displayclass-select (s postlines)
  (let (items selections)
    (output-prolog s 200)
    (output-header s "Save")
    (multiple-value-setq (selections postlines) (getslots "Class" postlines))
    (setq selections (mapcar #'read-value-string selections))
    (setq items (read-user-string (getf-post "Items" postlines)))
    (do ((l items (cdr l)) (nl))
        ((null l) (prorequest `(update . ,(nreverse nl))))
        (cond ((equal (car l) (car selections))
               (setq selections (cdr selections))
               (setq nl (cons `(good ,*client* ,(car l)) nl)))
              (t (setq nl (cons `(bad ,*client* ,(car l)) nl)))))
    (format s "<P>Done.<P>")
    (output-footer s)))


(defun output-displayclass (s class slots objects count start end)
  (format s "<CENTER><TABLE><TR><TD>")
  (cond ((and (= start 1) (geqp end count)))
        ((= count 1) (format s "<P>There is 1 viewable answer.<P>"))
        (t (format s "<P>There are ~D viewable answers  The following table shows answers ~A through ~A.<P>"
                   count start end)))
  (format s "</TD></TR><TR><TD>")
  (format s "<FORM ACTION=DisplayClass? METHOD=POST>")
  (output-display-table s class objects slots)
  (format s "</TD></TR><TR><TD>")
  (output-displayclass-commands s class objects count start end)
  (format s "</TD></TR></TABLE></CENTER>")
  (format s "</FORM>"))

(defun output-displayclass-commands (s class objects count start end)
  (format s "<TABLE WIDTH=100%><TR><TD WIDTH=50% VALIGN=TOP>")
  (unless (findp `(nocommand ,*gui* edit) *interface*)
    (format-hidden s "Class" (stringify class))
    (format-button s "Command" "   Edit   ")
    (format s "answers ")
    (format-text s "Startedit" (princ-to-string start) 5)
    (format s " through ")
    (format-text s "Endedit" (princ-to-string end) 5))
  (format s "<BR>")
  (multiple-value-setq (start end) (kerchunk count start end))
  (format-hidden s "Class" (stringify class))
  (format-button s "Command" "Display")
  (format s "answers ")
  (format-text s "Start" (princ-to-string start) 5)
  (format s " through ")
  (format-text s "End" (princ-to-string end) 5)
  (format s "</TD><TD WIDTH=50% VALIGN=TOP>")
  (unless (or (null objects) (findp `(nocommand ,*gui* save) *interface*))
    (format-button s "Command" "Copy")
    (format s "selected results.")
    (format-hidden s "Items" (format nil "~S" objects)))
  (format s "</TD></TR></TABLE>"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; updateclass
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defmethod process (s (file (eql 'updateclass)) postlines)
  (let (command)
    (setq command (getf-post "Command" postlines))
    (cond ((null command) (process-updateclass-start s postlines))
          ((string-equal command "   Edit   ") (process-updateclass-kerchunk s postlines))
          (t (process-updateclass-update s postlines)))))

(defun process-updateclass-start (s postlines)
  (let (class attributes objects count start end)
    (setq class (read-value-string (cdr (pop postlines))))
    (setq attributes (modifiable-slots class))
    (setq objects (prorequest `(ask-all ?x ,(makpred '?x class *gui*))))
    (multiple-value-setq (objects count start end) (trim objects 1 20))
    (output-prolog s 200)
    (output-header s "UpdateClass")
    (output-updateclass-table s class attributes objects count start end)
    (output-updateclass-next s class count start end)
    (output-footer s)))

(defun process-updateclass-kerchunk (s postlines)
  (let (class attributes objects count start end)
    (setq class (read-value-string (getf-post "Class" postlines)))
    (setq start (read-value-string (getf-post "Start" postlines)))
    (setq end (read-value-string (getf-post "End" postlines)))
    (setq attributes (modifiable-slots class))
    (setq objects (prorequest `(ask-all ?x ,(makpred '?x class *gui*))))
    (multiple-value-setq (objects count start end) (trim objects start end))
    (output-prolog s 200)
    (output-header s "UpdateClass")
    (output-updateclass-table s class attributes objects count start end)
    (output-updateclass-next s class count start end)
    (output-footer s)))

(defun process-updateclass-update (s postlines)
  (let (class attributes objects results rows tells answer count start end)
    (pop postlines)
    (setq attributes (read-user-string (cdr (pop postlines))))
    (setq objects (read-user-string (cdr (pop postlines))))
    (setq results (read-user-string (cdr (pop postlines))))
    (setq rows (read-updateclass-table postlines))
    (setq class (read-value-string (getf-post "Class" postlines)))
    (setq count (length rows))
    (setq start (read-value-string (getf-post "Start" postlines)))
    (setq end (read-value-string (getf-post "End" postlines)))
    (setq tells (get-updateclass-differences objects attributes results rows))
    (setq answer (prorequest `(tell ,(maksand (nreverse tells)))))
    (cond ((stringp answer) (http-problem s answer))
          (t (output-prolog s 200)
             (output-header s "Display")
             (output-displayclass s class attributes objects count start end)
             (output-footer s)))))


(defun output-updateclass-table (s class attributes objects count start end)
  (cond ((and (= start 1) (geqp end count)))
        ((= count 1) (format s "<P>There is 1 viewable answer.<P>"))
        (t (format s "<P>There are ~D viewable answers  The following table shows answers ~A through ~A.<P>"
                   count start end)))
  (force-output s)
  (output-updateclass-rowtable s class attributes objects))

(defun output-updateclass-rowtable (s class attributes items)
  (let ((results (request `(ask-table ,items ,attributes) *client* *agent*)))
    (format s "<FORM ACTION=UPDATECLASS? METHOD=POST>")
    (format-hidden s "Class" (stringify class))
    (format-hidden s "Attributes" (stringify-kif attributes))
    (format-hidden s "Objects" (stringify-kif items))
    (format-hidden s "Results" (stringify-kif results))
    (format s "<CENTER><TABLE BORDER>")
    (format s "<TR>")
    (format s "<TH>ID</TH>")
    (dolist (slot attributes)
      (format s "<TH>")
      (output-slotlink s slot)
      (format s "</TH>"))
    (format s "</TR>")
    (do ((l items (cdr l)) (m results (cdr m)))
        ((null l))
        (format s "<TR>")
        (format s "<TH ALIGN=LEFT>")
        (format-hidden s "Row" "")
        (output-value s (car l))
        (format s "</TH>")
        (dolist (vals (car m))
          (if (every #'(lambda (val) (numberp val)) vals)
              (format s "<TD ALIGN=RIGHT>")
              (format s "<TD>") )
          (format-text s "Entry" (make-list-string vals) 20)
          (format s "<BR></TD>"))
        (format s "</TR>"))
    (format s "</TABLE></CENTER><BR>")
    (format-button s "Command" "Update")
    (force-output s)
    (format s "</FORM>")))

(defun output-updateclass-next (s class count start end)
  (multiple-value-setq (start end) (kerchunk count start end))
  (format s "<FORM ACTION=UPDATECLASS? METHOD=POST>")
  (format-hidden s "Class" (stringify class))
  (format-button s "Command" "   Edit   ")
  (format s "answers ")
  (format-text s "Start" (princ-to-string start) 5)
  (format s " through ")
  (format-text s "End" (princ-to-string end) 5)
  (format s "</FORM>"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Miscellaneous
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun trim (results start end)
  (let (count)
    (setq count (length results))
    (cond ((not (integerp start)) (setq start 1))
          ((< start 1) (setq start 1)))
    (cond ((not (integerp end)) (setq end count))
          ((< end 1) (setq end (min count 20)))
          ((> end count) (setq end count)))
    (when (< end start) (setq end start))
    (cond ((and (= start 1) (= end count)))
          ((> start count) (setq results nil))
          (t (setq results (subseq results (1- start) end))))
    (values results count start end)))

(defun kerchunk (count start end)
  (cond ((and (= start 1) (= end count)))
        ((> count end) (setq start (1+ end) end (min count (+ end 20))))
        (t (setq start 1 end (min count 20))))
  (values start end))

(defun make-list-string (vals)
  (with-output-to-string (s)
    (loop for val in vals
          for first-time = t then nil
          unless first-time
          do (format s ", ")
          do (format s (stringify val)))))

(defun read-list-string (s)
  (do ((old 0) (pos (position #\, s) (position #\, s :start old)) (nl))
      ((null pos) (nreverse (cons (read-user-string (subseq s old)) nl)))
      (setq nl (cons (read-user-string (subseq s old pos)) nl))
      (setq old (1+ pos))))

(defun read-updateclass-table (postlines)
  (do ((row) (nl))
      ((not (string= (caar postlines) "Row")) (nreverse nl))
      (multiple-value-setq (row postlines) (get-class-row postlines))
      (setq nl (cons row nl))))

(defun get-class-row (postlines)
  (pop postlines)
  (get-class-entries postlines))

(defun get-class-entries (postlines)
  (do ((l postlines (cdr l)) (nl))
      ((or (null l) (not (string= (caar l) "Entry"))) (values (nreverse nl) l))
      (setq nl (cons (delete nil (read-list-string (cdar l))) nl))))

(defun get-updateclass-differences (objects attributes results rows)
  (do ((ol objects (cdr ol)) (tl results (cdr tl)) (rl rows (cdr rl)) (nl))
      ((null ol) (nreverse nl))
      (do ((al attributes (cdr al)) (vl (car tl) (cdr vl)) (cl (car rl) (cdr cl)))
          ((null al))
          (do ((il (car vl)) (jl (car cl)))
              ((null il) (dolist (j jl) (setq nl (cons (list (car al) (car ol) j) nl))))
              (cond ((equalp (car il) (car jl)) (setq il (cdr il) jl (cdr jl)))
                    (t (setq nl (cons `(not ,(list (car al) (car ol) (car il))) nl))
                       (setq il (cdr il))))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
