<html><head><title>Infomaster Tutorial - Lesson 5</title></head><body bgcolor="#FFFFFF" vlink="#660066" alink="990033" text="#000000" link="#000099"><table cellspacing=0 cellpadding=0 width="100%" border=0>  <tbody>   <tr>     <td noWrap width=150 ALIGN=CENTER><img src="file:///gullible/infomaster/images/infomaster.jpg" height=80 width=112 border=0></td>    <td noWrap width=* ALIGN=CENTER bgcolor=white>      <FONT COLOR=#113399>        <H1>Infomaster Tutorial</H1>        <H2>Lesson 5: Rules</H2>      </FONT></td>    <td noWrap width=150 ALIGN=CENTER>&nbsp;</td>  </tr>  </tbody> </table><HR/><H3>5.1 Introduction</H3><P>Data tables express relationships among objects.  For example, the parent tableexpresses the relationship between parents and their children.  The sentence<TT>(parent art bob)</TT> means that art is the parent of bob.<P>Rules represent relationships among tables.  For example, we can write a ruleto express the relationship between the parent table and the grandparent table. If one person is a parent of a second person and the second is a parent of a thirdperson, then the first person must be a grandparent of the third person.<P>In Infomaster, rules are expressed in a language called KIF (for KnowledgeInterchange Format).  KIF is a prefix version of the language of Relational Logicwith various extensions to enhance its expressiveness.  It includes thesentential representation introduced in the previous lesson and extends it toallow one to write relationships among such sentences.<P>In this Lesson, we introduce a portion of the KIF language.<H3>5.2 Rule Syntax</H3><P>The basic vocabulary of the language includes variables, constants, andlogical operators.  Individual variables are distinguished by the presence of? as initial character, and sequence variables are distinguished by thepresence of an initial @.  There is a fixed set of operators<TT>bagofall</TT>, <TT>not</TT>, <TT>and</TT>, <TT>or</TT>, <TT>=></TT>,<TT><=</TT>.  All others words are constants.<P>From this basic vocabulary, we can build <I>terms</I> to refer to objects inthe universe of discourse, as in the following example.  Terms are analogousto noun phrases in natural language.<XMP>    ?x    art    (listof art bob cal)</XMP><P>From terms, we can build relational sentences.  First and foremost thisprovides the ability to encode simple data, as in the examples shown below.  Notethat this is the same as the sentential form introduced in Lesson 3.<XMP>    (parent art bob)    (parent art bea)    (parent bob cal)</XMP><P>Using logical operators, we can encode boolean sentences, i.e. negations,conjunctions, and disjunctions.<XMP>    (not (parent art bob))    (and (parent art bob) (parent bob cal))    (or (parent art bob) (parent art bud))</XMP><P>A rule is an expression in the form shown below.  Here <I>p</I> and each ofthe <I>pi</I> isa a relational sentence or the negation of a relational sentence.<CENTER><TT>(<= <I>p</I> <I>p1</I> ... <I>pn</I>)</TT></CENTER><P>The first sentence with a rule is called the <I>head</I>.  The remainingexpressions together are called the <I>body</I>.  In some cases the head isreferred to as the conclusion and the elements of the body are called<I>subgoals</I>.<P>For example, the following two rules define the parent relation in terms offather and mother.<XMP>(<= (parent ?x ?y)    (father ?x ?y))(<= (parent ?x ?y)    (mother ?x ?y))</XMP><P>Another example.  We can define the grandparent relation in terms of parent asshown below.<XMP>(<= (grandparent ?x ?z)    (parent ?x ?y)    (parent ?y ?z))</XMP><P>In some cases, it is necessary to negate a subgoal or conclusion, as in thefollowing example.<XMP>(<= (female ?x)    (person ?x)    (not (male ?x))</XMP>In some cases, it is the conclusion that is negated.<XMP>(<= (not (female ?x))    (male ?x)</XMP><P>An implication is an expression of the form shown below.  Again, <I>p</I> andeach of the <I>pi</I> is a a relational sentence or the negation of a relationalsentence.<CENTER><TT>(=> <I>p1</I> ... <I>pn</I> <I>p</I>)</TT></CENTER><P>In this case, the last sentence in a rule is called the <I>head</I>.  Theother expressions together are called the <I>body</I>.  In some cases, thehead is referred to as the conclusion and the elements of the body are called<I>subgoals</I>.<P>From a logical perspective, implications and rules are just two ways of sayingthe same thing.  However, they have different practical uses, as we will see incoming lessons.<P>There are two ways of defining the semantics, or meaning, of rules - evaluativesemantics and constructive semantics.  We look at these separately in the nexttwo sections.<H3>5.3 Evaluative Semantics</H3><P>One way of defining the meaning of a logical language like KIF is to say whichdatabases satisfy the constituent sentences.  This is called evaluativesemantics.  It is useful in determining whether a database satisfies a set ofrules.<P>An instance of a rule is an expression obtained by consistently replacingvariables with constants from a “Herbrand universe” (the set of constants used ina database).<P>As an example, consider the rule shown below.<CENTER><TT>(<= (q ?x ?z) (p ?x ?y) (p ?y ?z))</TT></CENTER><P>If we assume a universe of discourse consisting of the constants a, b, and c,then the following are instances of this sentences.  There are, in addition, manyother instances.<CENTER><TT>(<= (q a c) (p a b) (p b c))</TT></CENTER><CENTER><TT>(<= (q a a) (p a c) (p c a))</TT></CENTER><P>The following sentence is <B>not</B> an instance, as the variable ?y is notreplaced consistently.<CENTER><TT>(<= (q a c) (p a b) (p a c))</TT></CENTER><P>A database D satisfies a rule if and only if, for every instance, if allof the subgoals are in D, then the head is in D. <P>Sample Rule:<CENTER><TT>(<= (q ?x ?z) (p ?x ?y) (p ?y ?z))</TT></CENTER><P>Databases that does not satisfy this rule:<CENTER><TT>{(p a b) (p b c) (p c d) (q a c)}</TT></CENTER><P>Databases that satisfy this rule:<CENTER><TABLE><TR><TD><TT>{(p a b) (p b c) (p c d) (q a c) (q b d)}</TT></TD></TR><TR><TD><TT>{(p a b) (p b c) (p c d) (q a c) (q b d) (q a d)}</TT></TD></TR><TR><TD><TT>{}</TT></TD></TR></TABLE></CENTER><P>A database satisfies a set of rules if and only if it satisfies each of therules in the set.<P>Sample Rules:<CENTER><TT>(<= (s ?x ?y) (p ?x ?y) (q ?x ?y))</TT></CENTER><CENTER><TT>(<= (t ?x ?z) (s ?x ?y) (r ?y ?z))</TT></CENTER><P>Database that satisfies the rules:<CENTER><TT>{(p a b) (q a b) (r b c) (s a b) (t a c)}</TT></CENTER><P>Database that does not satisfy the rules:<CENTER><TT>{(p a b) (q a b) (r b c) (s a b)}</TT></CENTER><P>A database D satisfies a negative rule if and only if, for every instance, ifall of the positive subgoals are in D and none of the negative subgoals are in D,then the head is in D if positive or the head is not in D if negative.Sample Rule:<XMP>(<= (not (female ?x))    (male ?x)</XMP><P>Database that satisfies this rule:<CENTER><TT>{(person a) (person b) (male a) (female b)}</TT></CENTER><H3>5.4 Constructive Semantics</H3><P>Typical database applications start with a partial database,i.e. tables forsome relations (the extensional relations) and not others (the intensionalrelations).  Rules are then written to define the intensional relations in termsof the extensional relations. <P>Given an extensional database D and a knowledge base K, we can obtain thecorresponding closure by computing all supersets of D that satisfies the rulesand taking their intersection.  However, the closure of D and K does notnecessarily satisfy K.  Moreover, computing things this way can be veryexpensive.  The alternative is to build up a database iteratively from D and K. This is constructive semantics.<P>A rule is safe if and only if every variable in the head appears in somesubgoal in the body.  <P>Safe Rule:<CENTER><TT>(<= (r ?x ?z) (p ?x ?y) (q ?y ?z))</TT></CENTER><P>Unsafe Rule:<CENTER><TT>(<= (r ?x ?z) (p ?x ?y) (q ?y ?x))</TT></CENTER><P>In Infomaster, we look only at rules that are safe.<P>The dependency graph for a set of rules is a directed graph in which (1) thenodes are the relations mentioned in the head and bodies of the rules and (2)there is an arc from a node p to a node q whenever p occurs with the body of arule in which q is in the head.<P>A set of rules is recursive if it contains a cycle.  Otherwise, it isnon-recursive.<P>The value of a single non-recursive rule on a database D is the set of all ruleheads obtained by consistently substituting constants from D for variables insuch a way that the substituted subgoals are all in D.<P>Sample Rule:<CENTER><TT>(<= (q ?x ?z) (p ?x ?y) (p ?y ?z))</TT></CENTER><P>Sample Database:<CENTER><TT>{(p a b) (p b c) (p c d)}</TT></CENTER><P>Value:<CENTER><TT>{(q a c) (q b d)}</TT></CENTER><P>The value of a set of rules with a common relation on a database D is the unionof the values on the individual rules.<P>Sample Rules:<CENTER><TABLE><TR><TD><TT>(<= (q ?x ?y) (p ?x ?y))</TT></TD></TR><TR><TD><TT>(<= (q ?x ?z) (p ?x ?y) (p ?y ?z))</TT></TD></TR></TABLE></CENTER><P>Sample Database:<CENTER><TT>{(p a b) (p b c) (p c d)}</TT></CENTER><P>Value:<CENTER><TT>{(q a b) (q b c) (q c d) (q a c) (q b d)}</TT></CENTER><P>To compute the value of a recursive rule, start with the empty relation. Compute the value using multiple rule computation.  Iterate till no new tuplesare added. <P>Sample Rules:<CENTER><TABLE><TR><TD><TT>(<= (q ?x ?z) (p ?x ?y))</TT></TD></TR><TR><TD><TT>(<= (q ?x ?z) (q ?x ?y) (q ?y ?z))</TT></TD></TR></TABLE></CENTER><P>Value Computation:<CENTER><TABLE><TR><TD><TT>{(p a b) (p b c) (p c d)}</TT></TD></TR><TR><TD><TT>{(q a b) (q b c) (q c d)}</TT></TD></TR><TR><TD><TT>{(q a c) (q b d)}</TT></TD></TR><TR><TD><TT>{(q a d)}</TT></TD></TR></TABLE></CENTER><P>There are various ways to compute the value of negative rules.<P>In negation as failure, a negation is true if and only if the negated sentenceis not known to be true.  This is the norm in database systems.<P>In classical negation, a negation is true only if the negated sentence is knownto be false (i.e. there must be rules concluding negated sentences).  This is thenorm in computational logic systems.<P>In semipositive negation, the negation of an extensional relation is treatedusing negation as failure and the negation of an intensional relation is treatedas classical negation.<P>Infomaster implements semipositive negation.<H3>5.5 Procedural Attachments</H3><P>See <A HREF=../sif/numbers.html><TT>../sif/numbers.html</TT></A> for adescription of predefined functions and relations on numbers.  See <AHREF=../sif/strings.html><TT>../sif/strings.html</TT></A> for a descriptionof predefined functions and relations on strings.<H3>Additional Reading</H3><P>See <A HREF =../sif/specification.html><TT>../sif/specification.html</TT></A>for more details on the language.<H3>Exercises</H3><OL><P><LI>Create a fullserver called <TT>myserver</TT>.<P><LI>Populate <TT>father</TT> and <TT>mother</TT> with some facts.  Be sureto include several generations.<P><LI>Add a rule to your fullserver to define the <TT>parent</TT> relationin terms of <TT>father</TT> and <TT>mother</TT>. <P><LI>Use the Ask operation to ask queries about your newly defined relations.<P><LI>Use the <B>Trace Execution</B> button on the Ask page to view theaction of your fullserver in answering your queries.  Tracing is an importantdebugging tool.  Look at the traces carefully and understand how they revealthe operation of the system.<P><LI> Define <TT>grandparent</TT> in terms of <TT>parent</TT>.<P><LI>Define <TT>ancestor</TT> in terms of <TT>parent</TT>.<P><LI>Define the unary relations <TT>male</TT> and <TT>female</TT>in terms of the <TT>father</TT> and <TT>mother</TT> relations.<P><LI>Define the ternary relation <TT>family</TT> in terms of the<TT>father</TT> and <TT>mother</TT> relations.  This relation holds of threepeople if and only if the second and third persons are the father ad mother ofthe first person.<P><LI>Define the <TT>nonparent</TT> relation.  (Nonparent holds of two peopleif and only if the first is <I>not</I> a parent of the second.)<P><LI>Define the <TT>sibling</TT> relation.  Remember that a person is not hisown sibling.<P><LI>Define the <TT>length</TT> relation which associates a list with itslength.  For example, your definition should allow Infomaster to prove<TT>(length (listof a b c) 3)</TT><P><LI>Define the <TT>children</TT> relation, which connects a person with thenumber of children that person has.  (Hint: Use <TT>bagofall</TT> and<TT>length</TT>.)<P><LI>Add a "fullname" attribute for each of the people in your database withvalue in the form <TT>"<B>lastname</B>, <B>firstname</B>"</TT>.<P><LI>Using <TT>fullname</TT>, define a new relation, called<TT>lastname</TT>, which relates a person and his lastname.<P><LI>Define a new relation, called <TT>nickname</TT>, which relates a personto his nickname.  By definition we take the nickname to be the stringcorresponding to the symbol representing the person.  (For example, if<TT>art</TT> is the symbol representing the person, then the string<TT>"Art"</TT> is his nickname.)<P><LI>Using <TT>nickname</TT> and <TT>lastname</TT>, define a new relation,called <TT>simplename</TT>, which relates a person with <TT>"<B>nickname</B>"</TT>as nickname and <TT>"<B>lastname</B>"</TT> as lastname to the simplename<TT>"<B>nickname lastname</B>"</TT>.</OL><H3>Solutions</H3>Data and Rules are given in <A HREF="myserver.kif"><TT>myserver.kif</TT></A>.<BR/><HR/><CENTER><FONT SIZE=1>(c) Copyright 1997-2003 by<A HREF="mailto:genesereth@stanford.edu">Michael Genesereth</A>.  All rights reserved.</FONT></CENTER></BODY></HTML>