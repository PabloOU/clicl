;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Epilog tests;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(reset)*;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Type predicates and converters;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; groundp;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(groundp 'a)T(groundp '?x)NIL(groundp ''?x)T(groundp '(p a b))T(groundp '(p ?x b))NIL;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; atomicp;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(atomicp 'raining)T(atomicp '(p a b))T(atomicp '(> 3 2))T(atomicp '(not (p a b)))NIL(atomicp '(and (p ?x ?y) (q ?x ?y)))NIL(atomicp '(or (p ?x ?y) (q ?x ?y)))NIL(atomicp '(=> (p ?x ?y) (q ?x ?y)))NIL(atomicp '(<= (p ?x ?y) (q ?x ?y)))NIL(atomicp '(<=> (p ?x ?y) (q ?x ?y)))NIL;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; literalp;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(literalp 'raining)T(literalp '(p a b))T(literalp '(> 3 2))T(literalp '(not (p a b)))T(literalp '(not (not (p a b))))NIL(literalp '(and (p ?x ?y) (q ?x ?y)))NIL(literalp '(or (p ?x ?y) (q ?x ?y)))NIL(literalp '(=> (p ?x ?y) (q ?x ?y)))NIL(literalp '(<= (p ?x ?y) (q ?x ?y)))NIL(literalp '(<=> (p ?x ?y) (q ?x ?y)))NIL;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; clausep;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(clausep 'sunny)T(clausep '(not raining))T(clausep '(or raining (not raining)))T(clausep '(<=> (marten ?x) (martin ?x)))NIL(clausep '(forall (?x) (=> (integer ?x) (number ?x))))NIL(clausep '(forall (?x) (or (not (integer ?x)) (number ?x))))NIL(clausep '(or (not (integer ?x)) (number ?x)))T(clausep '(or (not (integer ?x)) (and (number ?x) (rational ?x))))NIL(clausep '(not (> 3 (salary (president hp)))))T;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; alternativep;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(alternativep 'sunny)T(alternativep '(not raining))T(alternativep '(or raining sunny))NIL(alternativep '(and raining sunny))T(alternativep '(forall (?x) (<=> (p ?x) (q ?x))))NIL(alternativep '(and (or (not p) q) (or p (not q))))NIL(alternativep '(and (not (integer ?x)) (number ?x)))T(alternativep '(not (> 3 (salary (president hp)))))T;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; booleanp;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(booleanp 'bright)T(booleanp '(or (marten ?x) (martin ?x)))T(booleanp '(forall (?x) (=> (integer ?x) (number ?x))))NIL(booleanp '(forall (?x) (or (not (integer ?x)) (number ?x))))T(booleanp '(and (or x (not y) z @s) (not k)))T(booleanp '(term (quote (+ 2 3))))T(booleanp '(> (if true 3 4) 2))T;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; booleanize;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(booleanize 'bright)BRIGHT(booleanize '(or (marten ?x) (martin ?x)))(OR (MARTEN ?X) (MARTIN ?X))(booleanize '(forall (?x) (=> (integer ?x) (number ?x))))(FORALL (?X) (OR (NOT (INTEGER ?X)) (NUMBER ?X)))(booleanize '(shorter (quote (=> x y)) (quote (or (not x) y))))(SHORTER '(=> X Y) '(OR (NOT X) Y))(booleanize '(=> (red ?x) (=> (round ?x) (apple ?x))))(OR (NOT (RED ?X)) (OR (NOT (ROUND ?X)) (APPLE ?X)))(booleanize '(<= (parasitic ?u) (mistletoe ?x)))(OR (PARASITIC ?U) (NOT (MISTLETOE ?X)))(booleanize '(<=> (coniferous ?x) (bears-cones ?x)))(AND (OR (NOT (CONIFEROUS ?X)) (BEARS-CONES ?X))           (OR (CONIFEROUS ?X) (NOT (BEARS-CONES ?X))));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; skolemp;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(skolemp '(neighbor bertram sam))T(skolemp '(=> (zebra ?x) (striped ?x)))T(skolemp '(forall (?x) (=> (zebra ?x) (striped ?x))))NIL(skolemp '(nice (quote (exists (?a) (round ?a)))))T(skolemp '(or (not (integer ?x)) (and (number ?x) (rational ?x))))T(skolemp '(exists (?y) (loves ?x ?y)))NIL;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; skolemize;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(skolemize 'bright)BRIGHT(skolemize '(or (animal ?x) (vegetable ?x) (mineral ?x)))(OR (ANIMAL ?X) (VEGETABLE ?X) (MINERAL ?X))(skolemize '(forall (?x) (=> (martin ?x) (swallow ?x))))(=> (martin ?x) (swallow ?x))(skolemize '(forall (?x) (or (liberal ?x) (conservative ?x))))(or (liberal ?x) (conservative ?x))(unifyp (skolemize '(forall (?x) (exists (?y) (loves ?x ?y))))        '(LOVES ?X (?F ?X)))T(unifyp (skolemize '(exists (?y) (forall (?x) (loves ?x ?y))))        '(LOVES ?X (?F)))T(unifyp (skolemize '(exists (?y) (> ?x ?y)))        '(> ?x (?F ?x)))T(unifyp (skolemize '(exists (?x) (forall (?y) (exists (?z) (p ?w ?x ?y ?z)))))        '(P ?W (?F ?W) ?Y (?G ?Y ?W)))T;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; cnf;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(cnf '(=> (father ?x ?y) (father ?x ?z) (siblings ?y ?z)))(OR (NOT (FATHER ?X ?Y)) (NOT (FATHER ?X ?Z)) (SIBLINGS ?Y ?Z))(cnf '(=> (red ?x) (=> (round ?x) (apple ?x))))(OR (NOT (RED ?X)) (NOT (ROUND ?X)) (APPLE ?X))(cnf '(<= (parent ?x ?y) (father ?x ?y)))(OR (PARENT ?X ?Y) (NOT (FATHER ?X ?Y)))(cnf '(<=> (morning-star ?x) (evening-star ?x)))(AND (OR (MORNING-STAR ?X) (NOT (EVENING-STAR ?X)))     (OR (NOT (MORNING-STAR ?X)) (EVENING-STAR ?X)))(cnf '(or (and ?v ?w) (and ?x ?y)))(AND (OR ?V ?X) (OR ?V ?Y) (OR ?W ?X) (OR ?W ?Y))(cnf '(father jim ralph))(FATHER JIM RALPH)(not (equal (cnf '(exists (?x) (father ?x ralph)))            (cnf '(exists (?x) (father ?x ralph)))))T(cnf '(red ?x))(RED ?X)(unifyp (cnf '(exists (?x) (forall (?y) (exists (?z) (p ?w ?x ?y ?z)))))        '(P ?W (?F ?W) ?Y (?G ?Y ?W)))T;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; clauses;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(clauses 'sunny)(SUNNY)(clauses '(> 3 2))((> 3 2))(clauses '(=> (red ?x) (=> (round ?x) (apple ?x))))((OR (NOT (RED ?X)) (NOT (ROUND ?X)) (APPLE ?X)))(clauses '(or a b))((OR A B))(clauses '(and a b))(A B)(clauses '(<=> (odd ?x) (not (even ?x))))((OR (ODD ?X) (EVEN ?X)) (OR (NOT (ODD ?X)) (NOT (EVEN ?X))));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; cnfp;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(cnfp '(apple ?x))T(cnfp '(or (apple ?x) (banana ?x)))T(cnfp '(and (apple ?x) (red ?x)))T(cnfp '(and (and x y) z))NIL(cnfp '(forall (?x) (loves ?x micky)))NIL(cnfp '(exists (?x) (loves ?y ?x)))NIL(cnfp '(=> (apple ?x) (fruit ?x)))NIL(cnfp '(or (not (apple ?x)) (fruit ?x)))T(cnfp '(or (and a b) (and c d)))NIL(cnfp '(and (or a c) (or a d) (or b c) (or b d)))T;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; dnf;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(dnf '(red sky))(RED SKY)(dnf '(forall (?x) (=> (apple ?x) (fruit ?x))))(OR (NOT (APPLE ?X)) (FRUIT ?X))(dnf '(=> (red ?x) (=> (round ?x) (apple ?x))))(OR (NOT (RED ?X)) (NOT (ROUND ?X)) (APPLE ?X))(dnf '(and (apple fred) (round fred)))(AND (APPLE FRED) (ROUND FRED))(dnf '(and (or (alive ?x) (dead ?x)) (or (male ?x) (female ?x))))(OR (AND (ALIVE ?X) (MALE ?X))          (AND (ALIVE ?X) (FEMALE ?X))          (AND (DEAD ?X) (MALE  ?X))          (AND (DEAD ?X) (FEMALE ?X)))(unifyp (dnf '(exists (?x) (forall (?y) (exists (?z) (p ?w ?x ?y ?z)))))        '(P ?W (?F ?W) ?Y (?G ?Y ?W)))T;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; alternatives;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(alternatives 'sunny)(SUNNY)(alternatives '(> 3 2))((> 3 2))(alternatives '(=> (red ?x) (=> (round ?x) (apple ?x))))((NOT (RED ?X)) (NOT (ROUND ?X)) (APPLE ?X))(alternatives '(or a b))(A B)(alternatives '(and a b))((AND A B))(alternatives '(<=> (odd ?x) (not (even ?x))))((AND (ODD ?X) (NOT (ODD ?X)))       (AND (ODD ?X) (NOT (EVEN ?X)))       (AND (EVEN ?X) (NOT (ODD ?X)))       (AND (EVEN ?X) (NOT (EVEN ?X))));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; dnfp;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(dnfp '(apple ?x))T(dnfp '(and (apple ?x) (banana ?x)))T(dnfp '(or (apple ?x) (red ?x)))T(dnfp '(or (or x y) z))NIL(dnfp '(forall (?x) (loves ?x micky)))NIL(dnfp '(exists (?x) (loves ?y ?x)))NIL(dnfp '(=> (apple ?x) (fruit ?x)))NIL(dnfp '(or (not (apple ?x)) (fruit ?x)))T(dnfp '(or (and a b) (and c d)))T(dnfp '(and (or a c) (or a d) (or b c) (or b d)))NIL;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; brf;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(brf '(father john doe))(<= (FATHER JOHN DOE))(brf '(<= (fruit ?x) (apple ?x)))(<= (FRUIT ?X) (APPLE ?X))(brf '(=> (apple ?x) (fruit ?x)))(<= (not (apple ?x)) (not (fruit ?x)))(brf '(<=> (child ?x ?y) (parent ?y ?x)))(AND (<= (CHILD ?X ?Y) (PARENT ?Y ?X))           (<= (NOT (CHILD ?X ?Y)) (NOT (PARENT ?Y ?X))))(brf '(or (not a) b))(<= (NOT A) (NOT B))(brf '(or a (not b)))(<= A B);;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; brfp;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(brfp '(macintosh fred))T(brfp '(or (not (apple ?x)) (fruit ?x)))NIL(brfp '(forall (?x) (=> (apple ?x) (fruit ?x))))NIL(brfp '(and (apple macintosh) (fruit macintosh)))NIL(brfp '(<= (fruit ?x) (apple ?x)))T(brfp '(<= (apple ?x) (and (round ?x) (red ?x))))NIL(brfp '(<= (apple ?x) (round ?x) (red ?x)))T;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ebrfp;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(ebrfp '(blue water))T(ebrfp '(=> (senator ?x) (roman ?x)))NIL(ebrfp '(<=> (even ?x) (not (round ?x))))NIL(ebrfp '(not (even 7)))T(ebrfp '(not (and (even 6) (irrational 6))))NIL(ebrfp '(and (even 6) (rational 6)))NIL(ebrfp '(or (even 5) (odd 5)))NIL(ebrfp '(forall (?x) (bowfin ?x)))NIL(ebrfp '(<= (fruit ?x) (red ?x) (round ?x)))T(ebrfp '(<= (p traveling-salesman) (<= (p ?x) (np ?x))))NIL(ebrfp '(<= (p traveling-salesman) (or (p ?x) (not (np ?x)))))T;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; frf;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(frf '(father john doe))(=> (FATHER JOHN DOE))(frf '(=> (apple ?x) (fruit ?x)))(=> (APPLE ?X) (FRUIT ?X))(frf '(<= (fruit ?x) (apple ?x)))(=> (NOT (FRUIT ?X)) (NOT (APPLE ?X)))(frf '(<=> (child ?x ?y) (parent ?y ?x)))(AND (=> (NOT (CHILD ?X ?Y)) (NOT (PARENT ?Y ?X)))           (=> (CHILD ?X ?Y) (PARENT ?Y ?X)));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; frfp;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(frfp '(macintosh fred))T(frfp '(or (not (apple ?x)) (fruit ?x)))NIL(frfp '(forall (?x) (=> (apple ?x) (fruit ?x))))NIL(frfp '(and (apple macintosh) (fruit macintosh)))NIL(frfp '(=> (apple ?x) (fruit ?x)))T(frfp '(=> (and (round ?x) (red ?x)) (apple ?x)))NIL(frfp '(=> (round ?x) (red ?x) (apple ?x)))T;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; efrfp;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(efrfp '(blue water))T(efrfp '(=> (senator ?x) (roman ?x)))T(efrfp '(<= (waterspout ?u) (gargoyle ?u)))NIL(efrfp '(<=> (even ?x) (not (round ?x))))NIL(efrfp '(not (even 7)))T(efrfp '(not (and (even 6) (irrational 6))))NIL(efrfp '(and (even 6) (rational 6)))NIL(efrfp '(or (even 5) (odd 5)))NIL(efrfp '(forall (?x) (bowfin ?x)))NIL(efrfp '(=> (red ?x) (round ?x) (fruit ?x)))T(efrfp '(=> (=> (np ?x) (p ?x)) (p traveling-salesman)))NIL(efrfp '(=> (or (not (np ?x)) (p ?x)) (p traveling-salesman)))NIL;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; reverse-rule;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(reverse-rule 'p)p(reverse-rule '(apple macintosh))(APPLE MACINTOSH)(reverse-rule '(or a b))(OR A B)(reverse-rule '(<= r))(=> r)(reverse-rule '(=> r))(<= r)(reverse-rule '(<= r p q))(=> p q r)(reverse-rule '(=> p q r))(<= r p q)(reverse-rule '(=> (apple ?x) (computer ?x)))(<= (COMPUTER ?X) (APPLE ?X))(reverse-rule '(<= (reptile ?a) (pterodactyl ?a)))(=> (PTERODACTYL ?A) (REPTILE ?A))(reverse-rule '(forall (?x) (=> (ferrari ?x) (car ?x))))(FORALL (?X) (=> (FERRARI ?X) (CAR ?X)))(reverse-rule '(=> (car ?x) (=> (num-seats ?x 2) (sporty ?x))))(<= (=> (NUM-SEATS ?X 2) (SPORTY ?X)) (CAR ?X));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; contrapositives;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(contrapositives '(blue water))((BLUE WATER))(contrapositives '(or x y))((<= X (NOT Y)) (<= Y (NOT X)))(contrapositives '(and x y))(X Y)(contrapositives '(=> (apple ?x) (fruit ?x)))((<= (NOT (APPLE ?X)) (NOT (FRUIT ?X)))       (<= (FRUIT ?X) (APPLE ?X)))(contrapositives '(<= (number ?x) (odd ?x)))((<= (NUMBER ?X) (ODD ?X))       (<= (NOT (ODD ?X)) (NOT (NUMBER ?X))))(contrapositives '(<=> (even ?x) (not (odd ?x))))((<= (EVEN ?X) (NOT (ODD ?X)))       (<= (ODD ?X) (NOT (EVEN ?X)))       (<= (NOT (EVEN ?X)) (ODD ?X))       (<= (NOT (ODD ?X)) (EVEN ?X)))(contrapositives '(=> (red ?x) (round ?x) (apple ?x)))((<= (NOT (RED ?X)) (ROUND ?X) (NOT (APPLE ?X)))       (<= (NOT (ROUND ?X)) (RED ?X) (NOT (APPLE ?X)))       (<= (APPLE ?X) (RED ?X) (ROUND ?X)));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Matcher;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; varp;;; indvarp;;; seqvarp;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(varp 'red)NIL(varp '(p a b))NIL(varp '?x)T(varp '@x)T(indvarp '?x)t(indvarp '@x)nil(seqvarp '@x)t(seqvarp '?x)nil;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; eq;;; eql;;; equal;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(setq a '(one two))(ONE TWO)(setq b '(one two))(ONE TWO)(eql a a)T(equal a a)T(eql a b)NIL(equal a b)T;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; identp;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(identp '?x '?x)T(identp '@y '@y)T(identp '(quote ?x) '(quote ?y))NIL(identp nil '(quote nil))NIL(identp '(p '(g a) b) '(p (listof 'g 'a) b))T(identp '(p ?x b) '(p a b))NIL;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; samep;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(samep '(p ?x b) '(p ?y b))T(samep '(p ?x b) '(p a b))NIL(samep '(p ?x ?y) '(p ?y ?x))T(samep '(p ?x ?y) '(p ?w ?w))NIL(samep '(p ?x @y) '(p ?x ?y))NIL(samep '(p ?x @y) '(p ?y @x))T;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; samelist;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(samelist '(q e d) '(q e d))((T . T))(samelist '(p ?x b) '(p ?y b))((?X . ?Y) (T . T))(samelist '(p ?x b) '(p a b))NIL(samelist '(p ?x ?y) '(p ?y ?x))((?Y . ?X) (?X . ?Y) (T . T))(samelist '(p ?x ?y) '(p ?a ?b))((?Y . ?B) (?X . ?A) (T . T))(samelist '(p ?x ?y) '(p ?w ?w))NIL(samelist '(p ?x @y) '(p ?x ?y))NIL(samelist'(p ?x @y) '(p ?y @x))((@Y . @X) (?X . ?Y) (T . T));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; matchp;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(matchp '(p ?x b) '(p a b))T(matchp '(p ?x ?y) '(p ?y x))T(matchp '(parents bill @x) '(parents bill ralph mary))T(matchp '(p a b) '(p ?x b))NIL(matchp '(p a b) '(p c ?x))NIL(matchp '(p ?x b) '(p a ?x))NIL(matchp '(p ?x b) '(p ?x b))T;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; matcher;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(matcher '(p ?x b) '(p a b))((?X . A) (T . T))(matcher '(p ?x ?y) '(p ?y x))((?Y . X) (?X . ?Y) (T . T))(matcher '(parents bill @x) '(parents bill ralph mary))((@X RALPH MARY) (T . T))(matcher '(p a b) '(p ?x b))NIL(matcher '(p a b) '(p c ?x))NIL(matcher '(p ?x b) '(p a ?x))NIL(matcher '(p ?x b) '(p ?x b))((?X . ?X) (T . T));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; instp;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(instp '(p a b) '(p ?x b))T(instp '(p ?x b) '(p a b))NIL(instp '(p a b c)  '(p a @x))T;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; instantiator;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(instantiator '(p a b) '(p ?x b))((?X . A) (T . T))(instantiator '(p ?x b) '(p a b))NIL(instantiator '(p a b c)  '(p a @x))((@x B C) (T . T));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; mgup;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(mgup '(p ?x b) '(p a ?y))T(mgup '(p ?x b) '(p a ?x))NIL(mgup '(p ?x b) '(p ?x b))T(mgup '(p ?x (f ?y)) '(p (g ?u) ?v))T(mgup '(+ (2 ?x) @y) '(+ (?x ?z) 4 5))T(mgup '(+ (2 ?x) @y) '(+ (?x 3) 4 5))NIL;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; mgu;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(mgu '(p ?x b) '(p a ?y))((?Y . B) (?X . A) (T . T))(mgu '(p ?x b) '(p a ?x))NIL(mgu '(p ?x b) '(p ?x b))((T . T))(mgu '(p ?x (f ?y)) '(p (g ?u) ?v))((?V F ?Y) (?X G ?U) (T . T))(mgu '(+ (2 ?x) @y) '(+ (?x ?z) 4 5))((@Y 4 5) (?Z . 2) (?X . 2) (T . T))(mgu '(+ (2 ?x) @y) '(+ (?x 3) 4 5))NIL(let ((*occurcheck* nil)) (mgu '(p ?x (f ?x)) '(p (g ?y) ?y)))((?Y F ?X) (?X G ?Y) (T . T))(mgu '(p ?x (f ?x)) '(p (g ?y) ?y))NIL;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; unifyp;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(unifyp '(red ?x) '(red @x))T(unifyp '(p ?x) '(?x q))T(unifyp '(p (f x) (q y)) '(p ?x (q ?x)))NIL(unifyp '(+ ?x 3 (* 2 y)) '(+ 2 3 (* 2 ?x)))T;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; stdize;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(samep '(forall (?x) (=> (apple ?x) (fruit ?x)))       (stdize '(forall (?x) (=> (apple ?x) (fruit ?x)))))T(samep '(red ?x @y) (stdize '(red ?x @y)))T;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; plug;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(plug '(parent ?x ?y) '((?Y . SAM) (?X . FRED) (T . T)))(PARENT FRED SAM)(plug '(parent ?u jackson) '((?Y . SAM) (?X . FRED) (T . T)))(PARENT ?U JACKSON)(mgu '(father ?x ?y) '(father fred sam))((?Y . SAM) (?X . FRED) (T . T))(plug '(parent ?x ?y) '((?Y . SAM) (?X . FRED) (T . T)))(PARENT FRED SAM);;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Proprep;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; insert;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(insert '(brother ralph sue) 'global)(BROTHER RALPH SUE)(insert '(sister sue ralph) 'global)(SISTER SUE RALPH)(insert '(=> (father ?x ?y) (child ?y ?x)) 'global)(=> (FATHER ?X ?Y) (CHILD ?Y ?X))(insert '(sister sue ralph) 'global)(SISTER SUE RALPH)(indexps 'brother 'global)((BROTHER RALPH SUE))(indexps 'ralph 'global)((BROTHER RALPH SUE) (SISTER SUE RALPH) (SISTER SUE RALPH))(indexps '(brother ralph sue) 'global)((BROTHER RALPH SUE))(indexps '(father jim bill) 'global)((=> (FATHER ?X ?Y) (CHILD ?Y ?X)))(indexps '?x 'global)((BROTHER RALPH SUE) (SISTER SUE RALPH) (=> (FATHER ?X ?Y) (CHILD ?Y ?X)) (SISTER SUE RALPH))(uninsert (car (indexps '?x 'global)) 'global)(BROTHER RALPH SUE)(indexps '?x 'global)((SISTER SUE RALPH) (=> (FATHER ?X ?Y) (CHILD ?Y ?X)) (SISTER SUE RALPH))(uninsert '(sister sue ralph) 'global)(SISTER SUE RALPH)(indexps '?x 'global)((SISTER SUE RALPH) (=> (FATHER ?X ?Y) (CHILD ?Y ?X)) (SISTER SUE RALPH))(uninsert (car (indexps '?x 'global)) 'global)(SISTER SUE RALPH)(indexps '?x 'global)((=> (FATHER ?X ?Y) (CHILD ?Y ?X)) (SISTER SUE RALPH))(reset)*(insert '(mathematician eudoxus) 'global)(MATHEMATICIAN EUDOXUS)(insert '(astronomer menaechmus) 'global)(ASTRONOMER MENAECHMUS)(contents 'global)((MATHEMATICIAN EUDOXUS) (ASTRONOMER MENAECHMUS))(reset)*(insert '(mathematician eudoxus) 'global)(MATHEMATICIAN EUDOXUS)(insert '(astronomer menaechmus) 'global)(ASTRONOMER MENAECHMUS)(empty 'global)GLOBAL(contents 'global)NIL(reset)**theories*NIL(insert 'sunny 'lax)SUNNY(insert 'foggy 'sfo)FOGGY*theories*(SFO LAX)(empty 'LAX)LAX*theories*(SFO)(reset)*(deftheory global        "The sentences for the Global theory"        (father jim ralph)        (father jim sue)        (=> (apple ?x) (fruit ?x)))GLOBAL(contents 'global)((FATHER JIM RALPH)       (FATHER JIM SUE)       (=> (APPLE ?X) (FRUIT ?X)))(documentation 'global 'concept)"The sentences for the Global theory"(reset)*(save '(parent art bob) 'global)(PARENT ART BOB)(save '(parent art bob) 'global)NIL(contents 'global)((PARENT ART BOB))(save '(loves ?x ?x) 'global)(LOVES ?X ?X)(save '(loves jill jill) 'global)(LOVES JILL JILL)(save '(loves joe joe) 'global 'unifyp)NIL(save '(loves joe jill) 'global 'unifyp)(LOVES JOE JILL)(contents 'global)((PARENT ART BOB) (LOVES ?X ?X) (LOVES JILL JILL) (LOVES JOE JILL))(reset)*(save '(parent art bob) 'global)(PARENT ART BOB)(save '(parent art bea) 'global)(PARENT ART BEA)(save '(parent art bess) 'global)(PARENT ART BESS)(contents 'global)((PARENT ART BOB) (PARENT ART BEA) (PARENT ART BESS))(drop '(parent art bess) 'global)T(contents 'global)((PARENT ART BOB) (PARENT ART BEA))(drop '(parent ?x ?y) 'global)T(contents 'global)((PARENT ART BOB) (PARENT ART BEA))(drop '(parent ?x ?y) 'global 'unifyp)T(contents 'global)NIL(reset)*(deftheory global        (father jim ralph)        (father jim sue)        (mother jill ralph)        (=> (apple ?x) (fruit ?x)))GLOBAL(kill 'father 'global)T(contents 'global)((MOTHER JILL RALPH)       (=> (APPLE ?X) (FRUIT ?X)))(kill '(apple mac) 'global 'unifyp)T(contents 'global)((MOTHER JILL RALPH))(reset)*(save '(parent art bob) 'global)(PARENT ART BOB)(save '(parent art bea) 'global)(PARENT ART BEA)(save '(parent art bess) 'global)(PARENT ART BESS)(save '(=> (parent ?x ?y) (not parent ?y ?x)) 'global)(=> (PARENT ?X ?Y) (NOT PARENT ?Y ?X))(truep '(parent art bob) 'global)T(truep '(parent ?x bob) 'global)T(truep '(parent @l) 'global)T(truex '?x '(parent ?x bob) 'global)ART(truex '?y '(parent art ?y) 'global)BOB(truex '(related @l) '(parent @l) 'global)(RELATED ART BOB)(trues '?y '(parent art ?y) 'global)(BOB BEA BESS)(trues '(related ?x ?y) '(parent ?x ?y) 'global)((RELATED ART BOB) (RELATED ART BEA) (RELATED ART BESS))(setq gen (trueg '?y '(parent art ?y) 'global))*(funcall gen)BOB(funcall gen)BEA(funcall gen)BESS(funcall gen)NIL(reset)*(includes 'c 'global)T(includes 'd 'global)T(includes 'a 'c)T(includes 'a 'd)T(includes 'b 'd)T(includees 'a)(C D)(includees 'b)(D)(includees 'c)(GLOBAL)(includees 'd)(GLOBAL)(includees 'global)NIL(includers 'a)NIL(includers 'b)NIL(includers 'c)(A)(includers 'd)(A B)(includers 'global)(C D)(reset)*(includes 'top 'left)T(includes 'top 'right)T(includes 'left 'bottom)T(save '(p a) 'top)(P A)(save '(q a) 'left)(Q A)(save '(r a) 'right)(R A)(save '(s a) 'bottom)(S A)(truep '(p a) 'top)T(truep '(q a) 'top)NIL(knownp '(p a) 'top)T(knownp '(q a) 'top)T(knownp '(r a) 'top)T(knownp '(s a) 'top)T(reset)*(includes 'top 'left)T(includes 'top 'right)T(includes 'left 'bottom)T(save '(p a) 'top)(P A)(save '(p b) 'left)(P B)(save '(p c) 'right)(P C)(save '(p d) 'bottom)(P D)(knowns '?x '(p ?x) 'top)(A B D C)(reset)*;;;;(samep (sif '(not (r (f (g ?x)) b)))       '(OR (NOT (= (G ?X) ?X1)) (NOT (= (F ?X1) ?X2)) (NOT (R ?X2 B))))T;;;;(samep (car (rules '(r (f (g ?x)) b)))       '(<= (R ?X2 B) (= (F ?X1) ?X2) (= (G ?X) ?X1)))T(samep (car (rules '(<= (r (f ?x) ?y) (p ?x) (q (g ?y)))))       '(<= (R ?X1 ?Y) (= (F ?X) ?X1) (P ?X) (= (G ?Y) ?Y1) (Q ?Y1)))T;;;;(setq *functionals* '(f))(F)(samep (car (rules '(r (f (g ?x)) b)))       '(<= (R (F ?X1) B) (= (G ?X) ?X1)))T(setq *functionals* '(g))(G)(samep (car (rules '(r (f (g ?x)) b)))       '(<= (R ?X1 B) (= (F (G ?X)) ?X1)))T(setq *functionals* '(f g))(F G)(car (rules '(r (f (g ?x)) b)))(R (F (G ?X)) B)(setq *names* nil)NIL(samep (car (rules '(r (f (g a)) b)))       '(<= (R (F (G ?X)) ?Y) (= B ?Y) (= A ?X)))T(setq *names* t *functionals* nil)*;;;;(save '(<= (grandparent ?x ?z) (parent ?x ?y) (parent ?y ?z))            'global)(<= (GRANDPARENT ?X ?Z) (PARENT ?X ?Y) (PARENT ?Y ?Z))(save '(parent art bob) 'global)(PARENT ART BOB)(save '(parent bob cal) 'global)(PARENT BOB CAL)(save '(parent bob coe) 'global)(PARENT BOB COE)(knownp '(grandparent art cal) 'global)NIL(findp '(grandparent art cal) 'global)T(findx '?x '(grandparent ?x cal) 'global)ART(findx '?y '(grandparent art ?y) 'global)CAL(finds '?y '(grandparent art ?y) 'global)(CAL COE)(setq gen (findg '?y '(grandparent art ?y) 'global))*(funcall gen)CAL(funcall gen)COE(funcall gen)NIL(reset)*;;;;(save '(= (append (listof) ?m) ?m) 'global)*(save '(<= (= (append (listof ?x @l) ?m) (listof ?x @n))           (= (append (listof @l) ?m) (listof @n)))      'global)*(findx '?z '(= (append (listof 1 2) (listof 3 4)) ?z) 'global)(listof 1 2 3 4)(findval '(append (listof 1 2) (listof 3 4)) 'global)(listof 1 2 3 4)(reset)*;;;;(setq *saves* '(family))(FAMILY)(save '(parent art bob) 'global)(PARENT ART BOB)(save '(parent bob cal) 'global)(PARENT BOB CAL)(save '(parent bob coe) 'global)(PARENT BOB COE)(save '(=> (family ?x ?z) (parent ?x ?y) (family ?y ?z)) 'global)(=> (FAMILY ?X ?Z) (PARENT ?X ?Y) (FAMILY ?Y ?Z))(assume '(family art garfunkel) 'global)T(knowns '?x '(family ?x garfunkel) 'global)(ART BOB CAL COE)(setq *saves* nil)*(reset)*;;;;(deftheory global        (p a)        (p b)        (q b)        (<= (r ?x) (p ?x) (q ?x)))GLOBAL(let ((*depth* 0)) (findp '(p a) 'global))NIL*termination*T(let ((*depth* 1)) (findp '(p a) 'global))T(let ((*depth* 1)) (findp '(r b) 'global))NIL*termination*T(let ((*depth* 2)) (findp '(r b) 'global))T(let ((*depth* 1)) (findp '(s b) 'global))NIL*termination*NIL(reset)*;;;;(save '(<= (t ?x) (t ?x)) 'global)(<= (T ?X) (T ?X))(let ((*depth* 10) (*ancestry* nil)) (findp '(t a) 'global))NIL*termination*T(let ((*depth* 10) (*ancestry* t)) (findp '(t a) 'global))NIL*termination*NIL(reset)*;;;;(deftheory global        (p a)        (p b)        (q b)        (<= (r ?x) (p ?x) (q ?x))        (<= (s ?x) (p ?x) cut (q ?x))        (<= (s ?x) (q ?x)))GLOBAL(findx '?x '(r ?x) 'global)B(findx '?x '(s ?x) 'global)NIL(reset)*;;;;(deftheory group        (<= (= (* ?x ?y) ?x) (= ?y e))        (<= (= (* ?y ?x) ?x) (= ?y e))        (<= (= (* ?x ?y) e) (= ?y (inv ?x)))        (<= (= (* ?x ?v) ?w)            (= (* ?y ?z) ?v)            (= (* ?x ?y) ?u)            (= (* ?u ?z) ?w)))GROUP(deftheory equality        (= ?x ?x)        (<= (= ?x ?y) (= ?y ?x))        (<= (= ?x ?z) (= ?x ?y) (= ?y ?z)))EQUALITY(includes 'group 'equality)T(let ((*depth* 5)) (findp '(= (* (inv x) x) e) 'group))T(reset)*;;;;(findp '(> 3 2) 'global)t(findp '(not (> 2 3)) 'global)t(findx '?x '(> 3 ?x) 'global)nil;;;;(findp '(== (+ 2 2) 4) 'global)t(findx '?x '(== (+ 2 2) ?x) 'global)4;;;;(findp '(= (+ 2 2) 4) 'global)NIL(findx '?x '(= (+ 2 2) ?x) 'global)NIL(save '(<= (= ?x ?y) (== ?x ?y)) 'global)(<= (= ?X ?Y) (== ?X ?Y))(findp '(= (+ 2 2) 4) 'global)T(findx '?x '(== (+ 2 2) ?x) 'global)4;;;;(findp '(execute (listp '(1 2 3))) 'global)t(findval '(execute (length '(1 2 3))) 'global)3;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; basic.lisp tests;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(findx '?x '(makestring a ?x) 'test)"A"(findx '?x '(symbolize "a" ?x) 'test)a(findp '(isacharacter #\a) 'test)t(findp '(isacharacter a) 'test)nil(findp '(alphabetic #\a) 'test)t(findp '(alphabetic #\1) 'test)nil(findp '(uppercase #\A) 'test)t(findp '(uppercase #\a) 'test)nil(findp '(lowercase #\a) 'test)t(findp '(lowercase #\A) 'test)nil(findp '(digit #\1) 'test)t(findp '(digit #\a) 'test)nil(findp '(alphanumeric #\a) 'test)t(findp '(alphanumeric #\1) 'test)t(findp '(alphanumeric #\.) 'test)nil(findp '(chargreater #\b #\a) 'test)t(findp '(chargreater #\a #\b) 'test)nil(findp '(charless #\a #\b) 'test)t(findp '(charless #\b #\a) 'test)nil(findx '?x '(charupcase #\a ?x) 'test)#\A(findx '?x '(chardowncase #\A ?x) 'test)#\a(findx '?x '(charstring #\a ?x) 'test)"a"(findp '(isastring "a") 'test)t(findp '(isastring a) 'test)nil(findp '(stringgreater "bbc" "abc") 'test)t(findp '(stringgreater "abc" "bbc") 'test)nil(findp '(stringless "abc" "bbc") 'test)t(findp '(stringless "bbc" "abc") 'test)nil(findp '(substring "bc" "abcd") 'test)t(findp '(substring "abcd" "ab") 'test)nil(findx '?x '(stringlength "abc" ?x) 'test)3(findx '?x '(stringelement "abc" 2 ?x) 'test)#\b(findx '?x '(stringsubseq "abcd" 2 3 ?x) 'test)"bc"(findx '?x '(stringalphanumeric " a bc'd-e " ?x) 'test)"abcde"(findx '?x '(stringappend "abc" "def" "ghi" ?x) 'test)"abcdefghi"(findx '?x '(stringappend ?x) 'test)""(findx '?x '(stringcharpos #\b "abc" ?x) 'test)2(findx '?x '(stringcharpos #\d "abc" ?x) 'test)nil(findx '?x '(stringposition "bc" "abcd" ?x) 'test)2(findx '?x '(stringposition "cb" "abcd" ?x) 'test)nil(findx '?x '(stringsubstitute #\a #\b "abab" ?x) 'test)"aaaa"(findx '?x '(stringupcase "abc" ?x) 'test)"ABC"(findx '?x '(stringdowncase "ABC" ?x) 'test)"abc"(findx '?x '(stringcapitalize "abc.def" ?x) 'test)"Abc.Def";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; cnf tests;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(cnf 'true)true(cnf 'false)false(cnf 'p)p(cnf '(and))true(cnf '(and p))p(cnf '(and p q))(and p q)(cnf '(or))false(cnf '(or p))p(cnf '(or p q))(or p q)(cnf '(or (and p q) r))(and (or p r) (or q r))(cnf '(=>))false(cnf '(=> p))p(cnf '(=> p q r))(or (not p) (not q) r)(cnf '(=> (and p q) r))(or (not p) (not q) r)(cnf '(=> (or p q) r))(and (or (not p) r) (or (not q) r))(cnf '(=> p (and q r)))(and (or (not p) q) (or (not p) r))(cnf '(=> p (or q r)))(or (not p) q r)(cnf '(<=))false(cnf '(<= r))r(cnf '(<= r p q))(or r (not p) (not q))(cnf '(<= r (and p q)))(or r (not p) (not q))(cnf '(<= r (or p q)))(and (or r (not p)) (or r (not q)))(cnf '(<= (and q r) p))(and (or q (not p)) (or r (not p)))(cnf '(<= (or q r) p))(or q r (not p))(cnf '(<=>))false(cnf '(<=> r))r(cnf '(<=> p q))(and (or p (not q)) (or (not p) q))(cnf '(forall ?x (p ?x)))(p ?x)(consp (cadr (cnf '(exists ?x (p ?x)))))t(not (not (instp (cnf '(forall ?x (exists ?y (p ?x ?y ?z)))) '(p ?x (?f ?x ?z) ?z))))t(not (not (samep (cnf '(forall ?x (and (p ?x) (forall ?x (q ?x))))) '(and (p ?x) (q ?y)))))t(not (not (samep (cnf '(or (forall ?x (p ?x)) (forall ?x (q ?x)))) '(or (p ?x) (q ?x)))))t(cnf '(not true))false(cnf '(not false))true(cnf '(not p))(not p)(cnf '(not (not p)))p(cnf '(not (and)))false(cnf '(not (and p)))(not p)(cnf '(not (and p q)))(or (not p) (not q))(cnf '(not (or)))true(cnf '(not (or p)))(not p)(cnf '(not (or p q)))(and (not p) (not q))(cnf '(not (=>)))true(cnf '(not (=> p)))(not p)(cnf '(not (=> p q r)))(and p q (not r))(cnf '(not (<=)))true(cnf '(not (<= r)))(not r)(cnf '(not (<= r p q)))(and (not r) p q)(cnf '(not (<=>)))true(cnf '(not (<=> r)))(not r)(consp (cadadr (cnf '(not (forall ?x (p ?x))))))t(cnf '(not (exists ?x (p ?x))))(not (p ?x))(reset)*;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; base tests;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(save '(p ?x b) 'global)(p ?x b)(save '(p a b) 'global 'unifyp)nil(drop '(p a b) 'global 'samep)t(truep '(p ?x b) 'global 'samep)t(drop '(p a b) 'global 'unifyp)t(truep '(p ?x b) 'global 'samep)nil(save '(p (f a) b) 'global)(p (f a) b)(kill 'f 'global)t(truep '(p (f a) b) 'global)nil(truep '(> 3 2) 'global)nil(save '(> 2 3) 'global)(> 2 3)(truep '(> 2 3) 'global)t(drop '(> 2 3) 'global)t(truep '(> 2 3) 'global)nil(reset)*;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(save '(p ?x b) 'global)(p ?x b)(truep '(p ?x b) 'global 'eq)nil(truep '(p ?x b) 'global 'equal)t(truep '(p ?y b) 'global 'equal)nil(truep '(p ?y b) 'global 'samep)t(truep '(p ?x ?y) 'global 'samep)nil(truep '(p a b) 'global 'samep)nil(truep '(p ?x ?y) 'global 'matchp)t(truep '(p a ?y) 'global 'matchp)nil(truep '(p a b) 'global 'instp)t(truep '(p a ?y) 'global 'instp)nil(truep '(p a ?y) 'global 'mgup)t(truep '(p a ?x) 'global 'mgup)nil(truep '(p a ?x) 'global 'unifyp)t(reset)*;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(save '(p a b) 'global)(p a b)(save '(p a c) 'global)(p a c)(trues '?y '(p a ?y) 'global)(b c)(knownp '(p a ?y) 'global)t(knowns '?y '(p a ?y) 'global)(b c)(reset)*;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(save '(= (f ?x b) ?x) 'global)(= (f ?x b) ?x)(getval '(f ?x b) 'global 'eq)nil(getval '(f ?x b) 'global 'equal)?x(getval '(f ?y b) 'global 'equal)nil(getval '(f ?y b) 'global 'samep)?y(getval '(f ?x ?y) 'global 'samep)nil(getval '(f a b) 'global 'samep)nil(getval '(f ?x ?y) 'global 'matchp)?x(getval '(f a ?y) 'global 'matchp)nil(getval '(f a b) 'global 'instp)a(getval '(f a ?y) 'global 'instp)nil(getval '(f a ?y) 'global 'mgup)a(getval '(f a ?x) 'global 'mgup)nil(getval '(f a ?x) 'global 'unifyp)a(reset)*;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(setval '(f a) 1 'global)*(save '(<- (f b) 2) 'global)*(save '(<-- (f c) 3) 'global)*(getval '(f a) 'global)1(getval '(f b) 'global)nil(getval '(f c) 'global)nil(setval '(f a) 2 'global)2(getval '(f a) 'global)2(remval '(f ?x) 'global 'unifyp)t(getval '(f a) 'global)nil(save '(= (f ?x) ?x) 'global)*(value '(f 1) 'global 'instp)1(value '(f 1) 'global 'samep)nil(value '(g 1) 'global 'samep)nil(reset)t;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Match tests;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(identp 1 1)t(identp 1 2)nil(identp '(p 1) '(p '1))t(identp '(p '1) '(p 1))t(identp 'a 'b)nil(identp '(quote (f a b)) '(quote (f a b)))t(identp '(quote (f a b)) '(listof 'f 'a 'b))t(identp '(listof 'f 'a 'b) '(quote (f a b)))t(identp '(listof 'f 'a 'b) '(listof 'f 'a 'b))t(identp '(f (g a b) c) '(f (g a b) c))t(identp '(p quote (f a b)) '(p list (quote f) (quote a) (quote b)))nil(identp '(quote (f a (quote b))) '(listof (quote f) (quote a) (quote b)))nil(identp '(f (g ?x b) c) '(f (g a b) c))nil(identp '(f (g a b) c) '(f (g ?x b) c))nil(samep 1 1)t(samep 1 2)nil(samep '(p 1) '(p '1))t(samep '(p '1) '(p 1))t(samep 'a 'b)nil(samep '(quote (f a b)) '(quote (f a b)))t(samep '(quote (f a b)) '(listof 'f 'a 'b))t(samep '(listof 'f 'a 'b) '(quote (f a b)))t(samep '(listof 'f 'a 'b) '(listof 'f 'a 'b))t(samep '(f (g a b) c) '(f (g a b) c))t(samep '(p quote (f a b)) '(p list (quote f) (quote a) (quote b)))nil(samep '(quote (f a (quote b))) '(listof (quote f) (quote a) (quote b)))nil(samep '(f (g ?x b) c) '(f (g a b) c))nil(samep '(f (g a b) c) '(f (g ?x b) c))nil(samep '(f ?x ?y ?x) '(f ?y ?z ?y))t(samep '(f ?x ?y ?z) '(f ?y ?z ?y))nil(matchp 1 1)t(matchp 1 2)nil(matchp '(p 1) '(p '1))t(matchp '(p '1) '(p 1))t(matchp 'a 'b)nil(matchp '(quote (f a b)) '(quote (f a b)))t(matchp '(quote (f a b)) '(listof 'f 'a 'b))t(matchp '(listof 'f 'a 'b) '(quote (f a b)))t(matchp '(listof 'f 'a 'b) '(listof 'f 'a 'b))t(matchp '(f (g a b) c) '(f (g a b) c))t(matchp '(p quote (f a b)) '(p list (quote f) (quote a) (quote b)))nil(matchp '(quote (f a (quote b))) '(listof (quote f) (quote a) (quote b)))nil(matchp '(f (g ?x b) c) '(f (g a b) c))t(matchp '(f (g ?x ?x) c) '(f (g a b) c))nil(matchp '(f (g a b) c) '(f (g ?x b) c))nil(matchp '(listof 'f ?x 'b @z) '(quote (f a b c d)))t(matchp '(p (f @l) @l) '(p (f quote (g a)) list 'g 'a))nil(matchp '(p (listof 'f ?x) (listof 'g ?x)) '(p '(f 1) '(g 1)))t(mgup 1 1)t(mgup 1 2)nil(mgup '(p 1) '(p '1))t(mgup '(p '1) '(p 1))t(mgup 'a 'b)nil(mgup '(quote (f a b)) '(quote (f a b)))t(mgup '(quote (f a b)) '(listof 'f 'a 'b))t(mgup '(listof 'f 'a 'b) '(quote (f a b)))t(mgup '(listof 'f 'a 'b) '(listof 'f 'a 'b))t(mgup '(f (g a b) c) '(f (g a b) c))t(mgup '(p quote (f a b)) '(p list (quote f) (quote a) (quote b)))nil(mgup '(quote (f a (quote b))) '(listof (quote f) (quote a) (quote b)))nil(mgup '(f (g ?x b) c) '(f (g a b) c))t(mgup '(f (g ?x ?x) c) '(f (g a b) c))nil(mgup '(f (g a b) c) '(f (g ?x b) c))t(mgup '(listof 'f ?x 'b @z) '(quote (f a b ?y d)))t(mgup '(f ?x b) '(f a ?x))nil(let ((*occurcheck* t)) (mgup '?x '(f ?x)))nil(let ((*occurcheck* t)) (mgup '(p ?x ?y) '(p ?y ?x)))t(let ((*occurcheck* t)) (mgup '(p ?x ?x ?y ?y) '(p ?u ?v ?v ?u)))t(let ((*occurcheck* t)) (mgup '(p @l) '(p (f @l))))nil(let ((*occurcheck* t)) (mgup '(p @l) '(p (f '@l))))t(let ((*occurcheck* t)) (mgup '(p @l) '(p (f quote @l))))nil(identifyp 1 1)t(identifyp 1 2)nil(identifyp '(p 1) '(p '1))t(identifyp '(p '1) '(p 1))t(identifyp 'a 'b)nil(identifyp '(quote (f a b)) '(quote (f a b)))t(identifyp '(quote (f a b)) '(listof 'f 'a 'b))t(identifyp '(listof 'f 'a 'b) '(quote (f a b)))t(identifyp '(listof 'f 'a 'b) '(listof 'f 'a 'b))t(identifyp '(f (g a b) c) '(f (g a b) c))t(identifyp '(p quote (f a b)) '(p list (quote f) (quote a) (quote b)))nil(identifyp '(quote (f a (quote b))) '(listof (quote f) (quote a) (quote b)))nil(identifyp '(f (g ?x b) c) '(f (g a b) c))nil(identifyp '(f (g a b) c) '(f (g ?x b) c))nil(matchifyp 1 1)t(matchifyp 1 2)nil(matchifyp '(p 1) '(p '1))t(matchifyp '(p '1) '(p 1))t(matchifyp 'a 'b)nil(matchifyp '(quote (f a b)) '(quote (f a b)))t(matchifyp '(quote (f a b)) '(listof 'f 'a 'b))t(matchifyp '(listof 'f 'a 'b) '(quote (f a b)))t(matchifyp '(listof 'f 'a 'b) '(listof 'f 'a 'b))t(matchifyp '(f (g a b) c) '(f (g a b) c))t(matchifyp '(p quote (f a b)) '(p list (quote f) (quote a) (quote b)))nil(matchifyp '(quote (f a (quote b))) '(listof (quote f) (quote a) (quote b)))nil(matchifyp '(f (g ?x b) c) '(f (g a b) c))t(matchifyp '(f (g ?x ?x) c) '(f (g a b) c))nil(matchifyp '(f (g a b) c) '(f (g ?x b) c))nil(matchifyp '(listof 'f ?x 'b @z) '(quote (f a b c d)))t(matchifyp '(p ?x ?x) '(p (f ?y) (f a)))nil(unifyp 1 1)t(unifyp 1 2)nil(unifyp '(p 1) '(p '1))t(unifyp '(p '1) '(p 1))t(unifyp 'a 'b)nil(unifyp '(quote (f a b)) '(quote (f a b)))t(unifyp '(quote (f a b)) '(listof 'f 'a 'b))t(unifyp '(listof 'f 'a 'b) '(quote (f a b)))t(unifyp '(listof 'f 'a 'b) '(listof 'f 'a 'b))t(unifyp '(f (g a b) c) '(f (g a b) c))t(unifyp '(p quote (f a b)) '(p list (quote f) (quote a) (quote b)))nil(unifyp '(quote (f a (quote b))) '(listof (quote f) (quote a) (quote b)))nil(unifyp '(f (g ?x b) c) '(f (g a b) c))t(unifyp '(f (g ?x ?x) c) '(f (g a b) c))nil(unifyp '(f (g a b) c) '(f (g ?x b) c))t(unifyp '(listof 'f ?x 'b @z) '(quote (f a b ?y d)))t(unifyp '(f ?x b) '(f a ?x))t(unifyp '(p (f 'b @l) (g @m) (listof 'a @m)) '(p (f @n) (g @n) '(a b c)))t(let ((*occurcheck* t)) (unifyp '?x '(f ?x)))t(let ((*occurcheck* t)) (unifyp '(f ?x (g ?x)) '(f (g ?y) ?y)))nil(let ((*occurcheck* t)) (unifyp '(p ?x ?y) '(p ?y ?x)))t(let ((*occurcheck* t)) (unifyp '(p ?x ?x ?y ?y) '(p ?u ?v ?v ?u)))t(let ((*occurcheck* t)) (unifyp '(p ?x ?x) '(p (f @l) (f (g @l)))))nil(let ((*occurcheck* t)) (unifyp '(p ?x ?x) '(p (f @l) (f (g '@l)))))t(let ((*occurcheck* t)) (unifyp '(p ?x ?x) '(p (f @l) (f (g quote @l)))))nil(mgup '(f (h ?1 ?2 ?3) (h ?6 ?7 ?8) ?3 ?6)        '(f (h (g ?4 ?5) ?1 ?2) (h ?7 ?8 ?6) (g ?5 a) ?5))t(mgup '(f ?1 (g ?2 ?3) ?2 b)        '(f (g (h a ?5) ?2) ?1 (h a ?4) ?4))t(mgup '(f ?x (f ?u ?x))        '(f (f ?y a) (f ?z (f b ?z))))t(mgup '(A (B ?v) (C ?u ?v))        '(A (B ?w) (C ?w (D ?x ?y))))t(mgup '(q ?1 (g ?1) ?2 (h ?1 ?2) ?3 (k ?1 ?2 ?3))        '(q ?y1 ?y2 (c ?y2) ?y3 (f ?y2 ?y3) ?y4))t(mgup '(p (f ?x (g ?x ?y)) (h ?z ?y))        '(p ?z (h (f ?u ?v) (f ?d ?c))))t(mgup '(f ?1 ?2 ?3 ?4 ?5 ?6 ?7 ?8 ?9)        '(f ?2 ?3 ?4 ?5 ?6 ?7 ?8 ?9 a))t(mgup '(p ?w ?y ?x ?u)        '(p (g ?y ?y ?y) (g ?x ?x ?x) (g ?u ?u ?u) (g a a a)))t(mgup '(p ?1 ?3 (g ?2) c (h ?3 ?4 (f ?4 b)) ?4)        '(p (f ?3 ?y1) b ?y1 ?2 ?y2 (l ?y1 b)))t(mgup '(p ?1 ?2 ?3 ?4 ?5 (f ?y) ?7 ?8 ?9 ?10 (f a) ?7)        '(p ?2 ?3 ?4 ?5 ?6 ?6 ?8 ?9 ?10 ?11 ?11 ?1))t;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Proprep tests;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(setq foo (insert '(p a a) 'global))(p a a)(contents 'global)((p a a))(uninsert '(p a a) 'global)(p a a)(contents 'global)((p a a))(uninsert foo 'global)(p a a)(contents 'global)NIL(insert '(p a a) 'global)(p a a)(empty 'global)GLOBAL(contents 'global)nil;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(includes 'a 'c)t(includes 'b 'c)t(includes 'c 'd)t(includes 'c 'e)t(includers 'c)(a b)(includees 'c)(d e)(mapcar-theories 'identity 'a)(a c d e)(mapappend-theories 'list 'a)(a c d e)(mapcan-theories 'list 'a)(a c d e)(mapc-theories 'identity 'a)a(mapand-theories 'atom 'a)t(mapand-theories 'listp 'a)nil(mapor-theories 'listp 'a)nil(mapor-theories 'atom 'a)t(reset)t;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; primitiveness tests;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(primitivep 1)t(primitivep "abc")t(primitivep #\a)t(primitivep 'pi)nil(primitivep 'a)t(primitivep ''a)t(primitivep '(execute (car '(a))))nil(primitivep '(if true 1 2))nil(primitivep '(cond (true 1)))nil(primitivep '(listof 1 2 3))t(primitivep '(+ 1 2))nil(primitivep '(f a))nil(pseudoprimitivep 1)nil(pseudoprimitivep "abc")nil(pseudoprimitivep #\a)nil(pseudoprimitivep 'pi)t(pseudoprimitivep 'a)nil(pseudoprimitivep ''a)nil(pseudoprimitivep '(execute (car '(a))))nil(pseudoprimitivep '(if true 1 2))nil(pseudoprimitivep '(cond (true 1)))nil(pseudoprimitivep '(listof 1 2 3))nil(pseudoprimitivep '(+ 1 2))nil(pseudoprimitivep '(f a))t(pseudoprimitivep '(f pi))nil(pseudosentencep 'true)nil(pseudosentencep 'cut)nil(pseudosentencep 'false)nil(pseudosentencep 'p)t(pseudosentencep '(not p))t(pseudosentencep '(and p q))nil(pseudosentencep '(or p q))nil(pseudosentencep '(<= p q))nil(pseudosentencep '(<=> p q))nil(pseudosentencep '(=> p q))nil(pseudosentencep '(forall ?x true))nil(pseudosentencep '(exists ?x true))nil(pseudosentencep '(> 3 2))nil(pseudosentencep '(p a))t(pseudosentencep '(p pi))nil(reset)*;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; find tests;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(findp 'true 'global)t(findp 'cut 'global)t(findp 'false 'global)nil(findp '(== a a) 'global)t(findp '(== a b) 'global)nil(findp '(distinct a a) 'global)nil(findp '(distinct a b) 'global)t(findp '(word 'a) 'global)t(findp '(word a) 'global)nil(findp '(indvar '?x) 'global)t(findp '(indvar a) 'global)nil(findp '(seqvar '@l) 'global)t(findp '(seqvar a) 'global)nil(findp '(variable '?x) 'global)t(findp '(variable a) 'global)nil;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; findval tests;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(save '(<= (= ?x ?y) (== ?x ?y)) 'global)*(findval 2 'global)2(findval 'a 'global)a(findval '(f a) 'global)nil(findval '(execute (member 'b '(a b c))) 'global)'(b c)(findval '(listof 1 2 3) 'global)(listof 1 2 3)(findval '(nomination 1) 'global)1(findval '(nomination "abc") 'global)"abc"(findval '(nomination #\a) 'global)#\a(findval '(nomination a) 'global)'a(findval '(denotation 1) 'global)1(findval '(denotation "abc") 'global)"abc"(findval '(denotation #\a) 'global)#\a(findval '(denotation 'a) 'global)a(findx '?z '(= (denotation '(+ 2 2)) ?z) 'global)(+ 2 2)(findval '(denotation a) 'global)nil(findp '(complex-number #c(1 2)) 'global)t(findp '(complex-number a) 'global)nil(findp '(even-integer 2) 'global)t(findp '(even-integer a) 'global)nil(findp '(real-number 3.2) 'global)t(findp '(real-number a) 'global)nil(findp '(integer 2) 'global)t(findp '(integer a) 'global)nil(findp '(logbit 2 6) 'global)t(findp '(logbit 0 6) 'global)nil(findp '(logtest 2 6) 'global)t(findp '(logtest 2 -3) 'global)nil(findp '(negative -1) 'global)t(findp '(negative a) 'global)nil(findp '(isanumber 2) 'global)t(findp '(isanumber a) 'global)nil(findp '(odd-integer 3) 'global)t(findp '(odd-integer a) 'global)nil(findp '(positive 3) 'global)t(findp '(positive a) 'global)nil(findp '(rational-number 1/2) 'global)t(findp '(rational-number a) 'global)nil(findp '(zero 0) 'global)t(findp '(zero a) 'global)nil(findp '(< 2 3) 'global)t(findp '(< 3 3) 'global)nil(findp '(< a b) 'global)nil(findp '(=< 2 3) 'global)t(findp '(=< 3 2) 'global)nil(findp '(=< a b) 'global)nil(findp '(> 3 2) 'global)t(findp '(> 3 3) 'global)nil(findp '(> a b) 'global)nil(findp '(>= 3 2) 'global)t(findp '(>= 2 3) 'global)nil(findp '(>= a b) 'global)nil;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; findval tests;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(findval '(+ 1 2) 'global)3(findval '(- 3 2) 'global)1(findval '(* 2 3) 'global)6(findval '(/ 4 2) 'global)2(findval '(1+ 1) 'global)2(findval '(1- 2) 'global)1(findval '(abs -1) 'global)1(findval '(acos 1) 'global)0(findval '(acosh 1) 'global)0(findval '(ash 1 1) 'global)2;(findval '(asin 0) 'global);0;(findval '(asinh 0) 'global);0;(findval '(atan 0) 'global);0;(findval '(atanh 0) 'global);0(findval '(boole 6 1 1) 'global)1(findval '(ceiling 1.6) 'global)2(findval '(cis 0) 'global)#c(1 0)(findval '(complex 1 1) 'global)#c(1 1)(findval '(conjugate #c(1 1)) 'global)#c(1 -1)(findval '(cos 0) 'global)1(findval '(cosh 0) 'global)1(findval '(decode-float -1.2) 'global)0.6(findval '(denominator 1/2) 'global)2(findval '(exp 0) 'global)1(findval '(expt 2 3) 'global)8(findval '(fceiling 1.6) 'global)2.0(findval '(ffloor 1.6) 'global)1.0(findval '(floor 1.6) 'global)1(findval '(float 2) 'global)2.0(findval '(fround 1.6) 'global)2.0(integerp (findval '(float-digits -1.2) 'global))t(integerp (findval '(float-precision -1.2) 'global))t(integerp (findval '(float-radix -1.2) 'global))t(findval '(float-sign -1.2) 'global)-1.0(findval '(ftruncate 1.6) 'global)1.0(findval '(gcd 2 6) 'global)2(findval '(imagpart #c(1 2)) 'global)2(integerp (findval '(integer-decode-float 1.2) 'global))t(findval '(isqrt 5) 'global)2(findval '(lcm 2 3) 'global)6(findval '(log 8 2) 'global)3(findval '(logand 1 1) 'global)1(findval '(logandc1 0 1) 'global)1(findval '(logandc2 1 0) 'global)1(findval '(logcount 3) 'global)2(findval '(logeqv 1 1) 'global)-1(findval '(logior 1 1) 'global)1(findval '(lognand 0 1) 'global)-1(findval '(lognor 0 0) 'global)-1(findval '(lognot -4) 'global)3(findval '(logorc1 0 0) 'global)-1(findval '(logorc2 0 0) 'global)-1(findval '(logxor 0 1) 'global)1(findval '(max 1 2 3) 'global)3(findval '(min 1 2 3) 'global)1(findval '(mod 7 2) 'global)1(findval '(numerator 1/2) 'global)1(findval '(phase 0) 'global)0(findval '(rational 0.5) 'global)1/2(findval '(rationalize 0.5) 'global)1/2(findval '(realpart #c(1 2)) 'global)1(findval '(rem 3 2) 'global)1(findval '(round 1.6) 'global)2(findval '(scale-float 1.2 2) 'global)4.8(findval '(signum 23) 'global)1(findval '(sin 0) 'global)0(findval '(sinh 0) 'global)0(findval '(sqrt 4) 'global)2(findval '(tan 0) 'global)0(findval '(tanh 0) 'global)0(findval '(truncate 1.6) 'global)1;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Mike's tests for epilog backward chaining;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(findp 'true 'global)t(findp 'false 'global)nil(findp '(not true) 'global)nil(findp '(not false) 'global)t(findp '(and true true) 'global)t(findp '(and true false) 'global)nil(findp '(and false true) 'global)nil(findp '(and false false) 'global)nil(findp '(or true true) 'global)t(findp '(or true false) 'global)t(findp '(or false true) 'global)t(findp '(or false false) 'global)nil(deftheory global  (p a)  (p b)  (p c)  (q b)  (q c)  (<= (r ?x) (p ?x) (q ?x))  (<= (s ?x) (p ?x) cut (q ?x))  (<= (s ?x) (q ?x))  (<= (t ?x) (t ?x))  (j a)  (j b)  (k b)  (<= (l ?x) (j ?x) cut (k ?x))  (l c)  (<= (m ?x) (l ?x))  (m d))*(findx '?x '(and (p ?x) (q ?x)) 'global)b(finds '?x '(and (p ?x) (q ?x)) 'global)(b c)(setq foo (findg '?x '(and (p ?x) (q ?x)) 'global))*(funcall foo)b(funcall foo)c(funcall foo)nil(findx '?x '(or (p ?x) (q ?x)) 'global)a(finds '?x '(or (p ?x) (q ?x)) 'global)(a b c)(findx '?x '(r ?x) 'global)b(findx '?x '(s ?x) 'global)nil(findx '?x '(m ?x) 'global)d(deftheory cut  (<= (p ?x) (pp ?x))  (<= (p a))  (<= (q ?x) cut (qq ?x))  (<= (q b))  (<= (r ?x) (== (+ 1 1) 2) cut (rr ?x))  (<= (r c))  (<= (s ?x) (or (ss ?x) (sss ?x)))  (s d)  (ss a)  (ss b)  (sss c)  (<= (t ?x) (or (tt ?x) cut (ttt ?x)))  (t d)  (tt a)  (tt b)  (ttt c))*(finds '?x '(p ?x) 'cut)(a)(finds '?x '(q ?x) 'cut)nil(finds '?x '(r ?x) 'cut)nil(finds '?x '(s ?x) 'cut)(a b c d)(finds '?x '(t ?x) 'cut)(A B ?X C D)(deftheory pp  (pp a a)  (pp a b))*(deftheory qq  (qq b c))*(includes 'global 'pp)*(includes 'global 'qq)*(findx '(?x ?y ?z) '(and (pp ?x ?y) (qq ?y ?z)) 'global)(a b c)(let ((*depth* 0)) (findp '(p a) 'global))nil(let ((*depth* 1)) (findp '(p a) 'global))t(let ((*depth* 1)) (findp '(r c) 'global))nil(let ((*depth* 2)) (findp '(r c) 'global))t(let ((*depth* 10) (*ancestry* nil)) (or (findp '(t a) 'global) *termination*))t(let ((*depth* 10) (*ancestry* t)) (or (findp '(t a) 'global) *termination*))nil(reset)*(deftheory eq  (= (length (listof)) 0)  (<= (= (length (listof ?x @l)) ?n)      (= (length (listof @l)) ?n-1)      (== (+ ?n-1 1) ?n)))*(findx '?z '(= (length (listof a b c)) ?z) 'eq)3(length (cdr (findx '?l '(= (length ?l) 3) 'eq)))3;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Mike's tests for epilog forward chaining;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(deftheory save  (qqq a)  (=> (ppp ?x) (qqq ?x) (rrr ?x)))*(includes 'save 'global)*(setq *saves* '(rrr))*(assume '(ppp a) 'save)t(truep '(rrr a) 'save)t(reset)*;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Residue;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(deftheory residue  (<= (goal1 ?x ?y) (p ?x ?y) (unprovable (m ?x ?y)))  (<= (goal2 ?x ?y) (p ?x ?y) (unprovable (q ?x ?y)))  (<= (goal3 ?x)    (p ?x) (unprovable (m ?x ?y)))  (<= (goal4 ?x)    (p ?x) (unprovable (q ?x ?y)))  (<= (goal5 ?x)    (p ?x) (unprovable (q ?x ?y)) (r ?y))  (<= (q ?x ?y) (m ?x ?y) (n ?y ?z)))*(defun filter (x) (find x '(m n p r)))*(defun fulter (x) (declare (ignore x)) t)*(residues '(?x ?y) '(goal1 ?x ?y) 'residue #'filter #'fulter)*(residues '(?x ?y) '(goal2 ?x ?y) 'residue #'filter #'fulter)*(residues '(?x ?y) '(goal3 ?x) 'residue #'filter #'fulter)*(residues '(?x ?y) '(goal4 ?x) 'residue #'filter #'fulter)*(residues '(?x ?y) '(goal5 ?x) 'residue #'filter #'fulter)*;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; fullfindp;;; fullfindx;;; fullfinds;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(fullfindp '(> 3 2) 'global)t(fullfindp '(not (> 2 3)) 'global)t(fullfindx '?x '(> 3 ?x) 'global)nil(fullfindp '(== (+ 2 2) 4) 'global)t(fullfindx '?x '(== (+ 2 2) ?x) 'global)4(fullfindp '(execute (listp '(1 2 3))) 'global)t(fullfindx '?x '(execute (length '(1 2 3)) ?x) 'global)3(fullfindx '?x '(makestring a ?x) 'test)"A"(fullfindx '?x '(symbolize "a" ?x) 'test)a(fullfindp '(isacharacter #\a) 'test)t(fullfindp '(isacharacter a) 'test)nil(fullfindp '(alphabetic #\a) 'test)t(fullfindp '(alphabetic #\1) 'test)nil(fullfindp '(uppercase #\A) 'test)t(fullfindp '(uppercase #\a) 'test)nil(fullfindp '(lowercase #\a) 'test)t(fullfindp '(lowercase #\A) 'test)nil(fullfindp '(digit #\1) 'test)t(fullfindp '(digit #\a) 'test)nil(fullfindp '(alphanumeric #\a) 'test)t(fullfindp '(alphanumeric #\1) 'test)t(fullfindp '(alphanumeric #\.) 'test)nil(fullfindp '(chargreater #\b #\a) 'test)t(fullfindp '(chargreater #\a #\b) 'test)nil(fullfindp '(charless #\a #\b) 'test)t(fullfindp '(charless #\b #\a) 'test)nil(fullfindx '?x '(charupcase #\a ?x) 'test)#\A(fullfindx '?x '(chardowncase #\A ?x) 'test)#\a(fullfindx '?x '(charstring #\a ?x) 'test)"a"(fullfindp '(isastring "a") 'test)t(fullfindp '(isastring a) 'test)nil(fullfindp '(stringgreater "bbc" "abc") 'test)t(fullfindp '(stringgreater "abc" "bbc") 'test)nil(fullfindp '(stringless "abc" "bbc") 'test)t(fullfindp '(stringless "bbc" "abc") 'test)nil(fullfindp '(substring "bc" "abcd") 'test)t(fullfindp '(substring "abcd" "ab") 'test)nil(fullfindx '?x '(stringlength "abc" ?x) 'test)3(fullfindx '?x '(stringelement "abc" 2 ?x) 'test)#\b(fullfindx '?x '(stringsubseq "abcd" 2 3 ?x) 'test)"bc"(fullfindx '?x '(stringalphanumeric " a bc'd-e " ?x) 'test)"abcde"(fullfindx '?x '(stringappend "abc" "def" "ghi" ?x) 'test)"abcdefghi"(fullfindx '?x '(stringappend ?x) 'test)""(fullfindx '?x '(stringcharpos #\b "abc" ?x) 'test)2(fullfindx '?x '(stringcharpos #\d "abc" ?x) 'test)nil(fullfindx '?x '(stringposition "bc" "abcd" ?x) 'test)2(fullfindx '?x '(stringposition "cb" "abcd" ?x) 'test)nil(fullfindx '?x '(stringsubstitute #\a #\b "abab" ?x) 'test)"aaaa"(fullfindx '?x '(stringupcase "abc" ?x) 'test)"ABC"(fullfindx '?x '(stringdowncase "ABC" ?x) 'test)"abc"(fullfindx '?x '(stringcapitalize "abc.def" ?x) 'test)"Abc.Def"(fullfindp 'true 'global)t(fullfindp 'false 'global)nil(fullfindp '(== a a) 'global)t(fullfindp '(== a b) 'global)nil(fullfindp '(distinct a a) 'global)nil(fullfindp '(distinct a b) 'global)t(fullfindp '(word 'a) 'global)t(fullfindp '(word a) 'global)nil(fullfindp '(indvar '?x) 'global)t(fullfindp '(indvar a) 'global)nil(fullfindp '(seqvar '@l) 'global)t(fullfindp '(seqvar a) 'global)nil(fullfindp '(variable '?x) 'global)t(fullfindp '(variable a) 'global)nil(fullfindx '?x '(+ 1 2 ?x) 'global)3(fullfindx '?x '(- 3 2 ?x) 'global)1(fullfindx '?x '(* 2 3 ?x) 'global)6(fullfindx '?x '(/ 4 2 ?x) 'global)2(fullfindx '?x '(1+ 1 ?x) 'global)2(fullfindx '?x '(1- 2 ?x) 'global)1(fullfindx '?x '(abs -1 ?x) 'global)1(fullfindx '?x '(acos 1 ?x) 'global)0(fullfindx '?x '(acosh 1 ?x) 'global)0(fullfindx '?x '(ash 1 1 ?x) 'global)2;(fullfindx '?x '(asin 0 ?x) 'global);0;(fullfindx '?x '(asinh 0 ?x) 'global);0;(fullfindx '?x '(atan 0 ?x) 'global);0;(fullfindx '?x '(atanh 0 ?x) 'global);0(fullfindx '?x '(boole 6 1 1 ?x) 'global)1(fullfindx '?x '(ceiling 1.6 ?x) 'global)2(fullfindx '?x '(cis 0 ?x) 'global)#c(1 0)(fullfindx '?x '(complex 1 1 ?x) 'global)#c(1 1)(fullfindx '?x '(conjugate #c(1 1) ?x) 'global)#c(1 -1)(fullfindx '?x '(cos 0 ?x) 'global)1(fullfindx '?x '(cosh 0 ?x) 'global)1(fullfindx '?x '(decode-float -1.2 ?x) 'global)0.6(fullfindx '?x '(denominator 1/2 ?x) 'global)2(fullfindx '?x '(exp 0 ?x) 'global)1(fullfindx '?x '(expt 2 3 ?x) 'global)8(fullfindx '?x '(fceiling 1.6 ?x) 'global)2.0(fullfindx '?x '(ffloor 1.6 ?x) 'global)1.0(fullfindx '?x '(floor 1.6 ?x) 'global)1(fullfindx '?x '(float 2 ?x) 'global)2.0(fullfindx '?x '(fround 1.6 ?x) 'global)2.0(integerp (fullfindx '?x '(float-digits -1.2 ?x) 'global))t(integerp (fullfindx '?x '(float-precision -1.2 ?x) 'global))t(integerp (fullfindx '?x '(float-radix -1.2 ?x) 'global))t(fullfindx '?x '(float-sign -1.2 ?x) 'global)-1.0(fullfindx '?x '(ftruncate 1.6 ?x) 'global)1.0(fullfindx '?x '(gcd 2 6 ?x) 'global)2(fullfindx '?x '(imagpart #c(1 2) ?x) 'global)2(integerp (fullfindx '?x '(integer-decode-float 1.2 ?x) 'global))t(fullfindx '?x '(isqrt 5 ?x) 'global)2(fullfindx '?x '(lcm 2 3 ?x) 'global)6(fullfindx '?x '(log 8 2 ?x) 'global)3(fullfindx '?x '(logand 1 1 ?x) 'global)1(fullfindx '?x '(logandc1 0 1 ?x) 'global)1(fullfindx '?x '(logandc2 1 0 ?x) 'global)1(fullfindx '?x '(logcount 3 ?x) 'global)2(fullfindx '?x '(logeqv 1 1 ?x) 'global)-1(fullfindx '?x '(logior 1 1 ?x) 'global)1(fullfindx '?x '(lognand 0 1 ?x) 'global)-1(fullfindx '?x '(lognor 0 0 ?x) 'global)-1(fullfindx '?x '(lognot -4 ?x) 'global)3(fullfindx '?x '(logorc1 0 0 ?x) 'global)-1(fullfindx '?x '(logorc2 0 0 ?x) 'global)-1(fullfindx '?x '(logxor 0 1 ?x) 'global)1(fullfindx '?x '(max 1 2 3 ?x) 'global)3(fullfindx '?x '(min 1 2 3 ?x) 'global)1(fullfindx '?x '(mod 7 2 ?x) 'global)1(fullfindx '?x '(numerator 1/2 ?x) 'global)1(fullfindx '?x '(phase 0 ?x) 'global)0(fullfindx '?x '(rational 0.5 ?x) 'global)1/2(fullfindx '?x '(rationalize 0.5 ?x) 'global)1/2(fullfindx '?x '(realpart #c(1 2) ?x) 'global)1(fullfindx '?x '(rem 3 2 ?x) 'global)1(fullfindx '?x '(round 1.6 ?x) 'global)2(fullfindx '?x '(scale-float 1.2 2 ?x) 'global)4.8(fullfindx '?x '(signum 23 ?x) 'global)1(fullfindx '?x '(sin 0 ?x) 'global)0(fullfindx '?x '(sinh 0 ?x) 'global)0(fullfindx '?x '(sqrt 4 ?x) 'global)2(fullfindx '?x '(tan 0 ?x) 'global)0(fullfindx '?x '(tanh 0 ?x) 'global)0(fullfindx '?x '(truncate 1.6 ?x) 'global)1;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(deftheory global  (parent art bob)  (parent bob cal)  (parent bob coe)  (<= (grandparent ?x ?z) (parent ?x ?y) (parent ?y ?z)))*(fullfindp '(grandparent art cal) 'global)T(fullfindx '?x '(grandparent ?x cal) 'global)ART(fullfindx '?y '(grandparent art ?y) 'global)CAL(fullfinds '?y '(grandparent art ?y) 'global)(CAL COE)(reset)*;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(deftheory global  (= (append (listof) ?m) ?m)  (<= (= (append (listof ?x @l) ?m) (listof ?x @n))      (= (append (listof @l) ?m) (listof @n))))*(fullfindx '?z '(= (append (listof 1 2) (listof 3 4)) ?z) 'global)(listof 1 2 3 4)(reset)*;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(deftheory group        (<= (= (* ?x ?y) ?x) (= ?y e))        (<= (= (* ?y ?x) ?x) (= ?y e))        (<= (= (* ?x ?y) e) (= ?y (inv ?x)))        (<= (= (* ?x ?v) ?w)            (= (* ?y ?z) ?v)            (= (* ?x ?y) ?u)            (= (* ?u ?z) ?w)))GROUP(deftheory equality        (= ?x ?x)        (<= (= ?x ?y) (= ?y ?x))        (<= (= ?x ?z) (= ?x ?y) (= ?y ?z)))EQUALITY(includes 'group 'equality)T(let ((*depth* 5)) (fullfindp '(= (* (inv x) x) e) 'group))T(= *inferences* 421)T(= *unifications* 1230)T(reset)*;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(deftheory global        (p a)        (p b)        (q b)        (<= (r ?x) (p ?x) (q ?x)))GLOBAL(let ((*depth* 0)) (fullfindp '(p a) 'global))NIL*termination*T(let ((*depth* 1)) (fullfindp '(p a) 'global))T(let ((*depth* 1)) (fullfindp '(r b) 'global))NIL*termination*T(let ((*depth* 2)) (fullfindp '(r b) 'global))T(let ((*depth* 1)) (fullfindp '(s b) 'global))NIL*termination*NIL(reset)*;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(deftheory global  (<= (t ?x) (t ?x)))*(let ((*depth* 10) (*ancestry* nil)) (fullfindp '(t a) 'global))NIL*termination*T(let ((*depth* 10) (*ancestry* t)) (fullfindp '(t a) 'global))NIL*termination*NIL(reset)*;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; fullresidue;;; fullresidues;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(deftheory global    (NOT (DOIT P NOW))    (NOT (DOIT Q NOW))    (NOT (DOIT (not Q) NOW))    (<= (true p (next ?s))        (doit p ?s))    (<= (true q (next ?s))        (doit q ?s))    (<= (true r (next ?s))        (doit r ?s))    (<= (true p (next ?s))        (true p ?s)        (not (doit (not p) ?s)))    (<= (true q (next ?s))        (true q ?s)        (not (doit (not q) ?s)))    (<= (not (true p (next ?s)))        (not (true p ?s))        (not (doit p ?s)))    (<= (not (true q (next ?s)))        (not (true q ?s))        (not (doit q ?s)))    (<= (true p ?s)        (true p (next ?s))        (not (doit p ?s)))    (<= (good now))    (<= (good (next ?s)) (great (next ?s)) (good ?s))    (<= (great now))    (<= (great ?s) (true q ?s))    (<= (great ?s) (not (true p ?s)))    (<= (true p ?s)        (not (great ?s)))    (<= (not (great ?s))        (true p ?s)        (not (true q ?s)))    (<= (not (true p ?s))        (great ?s)        (not (true q ?s)))    (<= (true q ?s)        (great ?s)        (true p ?s))    (<= (state now))        (<= (state (next ?s))        (state ?s)))*(let ((*depth* 6)) (fullfindp '(great (next now)) 'global))T(let ((*depth* 6)) (fullresidue '(great (next now)) 'global  #'(lambda (x) (find x '(p q r -p -q -r)))  #'(lambda (x) (or (atom x)                    (and (eq 'not (car x))                         (listp (cadr x))                         (eq 'doit (caadr x)))))))(AND (NOT (DOIT P NOW)) (NOT (DOIT (NOT Q) NOW)))(reset)*;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; deffulltheory;;; define-fulltheory;;; fullassume;;; fullprovep;;; fullprovex;;; fullproves;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(deffulltheory global  (<= (r ?x) (p ?x) (q ?x)))global(contents 'global)((<= (R ?X) (P ?X) (Q ?X)) (<= (NOT (P ?X)) (NOT (R ?X)) (Q ?X)) (<= (NOT (Q ?X)) (NOT (R ?X)) (P ?X)))(reset)*;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(fullassume '(<= (r ?x) (p ?x) (q ?x)) 'global)(<= (r ?x) (p ?x) (q ?x))(contents 'global)((<= (R ?X) (P ?X) (Q ?X)) (<= (NOT (P ?X)) (NOT (R ?X)) (Q ?X)) (<= (NOT (Q ?X)) (NOT (R ?X)) (P ?X)))(reset)*;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(fullfindp '(or p (not p)) 'global)nil(fullprovep '(or p (not p)) 'global)T;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;