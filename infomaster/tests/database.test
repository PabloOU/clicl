;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Database Tests;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; order;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;*order*SIMPLE(order nil '(p a b))(P A B)(order nil '(or (p a b)))(P A B)(order nil '(and (p a b)))(P A B)(order nil '(and (p a b) (> 3 2)))(AND (> 3 2) (P A B))(order nil '(and (> 3 2) (p a b)))(AND (> 3 2) (P A B))(order '?x '(and (p ?x) (> ?x 2)))(AND (P ?X) (> ?X 2))(order '?x '(and (> ?x 2) (p ?x)))(AND (P ?X) (> ?X 2))(order '?x '(and (p ?x) (q ?y) (r ?x ?y)))(AND (P ?X) (Q ?Y) (R ?X ?Y));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; collapse (conjunctions);;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;*collapse*SIMPLE(collapse nil '(p a b))(P A B)(collapse nil '(or (p a b)))(P A B)(collapse nil '(and (p a b)))(P A B)(collapse '?x '(and (p ?x ?y) (q ?x) (p ?x ?z)))(AND (P ?X ?Y) (Q ?X) (P ?X ?Z)) ;;;??????????;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; raisin (disjunctions);;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(raisin nil '(p a b))(P A B)(raisin nil '(or (p a b)))(P A B)(raisin nil '(and (p a b)))(AND (P A B))(raisin '?x '(or (p ?x ?y) (q ?x) (p ?x ?z)))(OR (Q ?X) (P ?X ?Z));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; compress;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(compress '(p a b))(P A B)(compress '(or (p a b)))(P A B)(compress '(and (p a b)))(AND (P A B))(compress '(or (and (p a b) (q a b)) (and (p a b) (r a b))))(AND (P A B) (OR (Q A B) (R A B)));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; fastbase;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(defparameter *fast* (make-instance 'fastbase))*(save '(p a b) *fast*)(p a b)(save '(p a c) *fast*)(p a c)(save '(q c d) *fast*)(q c d)(findp '(p a b) *fast*)T(finds '?x '(p ?x b) *fast*)(A)(finds '?y '(p a ?y) *fast*)(B C)(finds '(?x ?y) '(p ?x ?y) *fast*)((A B) (A C))(finds '(?r ?x ?y) '(?r ?x ?y) *fast*)((P A B) (P A C) (Q C D))(findp '(not (p a b)) *fast*)NIL(findp '(not (p ?x b)) *fast*)NIL ;;; ??????(findp '(not (r a b)) *fast*)T(findp '(not (r ?x ?y)) *fast*)T(findp '(and (p ?x ?y) (q ?y ?z)) *fast*)T(findx '(?x ?z) '(and (p ?x ?y) (q ?y ?z)) *fast*)(A D)(finds '(?x ?z) '(and (p ?x ?y) (q ?y ?z)) *fast*)((A D))(findx '?bag '(and (p ?x ?y) (bagofall ?z (p ?x ?z) ?bag)) *fast*)(LISTOF B C)(findx '?bag '(bagofall (?y ?b) (and (p ?x ?y) (bagofall ?z (q ?y ?z) ?b)) ?bag) *fast*)(LISTOF (B (LISTOF)) (C (LISTOF D)))(empty *fast*)*(contents *fast*)NIL(findx '?x '(makestring a ?x) *fast*)"A"(findx '?x '(expression "a" ?x) *fast*)a(findp '(isacharacter #\a) *fast*)t(findp '(isacharacter a) *fast*)nil(findp '(alphabetic #\a) *fast*)t(findp '(alphabetic #\1) *fast*)nil(findp '(uppercase #\A) *fast*)t(findp '(uppercase #\a) *fast*)nil(findp '(lowercase #\a) *fast*)t(findp '(lowercase #\A) *fast*)nil(findp '(digit #\1) *fast*)t(findp '(digit #\a) *fast*)nil(findp '(alphanumeric #\a) *fast*)t(findp '(alphanumeric #\1) *fast*)t(findp '(alphanumeric #\.) *fast*)nil(findp '(chargreater #\b #\a) *fast*)t(findp '(chargreater #\a #\b) *fast*)nil(findp '(charless #\a #\b) *fast*)t(findp '(charless #\b #\a) *fast*)nil(findx '?x '(charupcase #\a ?x) *fast*)#\A(findx '?x '(chardowncase #\A ?x) *fast*)#\a(findx '?x '(charstring #\a ?x) *fast*)"a"(findp '(isastring "a") *fast*)t(findp '(isastring a) *fast*)nil(findp '(strgreater "bbc" "abc") *fast*)t(findp '(strgreater "abc" "bbc") *fast*)nil(findp '(strless "abc" "bbc") *fast*)t(findp '(strless "bbc" "abc") *fast*)nil(findp '(substring "bc" "abcd") *fast*)t(findp '(substring "abcd" "ab") *fast*)nil(findx '?x '(strlength "abc" ?x) *fast*)3(findx '?x '(strelement "abc" 2 ?x) *fast*)#\b(findx '?x '(strsubseq "abcd" 2 3 ?x) *fast*)"bc"(findx '?x '(stralphanumeric " a bc'd-e " ?x) *fast*)"abcde"(findx '?x '(strappend "abc" "def" "ghi" ?x) *fast*)"abcdefghi"(findx '?x '(strappend ?x) *fast*)""(findx '?x '(strcharpos #\b "abc" ?x) *fast*)2(findx '?x '(strcharpos #\d "abc" ?x) *fast*)nil(findx '?x '(strposition "bc" "abcd" ?x) *fast*)2(findx '?x '(strposition "cb" "abcd" ?x) *fast*)nil(findx '?x '(strsubstitute #\a #\b "abab" ?x) *fast*)"aaaa"(findx '?x '(strupcase "abc" ?x) *fast*)"ABC"(findx '?x '(strdowncase "ABC" ?x) *fast*)"abc"(findx '?x '(strcapitalize "abc.def" ?x) *fast*)"Abc.Def";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; database;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(defparameter *data* (make-instance 'database))*(save '(p a b) *data*)(p a b)(save '(p a c) *data*)(p a c)(save '(q c d) *data*)(q c d)(findp '(p a b) *data*)T(finds '?x '(p ?x b) *data*)(A)(finds '?y '(p a ?y) *data*)(B C)(finds '(?x ?y) '(p ?x ?y) *data*)((A B) (A C))(finds '(?r ?x ?y) '(?r ?x ?y) *data*)NIL ;;; Compare ((P A B) (P A C) (Q C D)) for *fast*(findp '(not (p a b)) *data*)NIL(findp '(not (p ?x b)) *data*)NIL ;;; ??????(findp '(not (r a b)) *data*)T(findp '(not (r ?x ?y)) *data*)T(findp '(and (p ?x ?y) (q ?y ?z)) *data*)T(findx '(?x ?z) '(and (p ?x ?y) (q ?y ?z)) *data*)(A D)(finds '(?x ?z) '(and (p ?x ?y) (q ?y ?z)) *data*)((A D))(findx '?bag '(and (p ?x ?y) (bagofall ?z (p ?x ?z) ?bag)) *data*)(LISTOF B C)(findx '?bag '(bagofall (?y ?b) (and (p ?x ?y) (bagofall ?z (q ?y ?z) ?b)) ?bag) *data*)(LISTOF (B (LISTOF)) (C (LISTOF D)))(empty *data*)*(contents *data*)NIL(findx '?x '(makestring a ?x) *data*)"A"(findx '?x '(expression "a" ?x) *data*)a(findp '(isacharacter #\a) *data*)t(findp '(isacharacter a) *data*)nil(findp '(alphabetic #\a) *data*)t(findp '(alphabetic #\1) *data*)nil(findp '(uppercase #\A) *data*)t(findp '(uppercase #\a) *data*)nil(findp '(lowercase #\a) *data*)t(findp '(lowercase #\A) *data*)nil(findp '(digit #\1) *data*)t(findp '(digit #\a) *data*)nil(findp '(alphanumeric #\a) *data*)t(findp '(alphanumeric #\1) *data*)t(findp '(alphanumeric #\.) *data*)nil(findp '(chargreater #\b #\a) *data*)t(findp '(chargreater #\a #\b) *data*)nil(findp '(charless #\a #\b) *data*)t(findp '(charless #\b #\a) *data*)nil(findx '?x '(charupcase #\a ?x) *data*)#\A(findx '?x '(chardowncase #\A ?x) *data*)#\a(findx '?x '(charstring #\a ?x) *data*)"a"(findp '(isastring "a") *data*)t(findp '(isastring a) *data*)nil(findp '(strgreater "bbc" "abc") *data*)t(findp '(strgreater "abc" "bbc") *data*)nil(findp '(strless "abc" "bbc") *data*)t(findp '(strless "bbc" "abc") *data*)nil(findp '(substring "bc" "abcd") *data*)t(findp '(substring "abcd" "ab") *data*)nil(findx '?x '(strlength "abc" ?x) *data*)3(findx '?x '(strelement "abc" 2 ?x) *data*)#\b(findx '?x '(strsubseq "abcd" 2 3 ?x) *data*)"bc"(findx '?x '(stralphanumeric " a bc'd-e " ?x) *data*)"abcde"(findx '?x '(strappend "abc" "def" "ghi" ?x) *data*)"abcdefghi"(findx '?x '(strappend ?x) *data*)""(findx '?x '(strcharpos #\b "abc" ?x) *data*)2(findx '?x '(strcharpos #\d "abc" ?x) *data*)nil(findx '?x '(strposition "bc" "abcd" ?x) *data*)2(findx '?x '(strposition "cb" "abcd" ?x) *data*)nil(findx '?x '(strsubstitute #\a #\b "abab" ?x) *data*)"aaaa"(findx '?x '(strupcase "abc" ?x) *data*)"ABC"(findx '?x '(strdowncase "ABC" ?x) *data*)"abc"(findx '?x '(strcapitalize "abc.def" ?x) *data*)"Abc.Def";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Experiments with faster find for databases;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(setq *ordinary* (make-instance 'theory))*(define-theory *ordinary* ""'((p a1 b1)  (p a1 b2)  (p a1 b3)  (p a1 b4)  (p a1 b5)  (q b2 c1)  (q b2 c2)  (q b4 c4)  (q b4 c5)))*(setq *database* (make-instance 'database))*(define-theory *database* ""'((p a1 b1)  (p a1 b2)  (p a1 b3)  (p a1 b4)  (p a1 b5)  (q b2 c1)  (q b2 c2)  (q b4 c4)  (q b4 c5)))*;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; database used alone;;; Speed up should be around factor of 5.;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(finds '(?x ?z) '(and (p ?x ?y) (q ?y ?z)) *ordinary*)((a1 c1) (a1 c2) (a1 c4) (a1 c5))(finds '(?x ?z) '(and (p ?x ?y) (q ?y ?z)) *database*)((a1 c1) (a1 c2) (a1 c4) (a1 c5));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; database included in another theory;;; Speed up should be around factor of 1.2.;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(includes 'test1 *ordinary*)*(includes 'test2 *database*)*(finds '(?x ?z) '(and (p ?x ?y) (q ?y ?z)) 'test1)((a1 c1) (a1 c2) (a1 c4) (a1 c5))(finds '(?x ?z) '(and (p ?x ?y) (q ?y ?z)) 'test2)((a1 c1) (a1 c2) (a1 c4) (a1 c5));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Reduction approach;;; test2 2.5 times faster than test1; test3 only slightly better than test1;;; This approach good when few rules and lots of data;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(deftheory test1 (<= (r ?x ?z) (p ?x ?y) (q ?y ?z)))*(deftheory test2 (<= (r ?x ?z) (p ?x ?y) (q ?y ?z)))*(deftheory test3 (<= (r ?x ?z) (p ?x ?y) (q ?y ?z)))*(decludes 'test2)*(includes 'test3 *database*)*(null (residues '(r ?x ?z) '(r ?x ?z) 'test2 #'irreduciblep))NIL(finds '(?x ?z) '(r ?x ?z) 'test1)((a1 c1) (a1 c2) (a1 c4) (a1 c5))(finds '(?x ?z) '(r ?x ?z) 'test3)((a1 c1) (a1 c2) (a1 c4) (a1 c5))#|(defparameter *test*  (make-instance 'dataserver :name 'test :indexing 'fullindexing :inference 'dataserver))(define-theory *test* ""  '((m a b)    (m b c)    (n c d)    (n d e)))(dataanswers 'r             '((<= (r ?x ?z) (p ?x ?y) (q ?y ?z))               (<= (p ?x ?y) (m ?x ?y))               (<= (q ?x ?y) (n ?x ?y)))             *test*)|#;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;