<html><head><title>Javalog Test</title><script type='text/javascript'>var database = new Array(5);var thing;var answer;function findp (query) {return findx('true',query)}function findx (result,query) {thing = result;  answer = false;  if (proone(query,empty(),nil)) {return answer};  return false}function finds (result,query) {thing = result;  answer = empty();  proall(query,empty(),nil);  return answer}//------------------------------------------------------------------------------function proone (p,pl,al) {//alert(grind(p) + '-' + pl + '-' + al);  if (symbolp(p)) {return prooners(p,pl,al)}  if (p[0] == 'not') {return proonenot(p,pl,al)}  if (p[0] == 'and') {return prooneand(p,pl,al)}  if (p[0] == 'or') {return prooneor(p,pl,al)}  if (p[0] == 'same') {return proonesame(p,pl,al)}  if (p[0] == 'distinct') {return proonedistinct(p,pl,al)}  return prooners(p,pl,al)}function proonenot (p,pl,al) {if (proone(p[1],empty(),al) == false) {return prooneexit(pl,al)}  return false}function prooneand (p,pl,al) {return prooneexit (append(rest(p),pl),al)}function prooneor (p,pl,al) {var n = p.length;  var bl;  for (var i=0; i<n; i++)      {if (bl == proone(p[i],pl,al)) {return true}}  return false}function proonesame (p,pl,al) {al = unify(p[1],p[2],al);  if (al != false) {return prooneexit(pl,al)};  return false}function proonedistinct (p,pl,al) {if (unify(p[1],p[2],al) == false) {return prooneexit(pl,al)};  return false}function prooners (p,pl,al) {var n = database.length;  var copy;  var bl;  for (var i=0; i<n; i++)      {copy = standardize(database[i]);       if (copy[0] == 'rule')          {bl = unify(copy[1],p,al);           if (bl != false && proone(copy[2],pl,bl)) {return true}}       else {bl = unify(copy,p,al);             if (bl != false && prooneexit(pl,bl)) {return true}}};  return false}function prooneexit (pl,al) {if (pl.length != 0) {return proone(pl[0],rest(pl),al)};  answer = plug(thing,al);  return true}//------------------------------------------------------------------------------function proall (p,pl,al) {//alert(grind(p) + '-' + pl + '-' + al);  if (symbolp(p)) {return proallrs(p,pl,al)}  if (p[0] == 'not') {return proallnot(p,pl,al)}  if (p[0] == 'and') {return proalland(p,pl,al)}  if (p[0] == 'or') {return proallor(p,pl,al)}  if (p[0] == 'same') {return proallsame(p,pl,al)}  if (p[0] == 'distinct') {return proalldistinct(p,pl,al)}  return proallrs(p,pl,al)}function proallnot (p,pl,al) {if (proall(p[1],empty(),al) == false) {proallexit(pl,al)}}function proalland (p,pl,al) {proallexit (append(rest(p),pl),al)}function proallor (p,pl,al) {var n = p.length;  var bl;  for (var i=0; i<n; i++) {proall(p[i],pl,al)}}function proallsame (p,pl,al) {al = unify(p[1],p[2],al);  if (al != false) {proallexit(pl,al)}}function proalldistinct (p,pl,al) {if (unify(p[1],p[2],al) == false) {proallexit(pl,al)}}function proallrs (p,pl,al) {var n = database.length;  var copy;  var bl;  for (var i=0; i<n; i++)      {copy = standardize(database[i]);       if (copy[0] == 'rule')          {bl = unify(copy[1],p,al);           if (bl != false) {proall(copy[2],pl,bl)}}       else {bl = unify(copy,p,al);             if (bl != false) {proallexit(pl,bl)}}}}function proallexit (pl,bl) {if (pl.length != 0) {return proall(pl[0],rest(pl),bl)};  answer.push(plug(thing,bl))}//------------------------------------------------------------------------------function unifier (x,y) {return unify(x,y,nil)}function unify (x,y,bl) {if (x == y) {return bl};  if (varp(x)) {return unifyvar(x,y,bl)};  if (symbolp(x)) {return unifyatom(x,y,bl)};  return unifyexp(x,y,bl)}function unifyvar (x,y,bl) {var dum = assoc(x,bl);  if (dum != false) {return unify(cdr(dum),y,bl)};  if (x == unifyval(y,bl)) {return bl};  return acons(x,y,bl)}function unifyval (y,bl) {if (varp(y))     {var dum = assoc(y,bl);      if (dum != false) {return unifyval(cdr(dum),bl)};      return y};  return y}function unifyatom (x,y,bl) {if (varp(y)) {return unifyvar(y,x,bl)}  else return false}function unifyexp(x,y,bl) {if (varp(y)) {return unifyvar(y,x,bl)}  if (symbolp(y)) {return false};  var m = x.length;  var n = y.length;    if (m != n) {return false};  for (var i=0; i<m; i++)      {bl = unify(x[i],y[i],bl);       if (bl == false) {return false}};  return bl}//------------------------------------------------------------------------------function plug (x,bl) {if (varp(x)) {return plugvar(x,bl)};  if (symbolp(x)) {return x};  return plugexp(x,bl)}function plugvar (x,bl) {var dum = assoc(x,bl);  if (dum == false) {return x};  return plug(cdr(dum),bl)}function plugexp (x,bl) {var n = x.length;  var exp = new Array(n);  for (var i=0; i<n; i++)      {exp[i] = plug(x[i],bl)};  return exp}//------------------------------------------------------------------------------var alist;function standardize (x) {alist = nil;  return standardizeit(x)}function standardizeit (x) {if (varp(x)) {return standardizevar(x)};  if (symbolp(x)) {return x};  return standardizeexp(x)}function standardizevar (x) {var dum = assoc(x,alist);  if (dum != false) {return cdr(dum)};  var rep = newvar();  alist = acons(x,rep,alist);  return rep}function standardizeexp (x) {var n = x.length;  var exp = new Array(n);  for (var i=0; i<n; i++)      {exp[i] = standardizeit(x[i])};  return exp}//------------------------------------------------------------------------------var input = '';var output = '';var current = 0;function scan (str) {input = str;  output = new Array(0);  var cur = 0;  var len = input.length;  while (cur < len)   {var charcode = input.charCodeAt(cur);    if (charcode == 32 || charcode == 13) {cur++}    else if (charcode == 38) {output[output.length] = '&'; cur++}    else if (charcode == 40) {output[output.length] = 'lparen'; cur++}    else if (charcode == 41) {output[output.length] = 'rparen'; cur++}    else if (charcode == 43) {output[output.length] = '+'; cur++}    else if (charcode == 44) {output[output.length] = 'comma'; cur++}    else if (charcode == 45) {output[output.length] = '-'; cur++}    else if (charcode == 46) {output[output.length] = '.'; cur++}    else if (charcode == 58) {cur = scanrulesym(cur)}    else if (charcode == 124) {output[output.length] = '|'; cur++}    else if (charcode == 126) {output[output.length] = '~'; cur++}    else if (idcharp(charcode)) {cur = scansymbol(cur)}    else cur++};  return output}function scanrulesym (cur) {if (input.length > cur+1 && input.charCodeAt(cur+1) == 45)     {output[output.length] = ':-'; return cur+2}  else return cur+1}function scansymbol (cur) {var n = input.length;  var exp = '';  while (cur < n)   {if (idcharp(input.charCodeAt(cur))) {exp = exp + input[cur]; cur++}    else break};  if (exp != '') {output[output.length] = exp};  return cur}function idcharp (charcode) {if (charcode >= 47 && charcode <= 56) {return true};  if (charcode >= 65 && charcode <= 90) {return true};  if (charcode >= 97 && charcode <= 122) {return true};  return false}//------------------------------------------------------------------------------function readdata (str) {return parsedata(scan(str))}function read (str) {return parse(scan(str))}//------------------------------------------------------------------------------function parsedata (str) {str.push('eof');  input = str;  current = 0;  exp = new Array(0);  while (current < input.length && input[current] != 'eof')   {exp[exp.length] = parsexp('lparen','rparen')};  return exp}function parse (str) {str.push('eof');  input = str;  current = 0;  return parsexp('lparen','rparen')}function parsexp (lop,rop) {var left = parseprefix(rop);  while (current < input.length)   {if (input[current] == 'eof') {return left}    else if (input[current] == 'lparen') {left = parseatom(left)}    else if (input[current] == '.') {current++; return(left)}    else if (precedencep(lop,input[current])) {return left}    else {left = parseinfix(left,input[current],rop)}};  return left}function parseprefix (rop) {var left = input[current];  current++;  return left}function parseatom (left) {var exp = parseparenlist();  exp.unshift(left);  return exp}function parseparenlist () {var exp = new Array(0);  current++;  while (current < input.length)   {exp.push(parsexp('comma','rparen'));    if (input[current] == 'rparen') {current++; return exp};    if (input[current] == 'comma') {current++}    else {return exp}};  return exp}function parseinfix (left,op,rop) {var left;  if (op == ':-') {return parserule(left,rop)};  if (op == '&') {return parseand(left,rop)};  return left}function parseand (left,rop) {current++;  return makeconjunction(left,parsexp('&',rop))}function parserule (left,rop) {current++;  var dum = parsexp(':-',rop);  return makerule(left,dum)}function precedencep (lop,rop) {if (lop == '&') {return true};  if (lop == ':-') {return rop != '&'};  return rop != '&' && rop != ':-'}//------------------------------------------------------------------------------function grind (p) {if (symbolp(p)) {return p};  if (p[0] == 'not') {return grindnegation(p)};  if (p[0] == 'and') {return grindconjunction(p)};  if (p[0] == 'rule') {return grindrule(p)};  return grindatom(p)}function grindatom (p) {var n = p.length;  var exp = p[0] + '(' + p[1];  for (var i=2; i<n; i++)      {exp = exp + ',' + p[i]}  exp = exp + ')';  return exp}function grindnegation (p) {return '-' + grind(p[1])}function grindconjunction (p) {return grind(p[1]) + ' & ' + grind(p[2])}function grindrule (p) {return grind(p[1]) + ' :- ' + grind(p[2])}function grinddata (data) {var exp = '';  var n = data.length;  for (var i=0; i<n; i++)      {exp = exp + grind(data[i]) + '<br/>'}  return exp}function grindalist (al) {var exp = '';  if (al == false) {return 'false'};  for (var l=al; !nullp(l); l=cdr(l))      {exp = exp + car(car(l)) + ' = ' + cdr(car(l)) + '<br/>'}  return exp}//------------------------------------------------------------------------------function makeatom (r,x,y) {var exp = new Array(3);  exp[0] = r;  exp[1] = x;  exp[2] = y;  return exp}function makenegation (p) {var exp = new Array(2);  exp[0] = 'not';  exp[1] = p;  return exp}function makeconjunction (p,q) {var exp = new Array(2);  exp[0] = 'and';  exp[1] = p;  exp[2] = q;  return exp}function makerule (head,body) {var exp = new Array(3);  exp[0] = 'rule';  exp[1] = head;  exp[2] = body;  return exp}//------------------------------------------------------------------------------var counter = 0;function newvar () {counter++;  return 'V' + counter}function varp (x) {return typeof x == 'string' && x[0] == x[0].toUpperCase()}function symbolp (x) {return typeof x == 'string'}function empty () {return new Array(0)}function rest (l) {var m  = l.slice(1,l.length);  return m}function append (l1,l2) {var m  = l1.concat(l2);  return m}var nil = 'nil';function cons (x,l) {var cell = new Array(2);  cell[0] = x;  cell[1] = l;  return cell}function car (l) {return l[0]}function cdr (l) {return l[1]}function nullp (l) {return l == 'nil'}function acons (x,y,al) {return cons(cons(x,y),al)}function assoc (x,al) {if (nullp(al)) {return false};  if (x == car(car(al))) {return car(al)};  return assoc(x,cdr(al))}//------------------------------------------------------------------------------var theory = new Array()function initdb () {database[0] = makeatom('p','a','b');  database[1] = makeatom('q','b','a');  database[2] = makeatom('q','b','b');  database[3] = makeatom('q','b','c');  database[4] = makeatom('q','b','d');  database[5] = makerule(makeatom('r','X','Z'),makeconjunction(makeatom('p','X','Y'),makeatom('q','Y','Z')));  database[6] = makerule(makeatom('s','X','Y'),makeatom('r','Y','X'));  database[7] = makerule(makeatom('t','X','Y'),makeconjunction(makeatom('r','X','Y'),makeatom('distinct','X','Y')));  return database}initdb();function readdatabase () {return readdata(document.getElementById('dataarea').value)}function scandatabase () {return scan(document.getElementById('dataarea').value)}function updateit () {database = readdata(document.getElementById('dataarea').value)}function tryit () {var str = document.getElementById('scriptarea').value;  document.getElementById('valuearea').innerHTML = eval(str)}</script></head><body bgclor="white"><br/><center><h1>Javalog Terminal</h1></center><hr/>Database:<br/><textarea id='dataarea' rows='10' cols='60' wrap='soft'>p(a,b).q(b,a).q(b,b).q(b,c).q(b,d).r(X,Z) :- p(X,Y) & q(Y,Z).s(X,Y) :- r(Y,X).t(X,Y) :- r(X,Y) & distinct(X,Y).</textarea><br/><input type='button' value="Update" onClick='updateit()'/><br/><br/>Query:<br/><input type='text' id='scriptarea' value='' size='60' maxlength='120'/><br/><input type='button' value="Eval" onClick='tryit()'/><br/><br/>Result:<br/><div id='valuearea'><br/></div><br/></body></html>