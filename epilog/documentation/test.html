<html><head><title>Minilog Test</title><script type='text/javascript'>function makeatom (r,x,y) {var exp = new Array(3);  exp[0] = r;  exp[1] = x;  exp[2] = y;  return exp}function makenegation (p) {var exp = new Array(2);  exp[0] = 'not';  exp[1] = p;  return exp}function makeconjunction (p,q) {var exp = new Array(2);  exp[0] = 'and';  exp[1] = p;  exp[2] = q;  return exp}function makerule (head,body) {var exp = new Array(3);  exp[0] = 'rule';  exp[1] = head;  exp[2] = body;  return exp}function grind (p) {if (symbolp(p)) {return p};  if (p[0] == 'not') {return grindnegation(p)};  if (p[0] == 'and') {return grindconjunction(p)};  if (p[0] == 'rule') {return grindrule(p)};  return grindatom(p)}function grindatom (p) {var n = p.length;  var exp = p[0] + '(' + p[1];  for (var i=2; i<n; i++)      {exp = exp + ',' + p[i]}  exp = exp + ')';  return exp}function grindnegation (p) {return '-' + grind(p[1])}function grindconjunction (p) {return grind(p[1]) + ' & ' + grind(p[2])}function grindrule (p) {return grind(p[1]) + ' :- ' + grind(p[2])}function grinddata (data) {var exp = '';  var n = data.length;  for (var i=0; i<n; i++)      {exp = exp + grind(data[i]) + '<br/>'}  return exp}function matcher (x,y) {return matchit(x,y,makebindinglist())}function matchit (x,y,bl) {if (x == y) {return bl};  if (varp(x)) {return matchvar(x,y,bl)};  if (symbolp(x)) {return matchatom(x,y,bl)};  return matchexp(x,y,bl)}function matchvar (x,y,bl) {var n = bl.length;  for (var i=1; i<n; i=i+2)      {if (bl[i] == x) {return matchit(bl[i+1],y,bl)}}  return addbinding(x,y,bl)}function matchatom (x,y,bl) {if (varp(y)) {return matchvar(y,x,bl)}  else return false}function matchexp(x,y,bl) {if (varp(y)) {return matchvar(y,x,bl)}  if (symbolp(y)) {return false};  var m = x.length;  var n = y.length;    if (m != n) {return false};  for (var i=0; i<m; i++)      {bl = matchit(x[i],y[i],bl);       if (bl == false) {return false}};  return bl}function unifier (x,y) {return unify(x,y,makebindinglist())}function unify (x,y,bl) {if (x == y) {return bl};  if (varp(x)) {return unifyvar(x,y,bl)};  if (symbolp(x)) {return unifyatom(x,y,bl)};  return unifyexp(x,y,bl)}function unifyvar (x,y,bl) {var n = bl.length;  for (var i=1; i<n; i=i+2)      {if (bl[i] == x) {return unify(bl[i+1],y,bl)}};  if (x == unifyval(y,bl)) {return bl};  return addbinding(x,y,bl)}function unifyval (y,bl) {if (varp(y))     {var dum;      var n = bl.length;      for (var i=1; i<n; i=i+2)          {if (bl[i] == y) {return unifyval(bl[i+1],bl)}}}  else {return y}}function unifyatom (x,y,bl) {if (varp(y)) {return unifyvar(y,x,bl)}  else return false}function unifyexp(x,y,bl) {if (varp(y)) {return unifyvar(y,x,bl)}  if (symbolp(y)) {return false};  var m = x.length;  var n = y.length;    if (m != n) {return false};  for (var i=0; i<m; i++)      {bl = unify(x[i],y[i],bl);       if (bl == false) {return false}};  return bl}function plug (x,bl) {if (varp(x)) {return plugvar(x,bl)};  if (symbolp(x)) {return x};  return plugexp(x,bl)}function plugvar (x,bl) {var val = getbinding(x,bl);  if (val == false) {return x};  return plug(val,bl)}function plugexp (x,bl) {var n = x.length;  var exp = new Array(n);  for (var i=0; i<n; i++)      {exp[i] = plug(x[i],bl)};  return exp}var alist;function standardize (x) {alist = makebindinglist();  return standardizeit(x)}function standardizeit (x) {if (varp(x)) {return standardizevar(x)};  if (symbolp(x)) {return x};  return standardizeexp(x)}function standardizevar (x) {var val = getbinding(x,alist);  if (val != false) {return val};  var rep = newvar();  alist = addbinding(x,rep,alist);  return rep}function standardizeexp (x) {var n = x.length;  var exp = new Array(n);  for (var i=0; i<n; i++)      {exp[i] = standardizeit(x[i])};  return exp}var database = new Array(5);var thing;var answer;function findp (query) {return findx('true',query)}function findx (result,query) {thing = result;  answer = false;  if (proone(query,empty(),makebindinglist())) {return answer};  return false}function finds (result,query) {thing = result;  answer = empty();  proall(query,empty(),makebindinglist());  return answer}function proone (p,pl,al) {alert(grind(p) + '-' + pl + '-' + al);  if (symbolp(p)) {return prooners(p,pl,al)}  if (p[0] == 'not') {return proonenot(p,pl,al)}  if (p[0] == 'and') {return prooneand(p,pl,al)}  if (p[0] == 'or') {return prooneor(p,pl,al)}  if (p[0] == 'same') {return proonesame(p,pl,al)}  if (p[0] == 'distinct') {return proonedistinct(p,pl,al)}  return prooners(p,pl,al)}function proonenot (p,pl,al) {if (proone(p[1],empty(),al) == false) {return prooneexit(pl,al)}  return false}function prooneand (p,pl,al) {return prooneexit (append(rest(p),pl),al)}function prooneor (p,pl,al) {var n = p.length;  var bl;  for (var i=0; i<n; i++)      {if (bl == proone(p[i],pl,al)) {return true}}  return false}function proonesame (p,pl,al) {al = unify(p[1],p[2],al);  if (al != false) {return prooneexit(pl,al)};  return false}function proonedistinct (p,pl,al) {if (unify(p[1],p[2],al) == false) {return prooneexit(pl,al)};  return false}function prooners (p,pl,al) {var n = database.length;  var copy;  var bl;  for (var i=0; i<n; i++)      {copy = standardize(database[i]);       if (copy[0] == 'rule')          {bl = unify(copy[1],p,al);           if (bl != false && proone(copy[2],pl,bl)) {return true}}       else {bl = unify(copy,p,al);             if (bl != false && prooneexit(pl,bl)) {return true}}};  return false}function prooneexit (pl,bl) {if (pl.length != 0) {return proone(pl[0],rest(pl),bl)};  answer = plug(thing,bl);  return true}function proall (p,pl,al) {alert(grind(p) + '-' + pl + '-' + al);  if (symbolp(p)) {return proallrs(p,pl,al)}  if (p[0] == 'not') {return proallnot(p,pl,al)}  if (p[0] == 'and') {return proalland(p,pl,al)}  if (p[0] == 'or') {return proallor(p,pl,al)}  if (p[0] == 'same') {return proallsame(p,pl,al)}  if (p[0] == 'distinct') {return proalldistinct(p,pl,al)}  return proallrs(p,pl,al)}function proallnot (p,pl,al) {if (proall(p[1],empty(),al) == false) {proallexit(pl,al)}}function proalland (p,pl,al) {proallexit (append(rest(p),pl),al)}function proallor (p,pl,al) {var n = p.length;  var bl;  for (var i=0; i<n; i++) {proall(p[i],pl,al)}}function proallsame (p,pl,al) {al = unify(p[1],p[2],al);  if (al != false) {proallexit(pl,al)}}function proalldistinct (p,pl,al) {if (unify(p[1],p[2],al) == false) {proallexit(pl,al)}}function proallrs (p,pl,al) {var n = database.length;  var copy;  var bl;  for (var i=0; i<n; i++)      {copy = standardize(database[i]);       if (copy[0] == 'rule')          {bl = unify(copy[1],p,al);           if (bl != false) {proall(copy[2],pl,bl)}}       else {alert(copy + ' - ' + al); bl = unify(copy,p,al);             if (bl != false) {proallexit(pl,bl); alert(answer)}}}}function proallexit (pl,bl) {if (pl.length != 0) {return proall(pl[0],rest(pl),bl)};  answer.push(plug(thing,bl))}var counter = 0;function newvar () {counter++;  return 'V' + counter}function makebindinglist () {var bl = new Array(1);  bl[0] = 'start';  return bl}function addbinding (x,v,bl) {var len = bl.length;  bl[len] = x;  bl[len+1] = v;  return bl}function getbinding (x,bl) {var n = bl.length;  for (var i=1; i<n; i=i+2)      {if (bl[i] == x) {return bl[i+1]}}  return false}function symbolp (x) {return typeof x == 'string'}function varp (x) {return typeof x == 'string' && x[0] == x[0].toUpperCase()}function empty () {return new Array(0)}function rest (l) {var m  = l.slice(1,l.length);  return m}function append (l1,l2) {var m  = l1.concat(l2);  return m}var theory = new Array()function findif () {var disp = document.getElementById('findarea');  var query = makeatom('p','X','Y');  var query = makeatom('q','Y','Z');  var query = makeconjunction(makeatom('p','X','Y'),makeatom('q','Y','Z'));  var query = makeatom('r','X','Z');  var query = makeatom('s','U','V');  var query = makeatom('t','U','V');  initdb();  disp.innerHTML = 'Data:<br/>' + grinddata(database) + '<br/>Query:<br/>' + grind(query) + '<br/><br/>Result:<br/>' + findp(query)}function findit () {var disp = document.getElementById('findarea');  var query = makeatom('p','X','Y');  var query = makeatom('q','Y','Z');  var query = makeconjunction(makeatom('p','X','Y'),makeatom('q','Y','Z'));  var query = makeatom('r','X','Z');  var query = makeatom('s','U','V');  var query = makeatom('t','U','V');  initdb();  disp.innerHTML = 'Data:<br/>' + grinddata(database) + '<br/>Query:<br/>' + grind(query) + '<br/><br/>Result:<br/>' + grind(findx(query,query))}function findem () {var disp = document.getElementById('findarea');  var query = makeatom('p','X','Y');  var query = makeatom('q','Y','Z');  var query = makeconjunction(makeatom('p','X','Y'),makeatom('q','Y','Z'));  var query = makeatom('r','X','Z');  var query = makeatom('s','U','V');  var query = makeatom('t','U','V');  initdb();  disp.innerHTML = 'Data:<br/>' + grinddata(database) + '<br/>Query:<br/>' + grind(query) + '<br/><br/>Result:<br/>' + grinddata(finds(query,query))}function initdb () {database[0] = makeatom('p','a','b');  database[1] = makeatom('q','b','a');  database[2] = makeatom('q','b','b');  database[3] = makeatom('q','b','c');  database[4] = makeatom('q','b','d');  database[5] = makerule(makeatom('r','X','Z'),makeconjunction(makeatom('p','X','Y'),makeatom('q','Y','Z')));  database[6] = makerule(makeatom('s','X','Y'),makeatom('r','Y','X'));  database[7] = makerule(makeatom('t','X','Y'),makeconjunction(makeatom('r','X','Y'),makeatom('distinct','X','Y')));  return database}function showtheory () {var disp = document.getElementById('disparea');  var n = theory.length;  disp.innerHTML = '';  for (var i=1; i<n; i++)      {disp.innerHTML = disp.innerHTML + grind(theory[i]) + '<br/>'}}function doit () {theory[1] = makeatom('p','a','a');  theory[2] = makeatom('p','a','b');  theory[3] = makeatom('q','b','c');  showtheory()}function matchem () {var disp = document.getElementById('matcharea');  var x = makeatom('p','X','X');  var y = makeatom('p','a','b');  var bl = matcher(x,y);  var n = bl.length;  disp.innerHTML = '';  if (bl == false) {disp.innerHTML = 'false'}     else {for (var i=1; i<n; i=i+2)               {disp.innerHTML = disp.innerHTML + bl[i] + ' = ' + bl[i+1] + '<br/>'}}}function unifyem () {var disp = document.getElementById('unifyarea');  var x = makeatom('p','X','b');  var y = makeatom('p','a','Y');  var bl = unifier(x,y);  var n = bl.length;  disp.innerHTML = '';  if (bl == false) {disp.innerHTML = 'false'}     else {for (var i=1; i<n; i=i+2)               {disp.innerHTML = disp.innerHTML + bl[i] + ' = ' + bl[i+1] + '<br/>'}}}function clearem () {var disp = document.getElementById('matcharea');  disp.innerHTML = ''}function standardizeem () {var disp = document.getElementById('standardizearea');  var exp = makerule(makeatom('r','X','Z'),makeconjunction(makeatom('p','X','Y'),makeatom('q','Y','Z')));  alist = makebindinglist();  disp.innerHTML = grindatom(standardize(exp))}function plugem () {var disp = document.getElementById('plugarea');  var exp = makeatom('p','X','X');  var bl = makebindinglist();  bl = addbinding('X','a',bl);  bl = addbinding('Y','b',bl);  disp.innerHTML = grindatom(plug(exp,bl))}function tryit () {var disp = document.getElementById('tryarea');  var arr1 = new Array(2);  var arr2 = new Array(2);  arr1[0] = 'a';  arr1[1] = 'b';  arr2 = arr1;  disp.innerHTML = 'arr1.unshift("e") = ' + arr1.unshift('e') + '</br/>arr1 = ' + arr1 + '</br/>arr2 = ' + arr2}</script></head><body bgclor="white"><br/><center><h1>Minilog 1.0 in Javascript</h1></center><hr/><div id='findarea'></div><br/><input type='button' value="Findp" onClick='findif()'/><input type='button' value="Findx" onClick='findit()'/><input type='button' value="Finds" onClick='findem()'/><hr/>Theory:<div id='disparea'>Empty</div><br/><input type='button' value="Test" onClick='doit()'/><hr/>Expression:<br/>p(X,X)<br/>Binding List:<br/>X = a<br/>Y = b<br/>Result:<div id='plugarea'><br/></div><br/><input type='button' value="plug" onClick='plugem()'/><hr/>Expression:<br/>p(X,Y)<br/>Result:<div id='standardizearea'><br/></div><br/><input type='button' value="Standardize" onClick='standardizeem()'/><hr/>Pattern and Expression:<br/>p(X,X)<br/>p(a,b)<br/>Matcher:<br/><div id='matcharea'></div><br/><input type='button' value="Match" onClick='matchem()'/><input type='button' value="Clear" onClick='clearem()'/><hr/>Pattern and Expression:<br/>p(X,b)<br/>p(a,Y)<br/>Matcher:<br/><div id='unifyarea'></div><br/><input type='button' value="Unify" onClick='unifyem()'/><hr/>Arrays:<br/>arr1 = [a,b]<br/>arr2 = [c,d]<br/>Result:<br/><div id='tryarea'></div><br/><input type='button' value="Tryit" onClick='tryit()'/></body></html>