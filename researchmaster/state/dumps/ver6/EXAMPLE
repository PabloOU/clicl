;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; example
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

    (example.instance        4qsdatalog)
    (prettyname              4qsdatalog "4-Queens Datalog")
    (shortname               4qsdatalog "4qsdatalog")
    (example.complete        4qsdatalog complete)
    (example.technique       4qsdatalog symmetryanalysis)
    (example.description     4qsdatalog "Take advantage of the fact that we can order the queens so that the first one is always placed left of the second, the second left of the third, and so on.  To do this, we use less-than instead of just distinct.")
    (example.efficiencygains 4qsdatalog "5x")
    (matrixshow              4qsdatalog true)
    (example.comments        4qsdatalog "We should be able to detect the fact that the query doesn't care about what order the queens are in; determining that less-than can be used and how to do that should then be possible.")
    (example.sourcequery     4qsdatalog "ent")
    (example.source          4qsdatalog "  (<= ent
      (not notent))
  (<= notent
      (goal17 ?X1 ?Y1 ?X2 ?Y2 ?X3 ?Y3 ?X4 ?Y4)
      (not (phi ?X1 ?Y1 ?X2 ?Y2 ?X3 ?Y3 ?X4 ?Y4)))
 
  (<= (phi ?X1 ?Y1 ?X2 ?Y2 ?X3 ?Y3 ?X4 ?Y4)
      (or (distinct ?x1 1)
          (distinct ?y1 1))
      (or (distinct ?x2 1)
          (distinct ?y2 1))
      (or (distinct ?x3 1)
          (distinct ?y3 1))
      (or (distinct ?x4 1)
          (distinct ?y4 1)))
      
  ; below ne is the not equal table
  (<= (goal17 ?X1 ?Y1 ?X2 ?Y2 ?X3 ?Y3 ?X4 ?Y4)
      
      (sub ?y1 ?x1 ?neg1)
      (add ?y1 ?x1 ?pos1)
      (sub ?y2 ?x2 ?neg2)
      (distinct ?X1 ?X2)
      (distinct ?Y1 ?Y2)
      (distinct ?neg2 ?neg1)
      (add ?y2 ?x2 ?pos2)
      (distinct ?pos2 ?pos1)
      
      
      (sub ?y3 ?x3 ?neg3)
      (distinct ?X1 ?X3) 
      (distinct ?Y1 ?Y3)
      (distinct ?X2 ?X3)
      (distinct ?Y2 ?Y3)
      (distinct ?neg3 ?neg2)
      (distinct ?neg3 ?neg1)
      (add ?y3 ?x3 ?pos3)
      (distinct ?pos3 ?pos2)
      (distinct ?pos3 ?pos1)
      
      (sub ?y4 ?x4 ?neg4)
      (distinct ?X1 ?X4)
      (distinct ?X2 ?X4)
      (distinct ?X3 ?X4)
      (distinct ?Y1 ?Y4)
      (distinct ?Y2 ?Y4)
      (distinct ?Y3 ?Y4)
      (distinct ?neg4 ?neg3)
      (distinct ?neg4 ?neg2)
      (distinct ?neg4 ?neg1)
      (add ?y4 ?x4 ?pos4)
      (distinct ?pos4 ?pos3)
      (distinct ?pos4 ?pos2)
      (distinct ?pos4 ?pos1))
  
  (add 1 1 2)
  (add 1 2 3)
  (add 1 3 4)
  (add 1 4 5)
  (add 2 1 3)
  (add 2 2 4)
  (add 2 3 5)
  (add 2 4 6)
  (add 3 1 4)
  (add 3 2 5)
  (add 3 3 6)
  (add 3 4 7)
  (add 4 1 5)
  (add 4 2 6)
  (add 4 3 7)
  (add 4 4 8)

  (sub 1 1 0)
  (sub 1 2 -1)
  (sub 1 3 -2)
  (sub 1 4 -3)
  (sub 2 1 1)
  (sub 2 2 0)
  (sub 2 3 -1)
  (sub 2 4 -2)
  (sub 3 1 2)
  (sub 3 2 1)
  (sub 3 3 0)
  (sub 3 4 -1)
  (sub 4 1 3)
  (sub 4 2 2)
  (sub 4 3 1)
  (sub 4 4 0)")
    (example.targetquery     4qsdatalog "ent")
    (example.target          4qsdatalog "  (<= ent
      (not notent))
  (<= notent
      (goal17 ?X1 ?Y1 ?X2 ?Y2 ?X3 ?Y3 ?X4 ?Y4)
      (not (phi ?X1 ?Y1 ?X2 ?Y2 ?X3 ?Y3 ?X4 ?Y4)))
 
  (<= (phi ?X1 ?Y1 ?X2 ?Y2 ?X3 ?Y3 ?X4 ?Y4)
      (or (distinct ?x1 1)
          (distinct ?y1 1))
      (or (distinct ?x2 1)
          (distinct ?y2 1))
      (or (distinct ?x3 1)
          (distinct ?y3 1))
      (or (distinct ?x4 1)
          (distinct ?y4 1)))
      
  ; below ne is the not equal table
  (<= (goal17 ?X1 ?Y1 ?X2 ?Y2 ?X3 ?Y3 ?X4 ?Y4)
      
      (sub ?y1 ?x1 ?neg1)
      (add ?y1 ?x1 ?pos1)
      (sub ?y2 ?x2 ?neg2)
      (< ?x1 ?x2)
      (distinct ?y1 ?y2)
      (distinct ?neg2 ?neg1)
      (add ?y2 ?x2 ?pos2)
      (distinct ?pos2 ?pos1)
      
      
      (sub ?y3 ?x3 ?neg3)
      (< ?x2 ?x3)
      (distinct ?y3 ?y1)
      (distinct ?y3 ?y2)
      (distinct ?neg3 ?neg2)
      (distinct ?neg3 ?neg1)
      (add ?y3 ?x3 ?pos3)
      (distinct ?pos3 ?pos2)
      (distinct ?pos3 ?pos1)
      
      (sub ?y4 ?x4 ?neg4)
      (< ?x3 ?x4)
      (distinct ?y4 ?y1)
      (distinct ?y4 ?y2)
      (distinct ?y4 ?y3)
      (distinct ?neg4 ?neg3)
      (distinct ?neg4 ?neg2)
      (distinct ?neg4 ?neg1)
      (add ?y4 ?x4 ?pos4)
      (distinct ?pos4 ?pos3)
      (distinct ?pos4 ?pos2)
      (distinct ?pos4 ?pos1))
  
  (add 1 1 2)
  (add 1 2 3)
  (add 1 3 4)
  (add 1 4 5)
  (add 2 1 3)
  (add 2 2 4)
  (add 2 3 5)
  (add 2 4 6)
  (add 3 1 4)
  (add 3 2 5)
  (add 3 3 6)
  (add 3 4 7)
  (add 4 1 5)
  (add 4 2 6)
  (add 4 3 7)
  (add 4 4 8)

  (sub 1 1 0)
  (sub 1 2 -1)
  (sub 1 3 -2)
  (sub 1 4 -3)
  (sub 2 1 1)
  (sub 2 2 0)
  (sub 2 3 -1)
  (sub 2 4 -2)
  (sub 3 1 2)
  (sub 3 2 1)
  (sub 3 3 0)
  (sub 3 4 -1)
  (sub 4 1 3)
  (sub 4 2 2)
  (sub 4 3 1)
  (sub 4 4 0)")

    (example.instance        4queens)
    (prettyname              4queens "4-Queens")
    (shortname               4queens "4queens")
    (example.complete        4queens incomplete)
    (example.technique       4queens consistency2deduction)
    (example.technique       4queens bilevel)
    (example.technique       4queens naf)
    (example.technique       4queens unnamed)
    (example.description     4queens "The traditional 8-queens puzzle, shrunken to a 4x4 board with 4 queens.  Two solutions exist to what is usually a CSP.  But in this example, we are asking an entailment query about those solutions: is the upper left square always blank?  This translation turns an entailment query stated in FHL into a datalog query.")
    (matrixshow              4queens true)
    (example.comments        4queens "In the source, add in UNA and DCA for all object constants, i.e. this is finite Herbrand logic.")
    (example.sourcequery     4queens "(forall (?x1 ?y1 ?x2 ?y2 ?x3 ?y3 ?x4 ?y4) 
              (=> (and (row q1 ?x1) (col q1 ?y1) (row q2 ?x2) (col q2 ?y2) (row q3 ?x3) (col q3 ?y3) (row q4 ?x4) (col q4 ?y4))
                  (not (or (and (= ?x1 1) (= ?y1 1))
                           (and (= ?x2 1) (= ?y2 1))
                           (and (= ?x3 1) (= ?y3 1))
                           (and (= ?x4 1) (= ?y4 1))))))")
    (example.source          4queens "  ; all the queens have different rows
  (<= (not (row ?x ?c))
      (row ?y ?c)
      (not (= ?x ?y)))

  ; all the queens have different columns
  (<= (not (col ?x ?c))
      (col ?y ?c)
      (not (= ?x ?y)))

  ; given a row and column, we can compute the two diagonals it is on.
  (<= (d ?q pos ?z) (row ?q ?x) (col ?q ?y) (sub ?y ?x ?z))
  (<= (d ?q neg ?z) (row ?q ?x) (col ?q ?y) (add ?y ?x ?z))

  ; all the queens have different diagonals
  (<= (not (d ?q1 ?sign ?z))
      (d ?q2 ?sign ?z)
      (not (= ?q1 ?q2)))

  ; add and subtract
  (add 1 1 2)
  (add 1 2 3)
  (add 1 3 4)
  (add 1 4 5)
  (add 2 1 3)
  (add 2 2 4)
  (add 2 3 5)
  (add 2 4 6)
  (add 3 1 4)
  (add 3 2 5)
  (add 3 3 6)
  (add 3 4 7)
  (add 4 1 5)
  (add 4 2 6)
  (add 4 3 7)
  (add 4 4 8)

  (sub 1 1 0)
  (sub 1 2 -1)
  (sub 1 3 -2)
  (sub 1 4 -3)
  (sub 2 1 1)
  (sub 2 2 0)
  (sub 2 3 -1)
  (sub 2 4 -2)
  (sub 3 1 2)
  (sub 3 2 1)
  (sub 3 3 0)
  (sub 3 4 -1)
  (sub 4 1 3)
  (sub 4 2 2)
  (sub 4 3 1)
  (sub 4 4 0)
")
    (example.targetquery     4queens "ent")
    (example.target          4queens "  (<= ent
      (not notent))
  (<= notent
      (goal17 ?X1 ?Y1 ?X2 ?Y2 ?X3 ?Y3 ?X4 ?Y4)
      (not (phi ?X1 ?Y1 ?X2 ?Y2 ?X3 ?Y3 ?X4 ?Y4)))
 
  (<= (phi ?X1 ?Y1 ?X2 ?Y2 ?X3 ?Y3 ?X4 ?Y4)
      (or (distinct ?x1 1)
          (distinct ?y1 1))
      (or (distinct ?x2 1)
          (distinct ?y2 1))
      (or (distinct ?x3 1)
          (distinct ?y3 1))
      (or (distinct ?x4 1)
          (distinct ?y4 1)))
      
  ; below ne is the not equal table
  (<= (goal17 ?X1 ?Y1 ?X2 ?Y2 ?X3 ?Y3 ?X4 ?Y4)
      
      (sub ?y1 ?x1 ?neg1)
      (add ?y1 ?x1 ?pos1)
      (sub ?y2 ?x2 ?neg2)
      (distinct ?X1 ?X2)
      (distinct ?Y1 ?Y2)
      (distinct ?neg2 ?neg1)
      (add ?y2 ?x2 ?pos2)
      (distinct ?pos2 ?pos1)
      
      
      (sub ?y3 ?x3 ?neg3)
      (distinct ?X1 ?X3) 
      (distinct ?Y1 ?Y3)
      (distinct ?X2 ?X3)
      (distinct ?Y2 ?Y3)
      (distinct ?neg3 ?neg2)
      (distinct ?neg3 ?neg1)
      (add ?y3 ?x3 ?pos3)
      (distinct ?pos3 ?pos2)
      (distinct ?pos3 ?pos1)
      
      (sub ?y4 ?x4 ?neg4)
      (distinct ?X1 ?X4)
      (distinct ?X2 ?X4)
      (distinct ?X3 ?X4)
      (distinct ?Y1 ?Y4)
      (distinct ?Y2 ?Y4)
      (distinct ?Y3 ?Y4)
      (distinct ?neg4 ?neg3)
      (distinct ?neg4 ?neg2)
      (distinct ?neg4 ?neg1)
      (add ?y4 ?x4 ?pos4)
      (distinct ?pos4 ?pos3)
      (distinct ?pos4 ?pos2)
      (distinct ?pos4 ?pos1))
  
  (add 1 1 2)
  (add 1 2 3)
  (add 1 3 4)
  (add 1 4 5)
  (add 2 1 3)
  (add 2 2 4)
  (add 2 3 5)
  (add 2 4 6)
  (add 3 1 4)
  (add 3 2 5)
  (add 3 3 6)
  (add 3 4 7)
  (add 4 1 5)
  (add 4 2 6)
  (add 4 3 7)
  (add 4 4 8)

  (sub 1 1 0)
  (sub 1 2 -1)
  (sub 1 3 -2)
  (sub 1 4 -3)
  (sub 2 1 1)
  (sub 2 2 0)
  (sub 2 3 -1)
  (sub 2 4 -2)
  (sub 3 1 2)
  (sub 3 2 1)
  (sub 3 3 0)
  (sub 3 4 -1)
  (sub 4 1 3)
  (sub 4 2 2)
  (sub 4 3 1)
  (sub 4 4 0)")

    (example.instance        dresdenqueens)
    (prettyname              dresdenqueens "Dresden Queens")
    (example.complete        dresdenqueens complete)
    (example.technique       dresdenqueens dataextraction)
    (example.technique       dresdenqueens generateoverguess)
    (example.description     dresdenqueens "When a GGP class was taught in Dresden, the 8-queens puzzle was used at some point.  The original axioms they wrote ran slowly when asking the query for the reward a player earned after having placed the 8 queens on the board.  The formulation was propositional: check if there are 8 queens that are attacked by some other queen; if so, award 0 points.  Then check if there are 7 queens that are attacked, and award 40 points.  And so on.  Nat changed the axioms so that first they compute how many queens are attacked and then use a lookup table to compute the points awarded.")
    (example.description     dresdenqueens "We extracted the data out of the rules and relied on generation instead of guess and check.")
    (example.efficiencygains dresdenqueens "(reward player ?x)
Source: 425 seconds, Target: 3 seconds")
    (matrixshow              dresdenqueens true)
    (example.source          dresdenqueens "  (<= (goal player ?s)
      (attacks ?n)
      (mapnum2val ?n ?s))
  (mapnum2val s0 100)
  (mapnum2val s2 90)
  (mapnum2val s3 80)
  (mapnum2val s4 70)
  (mapnum2val s5 60)
  (mapnum2val s6 50)
  (mapnum2val s7 40)
  (mapnum2val s8 0)
  (mapnum2val s9 0)
  (mapnum2val s10 0)
")
    (example.target          dresdenqueens "  (<= (goal player 100)
      (attacks s0))
  (<= (goal player 90)
      (attacks s2))
  (<= (goal player 80)
      (attacks s3))
  (<= (goal player 70)
      (attacks s4))
  (<= (goal player 60)
      (attacks s5))
  (<= (goal player 50)
      (attacks s6))
  (<= (goal player 40)
      (attacks s7))
  (<= (goal player 0)
      (attacks s8))
  (<= (goal player 0)
      (attacks s9))
  (<= (goal player 0)
      (attacks s10))
")
    (example.dateentered     dresdenqueens 3355255579)
    (example.datemodified    dresdenqueens 3355255579)

    (example.instance        exponentialnegation)
    (prettyname              exponentialnegation "Exponential negation")
    (shortname               exponentialnegation "ExpNeg")
    (example.complete        exponentialnegation complete)
    (example.technique       exponentialnegation naf)
    (example.description     exponentialnegation "An iff can be used to compactly define a complete relation; however, when converting an iff to clausal form, negating the body can produce a large number of rules.  This example shows that an exponential number of rules can be produced.  In general, if this example is generalized to include n disjuncts of conjunctions of length m, there are m^n rules of length m for defining the negative space.  There would be n rules of length m for defining the positive space.")
    (example.efficiencygains exponentialnegation "6/4 unis/infs to explore positive space versus 54/28 unis/infs to explore negative space")
    (matrixshow              exponentialnegation true)
    (example.sourcequery     exponentialnegation "(not illegal)")
    (example.source          exponentialnegation "(<=> illegal (or (and p1 p2 p3) (and q1 q2 q3) (and r1 r2 r3)))
")
    (example.targetquery     exponentialnegation "(not illegal)")
    (example.target          exponentialnegation "(<= illegal (or (and p1 p2 p3) (and q1 q2 q3) (and r1 r2 r3)))
")

    (example.instance        guess)
    (prettyname              guess "Guess")
    (shortname               guess "Guess")
    (example.complete        guess complete)
    (example.technique       guess staticconjordering)
    (example.description     guess "Example where a bad conjunct ordering requires non-zero work to find legal moves because the ground conjuncts are not moved all the way to the front.")
    (example.efficiencygains guess "In this game, search space shrinks from 64^2 to 1 per rule.")
    (matrixshow              guess true)
    (example.comments        guess "There may be a bug in the game -- something about greater than.")
    (example.sourcequery     guess "(legal chooser ?x)")
    (example.source          guess "  (role guesser)
  (role chooser)
  (<= (legal guesser ?g)
      (true (possible ?g))
      (true (control guesser))
  (<= (legal guesser wait)
      (true (control chooser))
  (<= (next (control guesser))
      (true (control chooser))
  (<= (next (control chooser))
      (true (control guesser))
  (<= (next (guess ?x))
      (does guesser ?x)
      (true (possible ?x))
  (<= (legal chooser higher)
      (true (possible ?n))
      (greater ?n ?x)
      (true (guess ?x))
      (true (control chooser))
  (<= (legal chooser lower)
      (true (possible ?n))
      (greater ?x ?n)
      (true (guess ?x))
      (true (control chooser))
  (<= (legal chooser wait)
      (true (control guesser))
  (<= (next (possible ?x))
      (true (possible ?x))
      (true (control guesser))
  (<= (next (possible ?x))
      (true (possible ?x))
      (greater ?x ?y)
      (true (guess ?y))
      (does chooser higher)
  (<= (next (possible ?x))
      (true (possible ?x))
      (greater ?y ?x)
      (true (guess ?y))
      (does chooser lower)
  (<= (next (step ?x))
      (true (step ?y))
      (succ ?y ?x)
  (<= (goal guesser 100)
      (not unfinished)
  (<= (goal guesser 0)
      unfinished
  (<= (goal chooser 100)
      unfinished
  (<= (goal chooser 0)
      (not unfinished)
  (<= terminal
      (not unfinished)
  (<= terminal
      (true (step 12))
  (<= unfinished
      (true (possible ?x))
      (true (possible ?y))
      (distinct ?x ?y)
  (<= (greater ?x ?y)
      (succ ?y ?x)
  (<= (greater ?x ?y)
      (succ ?x ?z)
      (greater ?z ?y)
  (init (step 1))
  (init (control guesser))
  (init (possible 1))
  (init (possible 2))
  (init (possible 3))
  (init (possible 4))
  (init (possible 5))
  (init (possible 6))
  (init (possible 7))
  (init (possible 8))
  (init (possible 9))
  (init (possible 10))
  (init (possible 11))
  (init (possible 12))
  (init (possible 13))
  (init (possible 14))
  (init (possible 15))
  (init (possible 16))
  (init (possible 17))
  (init (possible 18))
  (init (possible 19))
  (init (possible 20))
  (init (possible 21))
  (init (possible 22))
  (init (possible 23))
  (init (possible 24))
  (init (possible 25))
  (init (possible 26))
  (init (possible 27))
  (init (possible 28))
  (init (possible 29))
  (init (possible 30))
  (init (possible 31))
  (init (possible 32))
  (init (possible 33))
  (init (possible 34))
  (init (possible 35))
  (init (possible 36))
  (init (possible 37))
  (init (possible 38))
  (init (possible 39))
  (init (possible 40))
  (init (possible 41))
  (init (possible 42))
  (init (possible 43))
  (init (possible 44))
  (init (possible 45))
  (init (possible 46))
  (init (possible 47))
  (init (possible 48))
  (init (possible 49))
  (init (possible 50))
  (init (possible 51))
  (init (possible 52))
  (init (possible 53))
  (init (possible 54))
  (init (possible 55))
  (init (possible 56))
  (init (possible 57))
  (init (possible 58))
  (init (possible 59))
  (init (possible 60))
  (init (possible 61))
  (init (possible 62))
  (init (possible 63))
  (succ 1 2)
  (succ 2 3)
  (succ 3 4)
  (succ 4 5)
  (succ 5 6)
  (succ 6 7)
  (succ 7 8)
  (succ 8 9)
  (succ 9 10)
  (succ 10 11)
  (succ 11 12)
  (succ 12 13)
  (succ 13 14)
  (succ 14 15)
  (succ 15 16)
  (succ 16 17)
  (succ 17 18)
  (succ 18 19)
  (succ 19 20)
  (succ 20 21)
  (succ 21 22)
  (succ 22 23)
  (succ 23 24)
  (succ 24 25)
  (succ 25 26)
  (succ 26 27)
  (succ 27 28)
  (succ 28 29)
  (succ 29 30)
  (succ 30 31)
  (succ 31 32)
  (succ 32 33)
  (succ 33 34)
  (succ 34 35)
  (succ 35 36)
  (succ 36 37)
  (succ 37 38)
  (succ 38 39)
  (succ 39 40)
  (succ 40 41)
  (succ 41 42)
  (succ 42 43)
  (succ 43 44)
  (succ 44 45)
  (succ 45 46)
  (succ 46 47)
  (succ 47 48)
  (succ 48 49)
  (succ 49 50)
  (succ 50 51)
  (succ 51 52)
  (succ 52 53)
  (succ 53 54)
  (succ 54 55)
  (succ 55 56)
  (succ 56 57)
  (succ 57 58)
  (succ 58 59)
  (succ 59 60)
  (succ 60 61)
  (succ 61 62)
  (succ 62 63)")
    (example.targetquery     guess "(legal chooser ?x)")
    (example.target          guess "  (role guesser)
  (role chooser)

  (<= (legal guesser ?g)
      (true (control guesser))
      (true (possible ?g)))

  (<= (legal guesser wait)
      (true (control chooser)))

  (<= (next (control guesser))
      (true (control chooser)))

  (<= (next (control chooser))
      (true (control guesser)))

  (<= (next (guess ?x))
      (does guesser ?x)
      (true (possible ?x)))

  (<= (legal chooser higher)
      (true (control chooser))
      (true (possible ?n))
      (greater ?n ?x)
      (true (guess ?x)))

  (<= (legal chooser lower)
      (true (control chooser))
      (true (possible ?n))
      (greater ?x ?n)
      (true (guess ?x)))

  (<= (legal chooser wait)
      (true (control guesser)))

  (<= (next (possible ?x))
      (true (control guesser))
      (true (possible ?x)))

  (<= (next (possible ?x))
      (does chooser higher)
      (true (possible ?x))
      (greater ?x ?y)
      (true (guess ?y)))

  (<= (next (possible ?x))
      (does chooser lower)
      (true (possible ?x))
      (greater ?y ?x)
      (true (guess ?y)))

  (<= (next (step ?x))
      (true (step ?y))
      (succ ?y ?x))

  (<= (goal guesser 100)
      (not unfinished))
  (<= (goal guesser 0)
      unfinished)
  (<= (goal chooser 100)
      unfinished)
  (<= (goal chooser 0)
      (not unfinished))
  (<= terminal
      (not unfinished))
  (<= terminal
      (true (step 12)))
  (<= unfinished
      (true (possible ?x))
      (true (possible ?y))
      (distinct ?x ?y))
  (<= (greater ?x ?y)
      (succ ?y ?x))
  (<= (greater ?x ?y)
      (succ ?x ?z)
      (greater ?z ?y))
  (init (step 1))
  (init (control guesser))
  (init (possible 1))
  (init (possible 2))
  (init (possible 3))
  (init (possible 4))
  (init (possible 5))
  (init (possible 6))
  (init (possible 7))
  (init (possible 8))
  (init (possible 9))
  (init (possible 10))
  (init (possible 11))
  (init (possible 12))
  (init (possible 13))
  (init (possible 14))
  (init (possible 15))
  (init (possible 16))
  (init (possible 17))
  (init (possible 18))
  (init (possible 19))
  (init (possible 20))
  (init (possible 21))
  (init (possible 22))
  (init (possible 23))
  (init (possible 24))
  (init (possible 25))
  (init (possible 26))
  (init (possible 27))
  (init (possible 28))
  (init (possible 29))
  (init (possible 30))
  (init (possible 31))
  (init (possible 32))
  (init (possible 33))
  (init (possible 34))
  (init (possible 35))
  (init (possible 36))
  (init (possible 37))
  (init (possible 38))
  (init (possible 39))
  (init (possible 40))
  (init (possible 41))
  (init (possible 42))
  (init (possible 43))
  (init (possible 44))
  (init (possible 45))
  (init (possible 46))
  (init (possible 47))
  (init (possible 48))
  (init (possible 49))
  (init (possible 50))
  (init (possible 51))
  (init (possible 52))
  (init (possible 53))
  (init (possible 54))
  (init (possible 55))
  (init (possible 56))
  (init (possible 57))
  (init (possible 58))
  (init (possible 59))
  (init (possible 60))
  (init (possible 61))
  (init (possible 62))
  (init (possible 63))
  (succ 1 2)
  (succ 2 3)
  (succ 3 4)
  (succ 4 5)
  (succ 5 6)
  (succ 6 7)
  (succ 7 8)
  (succ 8 9)
  (succ 9 10)
  (succ 10 11)
  (succ 11 12)
  (succ 12 13)
  (succ 13 14)
  (succ 14 15)
  (succ 15 16)
  (succ 16 17)
  (succ 17 18)
  (succ 18 19)
  (succ 19 20)
  (succ 20 21)
  (succ 21 22)
  (succ 22 23)
  (succ 23 24)
  (succ 24 25)
  (succ 25 26)
  (succ 26 27)
  (succ 27 28)
  (succ 28 29)
  (succ 29 30)
  (succ 30 31)
  (succ 31 32)
  (succ 32 33)
  (succ 33 34)
  (succ 34 35)
  (succ 35 36)
  (succ 36 37)
  (succ 37 38)
  (succ 38 39)
  (succ 39 40)
  (succ 40 41)
  (succ 41 42)
  (succ 42 43)
  (succ 43 44)
  (succ 44 45)
  (succ 45 46)
  (succ 46 47)
  (succ 47 48)
  (succ 48 49)
  (succ 49 50)
  (succ 50 51)
  (succ 51 52)
  (succ 52 53)
  (succ 53 54)
  (succ 54 55)
  (succ 55 56)
  (succ 56 57)
  (succ 57 58)
  (succ 58 59)
  (succ 59 60)
  (succ 60 61)
  (succ 61 62)
  (succ 62 63)")

    (example.instance        jigsaw)
    (prettyname              jigsaw "Jigsaw")
    (shortname               jigsaw "Jigsaw")
    (example.complete        jigsaw complete)
    (example.technique       jigsaw residuesrewrite)
    (example.technique       jigsaw naf)
    (example.technique       jigsaw unnamed)
    (example.description     jigsaw "This is a 4-piece jigsaw puzzle.  The original jigsaw axioms are complicated, and converting them into clausal form is expensive.  Moreover, finding an answer after conversion takes a very, very long time.  Lastly, the relations included have modular definitions--they could be picked up and moved to other theories without (much) modification.  The new axioms include less information, but they include sufficient information to answer the query goal.  The new axioms find all answers in less than a second.")
    (example.efficiencygains jigsaw "13000x speedup")
    (matrixshow              jigsaw true)
    (example.sourcequery     jigsaw "(goal ?x ?y ?z ?w)")
    (example.source          jigsaw "  (<=> (cardinal ?x) (or (= ?x north) (= ?x south) (= ?x west) (= ?x east)))
  (<=> (piece ?x) (or (= ?x p1) (= ?x p2) (= ?x p3) (= ?x p4) (= ?x p0)))
  (<=> (orientation ?x) (or (= ?x 0) (= ?x 90) (= ?x 180) (= ?x 270)))

  ;(or (piece ?x) (orientation ?x) (cardinal ?x))

  (<=> (edge ?x ?y) 
       (or (and (= ?x p1) (or (= ?y east) (= ?y north)))
           (and (= ?x p2) (or (= ?y west) (= ?y north)))
           (and (= ?x p3) (or (= ?y west) (= ?y south)))
           (and (= ?x p4) (or (= ?y north) (= ?y east)))) )

  (<=> (rotate ?x ?amt ?y) 
       (or (and (= ?x north) (= ?amt 0) (= ?y north)) 
           (and (= ?x north) (= ?amt 90) (= ?y east))
           (and (= ?x north) (= ?amt 180) (= ?y south))
           (and (= ?x north) (= ?amt 270) (= ?y west))
           
           (and (= ?x south) (= ?amt 0) (= ?y south)) 
           (and (= ?x south) (= ?amt 90) (= ?y west))
           (and (= ?x south) (= ?amt 180) (= ?y north))
           (and (= ?x south) (= ?amt 270) (= ?y east))

           (and (= ?x east) (= ?amt 0) (= ?y east)) 
           (and (= ?x east) (= ?amt 90) (= ?y south))
           (and (= ?x east) (= ?amt 180) (= ?y west))
           (and (= ?x east) (= ?amt 270) (= ?y north))

           (and (= ?x west) (= ?amt 0) (= ?y west)) 
           (and (= ?x west) (= ?amt 90) (= ?y north))
           (and (= ?x west) (= ?amt 180) (= ?y east))
           (and (= ?x west) (= ?amt 270) (= ?y south))
           ))

  (<=> (orientededge ?x ?o ?e)
       (and (piece ?x) 
            (orientation ?o)
            (cardinal ?e)
            (or (and (edge ?x north)
                     (rotate north ?o ?e))
                (and (edge ?x south)
                     (rotate south ?o ?e))
                (and (edge ?x east)
                     (rotate east ?o ?e))
                (and (edge ?x west)
                     (rotate west ?o ?e)) )))

  (<=> (connectedh ?x ?xo ?y ?yo)
       (and (piece ?x)
            (orientation ?xo)
            (piece ?y)
            (orientation ?yo)
            (or (and (orientededge ?x ?xo east)
                     (orientededge ?y ?yo west))
                (and (not (orientededge ?x ?xo east))
                     (not (orientededge ?y ?yo west))) )))
 
  (<=> (connectedv ?x ?xo ?y ?yo)
       (and (piece ?x)
            (orientation ?xo)
            (piece ?y)
            (orientation ?yo)
            (or (and (orientededge ?x ?xo south)
                     (orientededge ?y ?yo north))
                (and (not (orientededge ?x ?xo south))
                     (not (orientededge ?y ?yo north))) )))

  ; border uses p0, a piece with no edges
  (<=> (border ?o1 ?o2 ?o3 ?o4)
       (and (connectedh p0 0 p1 ?o1)
            (connectedv p0 0 p1 ?o1)
            (connectedv p0 0 p2 ?o2)
            (connectedh p2 ?o2 p0 0)
            (connectedh p4 ?o4 p0 0)
            (connectedv p4 ?o4 p0 0)
            (connectedv p3 ?o3 p0 0)
            (connectedh p0 0 p3 ?o3)))

  (<=> (connected ?o1 ?o2 ?o3 ?o4)
       (and (connectedh p1 ?o1 p2 ?o2)
            (connectedh p3 ?o3 p4 ?o4)
            (connectedv p1 ?o1 p3 ?o3)
            (connectedv p2 ?o2 p4 ?o4)
            (border ?o1 ?o2 ?o3 ?o4)))

  (<= (goal ?o1 ?o2 ?o3 ?o4)
      (connected ?o1 ?o2 ?o3 ?o4))
 
")
    (example.targetquery     jigsaw "(goal ?x ?y ?z ?w)")
    (example.target          jigsaw "  (piece p1) 
  (piece p2) 
  (piece p3) 
  (piece p4) 
   
  (rotation 0) 
  (rotation 90) 
  (rotation 180) 
  (rotation 270) 
   
  (cardinal north) 
  (cardinal south) 
  (cardinal east) 
  (cardinal west) 
   
  (edge p1 north) 
  (edge p1 east) 
  (edge p2 north) 
  (edge p2 west) 
  (edge p3 south) 
  (edge p3 west) 
  (edge p4 north) 
  (edge p4 east) 
   
  (<= (rotate ?p ?rot east) 
      (or (and (edge ?p east) (same ?rot 0)) 
          (and (edge ?p north) (same ?rot 90)) 
          (and (edge ?p west) (same ?rot 180)) 
          (and (edge ?p south) (same ?rot 270)))) 
   
  (<= (rotate ?p ?rot west) 
      (or (and (edge ?p west) (same ?rot 0)) 
          (and (edge ?p south) (same ?rot 90)) 
          (and (edge ?p east) (same ?rot 180)) 
          (and (edge ?p north) (same ?rot 270)))) 
   
  (<= (rotate ?p ?rot north) 
      (or (and (edge ?p north) (same ?rot 0)) 
          (and (edge ?p west) (same ?rot 90)) 
          (and (edge ?p south) (same ?rot 180)) 
          (and (edge ?p east) (same ?rot 270)))) 
   
  (<= (rotate ?p ?rot south) 
      (or (and (edge ?p south) (same ?rot 0)) 
          (and (edge ?p east) (same ?rot 90)) 
          (and (edge ?p north) (same ?rot 180)) 
          (and (edge ?p west) (same ?rot 270)))) 
   
   
  (<= (goal ?nw ?ne ?sw ?se) 
      (rotation ?nw) 
      (rotation ?ne) 
      (rotation ?sw) 
      (rotation ?se) 
      (rotate p1 ?nw east) 
      (rotate p2 ?ne west) 
      (rotate p3 ?sw east) 
      (rotate p4 ?se west) 
      (rotate p1 ?nw south) 
      (rotate p3 ?sw north) 
      (rotate p2 ?ne south) 
      (rotate p4 ?se north))
")

    (example.instance        mapcoloring)
    (prettyname              mapcoloring "Map Coloring")
    (example.complete        mapcoloring incomplete)
    (example.technique       mapcoloring consistency2deduction)
    (example.technique       mapcoloring chirkovareformulation)
    (example.description     mapcoloring "The first version is not deductive; in fact, it entails which colorings are invalid.  The second version is deductive.  The first can be separated from region, hue, adjacent, but the second version builds all 3 into the formulation.  The first is more natural, but the second seems to be more efficient. Instead of building an arbitrary model for the axioms, we can use CSP/LP techniques to find an answer.  Actually, it is unclear to what extent the second formulation is faster than the first.")
    (matrixshow              mapcoloring true)
    (example.sourcequery     mapcoloring "(and (color r1 ?x) (color r2 ?y) (color r3 ?z))
")
    (example.source          mapcoloring "  (<= (not (color ?r ?c))
      (not (region ?r)))

  (<= (not (color ?r ?c))
      (not (hue ?c)))

  (<= (not (color ?r1 ?c))
      (adjacent ?r1 ?r2)
      (color ?r2 ?c))

  (region r1)
  (region r2)
  (region r3)

  (hue red)
  (hue blue)

  (adjacent r1 r2)
  (adjacent r2 r1)
  (adjacent r2 r3)
  (adjacent r3 r2)
")
    (example.targetquery     mapcoloring "(and (next ?x ?y) (next ?y ?z))")
    (example.target          mapcoloring "(next red blue)
(next blue red)")
    (example.dateentered     mapcoloring 3355255875)
    (example.datemodified    mapcoloring 3355255875)

    (example.instance        mazeworld)
    (prettyname              mazeworld "Maze World")
    (example.complete        mazeworld incomplete)
    (example.technique       mazeworld consistency2deduction)
    (example.technique       mazeworld unnamed)
    (example.description     mazeworld "Original maze world is an incomplete information game.  The new maze world is a complete information game, where all the uncertainty has been built into the role world.  When building the game tree for a 2-player incomplete game, the branching factor for your opponent is all possible moves since we don't necessarily know what moves that player can legally make.  Sometimes, some of those moves are inconsistent with the current state of the world.  By compiling the incompleteness into the world player, we can enumerate just the legal moves that are consistent with the state of the game.")
    (matrixshow              mazeworld true)
    (example.source          mazeworld "  (role robot)

    (initial 1)
    (successor 1 2)
    (successor 2 3)
    (successor 3 4)
    (successor 4 5)
    (successor 5 6)
    (successor 6 7)
    (successor 7 8)
    (successor 8 9)
    (successor 9 10)

    (adjacent a b)
    (adjacent b c)
    (adjacent c d)
    (adjacent d a)

    (percept robot bright)

    ;;;;

    (<= (legal robot move ?n))
    (<= (legal robot noop ?n))

    (<= (goal robot 100 ?n)
        (true (cell ?x) ?n)
        (true (gold ?x) ?n))
    
    (<= (goal robot 0 ?n)
        (true (cell ?x) ?n)
	(true (gold ?y) ?n)
        (distinct ?x ?y))
        
    (terminal 7)

    ;;;;
    
    ; state
    (true (cell a) 1)
    (not (true (gold a) 1))

    ; effector
    (<= (true (cell ?y) ?n)
        (successor ?m ?n)
        (does robot move ?m)
        (true (cell ?x) ?m)
        (adjacent ?x ?y))

    (<= (true (cell ?y) ?n)
        (successor ?m ?n)
        (does robot noop ?m)
        (true (cell ?y) ?n))
		
    
    ; state
    (<= (true (gold d) ?n)
        (not (true (gold a) ?n))
        (not (true (gold b) ?n))
        (not (true (gold c) ?n))
        (not (true (gold i) ?n)))

    
    ; gold sensor
    (<= (true (gold ?x) ?n)
        (sees robot bright ?n)
        (true (cell ?x) ?n))

    (<= (not (true (gold ?x) ?n))
        (not (sees robot bright ?n)) 
        (true (cell ?x) ?n))
    

    ; frame: monotonicity of gold
    (<= (true (gold ?x) ?n)
        (successor ?m ?n)
        (true (gold ?x) ?m))

    (<= (not (true (gold ?x) ?n))
        (successor ?m ?n)
        (not (true (gold ?x) ?m)))
")
    (example.target          mazeworld "  (role robot)
  (role world)
  
  (successor 1 2)
  (successor 2 3)
  (successor 3 4)
  (successor 4 5)
  (successor 5 6)
  (successor 6 7)
  (successor 7 8)
  (successor 8 9)
  (successor 9 10)
  
  (adjacent a b)
  (adjacent b c)
  (adjacent c d)
  (adjacent d a)
  
  (percept robot bright)

  ;;;;

  (init (step 1))
  (init (listof * * *))
  (init (cell a))
  
  ;;;;
  
  (<= (legal robot move))
  (<= (legal robot noop))
  
  (<= (legal world (listof ?x ?u ?v))
      (true (listof * ?u ?v))
      (bit3 ?x ?u ?v))
  (<= (legal world (listof ?x ?u ?v))
      (true (listof ?x * ?v))
      (bit3 ?x ?u ?v))
  (<= (legal world (listof ?x ?u ?v))
      (true (listof ?x ?u *))
      (bit3 ?x ?u ?v))
  (<= (legal world (listof ?x ?u ?v))
      (true (listof * * ?v))
      (bit3 ?x ?u ?v))
  (<= (legal world (listof ?x ?u ?v))
      (true (listof * ?u *))
      (bit3 ?x ?u ?v))
  (<= (legal world (listof ?x ?u ?v))
      (true (listof ?x * *))
      (bit3 ?x ?u ?v))
  (<= (legal world (listof ?x ?u ?v))
      (true (listof * * *))
      (bit3 ?x ?u ?v))
  
  
  (<= (bit3 ?x ?y ?z) (bit ?x) (bit ?y) (bit ?z))
  (bit 1) 
  (bit 0)
  
  (<= (goal robot 100)
      (true (cell ?x))
      (true (real (gold ?x))))
  
  (<= (goal robot 0)
      (true (cell ?x))
      (true (real ?y))
      (distinct ?x ?y))
  
  ;;;;
  
  ; counter
  (<= (next (step ?x))
      (true (step ?y))
      (successor ?y ?x))
  
  ; effector: world
  (<= (next (real ?x))
      (does world ?y)
      (item-true ?x ?y))
  
  (<= (item-true (gold b) (listof 1 ?y ?z)))
  (<= (item-true (gold c) (listof ?x 1 ?z)))
  (<= (item-true (gold d) (listof ?x ?y 1)))
  (<= (item-false (gold b) (listof 0 ?y ?z)))
  (<= (item-false (gold c) (listof ?x 0 ?z)))
  (<= (item-false (gold d) (listof ?x ?y 0)))
  
  ; effector: robot
  (<= (next (cell ?y))
      (does robot move)
      (true (cell ?x))
      (adjacent ?x ?y))
  
  (<= (next (cell ?y))
      (does robot noop)
      (true (cell ?y)))
  
  
  ; frame and sensor: skolem
  (<= (next (listof ?x ?y ?z))
      (val (gold b) ?x)
      (val (gold c) ?y)
      (val (gold d) ?z))
  
  (<= (val ?x 1)
      (tru ?x))
  (<= (val ?x 1)
      (true (listof @y))
      (item-true ?x (listof @y)))

  (<= (val ?x 0)
      (nottru ?x))
  (<= (val ?x 0)
      (true (listof @y))
      (item-false ?x (listof @y)))

  (<= (val ?x *)
      (true (listof @y))
      (not (item-true ?x (listof @y)))
      (not (item-false ?x (listof @y)))
      (not  (tru ?x))
      (not (nottru ?x)))

  
  (<= (nottru (gold ?y))
      (does robot move)
      (true (cell ?x))
      (adjacent ?x ?y)
      (does world ?wm)
      (item-false (gold ?y) ?wm)) 
  
  (<= (tru (gold ?y))
      (does robot move)
      (true (cell ?x))
      (adjacent ?x ?y)
      (does world ?wm)
      (item-true (gold ?y) ?wm)) 
")
    (example.dateentered     mazeworld 3355255765)
    (example.datemodified    mazeworld 3355255765)

    (example.instance        nqueens)
    (prettyname              nqueens "N-Queens")
    (shortname               nqueens "nqueens")
    (example.complete        nqueens incomplete)
    (example.technique       nqueens bilevel)
    (example.technique       nqueens naf)
    (example.technique       nqueens consistency2deduction)
    (example.technique       nqueens unnamed)
    (example.description     nqueens "Here we use (a minimal-model semantic version of) metalevel logic to describe the class of all X-queens queries, where the constraints are written as usual in FHL.  The recursive query definition is guarded by a single table that says how many queens are available (which I believe may play a crucial role in doing the translation).  The datalog version uses recursion and functions, again bounded by the single table with the number of queens.  ")
    (matrixshow              nqueens true)
    (example.comments        nqueens "Here we can do the reformulation once and apply it to any n-queens problem by simply changing the value in that NumQueens table and the add/sub facts.  We pay a little more in interpreting the Datalog because of the added recursion.

This example illustrates just C2D: we just want to enumerate all the solutiions.  (query ?x) is true in the Datalog version if ?x is a list of queen locations, ?x satisfies the constraints of n-queens, and ?x has n locations, where n is the value in the table querylength.
")
    (example.sourcequery     nqueens "  (query ?x)")
    (example.source          nqueens "
 ;;;;;;;;;; metalevel query definition ;;;;;;;;;;;;
(<= (query ?x)
      (queens ?x)
      (query-length ?n)
      (length ?x ?n))

  (<= (queen \"(and (row <?q> <?x>) (col <?q> <?y>))\")
      (queen ?q)
      (var ?x)
      (var ?y)
      (not (= ?x ?y)))

  (<= (queens \"(and ?x ?y)\")
      (queen ?x)
      (queens ?y))

  (<= (length \"(?x ?y ?z)\" (s 0))
      (not (= ?x \"and\")))
  (<= (length \"(and <?x> <?y>)\" (s ?z))
      (length ?y ?z))

  ;;;;;;; then we have the normal constraints ;;;;;;;;
  ; all the queens have different rows
  (<= (not (row ?x ?c))
      (row ?y ?c)
      (not (= ?x ?y)))

  ; all the queens have different columns
  (<= (not (col ?x ?c))
      (col ?y ?c)
      (not (= ?x ?y)))

  ; given a row and column, we can compute the two diagonals it is on.
  (<= (d ?q pos ?z) (row ?q ?x) (col ?q ?y) (sub ?y ?x ?z))
  (<= (d ?q neg ?z) (row ?q ?x) (col ?q ?y) (add ?y ?x ?z))

  ; all the queens have different diagonals
  (<= (not (d ?q1 ?sign ?z))
      (d ?q2 ?sign ?z)
      (not (= ?q1 ?q2)))

  ; add and subtract
  (add 1 1 2)
  (add 1 2 3)
  (add 1 3 4)
  (add 1 4 5)
  (add 2 1 3)
  (add 2 2 4)
  (add 2 3 5)
  (add 2 4 6)
  (add 3 1 4)
  (add 3 2 5)
  (add 3 3 6)
  (add 3 4 7)
  (add 4 1 5)
  (add 4 2 6)
  (add 4 3 7)
  (add 4 4 8)

  (sub 1 1 0)
  (sub 1 2 -1)
  (sub 1 3 -2)
  (sub 1 4 -3)
  (sub 2 1 1)
  (sub 2 2 0)
  (sub 2 3 -1)
  (sub 2 4 -2)
  (sub 3 1 2)
  (sub 3 2 1)
  (sub 3 3 0)
  (sub 3 4 -1)
  (sub 4 1 3)
  (sub 4 2 2)
  (sub 4 3 1)
  (sub 4 4 0)
")
    (example.targetquery     nqueens "(query ?x)")
    (example.target          nqueens "  (<= (query ?x)
      (querylength ?n)
      (ans ?x ?n))

  (<= (ans nil 0))
  (<= (ans (f ?x ?y) (s ?z))
      (ans ?y ?z)
      (augmentans ?x ?y))

  (<= (augmentans ?x ?y)
      (place-queen ?x)
      (not (some-queen-attacks ?x ?y)))

  (<= (place-queen (loc ?x ?y ?neg ?pos))
      (sub ?y ?x ?neg)
      (add ?y ?x ?pos))
      
  (<= (some-queen-attacks (loc ?x ?y ?neg ?pos) (f (loc ?x2 ?y2 ?neg2 ?pos2) ?rest))
      (or (= ?x ?x2)
          (= ?y ?y2)
          (= ?neg ?neg2)
          (= ?pos ?pos2)
          (some-queen-attacks (loc ?x ?y ?neg ?pos) ?rest)))
  (= ?x ?x)

  (querylength (s (s (s (s 0)))))
  (add 1 1 2)
  (add 1 2 3)
  (add 1 3 4)
  (add 1 4 5)
  (add 2 1 3)
  (add 2 2 4)
  (add 2 3 5)
  (add 2 4 6)
  (add 3 1 4)
  (add 3 2 5)
  (add 3 3 6)
  (add 3 4 7)
  (add 4 1 5)
  (add 4 2 6)
  (add 4 3 7)
  (add 4 4 8)

  (sub 1 1 0)
  (sub 1 2 -1)
  (sub 1 3 -2)
  (sub 1 4 -3)
  (sub 2 1 1)
  (sub 2 2 0)
  (sub 2 3 -1)
  (sub 2 4 -2)
  (sub 3 1 2)
  (sub 3 2 1)
  (sub 3 3 0)
  (sub 3 4 -1)
  (sub 4 1 3)
  (sub 4 2 2)
  (sub 4 3 1)
  (sub 4 4 0)
")

    (example.instance        toetictac)
    (prettyname              toetictac "Toetictac")
    (example.complete        toetictac complete)
    (example.technique       toetictac relationalizing)
    (example.technique       toetictac unnamed)
    (example.description     toetictac "Toetictac is a reconceptualization of the original axioms for tictactoe.  In the original version each of the 9 cells is labelled with an x, an o, or a b: cell(x,y,label).  In the new version each of the 9 cells (a,b,c,d,e,f,g,h,i) is either true of ecks or ohs or blank, each of which is a unary relation.")
    (example.description     toetictac "The old: each of the 9 cells is labelled with an x, an o, or a b: cell(x,y,label).  The new: each of the 9 cells (a,b,c,d,e,f,g,h,i) is either true of ecks or ohs or blank, each of which is a unary relation. ")
    (example.efficiencygains toetictac "(brute-force-playable source) takes 56.5 seconds.
(brute-force-playable target) takes 39 seconds.")
    (matrixshow              toetictac true)
    (example.source          toetictac "    (role white)
    (role black)
    (init (cell 1 1 b))
    (init (cell 1 2 b))
    (init (cell 1 3 b))
    (init (cell 2 1 b))
    (init (cell 2 2 b))
    (init (cell 2 3 b))
    (init (cell 3 1 b))
    (init (cell 3 2 b))
    (init (cell 3 3 b))
    (init (control white))
    (<= (next (cell ?m ?n x))
        (does white (mark ?m ?n))
        (true (cell ?m ?n b)))
    (<= (next (cell ?m ?n o))
        (does black (mark ?m ?n))
        (true (cell ?m ?n b)))
    (<= (next (cell ?m ?n ?w))
        (true (cell ?m ?n ?w))
        (distinct ?w b))
    (<= (next (cell ?m ?n b))
        (does ?w (mark ?j ?k))
        (true (cell ?m ?n b))
        (or (distinct ?m ?j) (distinct ?n ?k)))
    (<= (next (control white))
        (true (control black)))
    (<= (next (control black))
        (true (control white)))
    (<= (row ?m ?x)
        (true (cell ?m 1 ?x))
        (true (cell ?m 2 ?x))
        (true (cell ?m 3 ?x)))
    (<= (column ?n ?x)
        (true (cell 1 ?n ?x))
        (true (cell 2 ?n ?x))
        (true (cell 3 ?n ?x)))
    (<= (diagonal ?x)
        (true (cell 1 1 ?x))
        (true (cell 2 2 ?x))
        (true (cell 3 3 ?x)))
    (<= (diagonal ?x)
        (true (cell 1 3 ?x))
        (true (cell 2 2 ?x))
        (true (cell 3 1 ?x)))
    (<= (line ?x)
        (row ?m ?x))
    (<= (line ?x)
        (column ?m ?x))
    (<= (line ?x)
        (diagonal ?x))
    (<= open
        (true (cell ?m ?n b)))
    (<= (legal ?w (mark ?x ?y))
        (true (cell ?x ?y b))
        (true (control ?w)))
    (<= (legal white noop)
        (true (cell ?x ?y b))
        (true (control black)))
    (<= (legal black noop)
        (true (cell ?x ?y b))
        (true (control white)))
    (<= (goal white 100)
        (line x))
    (<= (goal white 50)
        (not (line x))
        (not (line o))
        (not open))
    (<= (goal white 0)
        (line o))
    (<= (goal black 100)
        (line o))
    (<= (goal black 50)
        (not (line x))
        (not (line o))
        (not open))
    (<= (goal black 0)
        (line x))
    (<= terminal
        (line x))
    (<= terminal
        (line o))
    (<= terminal
        (not open))
")
    (example.target          toetictac "    (role xplayer)
    (role oplayer)
    (init (blank a))
    (init (blank b))
    (init (blank c))
    (init (blank d))
    (init (blank e))
    (init (blank f))
    (init (blank g))
    (init (blank h))
    (init (blank i))
    (init (control xplayer))
    (<= (next (ecks ?m))
        (does xplayer (mark ?m))
        (true (blank ?m)))
    (<= (next (oh ?m))
        (does oplayer (mark ?m))
        (true (blank ?m)))
    (<= (next (ecks ?m))
        (true (ecks ?m)))
    (<= (next (oh ?m))
        (true (oh ?m)))
    (<= (next (blank ?m))
        (does ?w (mark ?n))
        (true (blank ?m))
        (distinct ?m ?n))
    (<= (next (control xplayer))
        (true (control oplayer)))
    (<= (next (control oplayer))
        (true (control xplayer)))
    (line a b c)
    (line a d g)
    (line d e f)
    (line b e h)
    (line g h i)
    (line c f i)
    (line a e i)
    (line c e g)
    (<= xline
        (line ?a ?b ?c)
        (true (ecks ?a))
        (true (ecks ?b))
        (true (ecks ?c)))
    (<= oline
        (line ?a ?b ?c)
        (true (oh ?a))
        (true (oh ?b))
        (true (oh ?c)))
    (<= open
        (true (blank ?m)))
    (<= (legal ?player (mark ?y))
        (true (blank ?y))
        (true (control ?player)))
    (<= (legal oplayer noop)
        (true (control xplayer)))
    (<= (legal xplayer noop)
        (true (control oplayer)))
    (<= (goal xplayer 100)
        xline)
    (<= (goal xplayer 50)
        (not xline)
        (not oline)
        (not open))
    (<= (goal xplayer 0)
        oline)
    (<= (goal oplayer 100)
        oline)
    (<= (goal oplayer 50)
        (not xline)
        (not oline)
        (not open))
    (<= (goal oplayer 0)
        xline)
    (<= terminal
        xline)
    (<= terminal
        oline)
    (<= terminal
        (not open))
")
    (example.dateentered     toetictac 3355255669)
    (example.datemodified    toetictac 3355255669)

    (example.instance        wumpusdisjunctive)
    (prettyname              wumpusdisjunctive "Disjunctive Wumpus World")
    (shortname               wumpusdisjunctive "wumpus.disj")
    (example.complete        wumpusdisjunctive incomplete)
    (example.technique       wumpusdisjunctive bilevel)
    (example.technique       wumpusdisjunctive consistency2deduction)
    (example.technique       wumpusdisjunctive naf)
    (example.technique       wumpusdisjunctive unnamed)
    (example.description     wumpusdisjunctive "In this snapshot version of wumpus world, at each step of the game, we write down what the percepts we have received mean.  For example, if we sense a stench then we write down that the wumpus is in one of the surrounding squares.  This incomplete theory is built on top of incomplete and, more to the point, disjunctive base tables.  The reformulation must then take into account that those base tables must be completed each time new info is added.  The way we complete the tables is to introduce new object constants into the language.  This example illustrates the problem of disjunctive base tables and a solution: the introduction of new object constants.")
    (matrixshow              wumpusdisjunctive true)
    (example.comments        wumpusdisjunctive "The only reason this example might be problematic for Otter/Vampire is that the query is a universal statement, and we have a DCA to worry about.

Add UNA/DCA to the source.")
    (example.sourcequery     wumpusdisjunctive "(forall (?x ?y) (=> (gold ?x) (wumpus ?y) (westof ?x ?y)))")
    (example.source          wumpusdisjunctive "  (or (gold a) (gold i) (gold b) (gold f) (gold j))
  (not (wumpus a))
  (not (wumpus i))
  (not (wumpus b))
  (not (wumpus f))
  (not (wumpus j))

  (or (wumpus g) (wumpus k) (wumpus o) (wumpus h) (wumpus p))
  (not (gold g))
  (not (gold k))
  (not (gold o))
  (not (gold h))
  (not (gold p))

(westof A B)
(westof A F)
(westof A J)
(westof A N)
(westof A C)
(westof A G)
(westof A K)
(westof A O)
(westof A D)
(westof A H)
(westof A L)
(westof A P)
(westof E B)
(westof E F)
(westof E J)
(westof E N)
(westof E C)
(westof E G)
(westof E K)
(westof E O)
(westof E D)
(westof E H)
(westof E L)
(westof E P)
(westof I B)
(westof I F)
(westof I J)
(westof I N)
(westof I C)
(westof I G)
(westof I K)
(westof I O)
(westof I D)
(westof I H)
(westof I L)
(westof I P)
(westof M B)
(westof M F)
(westof M J)
(westof M N)
(westof M C)
(westof M G)
(westof M K)
(westof M O)
(westof M D)
(westof M H)
(westof M L)
(westof M P)
(westof B C)
(westof B G)
(westof B K)
(westof B O)
(westof B D)
(westof B H)
(westof B L)
(westof B P)
(westof F C)
(westof F G)
(westof F K)
(westof F O)
(westof F D)
(westof F H)
(westof F L)
(westof F P)
(westof J C)
(westof J G)
(westof J K)
(westof J O)
(westof J D)
(westof J H)
(westof J L)
(westof J P)
(westof N C)
(westof N G)
(westof N K)
(westof N O)
(westof N D)
(westof N H)
(westof N L)
(westof N P)
(westof C D)
(westof C H)
(westof C L)
(westof C P)
(westof G D)
(westof G H)
(westof G L)
(westof G P)
(westof K D)
(westof K H)
(westof K L)
(westof K P)
(westof O D)
(westof O H)
(westof O L)
(westof O P)")
    (example.targetquery     wumpusdisjunctive "ent")
    (example.target          wumpusdisjunctive "  (<= ent
      (not notent))
  (<= notent
      (possgold ?x)
      (posswumpus ?y)
      (not (westof ?x ?y)))
      
  (<= (possgold ?x)
      (gold ?y)
      (part ?y ?x)
      (not (ngold ?x))
      (not (some-goldnotin ?x)))

  (<= (some-goldnotin ?x)
      (gold ?y)
      (not (part ?y ?x)))

  (<= (posswumpus ?x)
      (wumpus ?y)
      (part ?y ?x)
      (not (nwumpus ?x))
      (not (some-wumpusnotin ?x)))
  
  (<= (some-wumpusnotin ?x)
      (wumpus ?y)
      (not (part ?y ?x)))

  (gold aibfj)
  (ngold g)
  (ngold k)
  (ngold o)
  (ngold h)
  (ngold p)

  (wumpus gkohp)
  (nwumpus a)
  (nwumpus i)
  (nwumpus b)
  (nwumpus f)
  (nwumpus j)

  (part aibfj a)
  (part aibfj i)
  (part aibfj b)
  (part aibfj f)
  (part aibfj j)

  (part gkohp g)
  (part gkohp k)
  (part gkohp o)
  (part gkohp h)
  (part gkohp p)

(westof A B)
(westof A F)
(westof A J)
(westof A N)
(westof A C)
(westof A G)
(westof A K)
(westof A O)
(westof A D)
(westof A H)
(westof A L)
(westof A P)
(westof E B)
(westof E F)
(westof E J)
(westof E N)
(westof E C)
(westof E G)
(westof E K)
(westof E O)
(westof E D)
(westof E H)
(westof E L)
(westof E P)
(westof I B)
(westof I F)
(westof I J)
(westof I N)
(westof I C)
(westof I G)
(westof I K)
(westof I O)
(westof I D)
(westof I H)
(westof I L)
(westof I P)
(westof M B)
(westof M F)
(westof M J)
(westof M N)
(westof M C)
(westof M G)
(westof M K)
(westof M O)
(westof M D)
(westof M H)
(westof M L)
(westof M P)
(westof B C)
(westof B G)
(westof B K)
(westof B O)
(westof B D)
(westof B H)
(westof B L)
(westof B P)
(westof F C)
(westof F G)
(westof F K)
(westof F O)
(westof F D)
(westof F H)
(westof F L)
(westof F P)
(westof J C)
(westof J G)
(westof J K)
(westof J O)
(westof J D)
(westof J H)
(westof J L)
(westof J P)
(westof N C)
(westof N G)
(westof N K)
(westof N O)
(westof N D)
(westof N H)
(westof N L)
(westof N P)
(westof C D)
(westof C H)
(westof C L)
(westof C P)
(westof G D)
(westof G H)
(westof G L)
(westof G P)
(westof K D)
(westof K H)
(westof K L)
(westof K P)
(westof O D)
(westof O H)
(westof O L)
(westof O P)
")

    (example.instance        wumpuspercepts)
    (prettyname              wumpuspercepts "Wumpus World with Percepts")
    (shortname               wumpuspercepts "wumpus.per")
    (example.complete        wumpuspercepts incomplete)
    (example.technique       wumpuspercepts bilevel)
    (example.technique       wumpuspercepts consistency2deduction)
    (example.technique       wumpuspercepts naf)
    (example.technique       wumpuspercepts unnamed)
    (example.description     wumpuspercepts "A snapshot of wumpus world, after sensing a stench at one location and a shine at another.  Is the gold to the west of the wumpus in all cases?  Translate this problem stated in logic, where the data is the set of percepts, into a datalog program that checks the entailment by cases.  The tricky part here is that the percept tables (the ones that are supposed to be left out of the transformation) are incomplete; thus, we cannot import them directly into datalog. Because the tables are incomplete but not disjunctive, we create a complete table for stench, another complete table for notstench; likewise for shine.  The stench table includes all those cells where we observed a stench; the notstench table contains all those cells without a stench.  These can both be complete, and we know the environment maintains consistency. ")
    (matrixshow              wumpuspercepts true)
    (example.comments        wumpuspercepts "There is a version using functions to name cells.  Add UNA and DCA to the source.")
    (example.sourcequery     wumpuspercepts "     (forall (?x ?y) (=> (gold ?x) (wumpus ?y) (westof ?x ?y)))
")
    (example.source          wumpuspercepts "  ; complete tables
  (north a e)
  (north e i)
  (north i m)
  (north b f)
  (north f j)
  (north j n)
  (north c g)
  (north g k)
  (north k o)
  (north d h)
  (north h l)
  (north l p)

  (west a b)
  (west b c)
  (west c d)
  (west e f)
  (west f g)
  (west g h)
  (west i j)
  (west j k)
  (west k l)
  (west m n)
  (west n o)
  (west o p)
  
  (<=> (east ?x ?y) (west ?y ?x))
  (<=> (south ?x ?y) (north ?y ?x))

  ; more complete tables
  (westborder e)
  (westborder i)
  (northborder b)
  (northborder c)
  (eastborder h)
  (eastborder l)
  (southborder n)
  (southborder o)

  (nwcorner a)
  (necorner d)
  (swcorner m)
  (swcorner p)

  (notborder f)
  (notborder g)
  (notborder j)
  (notborder k)
  
  ; center
  (=> (stench ?cell)
      (notborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?celle)
          (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (notborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))
           (not (wumpus ?cellw))
           (not (wumpus ?cells))))

  ;;; borders

  ;west
  (=> (stench ?cell)
      (westborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (or (wumpus ?celln)
          (wumpus ?celle)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (westborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))
           (not (wumpus ?cells))))


  ; north
  (=> (stench ?cell)
      (northborder ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (or (wumpus ?celle)
          (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (northborder ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (and (not (wumpus ?celle))
           (not (wumpus ?cellw))
           (not (wumpus ?cells))))

      
  ; south
  (=> (stench ?cell)
      (southborder ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?celle)
          (wumpus ?cellw)))

  (=> (not (stench ?cell))
      (southborder ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))
           (not (wumpus ?cellw))))

  ; east
  (=> (stench ?cell)
      (eastborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (eastborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?cellw))
           (not (wumpus ?cells))))

  ;;; corners

  ; nw
  (=> (stench ?cell)
      (nwcorner ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (or (wumpus ?celle)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (nwcorner ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (and (not (wumpus ?celle))
           (not (wumpus ?cells))))

  ; ne
  (=> (stench ?cell)
      (necorner ?cell)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (or (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (necorner ?cell)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (and (not (wumpus ?cellw))
           (not (wumpus ?cells))))

  ; sw
  (=> (stench ?cell)
      (wwcorner ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (or (wumpus ?celln)
          (wumpus ?celle)))

  (=> (not (stench ?cell))
      (wwcorner ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))))

  ; se
  (=> (stench ?cell)
      (secorner ?cell)
      (north ?cell ?celln)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?cellw)))

  (=> (not (stench ?cell))
      (secorner ?cell)
      (north ?cell ?celln)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?cellw))))


  (exists ?x (wumpus ?x))
  (exists ?x (gold ?x))

  (shiney e)
  (not (stench e))
  (stench l)
  (not (shiney l))



; a complete table
(westof A B)
(westof A F)
(westof A J)
(westof A N)
(westof A C)
(westof A G)
(westof A K)
(westof A O)
(westof A D)
(westof A H)
(westof A L)
(westof A P)
(westof E B)
(westof E F)
(westof E J)
(westof E N)
(westof E C)
(westof E G)
(westof E K)
(westof E O)
(westof E D)
(westof E H)
(westof E L)
(westof E P)
(westof I B)
(westof I F)
(westof I J)
(westof I N)
(westof I C)
(westof I G)
(westof I K)
(westof I O)
(westof I D)
(westof I H)
(westof I L)
(westof I P)
(westof M B)
(westof M F)
(westof M J)
(westof M N)
(westof M C)
(westof M G)
(westof M K)
(westof M O)
(westof M D)
(westof M H)
(westof M L)
(westof M P)
(westof B C)
(westof B G)
(westof B K)
(westof B O)
(westof B D)
(westof B H)
(westof B L)
(westof B P)
(westof F C)
(westof F G)
(westof F K)
(westof F O)
(westof F D)
(westof F H)
(westof F L)
(westof F P)
(westof J C)
(westof J G)
(westof J K)
(westof J O)
(westof J D)
(westof J H)
(westof J L)
(westof J P)
(westof N C)
(westof N G)
(westof N K)
(westof N O)
(westof N D)
(westof N H)
(westof N L)
(westof N P)
(westof C D)
(westof C H)
(westof C L)
(westof C P)
(westof G D)
(westof G H)
(westof G L)
(westof G P)
(westof K D)
(westof K H)
(westof K L)
(westof K P)
(westof O D)
(westof O H)
(westof O L)
(westof O P)
")
    (example.targetquery     wumpuspercepts "ent")
    (example.target          wumpuspercepts "  (<= ent
      (not notent))
  (<= notent
      (possworld ?x ?y)
      (not (westof ?x ?y)))


  (<= (possworld ?x ?y)
      (possgold ?x)
      (posswumpus ?y))

  ; poss gold
  (<= (possgold ?x)
      (adjacentshiney ?x)
      (not (some-adjacentnonshiney ?x))
      (not (some-nonadjacentshiney ?x)))

  (<= (adjacentshiney ?x)
      (shiney ?s)
      (adjacent ?s ?x))

  (<= (some-nonadjacentshiney ?x)
      (shiney ?s)
      (not (adjacent ?s ?x)))

  (<= (some-adjacentnonshiney ?x)
      (adjacent ?x ?y)
      (nshiney ?y))

  ; poss wumpus
  (<= (posswumpus ?x)
      (adjacentstench ?x)
      (not (some-adjacentnonstench ?x))
      (not (some-nonadjacentstench ?x)))

  (<= (adjacentstench ?x)
      (stench ?s)
      (adjacent ?s ?x))

  (<= (some-nonadjacentstench ?x)
      (stench ?s)
      (not (adjacent ?s ?x)))

  (<= (some-adjacentnonstench ?x)
      (adjacent ?x ?y)
      (nstench ?y))
      
#|
 --- --- --- ---
| a | b | c | d |
 --- --- --- ---
| e | f | g | h |
 --- --- --- ---
| i | j | k | l |
 --- --- --- ---
| m | n | o | p |
 --- --- --- ---
Shine: e
Stench: l

|#

  (<= (adjacent ?x ?y)
      (or (north ?x ?y)
          (north ?y ?x)
          (west ?x ?y)
          (west ?y ?x)
          (and (west ?z ?x) (north ?y ?z))
          (and (west ?z ?x) (north ?z ?y))
          (and (west ?x ?z) (north ?y ?z))
          (and (west ?x ?z) (north ?z ?y))))

  (north a e)
  (north e i)
  (north i m)
  (north b f)
  (north f j)
  (north j n)
  (north c g)
  (north g k)
  (north k o)
  (north d h)
  (north h l)
  (north l p)

  (west a b)
  (west b c)
  (west c d)
  (west e f)
  (west f g)
  (west g h)
  (west i j)
  (west j k)
  (west k l)
  (west m n)
  (west n o)
  (west o p)
  
  (<= (east ?x ?y) (west ?y ?x))
  (<= (south ?x ?y) (north ?y ?x))


  (shiney e)
  (nstench e)
  (stench l)
  (nshiney l)

(westof A B)
(westof A F)
(westof A J)
(westof A N)
(westof A C)
(westof A G)
(westof A K)
(westof A O)
(westof A D)
(westof A H)
(westof A L)
(westof A P)
(westof E B)
(westof E F)
(westof E J)
(westof E N)
(westof E C)
(westof E G)
(westof E K)
(westof E O)
(westof E D)
(westof E H)
(westof E L)
(westof E P)
(westof I B)
(westof I F)
(westof I J)
(westof I N)
(westof I C)
(westof I G)
(westof I K)
(westof I O)
(westof I D)
(westof I H)
(westof I L)
(westof I P)
(westof M B)
(westof M F)
(westof M J)
(westof M N)
(westof M C)
(westof M G)
(westof M K)
(westof M O)
(westof M D)
(westof M H)
(westof M L)
(westof M P)
(westof B C)
(westof B G)
(westof B K)
(westof B O)
(westof B D)
(westof B H)
(westof B L)
(westof B P)
(westof F C)
(westof F G)
(westof F K)
(westof F O)
(westof F D)
(westof F H)
(westof F L)
(westof F P)
(westof J C)
(westof J G)
(westof J K)
(westof J O)
(westof J D)
(westof J H)
(westof J L)
(westof J P)
(westof N C)
(westof N G)
(westof N K)
(westof N O)
(westof N D)
(westof N H)
(westof N L)
(westof N P)
(westof C D)
(westof C H)
(westof C L)
(westof C P)
(westof G D)
(westof G H)
(westof G L)
(westof G P)
(westof K D)
(westof K H)
(westof K L)
(westof K P)
(westof O D)
(westof O H)
(westof O L)
(westof O P)")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
