;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; What about an iterative deepening version?;;; added another termination test in epilogancestor;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(defun process-epilog-answers (s postlines)  (let (variables premises conclusion        *termination* *inferences* *ancestry* *contrapositives* *depth*)    (setq variables (read-sentences (cdr (pop postlines))))    (setq premises (read-sentences (cdr (pop postlines))))    (setq conclusion (or (read-user-string (cdr (pop postlines))) 'false))    (setq *ancestry* (if (read-value-string (getf-post "Ancestry" postlines)) t))    (setq *contrapositives* (if (read-value-string (getf-post "Contrapositives" postlines)) t))    (setq *depth* (or (read-value-string (getf-post "Depth" postlines)) 5))    (output-prolog s 200)    (format s "<HTML>")    (format s "<BODY BGCOLOR=WHITE>")    (format s "<HR><CENTER><H1>Result</H1></CENTER><HR><BR>")    (if (epilogtop variables premises conclusion *theory*)        (format s "<P>Success after ~A step(s).</P>" *inferences*)        (format s "<P>Failure after ~A step(s).</P>" *inferences*))    (format s "<BR><HR>")    (format s "<ADDRESS>Comments to <A HREF=\"mailto:genesereth@cs.stanford.edu\">Michael R. Genesereth</A>.</ADDRESS>")    (format s "</BODY>")    (format s "</HTML>")))(defparameter *tautologies* 0)(defun epilogtop (*thing* premises conclusion th)  (let (*answers* *theory*)    (setq *theory* (make-instance 'theory))    (includes *theory* th)    (when *contrapositives*      (setq premises (nconc premises (list (maknot conclusion))))      (setq premises (contrapositives (maksand premises))))    (dolist (x premises) (save x *theory*))    (ignore-errors       (cond ((atom conclusion) (epilogstart conclusion *theory*))            ((eq (car conclusion) 'or) (epilogor conclusion *theory*))            (t (epilogstart conclusion *theory*))))    (empty *theory*)    (decludes *theory*)    (nreverse *answers*)))(defun epilogor (p th)  (do ((l (cdr p) (cdr l)))      ((null l) nil)      (when (and (epilogstart (car l) th) (not *termination*)) (return t))))(defun epilogstart (p *theory*)  (let ((alist (environment)))    (setq *unifications* 0)    (setq *termination* nil)    (setq *tautologies* 0)    (setq *inferences* (length (contents *theory*)))    (cond ((atom p) (epilogfind p (list p) alist 0 nil))          ((eq (car p) 'and) (epilogexit p alist 0 nil))          (t (epilogfind p (list p) alist 0 nil)))))(defun epilogfind (p pl al depth cont)  (setq *inferences* (1+ *inferences*))  (cond ((>= *inferences* *limit*) (setq *termination* t) nil)        ((> depth *depth*) nil)        ((and *ancestry* (epilogancestor p al cont)) nil)        ((epilogreduce p pl al depth cont))        (*termination* nil)        (t (epilogfindth p pl al depth cont))))(defun epilogancestor (p al cont)  (do ((l cont (cdr l)) (np (maknot p)) (flag))      ((null l) nil)      (if (identify (caaar l) (cadar l) p al) (return t))      (do ((m (cdaar l) (cdr l)))          ((null m))          (when (identify (car m) (cadar l) np al)            (setq *tautologies* (1+ *tautologies*) flag t)            (return t))          (if flag (return t)))))(defun epilogreduce (p pl al depth cont)  (do ((l cont (cdr l)) (ol))      ((null l))      (when (setq ol (unify (maknot (caaar l)) (cadar l) p al))        (cond ((epilogexit pl al depth cont)               (backup ol)               (return t))              (*termination* (backup ol) (return nil))              (t (backup ol))))))(defun epilogfindth (p pl al depth cont)  (do ((l (envindexps p al *theory*) (cdr l)) (bl (environment)) (ol)       (new (cons (list pl al depth) cont)))      ((null l))      (cond ((setq ol (unify (car l) bl p al))             (cond ((epilogexit pl al depth cont)                    (backup ol)                    (return t))                   (*termination* (backup ol) (return nil))                   (t (backup ol))))            ((and (listp (car l)) (eq '<= (caar l))                  (setq ol (unify (cadar l) bl p al)))             (cond ((epilogexit (cdar l) bl (1+ depth) new)                    (backup ol)                    (return t))                   (*termination* (backup ol) (return nil))                   (t (backup ol)))))))(defun epilogexit (pl al depth cont)  (cond ((cdr pl) (epilogfind (cadr pl) (cdr pl) al depth cont))        ((null cont)         (setq *inferences* (1+ *inferences*))         (setq *answers* (adjoin (plugstdexp *thing* alist) *answers*))         nil)        (t (epilogexit (caar cont) (cadar cont) (caddar cont) (cdr cont)))));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;