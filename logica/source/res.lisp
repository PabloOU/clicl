;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Logica;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(defparameter *stream* t)(defparameter *subsumption* nil)(defparameter *tautology* nil)(defparameter *unit* nil)(defparameter *input* nil)(defparameter *support* nil)(defparameter *ordered* nil)(defclass conclusion ()  ((sequence :accessor sequence :initarg :sequence :initform 1)   (sentence :accessor sentence :initarg :sentence :initform 'false)   (positive :accessor positive :initarg :positive :initform nil)   (negative :accessor negative :initarg :negative :initform nil)))(defun makeconclusion (s p n)  (make-instance 'conclusion :sentence s :positive p :negative n))(defun makclauses (p)  (mapcar #'(lambda (x) (cons 'or x)) (clausesets p)))#|(defun output-proof (s proof)  (format-proof s (convertproof proof)))(defun convertproof (proof)  (do ((l proof (cdr l)) (step 1 (1+ step)) (dum) (nl))      ((null l) (nreverse nl))      (setf (sequence (car l)) step)      (cond ((symbolp (positive (car l)))             (setq dum (list step (sentence (car l)) (positive (car l)))))            (t (setq dum (list step (sentence (car l))                               (sequence (positive (car l)))                               (sequence (negative (car l)))))))      (setq nl (cons dum nl))))(defun pruneproof (proof)  (markproof (car (last proof)))  (do ((l proof (cdr l)) (nl))      ((null l) (nreverse nl))      (when (equal (sequence (car l)) 0) (setq nl (cons (car l) nl)))))(defun markproof (node)  (cond ((equal (sequence node) 0))        (t (setf (sequence node) 0)           (when (typep (positive node) 'conclusion)             (markproof (positive node))             (markproof (negative node))))))|#(defun logica (premises conclusions end)  (do ((l premises (cdr l)) (nl))      ((null l) (setq premises (nreverse nl)))      (setq nl (cons (makeconclusion (car l) 'premise nil) nl)))  (do ((l conclusions (cdr l)) (nl))      ((null l) (setq conclusions (nreverse nl)))      (setq nl (cons (makeconclusion (car l) 'goal nil) nl)))  (cond (*input* (runinput premises conclusions end))        (t (runregular premises conclusions end))))(defun runinput (premises conclusions end)  (setq premises (nconc premises conclusions))  (unless *support* (setq conclusions premises))  (do ((l premises (cdr l)) (copy (copy-list premises))       (flag) (step (length premises)))      ((null l) premises)      (when (or flag (>= step end)) (return premises))      (do ((m copy (cdr m)))          ((null m))          (when (or flag (>= step end)) (return t))          (dolist (result (newresolve (car l) (car m)))            (unless (find (sentence result) premises :key #'sentence :test #'similarp)              (setq premises (nconc premises (list result)))              (setq step (1+ step)))            (cond ((equal (sentence result) '(or)) (setq flag t) (return t))                  ((>= step end) (return t)))))))(defun runregular (premises conclusions end)  (setq premises (nconc premises conclusions))  (unless *support* (setq conclusions premises))  (do ((l conclusions (cdr l)) (flag) (step (length premises)))      ((null l) premises)      (when (or flag (>= step end)) (return premises))      (do ((m premises (cdr m)))          ((eq m (cdr l)))          (when (or flag (>= step end)) (return t))          (dolist (result (newresolve (car l) (car m)))            (unless (find (sentence result) premises :key #'sentence :test #'similarp)              (setq premises (nconc premises (list result)))              (setq step (1+ step)))            (cond ((equal (sentence result) '(or)) (setq flag t) (return t))                  ((>= step end) (return t)))))))(defun newresolve (p q)  (let (results)    (cond ((and *unit* (not (or (unitp (sentence p)) (unitp (sentence q)))))           (setq results nil))          (*ordered* (setq results (newordered (sentence p) (sentence q))))          (t (setq results (newresolution (sentence p) (sentence q)))))    (do ((l results (cdr l)) (nl))        ((null l) (nreverse nl))        (setq nl (cons (makeconclusion (car l) q p) nl)))))(defun newresolution (p q)  (do ((l (cdr p) (cdr l)) (al (environment)) (bl (environment)) (result) (nl))      ((null l) (nreverse nl))      (do ((m (cdr q) (cdr m)))          ((null m))          (when (unify (maknot (car m)) bl (car l) al)            (setq result (newresolvent (remove (car m) (cdr q) :test #'eq) bl                                       (remove (car l) (cdr p) :test #'eq) al))            (setf (alist al) nil)            (setf (alist bl) nil)            (cond ((and *tautology* (tautologyp result)))                  (t (setq nl (adjoin result nl :test #'equal))))))))(defun newresolvent (x alist y bl)  (setq x (newplugstdexp x alist) y (newplugstdexp y bl))  (cons 'or (unionize x y)))(defun newordered (p q)  (let ((al (environment)) (bl (environment)) result)    (cond ((null (cdr p)) nil)          ((null (cdr q)) nil)          ((unify (maknot (cadr q)) bl (cadr p) al)           (setq result (newresolvent (remove (cadr q) (cdr q) :test #'eq) bl                                      (remove (cadr p) (cdr p) :test #'eq) al))           (setf (alist al) nil)           (setf (alist bl) nil)           (cond ((and *tautology* (tautologyp result)) nil)                 (t (list result)))))))(defun enderton (p q)  (do ((l (cdr p) (cdr l)) (result) (nl))      ((null l) (nreverse nl))      (do ((m (cdr q) (cdr m)))          ((null m))          (when (equal (car l) (maknot (car m)))            (setq result (maksor (unionize (remove (car l) (cdr p) :test #'eq)                                           (remove (car m) (cdr q) :test #'eq))))            (cond ((and *tautology* (tautologyp result)))                  (t (setq nl (adjoin result nl :test #'equal))))))))(defun newplugstdexp (x al)  (cond ((indvarp x) (newplugstdexpindvar x al))	((atom x) x)	((eq 'quote (car x)) x)	(t (newplugstdexpcdr x al))))(defun newplugstdexpcdr (x al)  (do ((l x (cdr l)) (nl))      ((null l) (nreverse nl))      (if (seqvarp (car l))          (return (nreconc nl (newplugstdexpseqvar (car l) al)))          (setq nl (cons (newplugstdexp (car l) al) nl)))))(defun newplugstdexpindvar (x al)  (let (dum)    (cond ((eq '?* x) '?*)          ((setq dum (getbdg x al))           (cond ((cddr dum) (newplugstdexp (cadr dum) (cddr dum)))                 ((eq alist al) x)                 ((cdr dum) (cadr dum))                 (t (setoldbdg dum (gentemp "?") alist))))          ((eq alist al) x)	  (t (setnewbdg x al (gentemp "?") alist)))))(defun newplugstdexpseqvar (x al)  (let (dum)    (cond ((eq '@* x) (list x))          ((setq dum (getbdg x al))           (cond ((cddr dum) (newplugstdexpcdr (cadr dum) (cddr dum)))                 ((eq alist al) (list x))                 ((cdr dum) (cadr dum))                 (t (setoldbdg dum (list (gentemp "@")) nil))))          ((eq alist al) (list x))          (t (setnewbdg x al (list (gentemp "@")) nil)))))(defun runit (premises step end)  (do ((l premises (cdr l)) (i 1 (1+ i)))      ((or (null l) (>= step end)))      (do ((m premises (cdr m)) (j 1 (1+ j)))          ((or (eq m (cdr l)) (>= step end)))          (dolist (result (resolve (car l) (car m)))            (cond ((>= step end))                  ((find result premises :test #'equalp))                  (t (setq premises (nconc premises (list result)))                     (format-step *stream* (incf step) result (format nil "~A, ~A" j i))))))))(defun format-step (s num step just)  (let ((*print-case* :downcase))    (format s "<TR><TH HALIGN=RIGHT>~A.</TH>" num)    (format s "<TD><TT>~A</TT></TD>" step)    (format s "<TD>~A</TD></TR>" just)))(defun resolve (p q)  (unless (and (listp p) (eq 'or (car p))) (setq p (list 'or p)))  (unless (and (listp q) (eq 'or (car q))) (setq q (list 'or q)))  (cond ((and *unit* (not (or (unitp p) (unitp q)))) nil)        (*ordered* (ordered p q))        (t (resolution p q))))(defun resolution (p q)  (setq q (stdize q))  (do ((l (cdr p) (cdr l)) (al) (result) (nl))      ((null l) (nreverse nl))      (do ((m (cdr q) (cdr m)))          ((null m))          (when (setq al (mgu (car l) (maknot (car m))))            (setq result (maksor (unionize (remove (car l) (cdr p) :test #'equal)                                           (remove (car m) (cdr q) :test #'equal))))            (setq result (decolonize (plug result al)))            (cond ((and *tautology* (tautologyp result)))                  (t (setq nl (adjoin result nl :test #'equalp))))))))(defun ordered (p q)  (let (al result)    (unless (and (listp p) (eq 'or (car p))) (setq p (list 'or p)))    (unless (and (listp q) (eq 'or (car q))) (setq q (list 'or q)))    (setq q (stdize q))    (cond ((null (cdr p)) nil)          ((null (cdr q)) nil)          ((setq al (mgu (cadr p) (maknot (cadr q))))           (setq result (maksor (unionize (cddr p) (cddr q))))           (setq result (decolonize (plug result al)))           (cond ((and *tautology* (tautologyp result)) nil)                 (t (list result)))))))(defun tautologyp (x)  (cond ((atom x) nil)        ((eq 'not (car x)) nil)        ((eq 'or (car x))         (do ((l (cdr x) (cdr l)))             ((null l) nil)             (when (find (maknot (car l)) (cdr l) :test #'equalp)               (return t))))))(defun unitp (x)  (cond ((atom x))        ((eq 'not (car x)))        ((eq 'or (car x)) (null (cddr x)))));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Miscellaneous;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(defun similarp (x y)  (cond (*subsumption* (subsumptionp y x))        (t (samep x y))))(defun samesetp (x y)  (and (samesubsetp (cdr x) (cdr y) truth) (samesubsetp (cdr y) (cdr x) truth)))(defun samesubsetp (x y al)  (cond ((null x) al)        (t (do ((m y (cdr m)) (bl))               ((null m) nil)               (when (and (setq bl (samepexp (car x) (car m) al))                          (samesubsetp (cdr x) y bl))                 (return bl))))))(defun subsumptionp (p q)  (subsumptionps (cdr p) (cdr q) truth))(defun subsumptionps (pl ql al)  (cond ((null pl) al)        (t (do ((m ql (cdr m)) (bl))               ((null m))               (if (and (setq bl (matchpexp (car pl) (car m) al))                        (setq bl (subsumptionps (cdr pl) ql bl)))                   (return bl))))))