(defun r ()  (tcp-shutdown)  (load "gullible:grading:grader")  (tcp-servers #'http-handler 4000 10));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Begin grading code;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; process the http request(defmethod process (s (file (eql 'grade)) postlines)  (format s "HTTP/1.0 200 OK") (crlf s)  ; make sure there are 2 blank lines after the Content-type.  otherwise you bonk.  (format s "Content-type: text/html") (crlf s) (crlf s)  (format s "<http><head><body bgcolor=white><center><h2>Homework Results</h2></center>") (crlf s)  ;(crlf s)  ;(format s "~A" postlines)  ;(crlf s)  ;(format s "<BR><BR>")  ; print out the student answers  (dolist (l (listify postlines))    (format s "~A <BR>" l)    (crlf s) )  (format s "<BR><BR>")  (format s "~A" (grade (listify postlines)))  (format s "<center><table border=2 cellspacing=4 cellpadding=4>")  (format s "<tr><th>Problem</th><th>Score</th><th>Student Answers</th><th>Solution data</th></tr>")  (let ((graded_results (reverse (grade (listify postlines)))))    (dolist (sc graded_results)      (format s "<tr><td>~A</td></tr>" sc)      (format s "<tr><td>~A</TD><td><B>~A</B></td><td>~A</td><td>~A</td></tr>" (car sc) (cadr sc) (caddr sc) (cddddr (cadddr sc)))      (crlf s) ))  (format s "</table></center><BR><BR>")  ;(format s "Notes:")  ;(format s "<uL><LI>Don't try to stick a comma in a text box. It'll croak.</uL>")   (finish-output s)   'done)  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; TODO: LogProof scoring; TODO: front end to solution file;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Grading functions;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; hash the student solutions.; list the true solutions.; score the student solutions.; return the score.(defun grade (postlines)  (let ((hash_student (parse-student postlines (make-hash-table)) )        (list_correct (parse-solutions (parse-raw-solutions (car (getf-post "solnfile" postlines))) nil)) )    (format t "~A" list_correct)    (get-scores hash_student list_correct nil) )); return a list of (prob# score studentAns correctAns)(defun get-scores (hash_student list_correct list_score)  (if (null list_correct)     list_score    (get-scores hash_student                 (cdr list_correct)                (cons (list (get-soln-name (car list_correct))                            (score (find-student-soln (car list_correct)                                                      hash_student)                                    (car list_correct))                            (gethash (get-soln-name (car list_correct)) hash_student)                            (car list_correct) )                      list_score) ))) ; score the student solution versus the actual solution; TODO: add tlhLogEquiv, tlhLogProof(defun score (student solution)  (cond   ; for each solution they get correct, give them x points.  For each solution they get wrong, sutract y points.   ((eql (get-soln-type solution) 'atExact)    (let ((symbol_student (symbolify student)))      (let ((i (intersection symbol_student (get-soln-ans solution))))        (- (* (length i) (get-soln-pos-points solution))            (* (if (> (length symbol_student) (length (get-soln-ans solution)))                (- (length symbol_student) (length i))                (- (length (get-soln-ans solution)) (length i)) )              (get-soln-neg-points solution)) ))))   ; if the solution they give is logically equivalent to the actual solution, full credit.  Else negative points.   ((eql (get-soln-type solution) 'atLogEquiv)     (if (grade-logical-equivalence (read-sentences (car student)) (get-soln-ans solution))      (get-soln-pos-points solution)      (* -1 (get-soln-neg-points solution)) ))   ; if the proof they supply is a correct proof of the concl from the premises, they get full credit.  Else negative points.   ((eql (get-soln-type solution) 'atLogProof)     (if (grade-proof student solution)      (get-soln-pos-points solution)      (* -1 (get-soln-neg-points solution)) ))      ; can't grade text   ((eql (get-soln-type solution) 'atText)     '0)   ; can't grade unknown   (t '-99) )); Score the logical equivalence and logical proof problems(defun grade-logical-equivalence (student solution)  ; special case no answer: can get =>soln and soln=>  (if (eq (length student) 0)    nil    (fullprovep (list '<=> (cons 'and student) (remove-nesting solution)) 'nothing) ));;;;;;;;;;;;;;; check proof; todo: parse proof out of user inputs(defun grade-proof (student solution)  ; ensure premises match the solution  (if (null (check-premises student (car (get-soln-ans solution))))    (get-soln-neg-points solution)  ; ensure conclusion matches the solution    (if (null (check-conclusion student (cadr (get-soln-ans solution))))      (get-soln-neg-points solution)      ; check the proof      (checkproof student) ))); check that the only premises used by the student are the ones given(defun check-premises (student premises)  (let ((stud_premises (get-premises student)))    (dolist (p stud_premises t)      (if (not (premise-member (cadr p) premises))        (return nil) ))))  ; find all the premises in a proof--left is 'premise'(defun get-premises (proof)  (let ((results nil))    (dolist (l proof results)        (let ((left (caddr l)) (right (cadddr l)))          (if (or (eq left 'premise) (eq right 'premise))            (setq results (cons l results)) ))))); determine if p is a member of prem_list (might expand to say logically equivalent)(defun premise-member (p prem_list)  (dolist (l prem_list nil)    (if (equal l p)      (return t) )))            ; check that the desired conclusion is somewhere in the proof(defun check-conclusion (student conclusion)  (dolist (l student nil)    (if (equal (cadr l) conclusion)      (return t) )));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Student parsing functions ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; parse-student parses the listified http request--it expects (name value) for the parameters.; expects a hash table as a parameter; returns a hash-table(defun parse-student (postlines hash)  (dolist (ans_pair postlines hash)    ; add to the current set of answers for this problem    ;(setf (gethash (car ans_pair) hash) (cons (read-solution (cadr ans_pair) nil) (gethash (car ans_pair) hash))) ))    (setf (gethash (car ans_pair) hash) (cons (cadr ans_pair) (gethash (car ans_pair) hash))) ));***** when I do (car (read-solution...)), I remove the first item if the student says "7 6".;      without the car, I get ((10)) which is not right(defun find-student-soln (solution hash_student)  (if (eql (get-soln-type solution) 'atLogProof)    ; build up the names for the html pieces of the proof    (let ((infer (read-from-string (concatenate 'string (string (get-soln-name solution)) "infer")))          (left (read-from-string (concatenate 'string (string (get-soln-name solution)) "left")))          (right (read-from-string (concatenate 'string (string (get-soln-name solution)) "right"))))            (format t "left: ~A, right: ~A, infer: ~A......" left right infer)      ; find the student answers corresponding to those names and reverse the lists      (let ((leftlist (gethash left hash_student))            (rightlist (gethash right hash_student))            (inferlist (gethash infer hash_student)))        (format t "left: ~A, right: ~A, infer: ~A......" leftlist inferlist rightlist)                ; join the 3 lists in the proper format: ((1 infer1 left1 right1) (2 infer2 left2 right2)...)        (let ((result nil))          (do ((i 1 (+ i 1))               (ll leftlist (cdr ll))               (rl rightlist (cdr rl))               (il inferlist (cdr il)))              (nil)            (if (null il) (return (reverse result)))            (setq result (cons (list i                                      (car (read-sentences (car il)))                                      (read-from-string (car ll))                                     (read-from-string (car rl)))                                result)) ))))                      (gethash (get-soln-name solution) hash_student) ));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Solution parsing functions ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; parse the actual solutions into the proper format for log. equiv, exact matching, etc.(defun parse-solutions (input result)  (if (null input)    result    (parse-solutions (cdr input)                      (cons (append (get-soln-non-ans (car input))                                    (reverse (read-solution (get-soln-ans (car input)) nil)))                           result) )));    (cons (append (get-soln-non-ans (car input)) (car (read-solution (get-soln-ans (car input)) nil)) );          (parse-solutions (cdr input) result) ))); execute read-sentences on the actual solution part of the solution and;   return result only if not nil.  otherwise, return the original answer(defun read-solution (ans result)  (if (null ans)    result        ; if answer is not nil    (if (listp ans)      ; if answer is a list, figure out first part and recurse      (let ((b (read-sentences (car ans))))        (if (eql (length b) 1) (setq b (car b)))        (if b           (read-solution (cdr ans) (cons b result))          (read-solution (cdr ans) (cons (car ans) result)) ))      ; if answer is not a list just figure it out      (let ((b (read-sentences ans)))           (if b          b          ans )))))    ; Parse set of answers into own list; TODO: Split answers based on delimiter, not on whitespace;(defun parse-solutions (input result);  (if (not (null input));    (let ((prob (first input)));      (let ( (p (first prob)) (type (second prob)) (delim (third prob)) );        (if (not (null delim));          (parse-solutions (rest input) (cons (list p type delim (cdddr prob)) result) );          (parse-solutions (rest input) (cons (list p type) result)) )));    result)); Wrapper around parse-list(defun parse-raw-solutions (filename)  (parse-list (read-file filename) '---------- nil))(defun read-file (filename)  (with-open-file (ifile filename :direction :input)     (do ((result nil (cons next result))         (next (read ifile nil 'eof)  (read ifile nil 'eof)))        ((equal next 'eof) (reverse result)) )));  '(---------- ;    prob1 atExact 4 "Yes" "No" ---------- ;    prob2 atExact 1 "10" ----------;    prob3 atLogEquiv 2 "(and p q)" ---------- ;    prob5 atText 7) )); prob4 atLogProof 3 "stuff" ----------;'((prob1 "Yes") (prob3 "(not (or (not p) (not q)))") (prob4 "shouldnotbechecked2") (prob5 "0text"));  (with-open-file (infile "psSoln" :direction :input);    (do ((result nil (cons next result));               (next (read infile nil 'eof) (read infile nil 'eof)));              ((equal next 'eof) (reverse result)))); Fields of the solution;;;;;;;;;;;;;;;;;;;;;;;;; return the name of the solution--always the 1st field(defun get-soln-name (solution)  (car solution) ); return the type of the solution--always the 2nd field(defun get-soln-type (solution)  (cadr solution) ); return the points for a correct answer(defun get-soln-pos-points (solution)  (caddr solution) ); return the points for an incorrect answer(defun get-soln-neg-points (solution)  (cadddr solution) ); return the answer as a list(defun get-soln-ans (solution)  (if (eql (get-soln-type solution) 'atText)    nil    (cddddr solution) ));  (case (get-soln-type solution);    ('atExact (cddddr solution));    ('atText nil);    ('atLogEquiv (cdddr solution));    ('atLogProof (cdddr solution));    (otherwise nil) )); return all but the answer of the list(defun get-soln-non-ans (solution)  (list (first solution) (second solution) (third solution) (fourth solution) ))    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Utility functions ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; hash-list takes a list of lists of the form;   (key value1 value2 ... valuen);   and returns a hash table of (value1 value2 ... valuen) keyed on key; input is the list of lists(defun hash-list (input hash)  (dolist (x input hash)    (setf (gethash (car x) hash) (cdr x)) ) ); Parses input which is in the following format:; (delimiter data )* (delimit)?  (the last delimit does not need to be there); Puts each set of data into its own list and returns it, ;  e.g. ---------- 1 2 3 ---------- 4 5 6 ---------- returns ((1 2 3) (4 5 6)); result should be passed nil--used to eliminate tail recursion; delimit should be passed the delimiter, in the example ----------(defun parse-list (input delimit result)  (if (not (null input))        ; input contains stuff    (let ((a (cdr (member delimit input))))      (if (null a)        ; input only contained delimit        result                     ; input contains actual stuff        (let ((b (member delimit a)))            (if (null b)               ; stuff does not end in delimit            (cons a result)            ; stuff ends in delimit            (parse-list b delimit (cons (subseq a 0 (- (length a) (length b))) result)) ))))    ; input contained nothing    result )); remove-nesting takes a list like ((((((a q)))))) and returns (a)(defun remove-nesting (l)  (if (listp l)    (if (and (= (length l) 1) (listp (car l)))      (remove-nesting (car l))      l )    l )); listify takes a list of ("x" . y) and returns a list of (x y)(defun listify (l)  (listify-rec l nil))(defun listify-rec (l res)  (if (null l)    res    (listify-rec (cdr l) (cons (list (read-from-string (caar l)) (cdar l) ) res)) )); take a list of strings and convert into symbols(defun symbolify (l)  (symbolify-rec l nil))(defun symbolify-rec (l result)  (if (null l)    result    (symbolify-rec (cdr l)                   (cons (read-from-string (car l)) result) )));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; End grading code;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;