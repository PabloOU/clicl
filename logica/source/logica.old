;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; (c) Copyright 1991-1993 Michael R. Genesereth;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Needed improvements (* most urgency, + much, o some, - little, = least):;;; * model elimination, reduction;;; * pure literal elimination;;; * set of support, linear;;; + visible indication of workspace;;; o setup for proof procedure;;; = fix resolution to work on clauses;;; = user-defined rules of inference;;; = better selection windows (indicating current selections);;; = assumptions; discharging, etc.;;; o suggestions: calculator keypad for unusual symbols;;; = terms as trees;;; o backward subsumption;;; o full subsumes in place of current unit subsumption;;; o unit conflict;;; o multiple goal literals in context of other literals subsumption;;; o literal ordering e.g. chat;;; o lock resolution;;; + graph data structure;;; o equality handling somehow (flattening or substitution axioms).;;;;;; * remaining search strategies;;; = user-defined search strategies;;;;;; - three valued truth table;;; = finite models;;;;;; - term stuff;;; = 2d formula manipulation;;;;;; o get number of beeps consistent;;; o pretty syntax for sentences;;; - line numbers and justifications;;; = graphics;;; = additional selectors to generate theories;;;;;; - error handling;;; - documentation;;; - lesson materials;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(defparameter *one* nil)(defparameter *two* nil);;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; System menu;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(defparameter *logica-menu*  (make-instance 'menu    :menu-title "File"    :menu-items (list (make-instance 'menu-item                        :menu-item-title "New database"                        :menu-item-action 'new-file)                      (make-instance 'menu-item                        :menu-item-title "Open database..."                        :menu-item-action 'open-file)                      (make-instance 'menu-item                        :menu-item-title "Save database"                        :menu-item-action 'save-file                        :command-key #\S)                      (make-instance 'menu-item                        :menu-item-title "Save database as..."                        :menu-item-action 'save-file-as)                      (make-instance 'menu-item                        :menu-item-title "Revert database"                        :menu-item-action 'revert-file)                      (make-instance 'menu-item                        :menu-item-title "Print database"                        :menu-item-action 'print-file)                      (make-instance 'menu-item                        :menu-item-title "-")                      (make-instance 'menu-item                        :menu-item-title "Quit"                        :menu-item-action 'quit                        :command-key #\Q))))(defun new-file ()  (make-instance 'logica-window    :view-position #@(10 50)    :view-size #@(400 340)))(defun open-file ()  (let ((file (choose-file-dialog)) (window))    (setq window (make-instance 'logica-window                   :window-title (namestring file)                   :view-position #@(20 50)                   :view-size #@(400 200)                   :window-show nil))    (buffer-insert-file (fred-buffer window) file)    (window-show window)))(defun save-file ()  (window-save (front-window)))(defun save-file-as ()  (window-save-as (front-window)))(defun revert-file ()  (window-revert (front-window)))(defun print-file ()  (window-hardcopy (front-window)));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Schema menu;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(defparameter *schema-menu*  (make-instance 'menu    :menu-title "Schema"    :menu-items (list (make-instance 'menu-item                        :menu-item-title "(=> p (=> q p))"                        :menu-item-action 'call-ii)                      (make-instance 'menu-item                        :menu-item-title "(=> (=> p (=> q r)) (=> (=> p q) (=> p r)))"                        :menu-item-action 'call-id)                      (make-instance 'menu-item                        :menu-item-title "(=> (=> p q) (=> (=> p (not q)) (not p)))"                        :menu-item-action 'call-in))))(defparameter *schemata* '(ii id in))(defun call-ii ()  (stash '(=> p (=> q p)) (front-window)))(defun call-id ()  (stash '(=> (=> p (=> q r)) (=> (=> p q) (=> p r))) (front-window)))(defun call-in ()  (stash '(=> (=> p q) (=> (=> p (not q)) (not p))) (front-window)));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Transform menu;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(defparameter *transform-menu*  (make-instance 'menu    :menu-title "Transform"    :menu-items (list (make-instance 'menu-item                        :menu-item-title "Boolean Form"                        :menu-item-action 'call-boolean-form)                      (make-instance 'menu-item                        :menu-item-title "Conjunctive Form"                        :menu-item-action 'call-conjunctive-form)                      (make-instance 'menu-item                        :menu-item-title "Disjunctive Form"                        :menu-item-action 'call-disjunctive-form)                      (make-instance 'menu-item                        :menu-item-title "Forward Form"                        :menu-item-action 'call-forward-form)                      (make-instance 'menu-item                        :menu-item-title "Backward Form"                        :menu-item-action 'call-backward-form)                      (make-instance 'menu-item                        :menu-item-title "Skolem Form"                        :menu-item-action 'call-skolem-form)                      (make-instance 'menu-item                        :menu-item-title "Rectification"                        :menu-item-action 'call-rectification)                      (make-instance 'menu-item                        :menu-item-title "Double Negation"                        :menu-item-action 'call-double-negation                        :command-key #\N)                      (make-instance 'menu-item                        :menu-item-title "And elimination"                        :menu-item-action 'call-and-elimination                        :command-key #\M)                      (make-instance 'menu-item                        :menu-item-title "Contrapositive"                        :menu-item-action 'call-contrapositive)                      (make-instance 'menu-item                        :menu-item-title "Universal instantiation"                        :menu-item-action 'call-universal-instantiation                        :command-key #\U)                      (make-instance 'menu-item                        :menu-item-title "Existential instantiation"                        :menu-item-action 'call-existential-instantiation                        :command-key #\E)                      (make-instance 'menu-item                        :menu-item-title "Factor"                        :menu-item-action 'call-factor))))(defparameter *transforms*  '(booleanize cnf dnf brf frf skolemize rectify    double-negation and-elimination contrapositive    universal-instantiation existential-instantiation factor))(defun call-boolean-form ()  (do ((l *one* (cdr l)) (window (front-window)))      ((null l))      (stash (booleanize (car l)) window)))(defun call-conjunctive-form ()  (do ((l *one* (cdr l)) (window (front-window)))      ((null l))      (stash (cnf (car l)) window)))(defun call-disjunctive-form ()  (do ((l *one* (cdr l)) (window (front-window)))      ((null l))      (stash (dnf (car l)) window)))(defun call-backward-form ()  (do ((l *one* (cdr l)) (window (front-window)))      ((null l))      (stash (brf (car l)) window)))(defun call-forward-form ()  (do ((l *one* (cdr l)) (window (front-window)))      ((null l))      (stash (frf (car l)) window)))(defun call-skolem-form ()  (do ((l *one* (cdr l)) (window (front-window)))      ((null l))      (stash (skolemize (car l)) window)))(defun call-rectification ()  (do ((l *one* (cdr l)) (window (front-window)))      ((null l))      (stash (rectify (car l)) window)))(defun call-clausal-form ()  (do ((l *one* (cdr l)) (window (front-window)) (ans) (success))      ((null l) (if (not success) (ed-beep)))      (when (setq ans (clauses (car l)))            (setq success t)            (mapc #'(lambda (p) (stash p window)) ans))))(defun call-double-negation ()  (do ((l *one* (cdr l)) (window (front-window)) (ans) (success))      ((null l) (if (not success) (ed-beep)))      (when (setq ans (double-negation (car l)))            (setq success t)            (mapc #'(lambda (p) (stash p window)) ans))))(defun call-and-elimination ()  (do ((l *one* (cdr l)) (window (front-window)) (ans) (success))      ((null l) (if (not success) (ed-beep)))      (when (setq ans (and-elimination (car l)))            (setq success t)            (mapc #'(lambda (p) (stash p window)) ans))))(defun call-contrapositive ()  (do ((l *one* (cdr l)) (window (front-window)) (ans) (success))      ((null l) (if (not success) (ed-beep)))      (when (setq ans (contrapositive (car l)))            (setq success t)            (mapc #'(lambda (p) (stash p window)) ans))))(defun call-universal-instantiation ()  (do ((l *one* (cdr l)) (window (front-window)) (ans) (success))      ((null l) (if (not success) (ed-beep)))      (when (setq ans (universal-instantiation (car l)))            (setq success t)            (mapc #'(lambda (p) (stash p window)) ans))))(defun call-existential-instantiation ()  (do ((l *one* (cdr l)) (window (front-window)) (ans) (success))      ((null l) (if (not success) (ed-beep)))      (when (setq ans (existential-instantiation (car l)))            (setq success t)            (mapc #'(lambda (p) (stash p window)) ans))))(defun call-factor ()  (do ((l *one* (cdr l)) (window (front-window)) (ans) (success))      ((null l) (if (not success) (ed-beep)))      (when (setq ans (factor (car l)))            (setq success t)            (mapc #'(lambda (p) (stash p window)) ans))));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Rule menu;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(defparameter *rule-menu*  (make-instance 'menu    :menu-title "Rule"    :menu-items (list (make-instance 'menu-item                        :menu-item-title "Modus ponens"                        :menu-item-action 'call-modus-ponens                        :command-key #\P)                      (make-instance 'menu-item                        :menu-item-title "Modus tollens"                        :menu-item-action 'call-modus-tollens                        :command-key #\T)                      (make-instance 'menu-item                        :menu-item-title "Implication"                        :menu-item-action 'call-implication                        :command-key #\I)                      (make-instance 'menu-item                        :menu-item-title "And introduction"                        :menu-item-action 'call-and-introduction)                      (make-instance 'menu-item                        :menu-item-title "Or introduction"                        :menu-item-action 'call-or-introduction                        :command-key #\O)                      (make-instance 'menu-item                        :menu-item-title "Unit resolution"                        :menu-item-action 'call-unit-resolution)                      (make-instance 'menu-item                        :menu-item-title "Ordered resolution"                        :menu-item-action 'call-ordered-resolution                        :command-key #\D)                      (make-instance 'menu-item                        :menu-item-title "General resolution"                        :menu-item-action 'call-resolution                        :command-key #\G)                      (make-instance 'menu-item                        :menu-item-title "Model Elimination"                        :menu-item-action 'call-model-elimination                        :disabled t))))(defparameter *rules*  '(modus-ponens modus-tollens    implication and-introduction or-introduction    unit-resolution ordered-resolution resolution model-elimination))(defun call-modus-ponens ()  (do ((l *one* (cdr l)) (window (front-window)) (success nil))      ((null l) (if (not success) (ed-beep)))      (do ((m *two* (cdr m)) (ans))          ((null m))          (when (setq ans (modus-ponens (car l) (car m)))            (setq success t)            (stash (car ans) window)))))(defun call-modus-tollens ()  (do ((l *one* (cdr l)) (window (front-window)) (success nil))      ((null l) (if (not success) (ed-beep)))      (do ((m *two* (cdr m)) (ans))          ((null m))          (when (setq ans (modus-tollens (car l) (car m)))            (setq success t)            (stash (car ans) window)))))(defun call-implication ()  (do ((l *one* (cdr l)) (window (front-window)) (success))      ((null l) (if (not success) (ed-beep)))      (do ((m *two* (cdr m)) (ans))          ((null m))          (when (setq ans (implication (car l) (car m)))            (setq success t)            (stash (car ans) window)))))(defun call-and-introduction ()  (do ((l *one* (cdr l)) (window (front-window)) (success))      ((null l) (if (not success) (ed-beep)))      (do ((m *two* (cdr m)) (ans))          ((null m))          (when (setq ans (and-introduction (car l) (car m)))            (setq success t)            (stash (car ans) window)))))(defun call-or-introduction ()  (do ((l *one* (cdr l)) (window (front-window)) (success))      ((null l) (if (not success) (ed-beep)))      (do ((m *two* (cdr m)) (ans))          ((null m))          (when (setq ans (or-introduction (car l) (car m)))            (setq success t)            (stash (car ans) window)))))(defun call-unit-resolution ()  (do ((l *one* (cdr l)) (window (front-window)) (success))      ((null l) (if (not success) (ed-beep)))      (do ((m *two* (cdr m)) (ans))          ((null m))          (when (setq ans (unit-resolution (car l) (car m)))                (setq success t)                (mapc #'(lambda (p) (stash p window)) ans)))))(defun call-ordered-resolution ()  (do ((l *one* (cdr l)) (window (front-window)) (success))      ((null l) (if (not success) (ed-beep)))      (do ((m *two* (cdr m)) (ans))          ((null m))          (when (setq ans (ordered-resolution (car l) (car m)))            (setq success t)            (stash (car ans) window)))))(defun call-resolution ()  (do ((l *one* (cdr l)) (window (front-window)) (success))      ((null l) (if (not success) (ed-beep)))      (do ((m *two* (cdr m)) (ans))          ((null m))          (when (setq ans (resolution (car l) (car m)))                (setq success t)                (mapc #'(lambda (p) (stash p window)) ans)))))(defun call-model-elimination ()  (do ((l *one* (cdr l)) (window (front-window)) (success))      ((null l) (if (not success) (ed-beep)))      (do ((m *two* (cdr m)) (ans))          ((null m))          (when (setq ans (model-elimination (car l) (car m)))                (setq success t)                (mapc #'(lambda (p) (stash p window)) ans)))))(defparameter *lisp* nil)(defun record (r x y z w)  (when (memp z traceexpressions 'instp)    (cond ((not *lisp*)           (let* ((buffer (fred-buffer w)) (end (buffer-size buffer)))             (ed-insert-with-style w (princ-to-string #\return) nil end)             (ed-insert-with-style w (princ-to-string z) nil end)             (ed-insert-with-style w (princ-to-string #\return) nil end)             (fred-update w)             (when *step* (setq *break* t) (do () ((not *break*))))))          (t (printapplication r x y z)))))(defun stash (p w)  (when t    (let* ((buffer (fred-buffer w)) (end (buffer-size buffer)))      (ed-insert-with-style w (princ-to-string #\return) nil end)      (ed-insert-with-style w (princ-to-string p) nil end)      (ed-insert-with-style w (princ-to-string #\return) nil end)      (fred-update w)      (when *step* (setq *break* t) (do () ((not *break*)))))))(defun printapplication (r x y z)  (fresh-line) (princ "Trying: ") (princ r) (terpri)  (princ " on: ") (princ x) (terpri)  (princ "and: ") (princ y) (terpri)  (princ "Result: ") (princ z) (terpri) (terpri))(defun present (window)  (let ((b (fred-buffer window))        (s (window-start-mark window))        (c (window-cursor-mark window)))    (if (> (buffer-line-start c) (+ (buffer-line-start s) 20))        (set-mark s (buffer-line-start b c -20)))    (fred-update window)));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Elimination menu;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(defparameter *elimination-menu*  (make-instance 'menu    :menu-title "Elimination"    :menu-items (list (make-instance 'menu-item                        :menu-item-title "Tautologies"                        :menu-item-action 'call-tautologies)                      (make-instance 'menu-item                        :menu-item-title "-")                      (make-instance 'menu-item                        :menu-item-title "Pure LIterals"                        :menu-item-action 'call-pure-literals                        :disabled t)                      (make-instance 'menu-item                        :menu-item-title "Subsumption"                        :menu-item-action 'call-subsumption))))(defparameter *eliminations* '(tautology))(defparameter *subsumptions* '(subsumes))(defun call-tautologies ()  (setq *one* (delete-if #'tautology *one*)))(defun tautology (p)  (and (consp p) (eq 'or (car p))       (do ((l (cdr p) (cdr l)))           ((null l))           (if (do ((m (cdr p) (cdr m)))                   ((null m))                   (if (and (consp (car m)) (eq 'not (caar m))                            (equal (car l) (cadar m)))                       (return t)))               (return t)))))(defun call-pure-literals ()  (setq *one* (delete-if #'tautology *one*)))(defun call-subsumption ()  (setq *one* (nreverse (subsumption *one* nil))))(defun subsumption (l ol)  (cond ((null l) ol)        ((rebmem (car l) (cdr l) #'subsumes) (subsumption (cdr l) ol))        ((rebmem (car l) ol #'subsumes) (subsumption (cdr l) ol))        (t (subsumption (cdr l) (cons (car l) ol)))))(defun subsumes (p q)  (cond ((atom p)         (cond ((atom q) (eq p q))               ((eq 'or q) (member p (cdr q) :test #'equal))))        ((eq 'or (car p)) nil)        (t (cond ((atom q) nil)                 ((eq 'or (car q)) (member p (cdr q) :test #'matchp))                 ((matchp p q))))));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Proof menu;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(defparameter *proof-menu*  (make-instance 'menu    :menu-title "Proof"    :menu-items (list (make-instance 'menu-item                        :menu-item-title "Schemata..."                        :menu-item-action 'select-schemata)                      (make-instance 'menu-item                        :menu-item-title "Transforms..."                        :menu-item-action 'select-transforms)                      (make-instance 'menu-item                        :menu-item-title "Rules..."                        :menu-item-action 'select-rules)                      (make-instance 'menu-item                        :menu-item-title "Eliminations..."                        :menu-item-action 'select-eliminations)                      (make-instance 'menu-item                        :menu-item-title "Method..."                        :menu-item-action 'select-method)                      (make-instance 'menu-item                        :menu-item-title "-")                      (make-instance 'menu-item                        :menu-item-title "Check"                        :menu-item-action 'check-proof                        :disabled t)                      (make-instance 'menu-item                        :menu-item-title "-")                      (make-instance 'menu-item                        :menu-item-title "Run"                        :menu-item-action 'run-method                        :command-key #\R)                      (make-instance 'menu-item                        :menu-item-title "Step"                        :menu-item-action 'step-method)                      (make-instance 'menu-item                        :menu-item-title "Break"                        :menu-item-action 'break-method                        :command-key #\,)                      (make-instance 'menu-item                        :menu-item-title "Next"                        :menu-item-action 'next-method                        :command-key #\\)                      (make-instance 'menu-item                        :menu-item-title "Continue"                        :menu-item-action 'continue-method                        :command-key #\/)                      (make-instance 'menu-item                        :menu-item-title "Abort"                        :menu-item-action 'abort-break                        :command-key #\.))))(defparameter *methods* '(bf bf-input))(defparameter *doschemata* nil)(defparameter *dotransforms* nil)(defparameter *dorules* nil)(defparameter *doeliminations* nil)(defparameter *dosubsumptions* nil)(defparameter *domethod* 'bf)(defparameter *step* nil)(defparameter *break* nil)(defun select-schemata ()  (setq *doschemata*        (select-item-from-list *schemata* :selection-type :disjoint)))(defun select-transforms ()  (setq *dotransforms*        (select-item-from-list *transforms* :selection-type :disjoint)))(defun select-rules ()  (setq *dorules*        (select-item-from-list *rules* :selection-type :disjoint)))(defun select-eliminations ()  (setq *doeliminations*        (select-item-from-list *eliminations* :selection-type :disjoint)))(defun select-method ()  (setq *domethod*        (car (select-item-from-list *methods* :selection-type :single))))(defun run-method ()  (eval-enqueue '(let ((*step* nil))                   (funcall *domethod* (view-sexps (front-window))))))(defun step-method ()  (eval-enqueue '(let ((*step* t))                   (funcall *domethod* (view-sexps (front-window))))))(defun break-method ()  (setq *step* t))(defun next-method ()  (setq *break* nil))(defun continue-method ()  (setq *step* nil *break* nil));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Model menu;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(defparameter *model-menu*  (make-instance 'menu    :menu-title "Model"    :menu-items (list (make-instance 'menu-item                        :menu-item-title "Truth table"                        :menu-item-action 'call-validity)                      (make-instance 'menu-item                        :menu-item-title "-")                      (make-instance 'menu-item                        :menu-item-title "Finite Model"                        :menu-item-action 'call-finite                        :disabled t))))(defun call-validity ()  (if (truth-value (ed-current-sexp (front-window)))      (ed-beep)      (progn (ed-beep) (ed-beep))))(defun truth-value (p)  (truth-cases p (atoms p) nil))(defun atoms (p)  (nreverse (atomsexp p nil)))(defun atomsexp (p nl)  (cond ((atom p) (adjoin p nl))        ((memq (car p) '(not and or => <= <=>))         (do ((l (cdr p) (cdr l)))             ((null l) nl)             (setq nl (atomsexp (car l) nl))))        (t (adjoin p nl))))(defun truth-cases (p l al)  (cond ((null l) (teval p al))        ((truth-cases p (cdr l) (acons (car l) t al))         (truth-cases p (cdr l) (acons (car l) nil al)))))(defun teval (p al)  (cond ((atom p) (cdr (assoc p al)))        ((eq 'not (car p)) (not (teval (cadr p) al)))        ((eq 'and (car p)) (every #'(lambda (x) (teval x al)) (cdr p)))        ((eq 'or (car p)) (some #'(lambda (x) (teval x al)) (cdr p)))        ((eq '=> (car p)) (or (not (teval (cadr p) al)) (teval (caddr p) al)))        ((eq '<= (car p)) (or (teval (cadr p) al) (not (teval (caddr p) al))))        (t (cdr (assoc p al)))));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Problems:;;;   Resolution rules do not remove duplicates;;;   Inconsistent checking for rule applicability;;;   No variable renaming;;;   Instantiating free variables;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; logica window;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(defclass logica-window (fred-window) ())(defmethod view-activate-event-handler ((window logica-window))  (call-next-method window)  (set-menubar (list *apple-menu* *logica-menu* *edit-menu*                     *schema-menu* *transform-menu* *rule-menu*                     *elimination-menu*                     *proof-menu* *model-menu* *windows-menu*)))(defmethod view-click-event-handler ((window logica-window) where)  (call-next-method window where)  (cond ((double-click-p)         (cond ((command-key-p) (setq *one* (nconc *one* (view-sexps window))))               ((option-key-p) (setq *two* (view-sexps window)))               (t (setq *one* (view-sexps window)))))))(defun view-selection (view)  (let ((buffer (fred-buffer view)) (start) (end))    (multiple-value-setq (start end) (selection-range view))    (buffer-substring buffer start end)))(defun view-sexps (view)  (read-from-string (concatenate 'string "(" (view-selection view) ")")));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Datum;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(defclass datum ()  ((pattern  :initarg :pattern  :accessor datum-pattern  :initform nil)   (uses     :initarg :uses     :accessor datum-uses     :initform nil)   (displays :initarg :displays :accessor datum-displays :initform nil)));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Setup;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(defun logica-about ()  (message-dialog   "This is logica.(c) Michael R. Genesereth 1991-1993"   :size #@(400 100)))(defun logica-start ()  (setq *one* nil *two* nil)  (remove-menu-items *apple-menu* (car (menu-items *apple-menu*)))  (add-menu-items *apple-menu*                  (make-instance 'menu-item                     :menu-item-title "About Logica"                     :menu-item-action 'logica-about))  (set-menubar (list *apple-menu* *logica-menu* *edit-menu*                     *schema-menu* *transform-menu* *rule-menu*                     *elimination-menu*                     *proof-menu* *model-menu* *windows-menu*)))(defun logica-toplevel ()  (logica-start)  (setq *idle* t)  (do () (nil) (event-dispatch)));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;