;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; (c) 1996-2002 Michael Genesereth;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(eval-when (compile load eval)  (proclaim '(special *sender* *receiver* *agent*)))(defconstant *month-names*  '(january february march april may june    july august september october november december))(defconstant *short-month-names*  '(jan feb mar apr may jun jul aug sep oct nov dec))(defconstant *day-names*  '(monday tuesday wednesday thursday friday saturday sunday))(defconstant *days-in-month*  '(31 28 31 30 31 30 31 31 30 31 30 31))(defconstant *short-day-names*  '(mon tue wed thu fri sat sun))(defun current-time (&optional (universal-time (get-universal-time)))  (multiple-value-bind    (second minute hour date month year dow dst zone)    (decode-universal-time universal-time)    (declare (ignore second dow dst zone))    (format nil "~:(~A~) ~D, ~D at ~A"	    (nth (1- month) *month-names*) date year	    (time-string hour minute))))(defun current-day ()  (multiple-value-bind    (second minute hour date month year dow dst zone)    (get-decoded-time)    (declare (ignore second minute hour date month year dst zone))    (format nil "~(~A~)" (nth dow *day-names*))))(defun current (kind)  (declare (type symbol kind))  (multiple-value-bind    (second minute hour date month year dow dst zone)    (get-decoded-time)    (case kind      (:second second)      (:minute minute)      (:hour hour)      (:date date)      (:month month)      (:year year)      (:day-of-week dow)      (:daylight-savings-time? dst)      (:time-zone zone))))(defun leap-year? (year)  (declare (type integer year))  (if (not (zerop (rem year 100)))      (zerop (rem year 4))      (zerop (rem year 400))))(defun seconds-until (hour minute)  "Returns seconds from now until then"  (declare (type (integer 0 23) hour))  (declare (type (integer 0 59) minute))  (multiple-value-bind    (now-second now-minute now-hour date month year dow dst zone)    (get-decoded-time)    (declare (ignore date month year dow dst zone) )    (mod (+ (* 60 60 (- hour now-hour))	    (* 60 (- minute now-minute))	    (- now-second) )         (* 24 60 60))))(defun time-string (hour minute)  (declare (type (integer 0 23) hour))  (declare (type (integer 0 59) minute))  (cond ((= hour 12) (format nil "12:~2,'0D pm" minute))        ((or (= hour 24) (= hour 0)) (format nil "12:~2,'0D am" minute))        ((< hour 12) (format nil "~D:~2,'0D am" hour minute))        (t (format nil "~D:~2,'0D pm" (- hour 12) minute))))(defun days-in (month &optional (year nil))  (if (and year (= month 2) (leap-year? year)) 29      (nth (1- month) *days-in-month*)))(defun day-of (month date year)  "Returns 0..6 = mon..sun of specified date"  (let ((ut (encode-universal-time 0 0 0 date month year)))    (multiple-value-bind      (second minute hour date month year dow dst zone)      (decode-universal-time ut)      (declare (ignore second minute hour date month year dst zone))      dow)))(defun current-date ()  (multiple-value-bind    (second minute hour date month year day-of-week dst zone)    (get-decoded-time)    (declare (ignore second minute hour day-of-week dst zone))    (format nil "~2,'0D/~2,'0D/~D" month date year)))(defun next-monday-date (&optional (time (get-universal-time)))  (multiple-value-bind    (second minute hour date month year day-of-week dst zone)    (decode-universal-time time)    (declare (ignore second minute hour dst zone))    (let ((days-ahead (mod (- 7 day-of-week) 7))	  (days-in-month (days-in month year)) )      (setq date (+ date days-ahead))      (when (> date days-in-month)	(setq date (- date days-in-month))	(incf month) )      (when (> month 12)	(setq month 1)	(incf year) ))    (format nil "~2,'0D/~2,'0D/~D" month date year)))(defun last-monday-date (&optional (time (get-universal-time)))  (multiple-value-bind    (second minute hour date month year dow dst zone)    (decode-universal-time time)    (declare (ignore second minute hour dst zone))    (setq date (- date dow))    (when (< date 1)      (decf month)      (when (< month 1)	(setq month 12)	(decf year))      (setq date (+ (days-in month year) date)))    (format nil "~2,'0D/~2,'0D/~D" month date year)))(defgeneric date-plus (month date year count interval))(defmethod date-plus (month date year count interval)  (declare (ignore interval))  (date-plus month date year count 'day))(defmethod date-plus (month date year count (interval (eql 'day)))  (setq date (+ date count))  (loop      for days-in-month = (days-in month year)      while (> date days-in-month)      do (setq date (- date days-in-month))	 (incf month)	 (when (> month 12)	   (setq month 1)	   (incf year) ))  (values month date year))(defmethod date-plus (month date year count (interval (eql 'week)))  (date-plus month date year (* 7 count) 'day) )(defmethod date-plus (month date year count (interval (eql 'biweek)))  (date-plus month date year (* 14 count) 'day) )(defmethod date-plus (month date year count (interval (eql 'month)))  (setq month (+ month count))  (multiple-value-bind (delta-year new-month) (truncate month 12)    (when (= new-month 0)      (setq new-month 12)      (decf delta-year) )    (setq year (+ year delta-year))    (setq month new-month))  (values month date year));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; http;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(defparameter *lock* (make-lock))(defparameter *logfile* nil)(defparameter *remote* "0.0.0.0")(defparameter *browser* "")(defparameter *client* 'anonymous)(defparameter *password* "anonymous")(defparameter *cookies* nil)(defparameter *security* nil)(defparameter *max-line-size* 1000000  "Bound on number of characters in one line from client")(defun http-handler (s host &optional (ip 0))  (declare (type stream s))  (declare (ignore host))  (with-open-stream (s s)    (ignore-errors (parse-http s ip))    (ignore-errors (finish-output s))    (ignore-errors (close s))))(defun parse-http (s *remote*)  (declare (type stream s))  (let ((firstline "") (postline "") (start) (end)        (contentlength *max-line-size*) (type 'x-www-form-urlencoded)        (*client* *client*) (*password* *password*)        *cookies* *browser* (*receiver* *agent*))    (setq start (get-universal-time))    (unless (setq firstline (get-http-line s))      (http-problem s "Error reading first line")      (return-from parse-http) )    (multiple-value-bind (command path protocol) (parse-request firstline)      (unless command	(http-problem s (format nil "Can't parse `~A'" firstline))	(return-from parse-http) )      (when protocol (multiple-value-setq (type contentlength) (parse-header s)))      (cond ((eq type 'acl)             (acl-handler s (read-content s contentlength)))            ((eq type 'sql)             (sql-handler s (read-content s contentlength)))            (t (multiple-value-bind (dir file query) (parse-path path)                 (if (string= command "POST")                   (setq postline (get-http-line s contentlength))                   (setq postline query))                 (html-handler s dir file postline)                 (when *logfile*                  (setq end (get-universal-time))                  (loghttp start end *remote* *browser* *client* firstline postline))))))))(defun parse-header (s)  (do ((line) (pos) (type) (len *max-line-size*))      (nil)      (setq line (string-left-trim '(#\space #\linefeed #\return) (get-http-line s)))      (cond ((string= line "") (return (values type len)))            ((and (startstringp "Authorization" line)                  (setq line (base64-to-string (subseq line 21)))                  (setq pos (position #\: line)))             (setq *client* (read-value-string (subseq line 0 pos)))             (setq *password* (subseq line (1+ pos)))             (when (or (null *client*) (null *password*))               (setq *client* 'anonymous *password* "anonymous")))            ((startstringp "Receiver" line)             (setq line (subseq line 10))	     (setq *receiver* (read-from-string line)))            ((startstringp "User-Agent" line)             (setq *browser* (subseq line 12)))            ((startstringp "Cookie" line)             (setq line (subseq line 8))             (setq *cookies* (parse-cookies line)))            ((startstringp "Content-type" line)             (when (setq pos (position #\/ line))               (setq type (read-value-string (subseq line (1+ pos))))))            ((startstringp "Content-length" line)             (setq line (subseq line 16))	     (when (not (find-if-not #'digit-char-p line))	       (setq len (read-from-string line)))))))(defun parse-cookies (line)  (do ((start 0) (end (length line)) (eq) (sc) (nl))      ((>= start end) (nreverse nl))      (cond ((whitep (elt line start)) (setq start (1+ start)))            ((setq eq (position #\= line :start start))             (setq sc (or (position #\; line :start start) end))             (when (< eq sc)               (setq nl (cons (cons (decode-url-chrs (subseq line start eq))                                    (decode-url-chrs (subseq line (1+ eq) sc)))                                     nl)))             (setq start (1+ sc)))            (t (setq start end)))))            (defun parse-request (string)  "Returns: (1) Command, (2) Path, (3) Protocol"  (declare (type string string))  (let (space-pos space2-pos)    (cond ((not (setq space-pos (position #\space string)))           (values nil nil nil))          ((setq space2-pos (position #\space string :start (1+ space-pos)))           (values (subseq string 0 space-pos)	           (subseq string (1+ space-pos) space2-pos)	           (subseq string (1+ space2-pos))))          (t (values (subseq string 0 space-pos)                     (subseq string (1+ space-pos))                     nil)))))(defun parse-path (path)  "Returns: (1) Directory, (2) File, (3) Query"  (declare (type string path))  (let (q-pos slash-pos dir file query)    (cond ((setq q-pos (position #\? path))	   (setq query (subseq path (1+ q-pos)))	   (setq path (subseq path 0 q-pos)))          (t (setq query "")))    (cond ((setq slash-pos (position #\/ path :from-end t))           (setq dir (subseq path 0 (1+ slash-pos)))	   (setq file (subseq path (1+ slash-pos))))          (t (setq dir "/" file path)))    (unless (or q-pos (string-equal file ""))      (setq query (strappend "Object=" file) file "Inspect"))    (setq dir (decode-url-chrs dir))    (setq file (decode-url-chrs file))    (setq query (decode-url-chrs query))    (values dir file query)))(defun loghttp (start end remote browser client first post)  (with-lock-grabbed (*lock*)    (with-open-file      (log *logfile* :direction :io :if-exists :append :if-does-not-exist :create)      (prin1 start log) (write-char #\tab log)      (prin1 end log) (write-char #\tab log)      (prin1 remote log) (write-char #\tab log)      (prin1 browser log) (write-char #\tab log)      (prin1 client log) (write-char #\tab log)      (prin1 first log) (write-char #\tab log)      (prin1 post log) (terpri log))))(defun get-http-line (s &optional (max-chars *max-line-size*) (timeout 10000))  (declare (type stream s))  (declare (type (integer 0 *) max-chars))  (declare (optimize speed (safety 1) (space 0) (debug 0)))  (with-output-to-string (out)    (do ((i 1) (time) (chr nil (read-char-no-hang s nil 'eof)))        ((or (eq chr 'eof) (eql chr #\linefeed) (> i max-chars)))        (cond ((null chr)	       (unless time (setq time (process-msecs)))	       (when (> (process-msecs) (+ timeout time))		     (print "Stream time out on read" *terminal-io*)		     (error "Stream time out on read")))	      ((graphic-char-p chr) (write-char chr out)               (setq i (1+ i) time nil))	      (t (setq i (1+ i) time nil))))))(defun read-content (s len &optional (timeout 10000))  (with-output-to-string (out)    (do ((i 1) (time) (chr nil (read-char-no-hang s nil 'eof)))        ((or (eq chr 'eof) (> i len)))        (cond ((null chr) 	       (unless time (setq time (process-msecs)))	       (when (> (process-msecs) (+ timeout time)) 		     (print "Stream time out on read" *terminal-io*)		     (error "Stream time out on read")))              ((graphic-char-p chr) (write-char chr out) (setq i (1+ i))	       (setq time nil))              (t (setq i (1+ i) time nil))))));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Password stuff;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(defun password (n)  (mod (- (* (* 7 (- (mod n 3) (mod n 5)) n) (* n n))          (* 983 n)          (integer-length n))       1000000))(defun pwd (s)  (setq s (string-downcase s))  (do ((i (length s) (1- i)) (n 0))      ((= i 0) (princ-to-string (password n)))      (setq n (+ (expt 8 (char-code (elt s (1- i)))) n))));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; base64 for authentication;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(defun base64-to-string (s) (number-to-string (base64-to-number s)))(defun string-to-base64 (s) (number-to-base64 (string-to-number s)))(defun string-to-number (s)  (do ((i 0 (1+ i)) (n (length s)) (out 0))      ((= i n) out)      (setq out (+ out (* (char-code (elt s (- n i 1))) (expt 256 i))))))(defun number-to-string (n)  (reverse (with-output-to-string (out)             (do ((n n (floor n 256)))                 ((zerop n))                 (unless (zerop (mod n 256))                   (write-char (code-char (mod n 256)) out))))))(defun base64-to-number (s)  (do ((i 0 (1+ i)) (n (length s)) (out 0))      ((= i n) out)      (setq out (+ out (* (base64-code (elt s (- n i 1))) (expt 64 i))))))(defun number-to-base64 (n)  (reverse (with-output-to-string (out)             (do ((n n (floor n 64)))                 ((zerop n))                 (write-char (code-base64 (mod n 64)) out)))))(defun base64-code (c)  (setq c (char-code c))  (cond ((and (>= c 65) (<= c 90)) (- c 65))        ((and (>= c 97) (<= c 122)) (- c 71))        ((and (>= c 48) (<= c 57)) (+ c 4))        ((= c 43) 62)        ((= c 47) 63)        (t 0)))(defun code-base64 (c)  (cond ((< c 26) (code-char (+ c 65)))        ((< c 52) (code-char (+ c 71)))        ((< c 62) (code-char (- c 4)))        ((= c 62) #\+)        ((= c 63) #\/)        (t #\=)))(defun decode-url-chrs (str)  (with-output-to-string (s)    (do ((i 0 (1+ i)) (n (length str)) (c))        ((>= i n))        (setq c (elt str i))        (cond ((eql c #\+) (write-char #\space s))              ((eql c #\%)               (write-char (code-char (readcode str i)) s)               (setq i (+ i 2)))              (t (write-char c s))))))(defun readcode (str i)  (let ((*read-base* 16))    (read-from-string str nil 0 :start (1+ i) :end (+ i 3))))(defun parse-post-data (line)  (declare (type string line))  (loop    with start = 0    while (and line (not (= start (length line))))    for eq-pos = (position #\= line :start start)    for amp-pos = (position #\& line :start start)    when eq-pos    collect (cons (decode-url-chrs (subseq line start eq-pos))                  (decode-url-chrs (subseq line (1+ eq-pos) amp-pos)))    do (if amp-pos (setq start (1+ amp-pos)) (setq start (length line)))))(defun parse-get-data (line)  (do ((start 0) (eqpos) (amppos) (nl))      ((= start (length line)) (nreverse nl))      (setq eqpos (position #\= line :start start))      (setq amppos (position #\& line :start start))      (when eqpos        (setq nl (cons (cons (decode-url-chrs (subseq line start eqpos))                             (decode-url-chrs (subseq line (1+ eqpos) amppos)))                       nl)))      (if amppos (setq start (1+ amppos)) (setq start (length line)))));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; im.lisp;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(eval-when (compile load eval)  (proclaim '(special *client* *host* *port* *library* *warehouse* *manager*)))(defparameter *gui* 'standard)(defparameter *agent* nil)(defparameter *interface* nil)(defparameter *title* "Proforma<SUP><FONT SIZE=-1>TM</FONT></SUP>")(defparameter *address* "Send questions, comments, and suggestions to<A HREF=\"mailto:help@epistemics.com\"><EM>help@epistemics.com</EM></A>.")(defparameter *interface-options* '(:rows))(defparameter *relations*  '(same distinct    < > =< >= + - * /    makestring expression    stralphanumeric    strappend    strcapitalize    strcharpos    strdowncase    strelement    strgreater    string    strlength    strless    strposition    strmatch    strmatchall    strmatchany    strmatchphrase    strsubseq    strsubstitute    strupcase    substring))(defclass interface (agent) ())(defmethod message-handler (*message* *sender* (*receiver* interface))  (let ((target (findx '?x `(recipient ,(name *receiver*) ?x) *manager*)))    (when target (request *message* *sender* target))))(defmethod reduction (msg sender (receiver interface))  (let ((target (find-recipient (name receiver))))    (when target (reduction msg sender target))))(defmethod expansion (msg sender (receiver interface))  (let ((target (find-recipient (name receiver))))    (when target (expansion msg sender target))))(defmethod optimization (msg sender (receiver interface))  (let ((target (find-recipient (name receiver))))    (when target (optimization msg sender target))))(defmethod sourcing (msg sender (receiver interface))  (let ((target (find-recipient (name receiver))))    (when target (sourcing msg sender target))))(defmethod plan (msg sender (receiver interface))  (let ((target (find-recipient (name receiver))))    (when target (plan msg sender target))));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; acl;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(defun acl-handler (s msg)  (let (answer)    (setq msg (read-user-string msg))    (setq answer (request msg *client* *receiver*))    (setq answer (prin1-to-string answer))    (when *trace*      (fresh-line *trace*) (prin1 msg *trace*) (force-output *trace*))    (format s "HTTP/1.0 200 OK") (crlf s)    (format s "Content-type: text/acl") (crlf s)    (format s "Content-length: ~A" (length answer)) (crlf s)    (crlf s)    (format s "~A" answer)    (finish-output s)    'done));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; html;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(defun html-handler (s dir file postline)  (let (postlines)    (setq postlines (parse-post-data postline))    (cond ((substringp "MSIE 4" *browser*)           (garbage-handler s dir file postlines))          ((substringp "MSIE 3" *browser*)           (crap-handler s dir file postlines))          (t (post-handler s dir file postlines)))));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Netscape;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(defun post-handler (s dir file postlines)  (let (*gui* *security* *interface* *agent*)    (cond ((string= dir "/") (setq *gui* 'standard))          (t (setq dir (string-left-trim '(#\/) dir))             (setq dir (string-right-trim '(#\/) dir))             (setq *gui* (read-from-string dir))))    (setq *security* (find-infobase *gui*))    (setq *interface* (find-formbase *gui*))    (setq *agent* *gui*)    (cond ((not *security*) (process s file postlines))          ((not (accessiblep *gui* *remote*))           (http-problem s "This interface is not accessible from your IP address."))          ((string-equal "Logout" file)           (format s "HTTP/1.0 200 OK") (crlf s)           (format s "Set-Cookie: ~A=~D; path=/" (addressify *gui*) 0) (crlf s)           (crlf s)           (html-message s "Logout successful."))          ((not (chkpwd *client* *password*))           (format s "HTTP/1.0 401 Unauthorized") (crlf s)           (format s "WWW-Authenticate: Basic realm=\"Infomaster\"") (crlf s)           (format s "Set-Cookie: ~A=~D; path=/" (addressify *gui*) (get-universal-time)) (crlf s)           (crlf s)           (html-message s "Bad password."))          ((not (chkcookie *client* (getf-post (addressify *gui*) *cookies*)))           (format s "HTTP/1.0 401 Unauthorized") (crlf s)           (format s "WWW-Authenticate: Basic realm=\"Infomaster\"") (crlf s)           (format s "Set-Cookie: ~A=~D; path=/" (addressify *gui*) (get-universal-time)) (crlf s)           (crlf s)           (html-message s "Session terminated."))          (t (process s file postlines)))));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Explorer up to version 3;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(defun crap-handler (s dir file postlines)  (let (*gui* *security* *interface* *agent*)    (cond ((string= dir "/") (setq *gui* 'standard))          (t (setq dir (string-left-trim '(#\/) dir))             (setq dir (string-right-trim '(#\/) dir))             (setq *gui* (read-from-string dir))))    (setq *security* (find-infobase *gui*))    (setq *interface* (find-formbase *gui*))    (setq *agent* *gui*)    (setq *client* (read-value-string (getf-post "User" *cookies*)))    (cond ((not *security*) (process s file postlines))          ((not (accessiblep *gui* *remote*))           (http-problem s "This interface is not accessible from your IP address."))          ((string-equal "Login" file) (post-login s postlines))          ((string-equal "Logout" file) (post-logout s))          ((not (chkcookie *client* (getf-post (addressify *gui*) *cookies*)))           (post-login s nil))          (t (process s file postlines)))))(defun post-login (s postlines)  (cond ((null postlines) (post-login-page s))        (t (post-login-doit s postlines))))(defun post-login-page (s)  (format s "HTTP/1.0 200 OK") (crlf s)  (format s "Pragma: no-cache") (crlf s)  (format s "Content-type: text/html") (crlf s)  (crlf s)  (output-header s "Login")  (format s "<FORM ACTION=\"Login?\" METHOD=\"POST\">")  (format s "<CENTER><TABLE>")  (format s "<TR><TH>User</TH><TD><INPUT TYPE=\"TEXT\" NAME=\"User\" SIZE=40></TD></TR>")  (format s "<TR><TH>Password</TH><TD><INPUT TYPE=\"PASSWORD\" NAME=\"Password\" SIZE=40></TD></TR>")  (format s "<TR><TH></TH><TD><INPUT TYPE=\"SUBMIT\" VALUE=\"Login\"></TD></TR>")  (format s "</TABLE></CENTER>")  (format s "</FORM>")  (output-footer s))(defun post-login-doit (s postlines)  (setq *client* (or (read-value-string (getf-post "User" postlines)) 'anonymous))  (setq *password* (getf-post "Password" postlines))  (cond ((chkpwd *client* *password*)         (format s "HTTP/1.0 200 OK") (crlf s)         (format s "Pragma: no-cache") (crlf s)         (format s "Set-Cookie: ~A=~D; path=/" (addressify *gui*) (get-universal-time)) (crlf s)         (format s "Set-Cookie: User=~A; path=/" (addressify *client*)) (crlf s)         (format s "Content-type: text/html") (crlf s)         (crlf s)         (html-message s "Thank you.  Press the Back button to continue."))        (t (format s "HTTP/1.0 200 OK") (crlf s)           (format s "Pragma: no-cache") (crlf s)           (format s "Set-Cookie: ~A=~D; path=/" (addressify *gui*) 0) (crlf s)           (format s "Set-Cookie: User=Anonymous; path=/") (crlf s)           (format s "Content-type: text/html") (crlf s)           (crlf s)           (html-message s "Bad login."))))(defun post-logout (s)  (format s "HTTP/1.0 200 OK") (crlf s)  (format s "Set-Cookie: ~A=~D; path=/" (addressify *gui*) 0) (crlf s)  (format s "Set-Cookie: User=Anonymous; path=/") (crlf s)  (crlf s)  (html-message s "Logout successful."));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Explorer version 4;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(defun garbage-handler (s dir file postlines)  (let (*gui* *security* *interface* *agent*)    (cond ((string= dir "/") (setq *gui* 'standard))          (t (setq dir (string-left-trim '(#\/) dir))             (setq dir (string-right-trim '(#\/) dir))             (setq *gui* (read-from-string dir))))    (setq *security* (find-infobase *gui*))    (setq *interface* (find-formbase *gui*))    (setq *agent* *gui*)    (setq *client* (read-value-string (getf-post "User" *cookies*)))    (cond ((not *security*) (process s file postlines))          ((not (accessiblep *gui* *remote*))           (http-problem s "This interface is not accessible from your IP address."))          ((string-equal "Login" file) (garbage-login s postlines))          ((string-equal "Logout" file) (post-logout s))          ((not (chkcookie *client* (getf-post (addressify *gui*) *cookies*)))           (post-login s nil))          (t (process s file postlines)))))(defun garbage-login (s postlines)  (cond ((null postlines) (garbage-login-page s))        (t (garbage-login-doit s postlines))))(defun garbage-login-page (s)  (format s "HTTP/1.1 205 Reset Content") (crlf s)  (format s "Cache-Control: no-cache") (crlf s)  (format s "Pragma: no-cache") (crlf s)  (format s "Content-type: text/html") (crlf s)  (crlf s)  (output-header s "Login")  (format s "<FORM ACTION=\"Login?\" METHOD=\"POST\">")  (format s "<CENTER><TABLE>")  (format s "<TR><TH>User</TH><TD><INPUT TYPE=\"TEXT\" NAME=\"User\" SIZE=40></TD></TR>")  (format s "<TR><TH>Password</TH><TD><INPUT TYPE=\"PASSWORD\" NAME=\"Password\" SIZE=40></TD></TR>")  (format s "<TR><TH></TH><TD><INPUT TYPE=\"SUBMIT\" VALUE=\"Login\"></TD></TR>")  (format s "</TABLE></CENTER>")  (format s "</FORM>")  (output-footer s))(defun garbage-login-doit (s postlines)  (setq *client* (or (read-value-string (getf-post "User" postlines)) 'anonymous))  (setq *password* (getf-post "Password" postlines))  (cond ((chkpwd *client* *password*)         (format s "HTTP/1.1 205 Reset Content") (crlf s)         (format s "Cache-Control: no-cache") (crlf s)         (format s "Pragma: no-cache") (crlf s)         (format s "Set-Cookie: ~A=~D; path=/" (addressify *gui*) (get-universal-time)) (crlf s)         (format s "Set-Cookie: User=~A; path=/" (addressify *client*)) (crlf s)         (format s "Content-type: text/html") (crlf s)         (crlf s)         (html-message s "Thank you.  Press the Back button to continue.  If yourbrowser is still showing the Login page, press the Refresh button as well."))        (t (format s "HTTP/1.1 200 OK") (crlf s)           (format s "Set-Cookie: ~A=~D; path=/" (addressify *gui*) 0) (crlf s)           (format s "Set-Cookie: User=Anonymous; path=/") (crlf s)           (format s "Content-type: text/html") (crlf s)           (crlf s)           (html-message s "Bad login."))))(defparameter *var-count* 0)(defparameter *web-server-port* 4800)(defparameter *http-status-codes*    '(;; 1xx: Informational            ;; 2xx: Success      (200 . "OK")      (201 . "Created")      (202 . "Accepted")      (203 . "Provisional information")      (204 . "No content")      (205 . "Reset content")      ;; 3xx: Redirection      (300 . "Multiple choices")      (301 . "Moved permanently")      (302 . "Moved temporarily")      (303 . "Method")      (304 . "Not modified")      ;; 4xx: Client error      (400 . "Bad request")      (401 . "Unauthorized")      (402 . "Payment required")      (403 . "Forbidden")      (404 . "Not found")      (405 . "Method not allowed")      (406 . "None acceptable")      (407 . "Proxy authentication required")      (408 . "Request timeout")      (409 . "Conflict")      (410 . "Gone")      ;; 5xx: Server error      (500 . "Internal server error")      (501 . "Not implemented")      (502 . "Bad gateway")      (503 . "Service unavailable")      (504 . "Gateway timeout")))(defun find-formbase (x)  (or (referent (findx '?x `(formbase ,x ?x) *manager*)) *manager*))(defun find-infobase (x)  (findx '?x `(infobase ,x ?x) *manager*))(defun accessiblep (interface ip)  (request `(ask-if (accessible ,interface ,ip)) *client* *security*))(defun chkpwd (client pwd)  (request `(ask-if (pwd ,client ,pwd)) *client* *security*))(defun chkcookie (client cookie)  (let (old new)    (setq old (or (read-value-string cookie) 0))    (setq new (get-universal-time))    (request `(ask-if (recent ,client ,(- new old))) *client* *security*)))(defun expiration (client)  (let (timeout)    (setq timeout (request `(ask-one ?x (timeout ,client ?x)) *client* *security*))    (cookietime (+ (get-universal-time) (if (integerp timeout) timeout 300)))))(defun termination ()  (cookietime (- (get-universal-time) 1000)))(defun cookietime (n)  (multiple-value-bind    (second minute hour date month year dow dst zone)    (decode-universal-time n 0)    (declare (ignore zone dst))    (format nil "~:(~A~), ~D-~:(~A~)-~D ~2,'0D:~2,'0D:~2,'0D GMT"	    (nth dow *day-names*) date (nth (1- month) *short-month-names*) year            hour minute second)));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Process;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(defmethod process (s file postlines)  (cond ((string-equal file "") (process-top s))        (t (with-lock-grabbed (*lock*) (process-logica s postlines)))));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Top;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(defun process-top (s)  (output-prolog s 200)  (format s"<HTML><BODY><HR><CENTER><H1>Logica</H1></CENTER><HR><FORM ACTION=http://sound.stanford.edu:4000/Logica?><TABLE><TR><TH VALIGN=TOP>Premises</TH><TD><TEXTAREA NAME=Premises ROWS=15 COLS=80 WRAP=SOFT></TEXTAREA></TD></TR><TR><TH VALIGN=TOP>Conclusion</TH><TD><TEXTAREA NAME=Question ROWS=5 COLS=80 WRAP=SOFT></TEXTAREA></TD></TR><TR><TH VALIGN=TOP>Strategy</TH><TD><INPUT TYPE=CHECKBOX NAME=Tautology> Tautology Elimination<BR><INPUT TYPE=CHECKBOX NAME=Unit> Unit Resolution<BR><INPUT TYPE=CHECKBOX NAME=Input> Input Resolution<BR><INPUT TYPE=CHECKBOX NAME=Ordered> Ordered Resolution<BR></TD></TR></TABLE></TD></TR></TABLE><HR><INPUT TYPE=SUBMIT NAME=Command VALUE=Display> steps <INPUT TYPE=TEXT NAME=Start VALUE=1 SIZE=5> through <INPUT TYPE=TEXT NAME=End VALUE=20 SIZE=5></FORM></HTML>"));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Execute;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(defparameter *stream* nil)(defparameter *postlines* nil)(defparameter *tautology* nil)(defparameter *unit* nil)(defparameter *input* nil)(defparameter *ordered* nil)(defun process-logica (*stream* postlines)  (let (premises conclusion *tautology* *unit* *input* *ordered* start end)    (setq premises (read-sentences (cdr (pop postlines))))    (setq conclusion (or (read-user-string (cdr (pop postlines))) 'false))    (setq *tautology* (if (read-value-string (getf-post "Tautology" postlines)) t))    (setq *unit* (if (read-value-string (getf-post "Unit" postlines)) t))    (setq *input* (if (read-value-string (getf-post "Input" postlines)) t))    (setq *ordered* (if (read-value-string (getf-post "Ordered" postlines)) t))    (setq start (read-value-string (getf-post "Start" postlines)))    (setq end (read-value-string (getf-post "End" postlines)))    (output-prolog *stream* 200)    (format *stream* "<HR><CENTER><H1>Result</H1></CENTER><HR>")    (unless (integerp start) (setq start 1))    (unless (and (integerp end) (>= end start)) (setq end start))    (logica premises conclusion start end)))(defun read-sentences (s)  (ignore-errors   (with-input-from-string (s s)     (do ((sentence (read s nil) (read s nil)) (nl))         ((null sentence) (nreverse nl))       (setq nl (cons sentence nl))))))(defun output-prolog (s status-code)  (format s "HTTP/1.0 ~D ~A"	  status-code (rest (assoc status-code *http-status-codes*))) (crlf s)  (format s "Set-Cookie: ~A=~D; path=/" (addressify *gui*) (get-universal-time)) (crlf s)  (format s "Content-type: text/html") (crlf s)  (crlf s))(defun output-header (s str &rest args)  (let ((page (find-page *gui*)) (postitle) (posinfo))    (cond ((and (setq postitle (search "</title>" page :test #'char-equal))                (setq posinfo (search "</info>" page :test #'char-equal)))           (format s "~A" (subseq page 0 postitle))           (apply #'format s str args)           (format s "~A" (subseq page postitle posinfo)))          (t (format s "<HTML>~%")             (format s "<HEAD><TITLE>")             (apply #'format s str args)             (format s "</TITLE></HEAD>~%")             (format s "<BODY>~%")             (format s "<HR><CENTER><H1>~A</H1></CENTER><HR>~%"                     (find-header *gui*))))))(defun output-footer (s)  (let ((page (find-page *gui*)) (pos))    (cond ((setq pos (search "</info>" page :test #'char-equal))           (format s "~A" (subseq page pos)))          (t (format s "<HR><ADDRESS>")             (format s (find-footer *gui*))             (format s "</ADDRESS>")             (format s "</BODY>")             (format s "</HTML>")))))(defun logica (premises conclusion start end)  (let ((step 0))    (format *stream* "<HTML>")    (format *stream* "<BODY>")    (format *stream* "<CENTER><TABLE BORDER>")    (format *stream* "<TR><TH>Step</TH><TH>Proof</TH><TH>Justification</TH></TR>")    (setq premises (mapcan #'clauses premises))    (setq conclusion (clauses (maknot conclusion)))    (do ((l premises (cdr l)))        ((or (null l) (>= step end)))        (format-step *stream* (incf step) (car l) "Premise"))    (do ((l conclusion (cdr l)))        ((or (null l) (>= step end)))        (format-step *stream* (incf step) (car l) "Conclusion"))    (setq premises (nconc premises conclusion))    (runlogica premises step end)    (finish-output *stream*)    (format *stream* "</TABLE></CENTER>")    (format *stream* "</BODY>")    (format *stream* "</HTML>")))(defun runlogica (premises step end)  (cond (*input* (inputresolution premises step end))        (t (runit premises step end))))(defun inputresolution (premises step end)  (let (copy)    (setq copy (copy-list premises))    (do ((l premises (cdr l)) (i 1 (1+ i)))        ((or (null l) (>= step end)))      (do ((m copy (cdr m)) (j 1 (1+ j)))          ((or (null m) (>= step end)))        (dolist (result (resolve (car l) (car m)))          (cond ((>= step end))                ((find result premises :test #'equalp))                (t (setq premises (nconc premises (list result)))                   (format-step *stream* (incf step) result (format nil "~A, ~A" j i)))))))))(defun runit (premises step end)  (do ((l premises (cdr l)) (i 1 (1+ i)))      ((or (null l) (>= step end)))      (do ((m premises (cdr m)) (j 1 (1+ j)))          ((or (eq m (cdr l)) (>= step end)))          (dolist (result (resolve (car l) (car m)))            (cond ((>= step end))                  ((find result premises :test #'equalp))                  (t (setq premises (nconc premises (list result)))                     (format-step *stream* (incf step) result (format nil "~A, ~A" j i))))))))(defun format-step (s num step just)  (let ((*print-case* :downcase))    (format s "<TR><TH HALIGN=RIGHT>~A.</TH>" num)    (format s "<TD><TT>~A</TT></TD>" step)    (format s "<TD>~A</TD></TR>" just)))(defun resolve (p q)  (unless (and (listp p) (eq 'or (car p))) (setq p (list 'or p)))  (unless (and (listp q) (eq 'or (car q))) (setq q (list 'or q)))  (cond ((and *unit* (not (or (unitp p) (unitp q)))) nil)        (*ordered* (ordered p q))        (t (resolution p q))))(defun propositional (p q)  (do ((l (cdr p) (cdr l)) (result) (nl))      ((null l) (nreverse nl))      (do ((m (cdr q) (cdr m)))          ((null m))          (when (equal (car l) (maknot (car m)))            (setq result (maksor (unionize (remove (car l) (cdr p) :test #'equal)                                           (remove (car m) (cdr q) :test #'equal))))            (cond ((and *tautology* (tautologyp result)))                  (t (setq nl (adjoin result nl :test #'equalp))))))))(defun resolution (p q)  (setq q (stdize q))  (do ((l (cdr p) (cdr l)) (al) (result) (nl))      ((null l) (nreverse nl))      (do ((m (cdr q) (cdr m)))          ((null m))          (when (setq al (mgu (car l) (maknot (car m))))            (setq result (maksor (unionize (remove (car l) (cdr p) :test #'equal)                                           (remove (car m) (cdr q) :test #'equal))))            (setq result (decolonize (plug result al)))            (cond ((and *tautology* (tautologyp result)))                  (t (setq nl (adjoin result nl :test #'equalp))))))))(defun ordered (p q)  (let (al result)    (unless (and (listp p) (eq 'or (car p))) (setq p (list 'or p)))    (unless (and (listp q) (eq 'or (car q))) (setq q (list 'or q)))    (setq q (stdize q))    (cond ((null (cdr p)) nil)          ((null (cdr q)) nil)          ((setq al (mgu (cadr p) (maknot (cadr q))))           (setq result (maksor (unionize (cddr p) (cddr q))))           (setq result (decolonize (plug result al)))           (cond ((and *tautology* (tautologyp result)) nil)                 (t (list result)))))))(defun unitp (x)  (cond ((atom x))        ((eq 'not (car x)))        ((eq 'or (car x)) (null (cddr x)))))(defun tautologyp (x)  (cond ((atom x) nil)        ((eq 'not (car x)) nil)        ((eq 'or (car x))         (do ((l (cdr x) (cdr l)))             ((null l) nil)             (when (find (maknot (car l)) (cdr l) :test #'equalp)               (return t))))));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Three types of conversion:;;;   stringification;;;   slashification;;;   htmlification or urlification;;;;;; Assumption:;;;   Numbers are stringified with princ-to-string;;;   Numbers need not be backslashed; backslashing has no effect;;;   Numbers need not be htmlified nor urlified;;;;;; Assumption:;;;   Strings are already strings and are not prettified in any way;;;   Strings MAY contain quotes and backslashes, necessitating backslashing;;;   Strings MAY contain special chars < > & ", necessitating htmlify or urlify;;;;;; Assumption:;;;   Symbols are converted with symbol-name and always prettified;;;   Symbols have read property, i.e. (read-from-string (symbol-name x)) = x;;;   i.e. no cases like |a| or |10:00| and so forth;;;   therefore, need not be backslashed; backslashing has no effect;;;   Symbol names MAY contain special chars, necessitating htmlify or urlify;;;;;; Assumption:;;;   Nothing else should occur; if it does, it prints as an empty string;;;;;; There are two types of output:;;;   urls;;;   html;;;;;; There are two types of output for each of these:;;;   viewing -- backslashing necessary;;;   editing -- no backslashing;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(defun addressify (x)  (urlify (prin1-to-string x)))(defun stringify (x)  (cond ((numberp x) (prin1-to-string x))        ((characterp x) (htmlify (prin1-to-string x)))        ((stringp x) (htmlify (prin1-to-string x)))        ((eq 'unknown x) "")        ((symbolp x) (htmlify (make-readable-string x)))        (t "")))(defun prettify (x)  (cond ((numberp x) (princ-to-string x))        ((characterp x) (htmlify (princ-to-string x)))        ((stringp x) (if (html-string? x) x (htmlify x)))        ((eq 'unknown x) "")        ((symbolp x) (htmlify (make-pretty-string x)))        (t "")));;;;(defun make-pretty-string (sym)  (let ((str (symbol-name sym)))    (cond ((some #'lower-case-p str) (substitute #\space #\- (format nil "~A" str)))          (t (substitute #\space #\- (format nil "~:(~A~)" str))))))(defun make-readable-string (sym)  (let ((str (symbol-name sym)))    (cond ((string= str "") "")          ;((char= (elt str 0) #\|) str)          (t (substitute #\space #\- (format nil "~:(~A~)" str))))))(defun html-string? (str)  (declare (type string str))  (or (startstringp "<>" str)      (startstringp "<HTML>" str)      (startstringp "<A HREF" str)      (startstringp "<PRE>" str)      (startstringp "<IMG SRC" str)));;;;(defun urlify (s)  (unless (stringp s) (setq s (princ-to-string s)))  (with-output-to-string (o)    (do ((i 0 (1+ i)) (c) (n (length s)))        ((= i n) o)        (setq c (elt s i))        (cond ((alphanumericp c) (write-char c o))              ((find c '(#\$ #\- #\_ #\. #\+) :test #'char=) (write-char c o))              (t (format o "%~:@(~2,'0x~)" (char-code c)))))))(defun htmlify (str)  (with-output-to-string (s)    (do ((i 0 (1+ i)) (n (length str)) (c))        ((= i n))        (setq c (elt str i))        (cond ((eql c #\") (format s "&quot;"))              ((eql c #\&) (format s "&amp;"))              ((eql c #\>) (format s "&gt;"))              ((eql c #\<) (format s "&lt;"))              (t (write-char c s))))))(defun translate-html-chars (str)  "Translate &quot; -> \", &amp; -> &, &gt; -> >, &lt; -> <, &#XX; -> <??>"  (declare (type string str))  (loop      with translations =	'(("amp" . "&") ("gt" . ">") ("lt" . "<") ("quot" . "\""))      with already-seen = 0      with html-ex-chr      with trans-char      for start = (position #\& str :start already-seen)      for end = (when start (position #\; str :start start))      while (and start end)      do (setq html-ex-chr (subseq str (1+ start) end))	 (setq trans-char	   (find html-ex-chr translations :key #'first :test #'string=) )	 (cond	  (trans-char	   (setq trans-char (rest trans-char))	   (setq str	     (concatenate 'string	       (subseq str 0 start) trans-char (subseq str (1+ end)) )))	  ((string= html-ex-chr ""))	  ((and (eql (elt html-ex-chr 0) #\#)		(not (find-if-not #'digit-char-p (subseq html-ex-chr 1))) )	   (setq str	     (concatenate 'string	       (subseq str 0 start)	       (string (code-char (read-from-string (subseq html-ex-chr 1))))	       (subseq str (1+ end)) ))))	 (setq already-seen (1+ start))      finally (return str) ))(defun output-kif (s kif)  (format s "<PRE>~%")  (format s "~A~%" (kif-to-html-string kif))  (format s "</PRE>")  (format s "~%") )(defun kif-to-html-string (kif)  (let ((*print-pretty* t))    (htmlify     (format nil "~A" (downcase-except-strings kif)))))(defun downcase-except-strings (obj)  (cond ((stringp obj) (concatenate 'string (string #\") obj (string #\")))        ((symbolp obj) (string-downcase (symbol-name obj)))        ((listp obj) (mapcar #'downcase-except-strings obj))        (t obj)));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Miscellaneous;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(defun slots-of-class (class)  (declare (type symbol class))  (finds '?s `(slot ,class ?s) *interface*))(defun queryable-slots (class)  (declare (type symbol class))  (remove-if #'(lambda (s) (findp `(noquery ,class ,s) *interface*))             (finds '?s `(slot ,class ?s) *interface*)))(defun displayable-slots (class)  (declare (type symbol class))  (remove-if #'(lambda (s)                 (or (findp `(nodisplay ,class ,s) *interface*)                     (findp `(style ,s password) *interface*)))             (finds '?s `(slot ,class ?s) *interface*)))(defun sortable-slots (class)  (declare (type symbol class))  (remove-if #'(lambda (s)                 (or (findp `(nosort ,class ,s) *interface*)                     (findp `(style ,s password) *interface*)))             (finds '?s `(slot ,class ?s) *interface*)))(defun inspectable-slots (class)  (declare (type symbol class))  (remove-if #'(lambda (s)                 (or (findp `(noinspect ,class ,s) *interface*)                     (findp `(style ,s password) *interface*)))             (finds '?s `(slot ,class ?s) *interface*)))(defun modifiable-slots (class)  (remove-if #'(lambda (s) (findp `(or (nomodify ,class ,s) (noupdate ,*gui* ,s)) *interface*))             (finds '?s `(slot ,class ?s) *interface*)))(defun uniquep (slot class)  (findp `(or (functional ,slot yes) (unique ,class ,slot)) *interface*))(defun subframep (slot)  (findp `(and (range ,slot ?c) (slot ?c ?s) (unprovable (noquery ?c ?s)))         *interface*))(defun arity-of-relation (relation)  (cond ((findx '?x `(arity ,relation ?x) *interface*))        ((find relation *relations*) 2)        (t 0)))(defun columns (relation)  (finds '?x `(column ,relation ?x) *interface*))(defun string-slot-p (slot)  (find (findx '?x `(style ,slot ?x) *interface*)        '(stringfield text textarea password)))(defun find-documentation (concept)  (findx '?doc `(documentation ,concept ?doc) *interface*))(defun find-subclasses (class)  (finds '?c `(ako ?c ,class) *interface*))(defun find-subrelations (class)  (finds '?c `(aro ?c ,class) *interface*));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; gui.lisp;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(defun find-page (interface)  (or (findx '?x `(page ,interface ?x) *interface*) ""))(defun html-message (s info)  (output-header s "Message")  (format s "<P>~A<P>" info)  (output-footer s))(defun http-problem (s info)  (output-prolog s 200)  (output-header s "Error")  (format s "<P>~A<P>" info)  (output-footer s))(defun process-more (s *postlines*)  (let (class slots aspect kif sorter order start end objects count)    (output-prolog s 200)    (output-header s "Result")    (setq class (read-value-string (cdr (pop *postlines*))))    (setq aspect (read-value-string (cdr (pop *postlines*))))    (setq kif (read-from-string (cdr (pop *postlines*))))    (when (setq sorter (convert-sorters))      (setq order (cadar sorter) sorter (caar sorter)))    (setq start (read-value-string (getf-post "Start" *postlines*)))    (setq end (read-value-string (getf-post "Solutions" *postlines*)))    (setq objects (request `(ask-all ,aspect ,kif) *client* *agent*))    (unless (viewablep *client* (gensym))      (setq objects (remove-if-not #'(lambda (x) (viewablep *client* x)) objects)))    (setq count (length objects))    (cond ((not (integerp start)) (setq start 1))          ((< start 1) (setq start 1)))    (cond ((not (integerp end)) (setq end count))          ((< end 1) (setq end (min count 20)))          ((> end count) (setq end count)))    (when (< end start) (setq end start))    (when sorter (setq objects (sortem objects sorter order)))    (cond ((and (= start 1) (= end count)))          ((> start count) (setq objects nil))          (t (setq objects (subseq objects (1- start) end))))    (setq slots (displayable-slots class))    (cond ((= count 0) (display-failure s aspect kif))          ((and (= count 1) (= (length slots) 1) (functionalp (car slots)))           (display-class s class slots objects count start end))          (t (display-class s class slots objects count start end)             (output-more-commands s class aspect kif sorter order count start end)))    (output-footer s)))(defun output-more-commands (s class aspect kif sorter order count start end)  (cond ((and (= start 1) (= end count)))        ((> count end) (setq start (1+ end) end (min count (+ end 20))))        (t (setq start 1 end (min count 20))))  (format s "<FORM ACTION=MORE? METHOD=POST>" (addressify class))  (format-hidden s "Class" (prettify class))  (format-hidden s "Aspect" (prettify aspect))  (format-hidden s "Kif" (htmlify (prin1-to-string kif)))  (format-hidden s "Sorter" (prettify sorter))  (format-hidden s "Order" (prettify order))  (format-button s "Command" "Display")  (format s " answers ")  (format-text s "Start" (princ-to-string start) 5)  (format s " through ")  (format-text s "Solutions" (princ-to-string end) 5)  (format s "</FORM>"))(defun rulify-frame (s *postlines*)  (let (aspect old kif class (*var-count* 0))    (output-prolog s 200)    (output-header s "Save Rule")    (setq aspect (first-aspect *postlines*))    (setq old (read-value-string (cdar *postlines*)))    (setq kif (convert-frame))    (setq class (read-value-string (getf-post "Class" *postlines*)))    (cond ((not class) (format s "<P>Bad class name.<P>"))          (t (dolist (rule (rules `(<= (isa ,aspect ,class) ,kif)))               (save rule *library*))             (save `(isa ,class class) *interface*)             (dolist (slot (displayable-slots old))               (save `(slot ,class ,slot) *interface*))             (save `(frame ,*gui* ,class) *interface*)             (format s "<P>Done.<P>")))    (output-footer s)));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; concepts.lisp;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(defun lessp (x y)  (cond ((numberp x)         (cond ((numberp y) (< x y))               ((null y))               ((or (characterp y) (stringp y) (symbolp y))                (string< (princ-to-string x) y))))        ((null x) nil)        ((or (characterp x) (stringp x) (symbolp x))         (cond ((numberp y) (string< x (princ-to-string y)))               ((null y))               ((or (characterp y) (stringp y) (symbolp y)) (string< x y))))))(defun greaterp (x y)  (cond ((numberp x)         (cond ((numberp y) (> x y))               ((null y))               ((or (characterp y) (stringp y) (and y (symbolp y)))                (string> (princ-to-string x) y))))        ((null x) nil)        ((or (characterp x) (stringp x) (and x (symbolp x)))         (cond ((numberp y) (string> x (princ-to-string y)))               ((null y))               ((or (characterp y) (stringp y) (symbolp y)) (string> x y))))))(defun find-domain (relation)  (findx '?v `(domain ,relation ?v) *interface*))(defun find-range (relation)  (findx '?v `(range ,relation ?v) *interface*))(defun find-options (relation)  (let (class options)  (cond ((finds '?v `(option ,relation ?v) *interface*))        ((and (setq class (find-range relation))              (setq options (request `(ask-all ?x (isa ?x ,class))                                     *client* *gui*)))         (cons 'unknown (sort options #'lessp)))        (t (list 'unknown)))))(defun find-checkbox-options (relation)  (let (class options)    (cond ((finds '?v `(option ,relation ?v) *interface*))          ((and (setq class (find-range relation))                (setq options (request `(ask-all ?x (isa ?x ,class))                                       *client* *gui*)))           (sort options #'lessp)))))(defun find-references (slot value)  (let (aporels (*var-count* 0))    (setq aporels (finds '?x `(aporel ,slot ?x) *interface*))    (do ((l (nreverse aporels) (cdr l)) (vl) (nl))        ((null l) (prorequest `(ask-one ,vl ,(maksand (nreverse nl)))))        (setq nl (cons (list (car l) value (setq value (genvar))) nl))        (setq vl (cons value vl)))))(defun find-components (slot value references)  (let (aporels)    (setq aporels (finds '?x `(aporel ,slot ?x) *interface*))    (do ((l references (cdr l)) (m aporels (cdr m)))        ((null l))        (if (equalp (car l) value) (return (find-args (car m) value))))))(defun find-args (relation value)  (sort (request `(ask-all ?x ,(list relation '?x value)) *client* *gui*) #'lessp))(defun newrefs (value refs)  (cond ((null refs) (list value))        ((equalp value (car refs)) (list (car refs)))        (t (cons (car refs) (newrefs value (cdr refs))))))(defun find-input-string (relation)  (let ((default (find-input relation)))    (if default (prettify default) "")))(defun find-input (relation)  (deval (findx '?v `(input ,relation ?v) *interface*)))(defun find-inputs (relation)  (mapcar #'deval (finds '?v `(input ,relation ?v) *interface*)))(defun find-default-string (relation)  (let ((default (find-default relation)))    (if default (prettify default) "")))(defun find-default (relation)  (deval (findx '?v `(default ,relation ?v) *interface*)))(defun find-defaults (relation)  (mapcar #'deval (finds '?v `(default ,relation ?v) *interface*)))(defun deval (val)  (cond ((atom val) val)        (t (ignore-errors (eval val)))));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; other.lisp;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(defun readas (str type)  (cond ((eq type 'string) str)        ((eq type 'date) (parsedate str))        ((eq type 'time) (parsetime str))        (t (read-user-string (substitute #\- #\space str)))))(defun read-value-string (str)  (cond ((stringablep str) (read-user-string str))        (t (read-user-string (substitute #\- #\space str)))))(defun read-user-string (str)  (declare (type string str))  (ignore-errors (read-from-string str nil nil)))(defun hyphenize (str)  (with-output-to-string (out)    (do ((i (find-nonwhite str 0 (length str))) (n (length str)))        ((>= i n) nil)        (cond ((not (whitep (elt str i)))               (write-char (elt str i) out) (setq i (1+ i)))              ((< (setq i (find-nonwhite str i n)) n)               (write-char #\- out))              (t (return t))))))(defun find-nonwhite (str pos len)  (do ((i pos (1+ i)))      ((>= i len) len)      (unless (whitep (elt str i)) (return i))))(defun stringablep (str)  (do ((i 0 (1+ i)) (n (length str)))      ((>= i n) nil)      (cond ((char-equal (elt str i) #\space))            ((char-equal (elt str i) #\") (return t))            (t (return nil)))))(defun menu-size (num-of-items)  (declare (type (integer 0 *) num-of-items))  (min 15       (max (truncate (/ num-of-items 40))	    (min 5 num-of-items) )))(defun read-from-post-data (name post-lines)  (declare (type string name))  (declare (type list post-lines))  (let ((data (getf-post name post-lines)))    (when (stringp data)      (read-user-string data) )))(defun getf-post (item postlines)  (cdr (assoc item postlines :test #'string-equal)))(defun getslots (slotname pl)  (do ((l pl (cdr l)) (slots))      ((or (null l) (string= (caar l) slotname)) (values (nreverse slots) l))      (setq slots (cons (caar l) slots))))(defun getvals (slotname pl)  (do ((l pl (cdr l)) (values))      ((or (null l) (not (string= (caar l) slotname))) (values (nreverse values) l))      (if (not (string= (cdar l) "")) (setq values (cons (cdar l) values)))))(defun getvalues (slotname pl)  (do ((l pl (cdr l)) (values))      ((or (null l) (not (string= (caar l) slotname))) (values (nreverse values) l))      (unless (string= (cdar l) "")        (setq values (cons (read-value-string (cdar l)) values)))))(defun popvals (slotname pl)  (do ((l pl (cdr l)))      ((or (null l) (not (string= (caar l) slotname))) l)))(defun getallvals (slotname pl)  (do ((l pl (cdr l)) (nl))      ((null l) (nreverse nl))      (when (string-equal (caar l) slotname) (setq nl (cons (cdar l) nl)))))(defun getf-revname (postlines)  (let ((dum (assoc "Command" postlines :test #'startstringp)))    (when dum (subseq (car dum) 8))))(defun getf-expname (postlines)  (let ((dum (assoc "Expand" postlines :test #'startstringp)))    (when dum (subseq (car dum) 7))));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; parse.lisp;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(defun datep (x)  (and (symbolp x)       (> (length (setq x (symbol-name x))) 6)       (digitp (elt x 0))       (digitp (elt x 1))       (char= (elt x 2) #\/)       (digitp (elt x 3))       (digitp (elt x 4))       (char= (elt x 5) #\/)       (not (find-if-not #'digitp x :start 6))))(defun parsedate (input)  (let (slash1 slash2 part1 part2 part3)    (setq input (remove #\| input))    (setq slash1 (or (position #\/ input) (position #\- input)))    (setq slash2      (or (position #\/ input :from-end t) (position #\- input :from-end t)))    (unless slash1 (return-from parsedate nil) )    ;; Separate parts    (setq part1 (subseq input 0 slash1))    (cond ((and slash2 (< slash1 slash2))	   (setq part2 (subseq input (1+ slash1) slash2))	   (setq part3 (subseq input (1+ slash2))))          (t (setq part2 (subseq input (1+ slash1)))	     (setq part3 (format nil "~D" (current :year)))))    ;; String -> Integer    (if (or (string= part1 "") (find-if-not #'digit-char-p part1) )	(setq part1 (current :month))        (setq part1 (parse-integer part1)) )    (if (or (string= part2 "") (find-if-not #'digit-char-p part2) )	(setq part2 (current :date))        (setq part2 (parse-integer part2)) )    (if (or (string= part3 "") (find-if-not #'digit-char-p part3) )	(setq part3 (current :year))        (setq part3 (parse-integer part3)) )    ;; Year abbreviation    (cond ((< part3 50) (setq part3 (+ part3 2000)))          ((< part3 100) (setq part3 (+ part3 1900))))        ;; Bounds checking    (when (or (< part1 1) (> part1 12)) (setq part1 (current :month)))    (when (or (< part2 1) (> part2 31)) (setq part2 (current :date)))    (when (or (< part3 1900) (> part3 2100)) (setq part3 (current :year)))    (intern (format nil "~2,'0D/~2,'0D/~4,'0D" part1 part2 part3))))(defun parseminute (s)  (intern (strappend "MINUTE." (princ-to-string (parsetime s)))))(defun parsetime (s)  (let (old pos hour minute)    (setq s (remove-if #'whitep s) old 0)    (cond ((setq pos (position #\: s))           (setq hour (parseinteger s 0 pos) old (1+ pos))           (cond ((setq pos (findnondigit s old))                  (setq minute (parseinteger s old pos) old pos))                 (t (setq minute 0 old nil))))          ((setq pos (findnondigit s old))           (setq hour (parseinteger s old pos) old pos minute 0))          (t (setq hour 0 old nil minute 0)))    (when (and old (<= hour 12) (find (elt s old) '(#\p #\P)))      (setq hour (+ hour 12)))    (+ (* hour 60) minute)))(defun parseinteger (s start end)  (cond ((= start end) 0)        (t (parse-integer s :start start :end end))))(defun findnondigit (s old)  (do ((i old (1+ i)) (n (length s)))      ((= i n) nil)      (when (not (digitp (elt s i))) (return i))))(defun prettifytime (time)  (let ((hour (floor time 60)) (minute (mod time 60)))    (cond ((<= hour 12) (format nil "~D:~2,'0D am" hour minute))          (t (format nil "~D:~2,'0D pm" (- hour 12) minute)))));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; kif.lisp;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(defun genvar (&optional (num nil))  (let (pname)    (unless num (setq num (1- (incf *var-count*))))    (setq pname (string-upcase (format nil "~26R" num)))    (setq pname (map 'string #'radix-to-letters pname))    (intern (format nil "?_~A" pname))))(defun table-var ()  (intern (format nil "?_~A" (incf *var-count*))))(defun uservar ()  (intern (format nil "?V~A" (incf *var-count*))))(defun specvar (x)  (intern (format nil "?~A" x)))(defun radix-to-letters (chr)  (declare (type character chr))  (let ((code (char-code chr)))    (if (<= code (char-code #\9))	(code-char (+ (char-code #\A) (- code (char-code #\0))))      (code-char (+ code 10)) )));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; display.lisp;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(defun display-result (s aspect results count start end)  (cond ((= count 1) (format s "<P>There is 1 viewable answer.<P>"))        (t (format s "<P>There are ~D viewable answers.  The following table shows answers ~A through ~A.<P>~%"                     count start end)))  (force-output s)  (show-table s aspect results))(defun display-none (s aspect kif)  (format s "<P>There are no viewable answers.~%")  (make-analyze-button s aspect kif))(defun show-table (s columns results)  (let ((nobasket (or (null results) (findp `(nocommand ,*gui* save) *interface*))))    (format s "<FORM ACTION=TUPLES? METHOD=POST>")    (format s "<CENTER>")    (showtable s columns results nobasket)    (format s "</CENTER><P>")    (force-output s)    (unless nobasket      (format s "<P>")      (format-button s "Command" "Save")      (format s "selected rows as relation")      (format-text s "Relation" "" 40)      (format-hidden s "Arity" (princ-to-string (length columns)))      (format-hidden s "Results" (htmlify (format nil "~S" results))))    (format s "</FORM>")))(defun showtable (s columns results nobasket)  (format s "<TABLE BORDER>")  (format s "<TR>")  (unless nobasket (format s "<TH></TH>"))  (dolist (column columns)    (format s "<TH>")    (output-doclink s column)    (format s "</TH>"))  (format s "</TR>")  (do ((l results (cdr l)) (i 1 (1+ i)))      ((null l))    (format s "<TR>")    (unless nobasket      (format s "<TH>")      (format-checkbox s (prettify i) "" nil)      (format s "</TH>"))    (loop      for item in (car l)      do (if (numberp item)           (format s "<TD ALIGN=RIGHT>")           (format s "<TD>"))      (output-value s item)      (format s "</TD>"))    (format s "</TR>"))  (format s "</TABLE>"))(defun display-cost (s)  (declare (special *account*))  (format s "<HR>~%")  (format s "The cost to answer this query: ")  (if (and (boundp '*account*)	   (integerp *account*) )      (format s "$~D.~D <EM>Fee waived</EM>"	      (truncate (/ *account* 100))	      (rem *account* 100) )    (format s "<EM>Unknown</EM>") )  (format s "<BR>~2%") )(defun make-pretty-variable (var)  (unless (symbolp var)    (return-from make-pretty-variable (make-pretty-string var)) )  (let ((var-name (symbol-name var)))    (cond ((string= var-name "") "")          ((eql (elt var-name 0) #\?)           (if (ignore-errors (eql (elt var-name 1) #\_))	     (format nil "<EM>~A</EM>" (make-pretty-string (subseq var-name 2)))	     (make-pretty-string (subseq var-name 1)) ))          (t (make-pretty-string var-name)))))(defun make-analyze-button (s aspect kif)  (declare (type stream s))  (declare (type (or symbol list) aspect))  (declare (type list kif))  (format s "<BR>")  (format s "<FORM ACTION=ANALYZE? METHOD=POST>")  (format-hidden s "ASPECT" (stringify aspect))  (format-hidden s "QUERY" (htmlify (format nil "~S" kif)))  (format s "<INPUT TYPE=SUBMIT VALUE=\"Analyze\"> zero answers.")  (format s "</FORM>"));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; class.lisp;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(defun display-class (s class slots objects count start end)  (let (lone?)    (cond ((= count 1)           (if (and (= (length slots) 1) (uniquep (car slots) class))               (setq lone? t)               (format s "<P>There is 1 viewable answer.<P>")))          (t (format s "<P>There are ~D viewable answers  The following table shows answers ~A through ~A.<P>"                     count start end)))    (force-output s)    (cond (lone? (show-lone-table s (first objects) (first slots)))          ((find :rows *interface-options*)           (show-row-table s class objects slots))          ((find :cols *interface-options*)           (show-col-table s objects slots))          ((>= (length slots) (length objects)) (show-col-table s objects slots))          (t (show-row-table s class objects slots)))))(defun display-failure (s aspect kif)  (format s "<P>There are no viewable answers.")  (make-analyze-button s aspect kif)  (format s "<P><DL><DT>TIPS to avoid zero answers:")  (format s "<DD>Do not supply or select values for all slots.")  (format s "<DD>Add more alternatives to menus.")  (format s "<DD>Add fewer alternatives to checkboxes.")  (format s "<DD>Do not check the \"Exact\" box for text items.")  (format s "<DD>Make sure your spelling is correct.")  (format s "</DL><P>"))(defun sortem (objects sorter order)  (let (values)    (setq values (request `(ask-all (?x ?y) (and (oneof ?x . ,objects)                                                 ,(list sorter '?x '?y)))                          *client* *agent*))    (setq order (if (eq order 'ascending) #'lessp #'greaterp))    (mapcar #'car (sort (extracts objects values) order :key #'cadr))))(defun extracts (items answers)  (setq answers (cons nil answers))  (do ((l items (cdr l)) (nl))      ((null l) (nreverse nl))      (do ((m answers) (nm))          ((null (cdr m)) (setq nl (cons (cons (car l) (nreverse nm)) nl)))          (cond ((eql (car l) (caadr m))                 (setq nm (cons (cadadr m) nm))                 (rplacd m (cddr m)))                (t (setq m (cdr m)))))))(defun show-lone-table (s object slot)  (declare (type stream s))  (declare (type symbol object slot))  (let (html)    (setq html (request `(ask-one ?html (,slot ,object ?html)) *client* *agent*))    (format s "<CENTER>")    (when (stringp html) (format s html))    (format s "</CENTER><P>")))(defun show-row-table (s class items slots)  (let ((results (request `(ask-table ,items ,slots) *client* *agent*))        (nohandle (findp `(nodisplay ,class handle) *interface*))        (nobasket (or (null items) (findp `(nocommand ,*gui* save) *interface*))))    (format s "<FORM ACTION=SAVE? METHOD=POST>")    (format s "<CENTER><TABLE BORDER>")    (format s "<TR>")    (unless nobasket (format s "<TH></TH>"))    (unless nohandle (format s "<TH>ID</TH>"))    (dolist (slot slots)      (format s "<TH>")      (output-doclink s slot)      (format s "</TH>"))    (format s "</TR>")    (do ((l items (cdr l)) (m results (cdr m)))        ((null l))        (format s "<TR>")        (unless nobasket          (format s "<TH>")          (format-checkbox s (prettify (car l)) "" nil)          (format s "</TH>"))        (unless nohandle          (format s "<TH>")          (output-value s (car l))          (format s "</TH>"))        (loop for vals in (car m)	      do (setq vals (remove 'unknown vals))              (if (every #'(lambda (val) (numberp val)) vals)                (format s "<TD ALIGN=RIGHT>")                (format s "<TD>") )              (loop                for val in vals                for first-time = t then nil                unless first-time                do (format s ", ")                do (output-value s val))              (format s "</TD>"))        (format s "</TR>"))    (format s "</TABLE></CENTER>")    (force-output s)    (unless nobasket      (format s "<P>")      (format-button s "Command" "Save")      (format s "selected results in class")      (format-text s "Class" "" 40)      (format s "<P>")      (format-button s "Command" "Drop")      (format s "selected results from class")      (format-text s "Class" "" 40)      (format-hidden s "Items" (format nil "~S" items))      (format-hidden s "Slots" (format nil "~S" slots))      (format-hidden s "Results" (htmlify (format nil "~S" results))))    (format s "</FORM>")))(defun show-col-table (s items slots)  (format s "<CENTER><TABLE BORDER>")  (loop      initially (format s "<TR><TH>ID</TH>")      for item in items      do (format s "<TH><FONT SIZE=-1><A HREF=\"INSPECT?Object=~A\">~A</A></FONT></TH>"		 (addressify item) (prettify item))      finally (format s "</TR>"))  (loop      with data = (invert-table                    (request `(ask-table ,items ,slots) *client* *agent*))      for slot in slots      do (format s "<TR><TD>")         (output-doclink s slot)         (format s "</TD>")         (loop	    for vals in (car data)	    do (setq vals (remove 'unknown vals))	       (if (every #'numberp vals)		   (format s "<TD ALIGN=\"RIGHT\">")		   (format s "<TD>") )	       (loop		   for val in vals		   for first-time = t then nil		   unless first-time		   do (format s ", ")		   do (output-value s val))	       (format s "</TD>"))         (setq data (cdr data))	 (format s "</TR>"))  (format s "</TABLE></CENTER>"))      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Analyze;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(defun process-analyze (s post-lines)  (output-prolog s 200)  (output-header s "Analyze Query")  (let ((aspect (read-from-post-data "ASPECT" post-lines)) query)    (setq query (read-user-string (getf-post "QUERY" post-lines)))    (format s "<P>The query")    (output-kif s (list 'ask-all aspect query))    (format s "resulted in zero matches.<P><HR>")    (unless (find (first query) '(and or))      (format s "<P>Further analysis is possible only for compound (AND/OR) queries.")      (output-footer s)      (return-from process-analyze))    (format s "<DL>")    (loop	for conjunct in (rest query)	for num =	  (request `(length (ask-all ,aspect ,conjunct)) *client* *agent*)	do (format s "<DT>")           (output-kif s conjunct)	   (if (numberp num)	       (format s "<DD> ...matches ~D object~:P." num)	       (format s "<DD> ...matches no objects.")))    (format s "</DL>"))  (output-footer s))(defun print-table (s table)  (format s "<P><CENTER><TABLE BORDER>")  (dolist (row table)    (format s "<TR>")    (dolist (col row)      (format s "<TD>")      (output-value s col)      (format s "</TD>"))    (format s "</TR>"))  (format s "</TABLE></CENTER><P>"))(defun output-menu (s slot options values)  (format s "<SELECT NAME=\"~A\" SIZE=~D MULTIPLE>"          (stringify slot) (menu-size (length options)))  (dolist (option options)    (if (member option values :test #'equalp)        (format s "<OPTION SELECTED>~A~%" (stringify option))        (format s "<OPTION>~A~%" (stringify option))))  (format s "</SELECT>"))(defun output-selector (s slot options value)  (format s "<SELECT NAME=\"~A\">" (stringify slot))  (dolist (option options)    (if (equalp option value)        (format s "<OPTION SELECTED>~A~%" (stringify option))        (format s "<OPTION>~A~%" (stringify option))))  (format s "</SELECT>"))(defun output-checkboxes (s slot options values)  (format s "<DL>")  (dolist (option options)    (format s "<DT>")    (format-checkbox s (stringify slot) (stringify option)                     (member option values :test #'equalp)))  (format s "</DL>"))(defun output-radiobuttons (s slot options value)  (when options    (format s "<DL>")    (format s "<DT>")    (format-radiobutton s (stringify slot) (stringify (car options))                        (equal (car options) value))    (dolist (option (cdr options))      (format s "<DT>")      (format-radiobutton s (stringify slot) (stringify option)                          (equal option value)))    (format s "</DL>")))(defun print-acl (s acl)  (let ((*print-case* :downcase) (*print-pretty* t))    (format s "~S" acl)))(defun format-text (s name value size)  (if (string= value "")      (format s "<INPUT TYPE=TEXT NAME=\"~A\" SIZE=\"~A\">" name size)      (format s "<INPUT TYPE=TEXT NAME=\"~A\" VALUE=\"~A\" SIZE=~A>"              name value size)))(defun format-textarea (s name text rows cols)  (format s "<TEXTAREA NAME=~A ROWS=~A COLS=~A WRAP=SOFT>" name rows cols)  (format s text)  (format s "</TEXTAREA>"))(defun format-simple-button (s value)  (format s "<INPUT TYPE=SUBMIT VALUE=\"~A\">" value))(defun format-button (s name value)  (format s "<INPUT TYPE=SUBMIT NAME=\"~A\" VALUE=\"~A\">" name value))(defun format-radiobutton (s name value checked)  (if checked      (format s "<INPUT TYPE=RADIO NAME=\"~A\" VALUE=\"~A\" CHECKED>~A"              name value value)      (format s "<INPUT TYPE=RADIO NAME=\"~A\" VALUE=\"~A\">~A"              name value value)))(defun format-checkbox (s name value checked)  (if checked    (format s "<INPUT TYPE=CHECKBOX NAME=\"~A\" VALUE=\"~A\" CHECKED>~A"            name value value)    (format s "<INPUT TYPE=CHECKBOX NAME=\"~A\" VALUE=\"~A\">~A"            name value value)))(defun format-password (s name value)  (format s "<INPUT TYPE=PASSWORD NAME=~A VALUE=\"~A\" SIZE=40>" name value))(defun format-hidden (s name value)  (format s "<INPUT TYPE=HIDDEN NAME=\"~A\" VALUE=\"~A\">" name value));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; functions.lisp;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(defun prorequest (msg)  (let ((log))    (if (and (listp msg) (find (car msg) '(tell untell))             (setq log (findx '?log `(logfile ,*gui* ?log) *interface*)))        (logmessage `(request ',msg ',(name *client*) ',(name *agent*)) log))    (request msg *client* *agent*)))(defun promessage (msg)  (let ((log))    (if (and (listp msg) (find (car msg) '(tell untell))             (setq log (findx '?log `(logfile ,*gui* ?log) *interface*)))        (logmessage `(message ',msg ',(name *client*) ',(name *agent*)) log))    (message msg *client* *agent*)))(defun logmessage (msg fn)  (with-open-file    (log fn :direction :io :if-exists :append :if-does-not-exist :create)    (prin1 msg log)    (terpri log)));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; A little something to show the class hierarchy;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(defun showframes (interface)  (if (stringp interface) (setq interface (read-value-string interface)))  (format *stream* "</XMP>")  (output-frames *stream* interface))(defun output-frames (s interface)  (do ((l (find-frames interface) (cdr l)))      ((null l))      (format s "<DD>")      (output-classes s (car l))))(defun showclasses (class)  (if (stringp class) (setq class (read-value-string class)))  (format *stream* "</XMP>")  (output-classes *stream* 'thing))(defun output-classes (s class)  (format s "<DL><DT>")  (output-value s class)  (crlf s)  (do ((l (find-subclasses class) (cdr l)))      ((null l))      (format s "<DD>")      (output-classes s (car l)))  (format s "</DL>")  (crlf s));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;