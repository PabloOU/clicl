(defmethod chains (p)  (let (universals alist alluniversals)    (setq universals (freevars p))    (poschains p)))(defun poschains (p)  (cond ((atom p) (cond ((eq 'true p) nil)                        ((eq 'cut p) nil)			((eq 'false p) (list nil))			(t (list (list p)))))	((eq 'not (car p)) (negposchains (cadr p)))	((eq 'and (car p)) (poschainsand p))	((eq 'or (car p)) (poschainsor p)) 	((eq 'xor (car p)) (negposchainsboth p))	((eq '=> (car p)) (poschainsforward p))	((eq '<= (car p)) (poschainsbackward p))	((eq '<=> (car p)) (poschainsboth p))	((eq 'forall (car p)) (poschainsforall p))	((eq 'exists (car p)) (poschainsexists p))	(t (list (list (poschainsexp p))))))(defun poschainsand (p)  (poschainsands (cdr p)))(defun poschainsands (l)  (cond ((null l) nil)	(t (conjoin (poschains (car l)) (poschainsands (cdr l))))))(defun poschainsor (p)  (poschainsors (cdr p)))(defun poschainsors (l)  (cond ((null l) (list nil))	(t (disjoin (poschains (car l)) (poschainsors (cdr l))))))(defun poschainsforward (p)  (cond ((null (cdr p)) (list nil))	(t (poschainsforwards (cdr p)))))(defun poschainsforwards (l)  (cond ((null (cdr l)) (poschains (car l)))	(t (disjoin (negposchains (car l)) (poschainsforwards (cdr l))))))(defun poschainsbackward (p)  (cond ((null (cdr p)) (list nil))	(t (disjoin (poschains (cadr p)) (negposchainsands (cddr p))))))(defun poschainsboth (p)  (cond ((null (cdr p)) (list nil))	((null (cddr p)) (poschains (cadr p)))	(t (conjoin (disjoin (poschains (cadr p)) (negposchains (caddr p)))                      (disjoin (negposchains (cadr p)) (poschains (caddr p)))))))(defun poschainsexists (p)  (let ((alist alist))    (addexist (cadr p))    (poschains (caddr p))))(defun poschainsforall (p)  (let ((universals universals) (alist alist))    (adduniv (cadr p))    (poschains (caddr p))))(defun negposchains (p)  (cond ((atom p) (cond ((eq 'true p) (list nil))                        ((eq 'cut p) (list nil))			((eq 'false p) nil)			(t (list (list (maknot p))))))	((eq 'not (car p)) (poschains (cadr p)))	((eq 'and (car p)) (negposchainsand p))	((eq 'or (car p)) (negposchainsor p)) 	((eq 'xor (car p)) (poschainsboth p))	((eq '=> (car p)) (negposchainsforward p))	((eq '<= (car p)) (negposchainsbackward p))	((eq '<=> (car p)) (negposchainsboth p))	((eq 'exists (car p)) (negposchainsexists p))	((eq 'forall (car p)) (negposchainsforall p))	(t (list (list (maknot (poschainsexp p)))))))(defun negposchainsor (p)  (negposchainsors (cdr p)))(defun negposchainsors (l)  (cond ((null l) nil)	(t (conjoin (negposchains (car l)) (negposchainsors (cdr l))))))(defun negposchainsand (p)  (negposchainsands (cdr p)))(defun negposchainsands (l)  (cond ((null l) (list nil))	(t (disjoin (negposchains (car l)) (negposchainsands (cdr l))))))(defun negposchainsforward (p)  (cond ((null (cdr p)) nil)	(t (negposchainsforwards (cdr p)))))(defun negposchainsforwards (l)  (cond ((null (cdr l)) (negposchains (car l)))	(t (conjoin (poschains (car l)) (negposchainsforwards (cdr l))))))(defun negposchainsbackward (p)  (cond ((null (cdr p)) nil)        (t (conjoin (negposchains (cadr p)) (poschainsands (cddr p))))))(defun negposchainsboth (p)  (cond ((null (cdr p)) nil)	((null (cddr p)) (negposchains (cadr p)))	(t (disjoin (conjoin (negposchains (cadr p)) (poschains (caddr p)))                     (conjoin (poschains (cadr p)) (negposchains (caddr p)))))))(defun negposchainsexists (p)  (let ((universals universals) (alist alist))    (adduniv (cadr p))    (negposchains (caddr p))))(defun negposchainsforall (p)  (let ((alist alist))    (addexist (cadr p))    (negposchains (caddr p))))(defun poschainsexp (p)  (cond ((varp p) (cond ((cdr (assoc p alist :test #'eq))) (t p)))	((atom p) p)        ((eq 'quote p) p)	((member (car p) '(forall exists) :test #'eq)	 (let ((alist alist))	   (addbag (cadr p))	   (list (car p) (poschainsexp (cadr p)) (poschainsexp (caddr p)))))	(t (mapcar #'poschainsexp p))))(defun conjoin (l m)  (cond ((null l) m)	((null m) l)	(t (let (nl)             (do ((ll l (cdr ll)))                 ((null ll))                 (unless (find (car ll) m :test #'superchainp)                   (setq nl (cons (car ll) nl))))             (do ((ml m (cdr ml)))                 ((null ml))                 (unless (find (car ml) nl :test #'superchainp)                   (setq nl (cons (car ml) nl))))             (nreverse nl)))))(defun disjoin (c d)  (cond ((or (null c) (null d)) nil)	(t (do ((l c (cdr l)) (res))	       ((null l) (nreverse res))	       (do ((m d (cdr m)))		   ((null m))		   (setq res (addchain (unionidentp (car l) (car m)) res)))))))(defun addchain (x l)  (do ((m l (cdr m)) (nl))      ((null m) (cons x (nreverse nl)))      (cond ;((subchainp x (car m)))            ;((subchainp (car m) x) (return l))            (t (setq nl (cons (car m) nl))))))(defun subchainp (c d)  (cond ((null c))        ((setq d (member (car c) d :test #'equalp)) (subchainp (cdr c) d))))(defun superchainp (c d)  (cond ((null d))        ((setq c (member (car d) c :test #'equalp)) (superchainp c (cdr d)))))