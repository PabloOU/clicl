<html>
<head>
<title>Herbrand Logic -- First-order Syntax and Herbrand Semantics</title>
<style>
	body {
		margin: 0px 0px 0px 0px;
		padding: 0px 0px 0px 0px;
		background: #DCCB8F;
	}
	#structure {
		margin: 8px 8px 8px 8px;
		border: 2px 2px 2px 2px;
		border-style: solid;
		border-color: gray;
		background: white;
		width: 98%
	}
	#navigation {
		border: 0px 0px 0px 0px;
	}
	td.whiteongreen {padding: 2px 2px 2px 2px; }
	#whiteongreen {background: #396F43; 
					color: white;}
	#whiteongreen a:link {color: white; text-decoration: none;}
	#whiteongreen a:visited {color: white; text-decoration: none;}
	#whiteongreen a:hover, a:active {color: white; text-decoration: underline;}
	
	#title {font: bold 30pt copperplate;
			align: center;}
	#nav { padding: 2px 4px 2px 4px;
		   	border-right: 2px solid white;}
	#nav1 { padding: 2px 4px 2px 4px;
		   	border-right: 2px solid white;
			border-left: 2px solid white; }
	#line { width: 70%;
			border-bottom: 1px solid white; }
	#overline { width: 70%;
				border-top: 1px solid gray;
				font-size: small; }
</style>
</head>
<body>
<table id="structure">
<tr><td id="whiteongreen">
	<div id="title">Herbrand Logic</div>
	<center>
	<table class="navigation">
	<tr>
	<td id="nav1"><a href="index.html">Overview</a></div>
	<td id="nav"><a href="herbrandlogic.html">Syntax and Semantics</a></div>
	<td id="nav"><a href="modeltheory-prooftheory.html">Proof and Model Theory</a></div>
	<td id="nav"><a href="goedel.html">Goedel</a></div>
	<td id="nav"><a href="applications.html">Applications</a></div>
	</tr></table></center>
</td></tr>
<tr><td>  




<h2>Syntax</h2>

<p>The syntax of Herbrand logic is exactly the same as for first-order logic.

<p><b>Definition (Vocabulary)</b>: A vocabulary V consists of:
<ul>
<li>A set of relation constants {r<sub>1</sub>, ..., r<sub>n</sub>}, each with an associated arity.
<li>A set of function constants {f<sub>1</sub>, ..., f<sub>m</sub>}, each with an associated arity.
<li>A non-empty set of object constants {c<sub>1</sub>, ..., c<sub>k</sub>}.
<li>A set of variables {x<sub>1</sub>,x<sub>2</sub>,...}.
</ul>

<p>For the sake of simplicity, we assume the set of constants in a vocabulary is finite.  A countable set of constants changes the wording of certain theorems, but conceptually nothing changes.   

<p><b>Definition (Term)</b>: A term in V:
<ul>
<li>A variable.
<li>An object constant.
<li>A function constant with arity n applied to n terms.
<li>Only expressions produced by the above rules are terms.
</ul>

<p><b>Definition (Sentence)</b>: A sentence in V:
<ul>
<li>A relation constant with arity n applied to n terms.
<li><img src="images/neg.gif"> <img src="images/phi.gif"> where <img src="images/phi.gif"> is a sentence.
<li><img src="images/phi.gif"> <img src="images/vee.gif"> <img src="images/psi.gif">, where <img src="images/phi.gif"> and <img src="images/psi.gif"> are sentences.
<li><img src="images/phi.gif"> <img src="images/wedge.gif"> <img src="images/psi.gif">, where <img src="images/phi.gif"> and <img src="images/psi.gif"> are sentences.
<li><img src="images/phi.gif"> <img src="images/Leftarrow.gif"> <img src="images/psi.gif">, where <img src="images/phi.gif"> and <img src="images/psi.gif"> are sentences.
<li><img src="images/phi.gif"> <img src="images/Rightarrow.gif"> <img src="images/psi.gif">, where <img src="images/phi.gif"> and <img src="images/psi.gif"> are sentences.
<li><img src="images/phi.gif"> <img src="images/Leftrightarrow.gif"> <img src="images/psi.gif">, where <img src="images/phi.gif"> and <img src="images/psi.gif"> are sentences.
<li><img src="images/forall.gif">x.<img src="images/phi.gif">, where <img src="images/phi.gif"> is a sentence.
<li><img src="images/exists.gif">x.<img src="images/phi.gif">, where <img src="images/phi.gif"> is a sentence.
<li>Only expressions produced by the above rules are sentences.
</ul>

<p>An <i>atom</i> is a sentence of the form p(t<sub>1</sub>,...,t<sub>n</sub>).  A <i>literal</i> is either an atom or the negation of an atom.  A <i>ground sentence</i> has no variables or quantifiers.  A <i>closed sentence</i> has no free variables, whereas an <i>open sentence</i> does have free variables.  We treat free variables in an open sentence as being implicitly universally quantified.

<h2>Semantics</h2>

<p>Herbrand logic differs from first-order logic solely in the structures it considers to be models.  The semantics of a given set of sentences is defined to be the set of Herbrand models that satisfy it, for a given vocabulary.

<p><b>Definition (Herbrand Model)</b>: A Herbrand model for vocabulary V is any set of ground atoms in V.

<!--
<p>Herbrand semantics allow one to determine whether a particular model satisfies a particular sentence by simply grounding the sentence, i.e. <img src="images/forall.gif"> and <img src="images/exists.gif"> range over the terms in V.

<p><b>Definition (Grounding)</b>: Consider the case of a closed sentence.  Let the ground terms in V be {t<sub>1</sub>,t<sub>2</sub>,...}.
<ul>
<li>Ground[p(u<sub>1</sub>,...,u<sub>n</sub>)] = p(u<sub>1</sub>,...,u<sub>n</sub>)
<li>Ground[<img src="images/forall.gif"> x.<img src="images/phi.gif">(x)] = Ground[<img src="images/phi.gif">(t<sub>1</sub>)] <img src="images/wedge.gif"> Ground[<img src="images/phi.gif">(t<sub>2</sub>)] <img src="images/wedge.gif"> ...
<li>Ground[<img src="images/exists.gif"> x.<img src="images/phi.gif">(x)] = Ground[<img src="images/phi.gif">(t<sub>1</sub>)] <img src="images/vee.gif"> Ground[<img src="images/phi.gif">(t<sub>2</sub>)] <img src="images/vee.gif"> ...
<li>Ground[<img src="images/neg.gif"> <img src="images/phi.gif">] = <img src="images/neg.gif"> Ground[<img src="images/phi.gif">]
<li>Ground[<img src="images/phi.gif"> <img src="images/wedge.gif"> <img src="images/psi.gif">] = Ground[<img src="images/phi.gif">] <img src="images/wedge.gif"> Ground[<img src="images/psi.gif">]
<li>Ground[<img src="images/phi.gif"> <img src="images/vee.gif"> <img src="images/psi.gif">] = Ground[<img src="images/phi.gif">] <img src="images/vee.gif"> Ground[<img src="images/psi.gif">]
<li>Ground[<img src="images/phi.gif"> <img src="images/Rightarrow.gif"> <img src="images/psi.gif">] = Ground[<img src="images/phi.gif">] <img src="images/Rightarrow.gif"> Ground[<img src="images/psi.gif">]
<li>Ground[<img src="images/phi.gif"> <img src="images/Leftarrow.gif"> <img src="images/psi.gif">] = Ground[<img src="images/phi.gif">] <img src="images/Leftarrow.gif"> Ground[<img src="images/psi.gif">]
<li>Ground[<img src="images/phi.gif"> <img src="images/Leftrightarrow.gif"> <img src="images/psi.gif">] = Ground[<img src="images/phi.gif">] <img src="images/Leftrightarrow.gif"> Ground[<img src="images/psi.gif">]
</ul>


<p>Notice that if there is at least one function, the number of terms is infinite, and the grounding of any sentence with quantifiers is an infinitely long expression.  Such expressions are not sentences in the logic, but serve only as a device for defining satisfaction.

<p>In the following definition, we use the convention <img src="images/wedge.gif"> <img src="images/psi.gif"><sub>i</sub> to mean a conjunction of sentences <img src="images/psi.gif"><sub>1</sub>,<img src="images/psi.gif"><sub>2</sub>,..., where the conjunction may be infinite.

-->

<p><b>Definition (Herbrand Satisfaction)</b>: Let <img src="images/phi.gif"> be a closed sentence
and M a Herbrand model in the vocabulary V.
<ul>
<li><img src="images/models.gif"><sub>M</sub> p(t<sub>1</sub>,...,t<sub>n</sub>) if and only if p(t<sub>1</sub>,...,t<sub>n</sub>) <img src="images/in.gif"> M.
<li><img src="images/models.gif"><sub>M</sub> <img src="images/neg.gif"> <img src="images/psi.gif"> if and only if <img src="images/notmodels.gif"><sub>M</sub> <img src="images/psi.gif">.
<li><img src="images/models.gif"><sub>M</sub> <img src="images/phi.gif"> <img src="images/wedge.gif"> <img src="images/psi.gif"> if and only if <img src="images/models.gif"><sub>M</sub> <img src="images/phi.gif"> and <img src="images/models.gif"><sub>M</sub> <img src="images/psi.gif">.
<li><img src="images/models.gif"><sub>M</sub> <img src="images/phi.gif"> <img src="images/vee.gif"> <img src="images/psi.gif"> if and only if <img src="images/models.gif"><sub>M</sub> <img src="images/phi.gif"> or <img src="images/models.gif"><sub>M</sub> <img src="images/psi.gif">.
<li><img src="images/models.gif"><sub>M</sub> <img src="images/phi.gif"> <img src="images/Rightarrow.gif"> <img src="images/psi.gif"> if and only if <img src="images/notmodels.gif"><sub>M</sub> <img src="images/phi.gif"> or <img src="images/models.gif"><sub>M</sub> <img src="images/psi.gif">.
<li><img src="images/models.gif"><sub>M</sub> <img src="images/phi.gif"> <img src="images/Leftarrow.gif"> <img src="images/psi.gif"> if and only if <img src="images/models.gif"><sub>M</sub> <img src="images/psi.gif"> <img src="images/Rightarrow.gif"> <img src="images/phi.gif">.
<li><img src="images/models.gif"><sub>M</sub> <img src="images/phi.gif"> <img src="images/Leftrightarrow.gif"> <img src="images/psi.gif"> if and only if either <img src="images/models.gif"><sub>M</sub> <img src="images/phi.gif"><img src="images/wedge.gif"><img src="images/psi.gif"> or <img src="images/models.gif"><sub>M</sub> <img src="images/neg.gif"><img src="images/phi.gif"> <img src="images/wedge.gif"> <img src="images/neg.gif"><img src="images/psi.gif">.
<li><img src="images/models.gif"><sub>M</sub> <img src="images/forall.gif">x.<img src="images/phi.gif">(x) if and only if <img src="images/models.gif"><sub>M</sub> <img src="images/phi.gif">(t) for all ground terms t in V.
<li><img src="images/models.gif"><sub>M</sub> <img src="images/exists.gif">x.<img src="images/phi.gif">(x) if and only if <img src="images/models.gif"><sub>M</sub> <img src="images/phi.gif">(t) for some ground term t in V. 
</ul>

<p>We always assume that satisfaction for a set of sentences <img src="images/Delta.gif"> is defined with respect to a vocabulary that includes all the constants and variables that appear in <img src="images/Delta.gif">.  Otherwise, a model might satisfy neither a sentence nor its negation.

<p><b>Definition (Herbrand Entailment)</b>: Let <img src="images/Delta.gif"> be a set of closed sentences and V a vocabulary that is a superset of the vocabulary of <img src="images/Delta.gif">.  Let <img src="images/phi.gif"> be a closed sentence. <img src="images/Delta.gif"> entails <img src="images/phi.gif"> with respect to vocabulary V if and only if every Herbrand model for V that satisfies <img src="images/Delta.gif"> also satisfies <img src="images/phi.gif">.<center> <img src="images/Delta.gif"> <img src="images/models.gif"> <img src="images/phi.gif"> wrt V if and only if <img src="images/models.gif"><sub>M</sub> <img src="images/Delta.gif"> <img src="images/Rightarrow.gif"> <img src="images/models.gif"><sub>M</sub> <img src="images/phi.gif">, where M is a model for V</center>


<h2>Examples</h2>

<p>The following sentence has two satisfying Herbrand models for the vocabulary {p, a, b}.
<ul>p(a)<br>
Models: {p(a)}, {p(a), p(b)}</ul>

<p>For the vocabulary {p, a}, there is only one satisfying model: {p(a)}.

<p>The following sentences are unsatisfiable for the vocabulary {p, a}.
<ul>p(a)<br>
	<img src="images/exists.gif">x.<img src="images/neg.gif"> p(x)<br>
</ul>
However, they are satisfiable for the vocabulary {p, a, b}.

<p>The dependence of satisfaction on a vocabulary is a little unusual.  To see why satisfaction is defined as it is, suppose instead of fixing the vocabulary up front (which defines the class of candidate models), we instead define satisfaction so that the vocabulary is gleamed from the sentences we are given.  Now consider the following axioms.
<ul>p(a)<br>
	<img src="images/neg.gif"> p(b)<br>
	<img src="images/exists.gif">x.<img src="images/neg.gif"> p(x)<br>
</ul>
This set of sentences is satisfied by the model {p(a), <img src="images/neg.gif"> p(b)} for vocabulary {p, a, b}.  But, if we were to drop out the <img src="images/neg.gif"> p(b) sentence, under the new definition of satisfaction, the vocabulary would be {p, a}, which as commented above is unsatisfiable.  That is, under this new definition of satisfaction, a set of sentences could be satisfiable, but a subset of those sentences could be unsatisfiable.  Clearly, that would cause havoc in proof procedures; by fixing the vocabulary up front, in this case to {p, a, b}, the satisfiability of a set of sentences ensures the satisfiability of every subset.


<p><center>
<div id="overline">
&copy; Copyright 2006 by 
<SCRIPT LANGUAGE="JavaScript" type="text/javascript">
<!--
var addr1 = "mailto:"
var addr2 = "thinrich"
var addr3 = "@"
var addr4 = "stanford.edu"
document.write( ' <A HREF=" ' + addr1 + addr2 + addr3 + addr4 + ' "> ' )
document.write ( ' Tim Hinrichs</A> ' )
//-->
</SCRIPT>
 and the Stanford Logic Group</div>
</center>
</td></tr></table>
</body>
</html>
