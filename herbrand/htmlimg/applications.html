<html>
<head>
<title>Herbrand Logic -- First-order Syntax and Herbrand Semantics</title>
<style>
	body {
		margin: 0px 0px 0px 0px;
		padding: 0px 0px 0px 0px;
		background: #DCCB8F;
	}
	#structure {
		margin: 8px 8px 8px 8px;
		border: 2px 2px 2px 2px;
		border-style: solid;
		border-color: gray;
		background: white;
		width: 98%
	}
	#navigation {
		border: 0px 0px 0px 0px;
	}
	td.whiteongreen {padding: 2px 2px 2px 2px; }
	#whiteongreen {background: #396F43; 
					color: white;}
	#whiteongreen a:link {color: white; text-decoration: none;}
	#whiteongreen a:visited {color: white; text-decoration: none;}
	#whiteongreen a:hover, a:active {color: white; text-decoration: underline;}
	
	#title {font: bold 30pt copperplate;
			align: center;}
	#nav { padding: 2px 4px 2px 4px;
		   	border-right: 2px solid white;}
	#nav1 { padding: 2px 4px 2px 4px;
		   	border-right: 2px solid white;
			border-left: 2px solid white; }
	#line { width: 70%;
			border-bottom: 1px solid white; }
	#overline { width: 70%;
				border-top: 1px solid gray;
				font-size: small; }
</style>
</head>
<body>
<table id="structure">
<tr><td id="whiteongreen">
	<div id="title">Herbrand Logic</div>
	<center>
	<table class="navigation">
	<tr>
	<td id="nav1"><a href="index.html">Overview</a></div>
	<td id="nav"><a href="herbrandlogic.html">Syntax and Semantics</a></div>
	<td id="nav"><a href="modeltheory-prooftheory.html">Proof and Model Theory</a></div>
	<td id="nav"><a href="goedel.html">Goedel</a></div>
	<td id="nav"><a href="applications.html">Applications</a></div>
	</tr></table></center>
</td></tr>
<tr><td>  



<p>Note: this page is still under construction.

<h2>Deductive Databases</h2>

<p>A database is a Herbrand model in a vocabulary without function constants, where only part of the vocabulary is known at any point in time.  The vocabulary is treated as unknown so that if at some point in time the model satisfies some sentence, then as long as the only updates to the model are additive, that sentence is still satisfied, i.e. databases are monotonic.

<p>For example, consider a simple database (Herbrand model).
<ul>{p(a), p(b), q(a)}</ul>
For the vocabulary {p, a, b}, this model satisfies the sentence <img src="images/forall.gif"> x.p(x). If later the sentence q(c) were added, the database would become
<ul>{p(a), p(b), q(a), q(c)}</ul>
Clearly, the universe for the model must include a,b,c which means that it no longer satisfies <img src="images/forall.gif"> x.p(x).  This is a nonmontonic result: adding knowledge causes previous answers to change.  

<p>By keeping the vocabulary and universe unknown, the original database does not satisfy <img src="images/forall.gif"> x.p(x) for the simple reason that the database <i>never</i> satisfies <img src="images/forall.gif"> x.p(x).  Since such a query is always false, database query languages do not allow one to ask universal queries.  Thus, answering a database query amounts to checking whether some sentence <img src="images/exists.gif"><sup>*</sup>.<img src="images/phi.gif">(x<sub>1</sub>,...,x<sub>n</sub>) is satisfied by the model, or more precisely, it amounts to finding all the x<sub>1</sub>,...,x<sub>n</sub> such that the model satisfies <img src="images/phi.gif">(x<sub>1</sub>,...,x<sub>n</sub>).

<p>Deductive databases use variants of Datalog to query a database.  Datalog is  a subset of first-order logic, which is quantifier free.  

<p><b>Definition (Datalog Rule)</b>: A Datalog rule is an implication (where :- is used instead of <img src="images/Leftarrow.gif"> and , is used in place of <img src="images/wedge.gif">, as is traditional).
<ul>h :- b<sub>1</sub>, b<sub>2</sub>, ..., b<sub>n</sub><br>
- h is an atom.<br>
- each b<sub>i</sub> is a literal.<br>
- there are no function constants.<br>
- every variable in a negative literal must appear in a positive literal in the body. <br>
- every variable in the head must appear in the body.<br>
</ul>

<p>Datalog is usually viewed as extending a database with a set of view definitions, but because Herbrand semantics allows for multiple models, it is inappropriate for extending a single model.  Two variations on Herbrand semantics are often used as the semantics for Datalog: minimal Herbrand semantics and stable model semantics.  We leave discussion of stable model semantics to the section on Prolog.

<p>If a set of Datalog rules has no negation, i.e. when every b<sub>i</sub> is an atom, it is Horn.  It is well-known that Horn rules have a well-defined minimal model (as measured by the number of ground atoms in the Herbrand model), and the semantics for such a set of rules is defined to be that model.  When the rules do include negation, the minimal model is not necessarily well-defined.  For example, the sentence
<ul>p(a) :- not q(a)</ul>
is logically equivalent to
<ul>p(a) <img src="images/vee.gif"> q(a)</ul>
which has two minimal models: {p(a)} and {q(a)}.

<p>While negation does present some problems for the notion of a minimal Herbrand semantics, certain forms of negation do have well-defined minimal models.  Stratification is one such form.

<p><b>Definition (Datalog Stratification)</b>: A set of Datalog rules are stratified when the following graph is acyclic.  The set of nodes is the set of relation constants in the set of rules.  An edge from n to m exists whenever the relation constant n appears as a negative literal in the body of a rule with m in the head.  Stratum 0 is the set of all nodes without incoming edges.  Stratum 1 is the set of all nodes adjacent to a node in stratum 0; stratum i+1 is the set of all nodes adjacent to a node in stratum i that are not in stratum i.

<p>Clearly, if there is no negation, the graph has no edges, which means it has a single stratum and is acyclic.  When a set of Datalog rules is stratified, we can always choose a single Herbrand model as its semantics.

<p><b>Definition (Stratified Datalog Semantics)</b>: Let S be a set of stratified Datalog rules.  Stratum 0 contains no negation; thus it has a minimal model.  The minimal model for stratum i+1 is constructed by extending the minimal model for stratum i by evaluating the body of all rules in stratum i+1 in the minimal model of stratum i.  

<p>For example, consider the following stratified rules, where it is traditional to use not in place of <img src="images/neg.gif">.
<ul>p(a) :- not q(a)<br>
q(b) :- not t(b)<br>
t(c)<br>
</ul>
The minimal model for these sentences is computed as follows.  Stratum 0 is just {t}; stratum 1 is {q}, and stratum 2 is {p}.  For stratum 0, the minimal model is just <ul>{t(c)}.</ul>  The only rule in stratum 1 is the one with q in its head: q(b) :- not t(b).  The body not t(b) is true in the model {t(c)}. Thus, the minimal model for stratum 1 is 
<ul>{t(c), q(b)}.</ul>
For stratum 2, the rule body of p(a) :- not q(a) is true in {t(c), q(b)}, making the minimal model for this set of Datalog rules <ul>{t(c), q(b), p(a)} <img src="images/qed.gif"></ul>

<p>Variables in negative literals can be problematic.  Consider the rule set
<ul>p(x) :- not q(x)<br>
q(a)</ul>  The minimal model for stratum 0 is {q(a)}.  The minimal model for stratum 1 requires computing all the x such that not q(x) is true.  If the vocabulary were known, an implementation could, when faced with such a rule, enumerate all the object constants in that vocabulary, using NAF on each grounding of the literal.  But because the vocabulary is never known in a database, no enumeration can occur.  However, for the case where negative literals can always be evaluated over the known vocabulary, the minimal model can be computed.

<p>The last two constraints in the definition for a Datalog rule ensure that condition: (1) every variable in a negative literal must occur in a positive literal in the body and (2) every variable in the head must occur in the body.  The first constraint avoids the problem illustrated in the last example.  The rule p(x) :- not q(x) is not allowed since x occurs in a negative literal but in no positive literal in the body.  However, constraint (1) is not sufficient for ensuring the negative literals can always be evaluated in the known vocabulary.  For example, consider the following rules:
<ul>p(x) :- q(x), not r(x)<br>
q(x) :-</ul>
They satisfy constraint (1) but not (2).  q is true of everything in the vocabulary, both known and unknown.  Thus, even though x occurs in a positive literal, not r(x) must be evaluated over the unknown part of the vocabulary.  Conditions (1) and (2) are sufficiently strong to ensure the Stratified semantics assigns a well-defined model to every set of Datalog rules.

<p>Now that the motivation for the definition of a Datalog rule has been explained, some decidability results can be given.  Because Datalog does not allow function constants, the number of Herbrand models for any finite vocabulary is finite.  Regardless which semantics are used, as long as the semantics assigns some subset of all Herbrand models over a finite vocabulary and checking satisfaction is decidable, entailment is decidable.

<p><b>Theorem (Datalog is Decidable)</b>: Let <img src="images/Delta.gif"> be a finite set of Datalog rules.  Let S be a semantics for Datalog that chooses some subset of the Herbrand models over the vocabulary induced by <img src="images/Delta.gif">, where checking whether a model satisfies <img src="images/Delta.gif"> is decidable.  Let <img src="images/phi.gif"> be the query. 
<center><img src="images/Delta.gif"> <img src="images/models.gif"> <img src="images/phi.gif"> under the semantics S is decidable.</center>
<br><b>Proof</b>:  Since <img src="images/Delta.gif"> itself is finite, the vocabulary and therefore the number and size of all Herbrand models over that vocabulary is finite.  Because satisfaction in S is decidable, to check entailment, enumerate each model for the vocabulary and when it satisfies <img src="images/Delta.gif"> check whether it satisfies <img src="images/phi.gif">.  If every model that satisfies <img src="images/Delta.gif"> satisfies <img src="images/phi.gif">, <img src="images/Delta.gif"> <img src="images/models.gif"> <img src="images/phi.gif">.  Otherwise <img src="images/Delta.gif"> <img src="images/notmodels.gif"> <img src="images/phi.gif">. <img src="images/qed.gif">

<p>Unlike theorem proving, answering a query in a database usually means finding all the tuples for which the query is satisfied.  We call this materializing the query.

<p><b>Definition (Materialization)</b>: Let <img src="images/Delta.gif"> be a set of sentences and <img src="images/phi.gif">(x<sub>1</sub>,...,x<sub>n</sub>) be a query with free variables x<sub>1</sub>,...,x<sub>n</sub>.  The materialization of the query for <img src="images/Delta.gif"> is the set of all &lt;t<sub>1</sub>,...,t<sub>n</sub>&gt; such that <img src="images/Delta.gif"> <img src="images/models.gif"> <img src="images/phi.gif">(t<sub>1</sub>,...,t<sub>n</sub>), where each t<sub>i</sub> is ground.


<p><b>Corollary (Materializing Datalog is Decidable)</b>: Same conditions as the last theorem.  <img src="images/phi.gif"> has the free variables x<sub>1</sub>,...,x<sub>n</sub>.  Materializing <img src="images/phi.gif"> for <img src="images/Delta.gif"> is decidable.
<br><b>Proof</b>: Let <img src="images/sigma.gif"> be some substitution x<sub>1</sub>/c<sub>1</sub>,...,x<sub>n</sub>/c<sub>n</sub>, where each c<sub>i</sub> is an object constant in the vocabulary of <img src="images/Delta.gif">.  By the above theorem <img src="images/Delta.gif"> <img src="images/models.gif"> <img src="images/phi.gif"><img src="images/sigma.gif"> is decidable.  If <img src="images/Delta.gif"> <img src="images/models.gif"> <img src="images/phi.gif"><img src="images/sigma.gif">, add the tuple &lt;c<sub>1</sub>,...,c<sub>n</sub>&gt; into the materialization.  Since <img src="images/phi.gif"> is finite, the number of variables is finite; since <img src="images/Delta.gif"> is finite, the number of object constants is finite.  Thus, the number of distinct <img src="images/sigma.gif">s is finite; check entailment for each one and return the resulting set of tuples. <img src="images/qed.gif">

<h3>Completeness and NAF implementation</h3>

<p>Minimal Herbrand semantics, whatever the form, ensures that at most one model satisfies a given set of Datalog rules.  Assuming the rules are consistent, the consequences of those rules is an axiomatically complete theory.

<p><b>Definition (Axiomatic Completeness)</b>: A theory T is axiomatically complete for language L if and only if for every closed sentence <img src="images/sigma.gif"> in L, <center>T <img src="images/models.gif"> <img src="images/sigma.gif">  <img src="images/vee.gif">  T <img src="images/models.gif"> <img src="images/neg.gif"><img src="images/sigma.gif"></center>

<p>When a theory in a complete logic, i.e. a logic with a complete proof procedure, is axiomatically complete and has a recursively enumerable axiomatization, the theory is decidable: for any query <img src="images/phi.gif">, interleave proof attempts for <img src="images/phi.gif"> and <img src="images/neg.gif"> <img src="images/phi.gif">.  One of them is entailed, and because the logic is complete, the proof will be found.  In such a theory, negation as failure (NAF) is monotonic: failing to prove <img src="images/phi.gif"> ensures that <img src="images/neg.gif"> <img src="images/phi.gif"> is entailed.  

<p><b>Definition (Negation as Failure)</b>: Negation as failure is the following inference rule:
<center><table border="0">
<tr><td style="border-bottom: 1px solid black"><img src="images/Delta.gif"> <img src="images/notmodels.gif"> <img src="images/phi.gif"></td></tr><tr><td><img src="images/Delta.gif"> <img src="images/models.gif"> <img src="images/neg.gif"><img src="images/phi.gif"></td></tr></table></center>

<p>NAF is monotonic whenever <img src="images/Delta.gif"> entails either the query in question or its negation, i.e. <img src="images/Delta.gif"> is complete for the language that includes either the query or its negation.  

<p><b>Theorem (Monotonic NAF)</b>: NAF is monotonic for a particular query <img src="images/phi.gif"> if and only if the theory is complete wrt the language {<img src="images/phi.gif">}. 
<br><b>Proof</b>: 
<ul><img src="images/Delta.gif"> <img src="images/models.gif"> <img src="images/phi.gif"> <img src="images/vee.gif"> <img src="images/Delta.gif"> <img src="images/models.gif"> <img src="images/neg.gif"><img src="images/phi.gif"> (<img src="images/Delta.gif"> is complete)<br>
		<img src="images/Leftrightarrow.gif"> <img src="images/neg.gif"> (<img src="images/Delta.gif"> <img src="images/models.gif"> <img src="images/phi.gif">) <img src="images/Rightarrow.gif"> <img src="images/Delta.gif"> <img src="images/models.gif"> <img src="images/neg.gif"><img src="images/phi.gif"> (Logical equivalence of p <img src="images/vee.gif"> q and <img src="images/neg.gif"> p <img src="images/Rightarrow.gif"> q)<br>
 		<img src="images/Leftrightarrow.gif"> <img src="images/Delta.gif"> <img src="images/notmodels.gif"> <img src="images/phi.gif"> <img src="images/Rightarrow.gif"> <img src="images/Delta.gif"> <img src="images/models.gif"> <img src="images/neg.gif"><img src="images/phi.gif"> (Every query is either entailed or not entailed)<img src="images/qed.gif"></ul>
		

<p>Because the Stratified Datalog semantics assigns a single model to a set of rules, it ensures every theory is axiomatically complete.  The above theorem ensures NAF is monotonic for every query.  One benefit to these semantics is that there need be no rules with negative literals in the head, which is reflected in the definition of Datalog rules.  

<p>Since the negative portion of the theory is never explicitly written, a proof system for Datalog must rely on NAF.  The definition of Stratified Semantics can be implemented directly, causing the proof system to construct the minimal model by constructing one stratum after another.  Another approach begins at the query and applies the rules backwards.  Some implementations, on the other hand, start with the query and use the rules backwards.  They evaluate negative literals in rule bodies with NAF: attempt to prove the positive version of the literal, and if that fails, conclude that the negative version must be true.  If not done carefully, the proof procedure can fail to find a proof even when one exists.

<p>For example, consider the following rule-set.
<ul>p(x,y) :- p(x,z), p(z,y)<br>
q(a) :- not p(a,a)<br>
q(a)</ul>

These rules are stratified; they have the following model: {q(a)}.  The first rule says that p is transitive.  The second rule says that q(a) is true if p(a,a) cannot be proven.  The third rule says that q(a) is true.  If the query is q(a), here is what the proof trace might look like.  
<ul>q(a) is true if p(a,a) cannot be proven<br>
p(a,a) can be proven if p(a,z) and p(z,a) can be proven<br>
p(a,z) can be proven if p(a,w) and p(w,z) can be proven<br>
...</ul>
Simple iterative deepening does not help here since NAF launches a brand new proof attempt for p(a,a), and iterative deepening on p(a,a) will run forever.  If iterative deepening is to be used with NAF, depth limits must be shared among proof attempts.

 


<h2>Prolog</h2>

<p>This section is entitled Prolog instead of the more popular term Logic Programming to emphasize the fact that these are different concepts.  The first is a particular family of languages that were developed to program computers where all the logic is in rule form, and negation as failure is prevalent.  The second is the paradigm of programming a computer using formal logic itself, regardless the syntax or semantics.  (I personally find naming concepts very tiresome.  Logic programming is a good name; using it to refer to a particular implementation only diminishes its value.  And, because this distinction is not made in the literature, it is worth noting here.)

<p>Prolog can be seen as a generalization of Datalog.  Function constants are allowed, certain restrictions are removed, and a more general rule form has been investigated.

<p><b>Definition (Prolog Rule)</b>: A Prolog rule is an implication.
<ul>h<sub>1</sub> <img src="images/vee.gif"> ... <img src="images/vee.gif"> h<sub>m</sub> :- b<sub>1</sub>, b<sub>2</sub>, ..., b<sub>k</sub>, not b<sub>k+1</sub>, ..., not b<sub>n</sub><br>
- each h<sub>i</sub> is an atom.<br>
- each b<sub>i</sub> is a literal, e.g. p(a) or <img src="images/neg.gif"> p(a).<br>
- each not b<sub>j</sub> is a NAF literal, e.g. not p(a) or not <img src="images/neg.gif"> p(a)<br>
</ul>

<p>When compared to the definition of a Datalog Rule, (1) disjunction is allowed in the head, (2) regular negation is allowed in the body, (3) variables are unrestricted, and (4) function constants are allowed.  What we shall call <i>vanilla Prolog</i> does not allow (1) or (2).  It is this version of Prolog we assume from this point on, making the definition as follows.

<p><b>Definition (Vanilla Prolog Rule)</b>: A vanilla Prolog rule is an implication.
<ul>h :- b<sub>1</sub>, b<sub>2</sub>, ..., b<sub>n</sub><br>
- h is an atom.<br>
- each b<sub>i</sub> is a NAF literal, e.g. p(a) or not p(a).<br>
</ul><img src="images/qed.gif">

<p>Adding function constants alone is sufficient to lose the decidability of entailment.  One can see this by encoding Diophantine equations (see the section on Proof and Model Theory).

<p>The Stratified Datalog semantics works equally well with function constants, but researchers have found stratification sometimes too restrictive; consequently, they [Gelfond and Lifschitz] have invented stable model semantics, which are closer to Herbrand semantics than minimal Herbrand semantics in that a Prolog theory is not necessarily axiomatically complete, i.e. instead of assigning a single model to a set of sentences, it assigns multiple models.

<p>Propositional stable model semantics relies on the notion of a stable model, which in turn relies on the Gelfond-Lifschitz transformation.

<p><b>Definition (Gelfond-Lifschitz Transformation)</b>: Let <img src="images/Delta.gif"> be a set of ground vanilla Prolog rules and M a Herbrand model in the vocabulary of <img src="images/Delta.gif">.  The Gelfond-Lifschitz transformation of <img src="images/Delta.gif"> with respect to M is defined as follows.
<ol>
<li>Delete any rule in <img src="images/Delta.gif"> with a literal not b<sub>i</sub> in the body where b<sub>i</sub> <img src="images/in.gif"> M.
<li>Delete all negative literals from rules in <img src="images/Delta.gif">.
</ol>
Denote this by GL[<img src="images/Delta.gif">,M]. <img src="images/qed.gif">

<p>The result of this transformation with respect to a model M is a set of rules without negation.  If M is minimal, it is a stable model.

<p><b>Definition (Stable Model)</b>: Let <img src="images/Delta.gif"> be a set of ground vanilla Prolog rules and M a Herbrand model in the vocabulary of <img src="images/Delta.gif">. M is a stable model of <img src="images/Delta.gif"> if and only if M is the minimal satisfying model of GL[<img src="images/Delta.gif">,M].

<p>There will always be exactly one minimal model of GL[<img src="images/Delta.gif">,M] since it is Horn.

<p><b>Definition (Propositional Stable Model Semantics)</b>: Let <img src="images/Delta.gif"> be a set of ground vanilla Prolog rules.  <img src="images/Delta.gif"> <img src="images/models.gif"> <img src="images/phi.gif"> if and only if every stable model of P satisfies <img src="images/phi.gif">.

<p><b>Definition (Stable Model Semantics)</b>: Let <img src="images/Delta.gif"> be a set of vanilla Prolog rules.  Let <img src="images/Delta.gif">' be all ground instantiations of the rules in <img src="images/Delta.gif">.  <img src="images/Delta.gif"> <img src="images/models.gif"> <img src="images/phi.gif"> if and only if <img src="images/Delta.gif">' <img src="images/models.gif"> <img src="images/phi.gif">.



<h2>Formal Verification</h2>



<p><center>
<div id="overline">
&copy; Copyright 2006 by 
<SCRIPT LANGUAGE="JavaScript" type="text/javascript">
<!--
var addr1 = "mailto:"
var addr2 = "thinrich"
var addr3 = "@"
var addr4 = "stanford.edu"
document.write( ' <A HREF=" ' + addr1 + addr2 + addr3 + addr4 + ' "> ' )
document.write ( ' Tim Hinrichs</A> ' )
//-->
</SCRIPT>
 and the Stanford Logic Group</div>
</center>
</td></tr></table>
</body>
</html>
