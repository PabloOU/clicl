<html>
<head>
<title>Herbrand Logic -- First-order Syntax and Herbrand Semantics</title>
<style>
	a:active, a:visited, a:link {color: #09641A; text-decoration: none;}
	a:hover {color: #09641A; text-decoration: underline;}
	body {
		margin: 0px 0px 0px 0px;
		padding: 0px 0px 0px 0px;
		background: #DCCB8F;
	}
	#structure {
		margin: 8px 8px 8px 8px;
		border: 2px 2px 2px 2px;
		border-style: solid;
		border-color: gray;
		background: white;
		width: 98%
	}
	#navigation {
		border: 0px 0px 0px 0px;
	}
	td.whiteongreen {padding: 2px 2px 2px 2px; }
	#whiteongreen {background: #396F43; 
					color: white;}
	#whiteongreen a:link {color: white; text-decoration: none;}
	#whiteongreen a:visited {color: white; text-decoration: none;}
	#whiteongreen a:hover, a:active {color: white; text-decoration: underline;}
	
	#title {font: bold 30pt copperplate;
			align: center;}
	#nav { padding: 2px 4px 2px 4px;
		   	border-right: 2px solid white;}
	#nav1 { padding: 2px 4px 2px 4px;
		   	border-right: 2px solid white;
			border-left: 2px solid white; }
	#line { width: 70%;
			border-bottom: 1px solid white; }
	#overline { width: 70%;
				border-top: 1px solid gray;
				font-size: small; }

</style>
</head>
<body>
<table id="structure">
<tr><td id="whiteongreen">
	<div id="title">Herbrand Logic</div>
	<center>
	<table class="navigation">
	<tr>
	<td id="nav1"><a href="index.html">Overview</a></div>
	<td id="nav"><a href="herbrandlogic.html">Syntax and Semantics</a></div>
	<td id="nav"><a href="modeltheory-prooftheory.html">Proof and Model Theory</a></div>
	<td id="nav"><a href="goedel.html">Goedel</a></div>
	<td id="nav"><a href="applications.html">Applications</a></div>
	</tr></table></center>
</td></tr>
<tr><td>  



This page defines the syntax and semantics of Herbrand logic, and for the purpose of comparison, first-order logic.  It finishes with a couple of quick examples illustrating the difference between first-order semantics and Herbrand semantics.

<h2>Syntax</h2>

<p>The syntax of Herbrand logic is exactly the same as for first-order logic.

<p><b>Definition (Vocabulary)</b>: A vocabulary V consists of:
<ul>
<li>A set of relation constants {r<sub>1</sub>, ..., r<sub>n</sub>}, each with an associated arity.
<li>A set of function constants {f<sub>1</sub>, ..., f<sub>m</sub>}, each with an associated arity.
<li>A non-empty set of object constants {c<sub>1</sub>, ..., c<sub>k</sub>}.
<li>A set of variables {x<sub>1</sub>,x<sub>2</sub>,...}.
</ul>

<p>For the sake of simplicity, we assume the set of constants in a vocabulary is finite.  A countable set of constants changes the wording of certain theorems, but conceptually nothing changes.   

<p><b>Definition (Term)</b>: A term in V:
<ul>
<li>A variable.
<li>An object constant.
<li>A function constant with arity n applied to n terms.
<li>Only expressions produced by the above rules are terms.
</ul>

<p><b>Definition (Sentence)</b>: A sentence in V:
<ul>
<li>A relation constant with arity n applied to n terms.
<li>&#x00AC; &phi; where &phi; is a sentence.
<li>&phi; &#8744; &psi;, where &phi; and &psi; are sentences.
<li>&phi; &#8743; &psi;, where &phi; and &psi; are sentences.
<li>&phi; &lArr; &psi;, where &phi; and &psi; are sentences.
<li>&phi; &rArr; &psi;, where &phi; and &psi; are sentences.
<li>&phi; &hArr; &psi;, where &phi; and &psi; are sentences.
<li>&forall;x.&phi;, where &phi; is a sentence.
<li>&exist;x.&phi;, where &phi; is a sentence.
<li>Only expressions produced by the above rules are sentences.
</ul>

<p>An <i>atom</i> is a sentence of the form p(t<sub>1</sub>,...,t<sub>n</sub>).  A <i>literal</i> is either an atom or the negation of an atom.  A <i>ground sentence</i> has no variables or quantifiers.  A <i>closed sentence</i> has no free variables, whereas an <i>open sentence</i> does have free variables.  We treat free variables in an open sentence as being implicitly universally quantified.

<h2>Herbrand Semantics</h2>

<p>Herbrand logic differs from first-order logic solely in the structures it considers to be models.  The semantics of a given set of sentences is defined to be the set of Herbrand models that satisfy it, for a given vocabulary.

<p><b>Definition (Herbrand Model)</b>: A Herbrand model for vocabulary V is any set of ground atoms in V.

<!--
<p>Herbrand semantics allow one to determine whether a particular model satisfies a particular sentence by simply grounding the sentence, i.e. &forall; and &exist; range over the terms in V.

<p><b>Definition (Grounding)</b>: Consider the case of a closed sentence.  Let the ground terms in V be {t<sub>1</sub>,t<sub>2</sub>,...}.
<ul>
<li>Ground[p(u<sub>1</sub>,...,u<sub>n</sub>)] = p(u<sub>1</sub>,...,u<sub>n</sub>)
<li>Ground[&forall; x.&phi;(x)] = Ground[&phi;(t<sub>1</sub>)] &#8743; Ground[&phi;(t<sub>2</sub>)] &#8743; ...
<li>Ground[&exist; x.&phi;(x)] = Ground[&phi;(t<sub>1</sub>)] &#8744; Ground[&phi;(t<sub>2</sub>)] &#8744; ...
<li>Ground[&#x00AC; &phi;] = &#x00AC; Ground[&phi;]
<li>Ground[&phi; &#8743; &psi;] = Ground[&phi;] &#8743; Ground[&psi;]
<li>Ground[&phi; &#8744; &psi;] = Ground[&phi;] &#8744; Ground[&psi;]
<li>Ground[&phi; &rArr; &psi;] = Ground[&phi;] &rArr; Ground[&psi;]
<li>Ground[&phi; &lArr; &psi;] = Ground[&phi;] &lArr; Ground[&psi;]
<li>Ground[&phi; &hArr; &psi;] = Ground[&phi;] &hArr; Ground[&psi;]
</ul>


<p>Notice that if there is at least one function, the number of terms is infinite, and the grounding of any sentence with quantifiers is an infinitely long expression.  Such expressions are not sentences in the logic, but serve only as a device for defining satisfaction.

<p>In the following definition, we use the convention &#8743; &psi;<sub>i</sub> to mean a conjunction of sentences &psi;<sub>1</sub>,&psi;<sub>2</sub>,..., where the conjunction may be infinite.

-->

<p><b>Definition (Herbrand Satisfaction)</b>: Let &phi; be a closed sentence
and M a Herbrand model in the vocabulary V.
<ul>
<li>|=<sub>M</sub> s=t if and only if s and t are syntactically identical.
<li>|=<sub>M</sub> p(t<sub>1</sub>,...,t<sub>n</sub>) if and only if p(t<sub>1</sub>,...,t<sub>n</sub>) &isin; M.
<li>|=<sub>M</sub> &#x00AC; &psi; if and only if |#<sub>M</sub> &psi;.
<li>|=<sub>M</sub> &phi; &#8743; &psi; if and only if |=<sub>M</sub> &phi; and |=<sub>M</sub> &psi;.
<li>|=<sub>M</sub> &phi; &#8744; &psi; if and only if |=<sub>M</sub> &phi; or |=<sub>M</sub> &psi;.
<li>|=<sub>M</sub> &phi; &rArr; &psi; if and only if |#<sub>M</sub> &phi; or |=<sub>M</sub> &psi;.
<li>|=<sub>M</sub> &phi; &lArr; &psi; if and only if |=<sub>M</sub> &psi; &rArr; &phi;.
<li>|=<sub>M</sub> &phi; &hArr; &psi; if and only if either |=<sub>M</sub> &phi;&#8743;&psi; or |=<sub>M</sub> &#x00AC;&phi; &#8743; &#x00AC;&psi;.
<li>|=<sub>M</sub> &forall;x.&phi;(x) if and only if |=<sub>M</sub> &phi;(t) for all ground terms t in V.
<li>|=<sub>M</sub> &exist;x.&phi;(x) if and only if |=<sub>M</sub> &phi;(t) for some ground term t in V. 
</ul>

<p>We always assume that satisfaction for a set of sentences &Delta; is defined with respect to a vocabulary that includes all the constants and variables that appear in &Delta;.  Otherwise, a model might satisfy neither a sentence nor its negation.

<p>One of the consequences of this definition is that the theory of equality is fixed in Herbrand logic: every ground term is distinct from every other ground term and the universe.  Another consequence is that quantifiers range over exactly the set of all ground terms.  That is, Herbrand logic builds in a domain closure axiom (which is sometimes infinitely long) and unique-names axioms.  

<p><b>Definition (Herbrand Entailment)</b>: Let &Delta; be a set of closed sentences and V a vocabulary that is a superset of the vocabulary of &Delta;.  Let &phi; be a closed sentence. &Delta; entails &phi; with respect to vocabulary V if and only if every Herbrand model for V that satisfies &Delta; also satisfies &phi;.<center> &Delta; |= &phi; wrt V if and only if  |=<sub>M</sub> &Delta; implies |=<sub>M</sub> &phi;, where M is a Herbrand model for V</center>

<p>If no vocabulary is named in satisfaction or entailment, it is assumed the minimal vocabulary is used, i.e. the vocabulary that includes just the constants in the sentences given.

<h2>First-order Semantics</h2>
<p>To demonstrate the simplicity of Herbrand semantics, here we give the standard semantics of first-order logic for comparison.  To be clear, Herbrand logic does not have the following semantics; it has the semantics from the last section.
<p><b>Definition (First-order Model)</b>: A first-order model M consists of
<ul><li>|M|: universe
<li>For each n-ary relation constant p an n-ary relation p<sup>M</sup> over |M|
<li>For each n-ary function constant f an n-ary function f<sup>M</sup> over |M|
<li>For each object constant c an element c<sup>M</sup> from |M|
</ul>

<p><b>Definition (Variable Assignment)</b>: In a model M, a variable assignment is a mapping of all the variables in the vocabulary to elements in |M|.

<p>Given an arbitrary model and a variable assignment for that model, every term in the language is assigned an element in that model's universe.  

<p><b>Definition(e<sub>v</sub>)</b>: Let v be a variable assignment and M a first-order model.  e<sub>v</sub> maps a term to an element of |M|.
<ul><li>For variable x, e<sub>v</sub>(x) = v(x)
<li>For object constant c, e<sub>v</sub>(c) = c<sup>M</sup>
<li>For terms t<sub>1</sub>,...,t<sub>n</sub>, e<sub>v</sub>(f(t<sub>1</sub>,...,t<sub>n</sub>)) = f<sup>M</sup>(e<sub>v</sub>(t<sub>1</sub>),...,e<sub>v</sub>(t<sub>n</sub>))
</ul>

<p>Finally we can define satisfaction in a model.  Satisfaction assumes there is some given variable assignment v.

<p><b>Definition(First-order Satisfaction)</b>: Let M be a model and v a variable assignment for M.  |=<sub>M</sub> &phi; is defined as follows.
<ul>
<li>|=<sub>M</sub> t<sub>1</sub>=t<sub>2</sub>[v] iff e<sub>v</sub>(t<sub>1</sub>)=e<sub>v</sub>(t<sub>2</sub>)
<li>|=<sub>M</sub> p(t<sub>1</sub>,...,t<sub>n</sub>)[v] iff &lt;e<sub>v</sub>(t<sub>1</sub>),...,e<sub>v</sub>(t<sub>n</sub>)&gt; &isin; p<sup>M</sup>
<li>|=<sub>M</sub> &#x00AC; &phi;[v] iff |# &phi;[v]
<li>|=<sub>M</sub> &phi; &#8743; &psi; [v] iff |=<sub>M</sub> &phi;[v] and |=<sub>M</sub> &psi;[v]
<li>|=<sub>M</sub> &phi; &#8744; &psi; [v] iff |=<sub>M</sub> &phi;[v] or |=<sub>M</sub> &psi;[v] 
<li>|=<sub>M</sub> &phi; &rArr; &psi; [v] iff |#<sub>M</sub> &phi;[v] or |=<sub>M</sub> &psi;[v] 
<li>|=<sub>M</sub> &phi; &lArr; &psi; [v] iff |=<sub>M</sub> &psi; &rArr; &phi; [v] 
<li>|=<sub>M</sub> &phi; &hArr; &psi; [v] iff |=<sub>M</sub> &phi; &#8743; &psi; [v] or |=<sub>M</sub> &#x00AC;&phi; &#8743; &#x00AC;&psi; [v]
<li>|=<sub>M</sub> &forall;x.&phi;[v] iff for every d in |M| |=<sub>M</sub> &phi;[v(x/d)]
<li>|=<sub>M</sub> &exist;x.&phi;[v] iff for some d in |M| |=<sub>M</sub> &phi;[v(x/d)]
</ul>

<p><b>Definition (First-order Entailment)</b>: Let &Delta; be a set of sentences and &phi; be a sentence.  &Delta; entails &phi; if and only if every first-order model that satisfies &Delta;[v] for all variable assignments v also satisfies &phi;[v] for all variable assignments v.
<center>&Delta; |= &phi; if and only if for all variable assignments v and u, |=<sub>M</sub> &Delta;[v] implies |=<sub>M</sub> &phi;[u], where M is a first-order model</center>


<h2>Examples</h2>

<p>The following sentence has two satisfying Herbrand models for the vocabulary {p, a, b}.  It has infinitely many first-order models.
<ul>p(a)<br>
Herbrand Models: {p(a)}, {p(a), p(b)}<br>
Some First-order Models: <br>
&nbsp;&nbsp;&nbsp;{{1},p={&lt;1&gt;},a=1,b=1}, <br>
&nbsp;&nbsp;&nbsp;{{1,2,3,...},p={&lt;17&gt;,&lt;63&gt;}, a=17, b=51}, <br>
&nbsp;&nbsp;&nbsp;{Reals, p={&lt;3.14159...&gt;,&lt;17.0&gt;}, a=3.14159..., b=0.33333...} </ul>

<p>In Herbrand logic, restricting the vocabulary to {p, a} ensures there is only one satisfying model: {p(a)}.  In first-order logic, shrinking the vocabulary does not reduce the number of models at all; the only difference is that models of the smaller vocabulary do not have an assignment for b.

<p>The following sentences are Herbrand unsatisfiable for the vocabulary {p, a}.
<ul>p(a)<br>
	&exist;x.&#x00AC; p(x)<br>
</ul>
However, in first-order logic, regardless the vocabulary, they are always satisfiable, e.g. {{1,2}, p={&lt;1&gt;}, a=1}.  In Herbrand logic, enlarging the vocabulary to include an extra element is sufficient for satisfiability in this example: the vocabulary {p, a, b} allows the satisfying model {p(a)}.  

<p>More generally, in first-order logic, changing the vocabulary never changes the satisfiability (again the vocabulary must always be a superset of the symbols in the axiom set), whereas in Herbrand logic, changing the vocabulary can affect satisfiability.

<p>A note on the dependence of Herbrand satisfaction on a vocabulary. To see why satisfaction is defined as it is, suppose instead of fixing the vocabulary up front (which defines the class of candidate models), we instead define satisfaction so that the vocabulary is gleamed from the sentences we are given.  Now consider the following axioms.
<ul>p(a)<br>
	&#x00AC;p(b)<br>
	&exist;x.&#x00AC;p(x)<br>
</ul>
This set of sentences is satisfied by the model {p(a), &#x00AC;p(b)} for vocabulary {p, a, b}.  But, if we were to drop out the &#x00AC; p(b) sentence, under the new definition of satisfaction, the vocabulary would be {p, a}, which as commented above is unsatisfiable.  That is, under this new definition of satisfaction, a set of sentences could be satisfiable, but a subset of those sentences could be unsatisfiable.  Clearly, that would cause havoc in proof procedures; by fixing the vocabulary up front, in this case to {p, a, b}, the satisfiability of a set of sentences ensures the satisfiability of every subset.


<p><center>
<div id="overline">
&copy; Copyright 2006 by 
<SCRIPT LANGUAGE="JavaScript" type="text/javascript">
<!--
var addr1 = "mailto:"
var addr2 = "thinrich"
var addr3 = "@"
var addr4 = "stanford.edu"
document.write( ' <A HREF=" ' + addr1 + addr2 + addr3 + addr4 + ' "> ' )
document.write ( ' Tim Hinrichs</A> ' )
//-->
</SCRIPT>
 and the <a href="http://logic.stanford.edu/">Stanford Logic Group</a></div>
</center>
</td></tr></table>
</body>
</html>
