<HTML><HEAD><TITLE> Syntax </TITLE></HEAD><BODY><HR><H2>Standard Information Format Specification</H2><H2>Chapter 2: Syntax </H2><HR><H3>Introduction</H3>As with many computer-oriented languages, the syntax of SIF is most easilydescribed in three layers.  First, there are the basic <I>characters</I> of thelanguage.  These characters can be combined to form <I>lexemes</I>.  Finally,the lexemes of the language can be combined to form grammatically legal<I>expressions</I>.  Although this layering is not strictly essential to thespecification of SIF, it simplifies the description of the syntax by dealing withwhite space at the lexeme level and eliminating that detail from the expressionlevel.<P>In this chapter, the syntax of SIF is presented using a modified BNF notation. All nonterminals and BNF punctuation are written in boldface, while characters inSIF are expressed in plain font.  The notation<TT><B>{</B>x1,...,xn<B>}</B></TT> means the set of terminals<TT>x1,...,xn</TT>.  The notation <TT><B>[nonterminal]</B></TT>means zero or one instances of <TT><B>nonterminal</B></TT>;<TT><B>nonterminal*</B></TT> means zero or more occurrences;<TT><B>nonterminal+</B></TT> means one or more occurrences;<TT><B>nonterminal^n</B></TT> means <TT><B>n</B></TT> occurrences.  The notation<TT><B>nonterminal1 - nonterminal2</B></TT> refers to all of the members of<TT><B>nonterminal1</B></TT> except for those in <TT><B>nonterminal2</B></TT>. The notation <TT><B>int(n)</B></TT> denotes the decimal representationof integer n.  The nonterminals <B>space</B>, <B>tab</B>, <B>return</B>,<B>linefeed</B>, and <B>page</B> refer to the characters corresponding to asciicodes 32, 9, 13, 10, and 12, respectively.  The nonterminal <B>character</B>denotes the set of all 128 ascii characters.  The nonterminal <B>empty</B> denotesthe empty string.<H3>Characters</H3><P>SIF characters are classified as upper case letters, lower case letters, digits,alpha characters (non-alphabetic characters that are used in the same waythat letters are used), special characters, white space, and other characters(every ascii character that is not in one of the other categories).<P><PRE><B>    upper ::= </B>A<B> | </B>B<B> | </B>C<B> | </B>D<B> | </B>E<B> | </B>F<B> | </B>G<B> | </B>H<B> | </B>I<B> | </B>J<B> | </B>K<B> | </B>L<B> | </B>M<B> |               </B>N<B> | </B>O<B> | </B>P<B> | </B>Q<B> | </B>R<B> | </B>S<B> | </B>T<B> | </B>U<B> | </B>V<B> | </B>W<B> | </B>X<B> | </B>Y<B> | </B>Z<B>    lower ::= </B>a<B> | </B>b<B> | </B>c<B> | </B>d<B> | </B>e<B> | </B>f<B> | </B>g<B> | </B>h<B> | </B>i<B> | </B>j<B> | </B>k<B> | </B>l<B> | </B>m<B> |               </B>n<B> | </B>o<B> | </B>p<B> | </B>q<B> | </B>r<B> | </B>s<B> | </B>t<B> | </B>u<B> | </B>v<B> | </B>w<B> | </B>x<B> | </B>y<B> | </B>z<B>    digit ::= </B>0<B> | </B>1<B> | </B>2<B> | </B>3<B> | </B>4<B> | </B>5<B> | </B>6<B> | </B>7<B> | </B>8<B> | </B>9<B>    alpha ::= </B>!<B> | </B>$<B> | </B>%<B> | </B>&<B> | </B>*<B> | </B>+<B> | </B>-<B> | </B>.<B> | </B>/<B> | </B><<B> | </B>=<B> | </B>><B> | </B>?<B> |              </B>@<B> | </B>_<B> | </B>~<B> |    special ::= </B>"<B> | </B>#<B> | </B>'<B> | </B>(<B> | </B>)<B> | </B>,<B> | </B>\<B> | </B>^<B> | </B>`<B>    white ::= space | tab | return | linefeed | page</B></PRE>A normal character is either an upper case, a lower case character, a digit, or analpha character.<PRE><B>    normal ::= upper | lower | digit | alpha</B></PRE><H3>Lexemes</H3>The process of converting characters into lexemes in called <I>lexicalanalysis</I>.  The input to this process is a stream of characters, and theoutput is a stream of <I>lexemes</I>.<P>The function of a lexical analyzer is cyclic.  It reads characters from theinput string until it encounters a character that cannot be combined withprevious characters to form a legal lexeme.  When this happens, it outputsthe lexeme corresponding to the previously read characters.  It then starts theprocess over again with the new character.  Whitespace causes a break in thelexical analysis process but otherwise is discarded unless it occurs withina string or is preceded by a suitable escape character.<P>There are five types of lexemes in SIF -- special lexemes, words, characterreferences, character strings, and character blocks.<P>Each special character forms its own lexeme.  It cannot be combined with othercharacters to form more complex lexemes, except through the ``escape'' syntaxdescribed below.<P>A <I>word</I> is a contiguous sequence of (1) normal characters or (2) othercharacters preceded by the escape character <TT>\</TT>.<P><PRE><B>    word ::= normal | word normal | word</B>\<B>character</B></PRE><P>Except for characters following <TT>\</TT>, the lexical analysis of words is caseinsensitive.  The output lexeme for any word corresponds to the lexeme obtained byconverting all letters not following <TT>\</TT> to their upper case equivalents. For example, the word <TT>abc</TT> and the word <TT>ABC</TT> map into the samelexeme.  The word <TT>a\bc</TT> maps into the same lexeme as the word<TT>A\bC</TT>, which is not the same as the lexeme for the word <TT>ABC</TT>.<P>A <I>character reference</I> consists of the characters <TT>#</TT>,<TT>\</TT>, and any character.  Character references allow us to refer tocharacters as characters and differentiate them from one-character symbols,which may refer to other objects.<P><PRE><B>    charref ::= </B>#\<B>character</B></PRE>A <I>character string</I> is a series of characters enclosed in quotationmarks.  The escape character <TT>\</TT> is used to permit the inclusion ofquotation marks and the <TT>\</TT> character itself within such strings.<P><PRE><B>    string ::= </B>"<B>quotable</B>"<B>    quotable ::= empty | quotable strchar | quotable</B>\<B>character    strchar ::= character - {</B>"<B>,</B>\<B>}</B></PRE>Sometimes it is desirable to group together a sequence of arbitrary bits orcharacters without imposing escape characters, e.g. to encode images, audio, orvideo in special formats.  Character blocks permit this sort of grouping throughthe use of a prefix that specifies how many of the following characters are togrouped together in this way.  A <I>character block</I> consists of thecharacter <TT>#</TT> followed by the decimal encoding of a positive integer <B>n</B>,the character <TT>q</TT> or <TT>Q</TT>, and then <B>n</B> arbitrary characters.<P><PRE><B>    block ::= </B>#<B> int(n) </B>q<B> character^n | </B>#<B> int(n) </B>Q<B> character^n</B></PRE>For the purpose of grammatical analysis, it is useful to subdivide the class ofwords a little further, viz. as variables, operators, and constants.<P>A <I>variable</I> is a word in which the first character is <TT>?</TT> or <TT>@</TT>. A variable that begins with <TT>?</TT> is called an <I>individual variable</I>.  Avariable that begins with an <TT>@</TT> is called a <I>sequence variable</I>.<P><PRE><B>    variable ::= indvar | seqvar    indvar ::= </B>?<B>word    seqvar ::= </B>@<B>word</B></PRE><I>Operators</I> are used in forming complex expressions of various sorts. <PRE><B>    operator ::=  </B>unprovable<B> | </B>not<B> | </B>and<B> | </B>or<B> | </B>=><B> | </B><=<B></B></PRE>All other words are called <I>constants</I>.<P><PRE><B>    constant ::= word - variable - operator</B></PRE>Semantically, there are four categories of constants in SIF -- object constants,function constants, relation constants, and logical constants.  <I>Objectconstants</I> are used to denote individual objects.  <I>Function constants</I>denote functions on those objects.  <I>Relation constants</I> denote relations. <I>Logical constants</I> express conditions about the world and are either trueor false.  SIF is unusual among logical languages in that there is no syntacticdistinction among these four types of constants; any constant can be used whereany other constant can be used.  The differences between these categories ofconstants is entirely semantic.<P><H3>Expressions</H3>The legal expressions of SIF are formed from lexemes according to the rulespresented in this section.  There are three disjoint types of expressions inthe language -- <I>terms</I>, <I> sentences</I>, and <I>forms</I>. Terms are used to denote objects in the world being described; sentences and formsare used to express facts about the world.  A <I>knowledge base</I> is a finitesequence of forms.<P>There are six types of terms in SIF -- individual variables, constants,character references, character strings, character blocks, and list expressions. Individual variables, constants, character references, strings, and blocks werediscussed earlier.<P> <PRE><B>    term ::= indvar | constant | charref | string | block | listexpr</B></PRE>A list expression is either an <I>atom</I> or a sequence of listexpressions surrounded by parentheses.  An atom is either a word or acharacter reference or a character string or a character block.<PRE><B>    listexpr ::= atom | </B>(<B>listexpr*</B>)<B>    atom ::= word | charref | string | block</B></PRE>The following BNF defines the set of legal sentences in SIF.  Thereare three types of sentences.  We have already mentioned logical constants.<P><PRE><B>    sentence ::= constant | relsent | quantsent | logsent</B></PRE>A <I>relational sentence</I> consists of a relation constant and an arbitrarynumber of <I>argument</I> terms, terminated by an optional sequence variable. As with functional terms, there is no syntactic  restriction on the number ofargument terms in a relation sentence -- the same relation constant can beapplied to any finite number of arguments.<P><PRE><B>    relsent ::= </B>(<B>constant term* [seqvar]</B>)<B></B></PRE><P>It is noteworthy that the syntax of relational sentences is the same as that offunctional terms.  On the other hand, their meanings are different.  Fortunately,the context of each such expression determines its type (as an embedded term inone case or as a top-level sentence or argument to some sentential operator inthe other case); and so this slight ambiguity causes no problems.<P>The syntax of <I>quantified sentences</I> takes the form shown below.<PRE><B>    quantsent ::= </B>(bagofall <B>term</B> <B>sentence</B> <B>term</B>)<B></B></PRE><P>The syntax of <I>logical sentences</I> depends on the logical operatorinvolved.  A sentence involving the <TT>not</TT> operator is called a <I>negation</I>.  A sentence involving the <TT>and</TT> operator is called a<I>conjunction</I>, and the arguments are called <I>conjuncts</I>.  A sentenceinvolving the <TT>or</TT> operator is called a <I>disjunction</I>, and thearguments are called <I>disjuncts</I>.<PRE><B>    logsent ::= </B>(not <B>sentence</B>)<B> |                </B>(and <B>sentence*</B>)<B> |                </B>(or <B>sentence*</B>)<B>                </B></PRE><P>As with sentences, the syntax of a <I>form</I> depends on the logicaloperator involved.  A form involving the <TT>=></TT> operator is called an<I>implication</I>; all of its arguments but the last are called<I>antecedents</I>; and the last argument is called the <I>consequent</I>.  Asentence involving the <TT><=</TT> operator is called a <I>reverse implication</I>;its first argument is called the <I>consequent</I>; and the remaining arguments arecalled the <I>antecedents</I>.<PRE><B>    form ::= sentence |             </B>(=> <B>sentence* sentence</B>)<B> |             </B>(<= <B>sentence sentence*</B>)<B></B></PRE><P>A <I>knowledge base</I> is a finite sequence of forms.  It is defined as asequence because the order of forms in a knowledge base may have affect theway the knowledge base is processed by interpreters.<P><HR><ADDRESS><A HREF="mailto:genesereth@cs.stanford.edu">Michael R. Genesereth</A></ADDRESS></BODY></HTML>