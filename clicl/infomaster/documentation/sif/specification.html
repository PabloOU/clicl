<HTML><HEAD><TITLE>SIF Specification</TITLE></HEAD><BODY><HR><CENTER><H1>Standard Information Format</H1><H1>Specification </H1></CENTER><HR><OL><LI><A HREF = "introduction.html">Introduction</A> <LI><A HREF = "syntax.html">Syntax</A><LI><A HREF = "logic.html">Logic</A><LI><A HREF = "numbers.html">Numbers</A><LI><A HREF = "strings.html">Characters and Strings</A></OL><HR><H2>1. Introduction </H2><P>Standard Information Format (SIF) is a simplified version of KnowledgeInterchange Format (KIF), a computer-oriented language for therepresentation of data and knowledge.  It has declarative semantics (i.e. themeaning of expressions in the representation can be understood without appealto an interpreter for manipulating those expressions), and it is logicallycomprehensive (i.e. it provides for the expression of arbitrary sentences inrelational logic).<HR><H2>2. Syntax</H2><H4>Introduction</H4>As with many computer-oriented languages, the syntax of SIF is most easilydescribed in three layers.  First, there are the basic <I>characters</I> of thelanguage.  These characters can be combined to form <I>lexemes</I>.  Finally,the lexemes of the language can be combined to form grammatically legal<I>expressions</I>.  Although this layering is not strictly esential to thespecification of SIF, it simplifies the description of the syntax by dealing withwhite space at the lexeme level and eliminating that detail from the expressionlevel.<P>In this chapter, the syntax of SIF is presented using a modified BNF notation. All nonterminals and BNF punctuation are written in boldface, while characters inSIF are expressed in plain font.  The notation<TT><B>{</B>x1,...,xn<B>}</B></TT> means the set of terminals<TT>x1,...,xn</TT>.  The notation <TT><B>[nonterminal]</B></TT>means zero or one instances of <TT><B>nonterminal</B></TT>;<TT><B>nonterminal*</B></TT> means zero or more occurrences;<TT><B>nonterminal+</B></TT> means one or more occurrences;<TT><B>nonterminal^n</B></TT> means <TT><B>n</B></TT> occurrences.  The notation<TT><B>nonterminal1 - nonterminal2</B></TT> refers to all of the members of<TT><B>nonterminal1</B></TT> except for those in <TT><B>nonterminal2</B></TT>. The notation <TT><B>int(n)</B></TT> denotes the decimal representationof integer n.  The nonterminals <B>space</B>, <B>tab</B>, <B>return</B>,<B>linefeed</B>, and <B>page</B> refer to the characters corresponding to asciicodes 32, 9, 13, 10, and 12, respectively.  The nonterminal <B>character</B>denotes the set of all 128 ascii characters.  The nonterminal <B>empty</B> denotesthe empty string.<H3>Characters</H3><P>SIF characters are classified as upper case letters, lower case letters, digits,alpha characters (non-alphabetic characters that are used in the same waythat letters are used), special characters, white space, and other characters(every ascii character that is not in one of the other categories).<P><PRE><B>    upper ::= </B>A<B> | </B>B<B> | </B>C<B> | </B>D<B> | </B>E<B> | </B>F<B> | </B>G<B> | </B>H<B> | </B>I<B> | </B>J<B> | </B>K<B> | </B>L<B> | </B>M<B> |               </B>N<B> | </B>O<B> | </B>P<B> | </B>Q<B> | </B>R<B> | </B>S<B> | </B>T<B> | </B>U<B> | </B>V<B> | </B>W<B> | </B>X<B> | </B>Y<B> | </B>Z<B>    lower ::= </B>a<B> | </B>b<B> | </B>c<B> | </B>d<B> | </B>e<B> | </B>f<B> | </B>g<B> | </B>h<B> | </B>i<B> | </B>j<B> | </B>k<B> | </B>l<B> | </B>m<B> |               </B>n<B> | </B>o<B> | </B>p<B> | </B>q<B> | </B>r<B> | </B>s<B> | </B>t<B> | </B>u<B> | </B>v<B> | </B>w<B> | </B>x<B> | </B>y<B> | </B>z<B>    digit ::= </B>0<B> | </B>1<B> | </B>2<B> | </B>3<B> | </B>4<B> | </B>5<B> | </B>6<B> | </B>7<B> | </B>8<B> | </B>9<B>    alpha ::= </B>!<B> | </B>$<B> | </B>%<B> | </B>&<B> | </B>*<B> | </B>+<B> | </B>-<B> | </B>.<B> | </B>/<B> | </B><<B> | </B>=<B> | </B>><B> | </B>?<B> |              </B>@<B> | </B>_<B> | </B>~<B> |    special ::= </B>"<B> | </B>#<B> | </B>'<B> | </B>(<B> | </B>)<B> | </B>,<B> | </B>\<B> | </B>^<B> | </B>`<B>    white ::= space | tab | return | linefeed | page</B></PRE>A normal character is either an upper case, a lower case character, a digit, or analpha character.<PRE><B>    normal ::= upper | lower | digit | alpha</B></PRE><H3>Lexemes</H3>The process of converting characters into lexemes in called <I>lexicalanalysis</I>.  The input to this process is a stream of characters, and theoutput is a stream of <I>lexemes</I>.<P>The function of a lexical analyzer is cyclic.  It reads characters from theinput string until it encounters a character that cannot be combined withprevious characters to form a legal lexeme.  When this happens, it outputsthe lexeme corresponding to the previously read characters.  It then starts theprocess over again with the new character.  Whitespace causes a break in thelexical analysis process but otherwise is discarded.<P>There are five types of lexemes in SIF -- special lexemes, words, characterreferences, character strings, and character blocks.<P>Each special character forms its own lexeme.  It cannot be combined with othercharacters to form more complex lexemes, except through the ``escape'' syntaxdescribed below.<P>A <I>word</I> is a contiguous sequence of (1) normal characters or (2) othercharacters preceded by the escape character <TT>\</TT>.<P><PRE><B>    word ::= normal | word normal | word</B>\<B>character</B></PRE><P>Except for characters following <TT>\</TT>, the lexical analysis of words is caseinsensitive.  The output lexeme for any word corresponds to the lexeme obtained byconverting all letters not following <TT>\</TT> to their upper case equivalents. For example, the word <TT>abc</TT> and the word <TT>ABC</TT> map into the samelexeme.  The word <TT>a\bc</TT> maps into the same lexeme as the word<TT>A\bC</TT>, which is not the same as the lexeme for the word <TT>ABC</TT>.<P>A <I>character reference</I> consists of the characters <TT>#</TT>,<TT>\</TT>, and any character.  Character references allow us to refer tocharacters as characters and differentiate them from one-character symbols,which may refer to other objects.<P><PRE><B>    charref ::= </B>#\<B>character</B></PRE>A <I>character string</I> is a series of characters enclosed in quotationmarks.  The escape character <TT>\</TT> is used to permit the inclusion ofquotation marks and the <TT>\</TT> character itself within such strings.<P><PRE><B>    string ::= </B>"<B>quotable</B>"<B>    quotable ::= empty | quotable strchar | quotable</B>\<B>character    strchar ::= character - {</B>"<B>,</B>\<B>}</B></PRE>Sometimes it is desirable to group together a sequence of arbitrary bits orcharacters without imposing escape characters, e.g. to encode images, audio, orvideo in special formats.  Character blocks permit this sort of grouping throughthe use of a prefix that specifies how many of the following characters are togrouped together in this way.  A <I>character block</I> consists of thecharacter <TT>#</TT> followed by the decimal encoding of a positive integer <B>n</B>,the character <TT>q</TT> or <TT>Q</TT>, and then <B>n</B> arbitrary characters.<P><PRE><B>    block ::= </B>#<B> int(n) </B>q<B> character^n | </B>#<B> int(n) </B>Q<B> character^n</B></PRE>For the purpose of grammatical analysis, it is useful to subdivide the class ofwords a little further, viz. as variables, operators, and constants.<P>A <I>variable</I> is a word in which the first character is <TT>?</TT> or <TT>@</TT>. A variable that begins with <TT>?</TT> is called an <I>individual variable</I>.  Avariable that begins with an <TT>@</TT> is called a <I>sequence variable</I>.<P><PRE><B>    variable ::= indvar | seqvar    indvar ::= </B>?<B>word    seqvar ::= </B>@<B>word</B></PRE><I>Operators</I> are used in forming complex expressions of various sorts. <PRE><B>    operator ::=  </B>unprovable<B> | </B>not<B> | </B>and<B> | </B>or<B> | </B>=><B> | </B><=<B></B></PRE>All other words are called <I>constants</I>.<P><PRE><B>    constant ::= word - variable - operator</B></PRE>Semantically, there are four categories of constants in SIF -- object constants,function constants, relation constants, and logical constants.  <I>Objectconstants</I> are used to denote individual objects.  <I>Function constants</I>denote functions on those objects.  <I>Relation constants</I> denote relations. <I>Logical constants</I> express conditions about the world and are either trueor false.  SIF is unusual among logical languages in that there is no syntacticdistinction among these four types of constants; any constant can be used whereany other constant can be used.  The differences between these categories ofconstants is entirely semantic.<P><H3>Expressions</H3>The legal expressions of SIF are formed from lexemes according to the rulespresented in this section.  There are three disjoint types of expressions inthe language -- <I>terms</I>, <I> sentences</I>, and <I>forms</I>. Terms are used to denote objects in the world being described; sentences and formsare used to express facts about the world.  A <I>knowledge base</I> is a finitesequence of forms.<P>There are six types of terms in SIF -- individual variables, constants,character references, character strings, character blocks, and list expressions. Individual variables, constants, character references, strings, and blocks werediscussed earlier.<P> <PRE><B>    term ::= indvar | constant | charref | string | block | listexpr</B></PRE>A list expression is either an <I>atom</I> or a sequence of listexpressions surrounded by parentheses.  An atom is either a word or acharacter reference or a character string or a character block.<PRE><B>    listexpr ::= atom | </B>(<B>listexpr*</B>)<B>    atom ::= word | charref | string | block</B></PRE>The following BNF defines the set of legal sentences in SIF.  Thereare three types of sentences.  We have already mentioned logical constants.<P><PRE><B>    sentence ::= constant | relsent | logsent</B></PRE>A <I>relational sentence</I> consists of a relation constant and an arbitrarynumber of <I>argument</I> terms, terminated by an optional sequence variable. As with functional terms, there is no syntactic  restriction on the number ofargument terms in a relation sentence -- the same relation constant can beapplied to any finite number of arguments.<P><PRE><B>    relsent ::= </B>(<B>constant term* [seqvar]</B>)<B></B></PRE><P>It is noteworthy that the syntax of relational sentences is the same as that offunctional terms.  On the other hand, their meanings are different.  Fortunately,the context of each such expression determines its type (as an embedded term inone case or as a top-level sentence or argument to some sentential operator inthe other case); and so this slight ambiguity causes no problems.<P>The syntax of <I>logical sentences</I> depends on the logical operatorinvolved.  A sentence involving the <TT>not</TT> operator is called a <I>negation</I>.  A sentence involving the <TT>and</TT> operator is called a<I>conjunction</I>, and the arguments are called <I>conjuncts</I>.  A sentenceinvolving the <TT>or</TT> operator is called a <I>disjunction</I>, and thearguments are called <I>disjuncts</I>.<PRE><B>    logsent ::= </B>(unprovable <B>sentence</B>)<B> |                 </B>(not <B>sentence</B>)<B> |                </B>(and <B>sentence*</B>)<B> |                </B>(or <B>sentence*</B>)<B>                </B></PRE><P>As with sentences, the syntax of a <I>form</I> depends on the logicaloperator involved.  A form involving the <TT>=></TT> operator is called an<I>implication</I>; all of its arguments but the last are called<I>antecedents</I>; and the last argument is called the <I>consequent</I>.  Asentence involving the <TT><=</TT> operator is called a <I>reverse implication</I>;its first argument is called the <I>consequent</I>; and the remaining arguments arecalled the <I>antecedents</I>.<PRE><B>    form ::= sentence |             </B>(=> <B>sentence* sentence</B>)<B> |             </B>(<= <B>sentence sentence*</B>)<B></B></PRE><P>A <I>knowledge base</I> is a finite sequence of forms.  It is defined as asequence because the order of forms in a knowledge base may have affect theway the knowledge base is processed by interpreters.<P><HR><H2>3. Logic </H2><H3>Bottom</H3>In KIF, all functions are total, i.e. there is a value for every combinationof arguments.  In order to allow a user to express the idea that a functionis not meaningful for certain arguments, KIF assumes that there is a special"undefined" object in the universe and provides the object constant<TT>bottom</TT> to refer to this object.<P><H3>True and False</H3>The truth value of <TT>true</TT> is true, and the truth value of <TT>false</TT>is false.<P><H3>Equations and Inequalities</H3>An equation is true if and only if the terms in the equation refer to the same objectin the universe of discourse.<P>An inequality is true if and only if the terms in the equation refer to distinctobjects in the universe of discourse.<P><H3>Relational Sentences</H3>A simple relational sentence without a terminating sequence variable is trueif and only if the relation denoted by the relation constant in the sentenceis true of the objects denoted by the arguments.  Equivalently, viewing arelation as a set of tuples, we say that the relational sentence is true ifand only if the tuple of objects formed from the values of the arguments is amember of the set of tuples denoted by the relation constant.<P>If a relational sentence terminates in a sequence variable, the sentenceis true if and only if the relation contains the tuple consisting of thevalues of the terms that precede the sequence variable together with theobjects in the sequence denoted by the variable.<P><H3>Logical Sentences</H3>A negation is true if and only if the negated sentence is false.<P>A conjunction is true if and only if every conjunct is true.<P>A disjunction is true if and only if at least one of the disjuncts istrue.<P><H3>Forms</H3>If every antecedent in an implication is true, then the implication as a wholeis true if and only if the the consequent is true.  If any of the antecedentsis false, then the implication as a whole is true, regardless of the truthvalue of the consequent.<P>A reverse implication is just an implication with the consequent and antecedentsreversed.<P>Note that the significance of variables in sentences and formsdepends on context.  Variables in an assertion are assumed to beuniversally quantified.  Variables in a query are assumed to beexistentially quantified.  In other words, the meaning of variables isdetermined by the way in which SIF is used.  It cannot be unambiguouslydefined within SIF itself.<HR><H2>4. Numbers</H2><H3>Introduction</H3><P>The referent of every numerical constant in KIF is assumed to be the numberfor which that constant is the base 10 representation.  Among other things,this means that we can infer inequality of all distinct numerical constants.<P>We use the intended meaning of numerical constants in defining the numericalrelations in this chapter.  In effect, we require that theserelations behave correctly on all numbers represented in thisway.<P>Remember that SIF does not allow sentences containing complex arithmeticexpressions.  For example. we cannot write the mathematical sentence 2*(3+4)=14directly.  Rather, this must be written using the underlying relations withoutcomplex terms.  For example, the preceding sentence would be written <TT>(<= (*2 ?x 14) (+ 3 4 ?x))</TT>.<P>Since such terms cannot be written in SIF, in SIF there is no distinctionbetween function constants (which can usually be used in such expressions) andrelation constants (which cannot).  Nevertheless, there is still a distinctionbetween arithmetic relations that are functional (e.g. + and *) and those thatare purely relational (e.g. &lt; and &gt;).  In this section, these two classesof arithmetic relations.<H3>Functions on Numbers</H3><DL><P><DT><TT>*</TT><DD>The sentence <TT>(* <B>t1</B> ... <B>tn</B> <B>t</B>)</TT> is true ifand only if <B>t</B> denotes the product of the numbers denoted by <B>t1</B> ...<B>tn</B>.<P><DT><TT>+</TT><DD>The sentence <TT>(+ <B>t1</B> ... <B>tn</B> <B>t</B>)</TT> is true ifand only if <B>t</B> denotes the sum of the numbers denoted by <B>t1</B> ...<B>tn</B>.<P><DT><TT>-</TT><DD>The sentence <TT>(- <B>t1</B> ... <B>tn</B> <B>t</B>)</TT> is true ifand only if <B>t</B> denotes the difference of the number denoted by <B>t1</B>and the numbers denoted by <TT><B>t2</B></TT> ... <B>tn</B>.  An exceptionoccurs when <B>n=1</B>, in which case <B>t</B> denotes the negation of thenumber denoted by <TT><B>t1</B></TT>.<P><DT><TT>/</TT><DD>The sentence <TT>(/ <B>t1</B> ... <B>tn</B> <B>t</B>)</TT> is true ifand only if <B>t</B> denotes the quotient of the number denoted by <B>t1</B>and the numbers denoted by <TT><B>t2</B></TT> ... <B>tn</B>.  An exceptionoccurs when <B>n=1</B>, in which case <B>t</B> denotes the reciprocal of thenumber denoted by <TT><B>t1</B></TT>.<P><DT><DT><TT>1+</TT><DD>The sentence <TT>(1+ <B>t1</B> <B>t</B>)</TT> is true ifand only if <B>t</B> denotes the sum of 1 and the number denoted by <B>t1</B>.<P><DT><TT>1-</TT><DD>The sentence <TT>(1- <B>t1</B> <B>t</B>)</TT> is true ifand only if <B>t</B> denotes the difference the number denoted by<B>t1</B> and 1.<DT><P><DT><TT>abs</TT><DD>The sentence <TT>(abs <B>t1</B> <B>t</B>)</TT> is true if and only if<TT><B>t</B></TT> denotes the absolute value of the number denoted by<TT><B>t1</B></TT>. <P><P><DT><TT>acos</TT><DD>The sentence <TT>(acos <B>t1</B> <B>t</B>)</TT> is true if and only if<TT><B>t</B></TT> denotes the arc cosine of the number denoted by<TT><B>t1</B></TT>.<P><DT><TT>acosh</TT><DD>The sentence <TT>(acosh <B>t1</B> <B>t</B>)</TT> is true if and only if<TT><B>t</B></TT> denotes the hyperbolic arc cosine of the number denoted by<TT><B>t1</B></TT>.<P><DT><TT>ash</TT><DD>The sentence <TT>(ash <B>t1</B> <B>t2</B> <B>t</B>)</TT> is true if and onlyif <TT><B>t</B></TT> denotes the result of arithmetically shifting the two'scomplement representation of the number denoted by <TT><B>t1</B></TT> by thenumber of bits denoted by <TT><B>t2</B></TT> (left or right shifting dependingon the whether <TT><B>t2</B></TT> is positive or negative).<P><DT><TT>asin</TT><DD>The sentence <TT>(asin <B>t1</B> <B>t</B>)</TT> is true if and only if<TT><B>t</B></TT> denotes the arc sin of the number denoted by<TT><B>t1</B></TT>.<P><DT><TT>asinh</TT><DD>The sentence <TT>(asinh <B>t1</B> <B>t</B>)</TT> is true if and only if<TT><B>t</B></TT> denotes the hyperbolic arc sine of the number denoted by<TT><B>t1</B></TT>.<P><DT><TT>atan</TT><DD>The sentence <TT>(atan <B>t1</B> <B>t</B>)</TT> is true if and only if<TT><B>t</B></TT> denotes the arc tangent of the number denoted by<TT><B>t1</B></TT>.<P><DT><TT>atanh</TT><DD>The sentence <TT>(atanh <B>t1</B> <B>t</B>)</TT> is true if and only if<TT><B>t</B></TT> denotes the hyperbolic arc tangent of the number denoted by<TT><B>t1</B></TT>.<P><DT><TT>boole</TT><DD>The sentence <TT>(boole <B>t1</B> <B>t2</B> <B>t3</B> <B>t</B>)</TT> is trueif and only if <TT><B>t</B></TT> denotes the result of applying the operationdenoted by the number denoted by <TT><B>t1</B></TT> to the numbers denoted by<TT><B>t2</B></TT> and <TT><B>t3</B></TT>.<P><DT><TT>ceiling</TT><DD>The sentence <TT>(ceiling <B>t1</B> <B>t</B>)</TT> is true if and only if<TT><B>t</B></TT> denotes the smallest integer greater than or equal tothe number denoted by <TT><B>t1</B></TT>.<P><DT><TT>cis</TT><DD>The sentence <TT>(cis <B>t1</B> <B>t</B>)</TT> is true if and only if<TT><B>t</B></TT> denotes the complex number <B>cos(t1) + i sin(t1)</B>. Theargument is any non-complex number of radians.<P><DT><TT>conjugate</TT><DD>The sentence <TT>(conjugate <B>t1</B> <B>t</B>)</TT> is true if and only if<TT><B>t</B></TT> denotes the complex conjugate of the number denoted by<TT><B>t1</B></TT>.<P><DT><TT>cos</TT><DD>The sentence <TT>(cos <B>t1</B> <B>t</B>)</TT> is true if and only if<TT><B>t</B></TT> denotes the cosine of the number denoted by<TT><B>t1</B></TT> (in radians).<P><DT><TT>cosh</TT><DD>The sentence <TT>(cosh <B>t1</B> <B>t</B>)</TT> is true if and only if<TT><B>t</B></TT> denotes the hyperbolic cosine of the number denoted by<TT><B>t1</B></TT> (in radians).<P><DT><TT>decode-float</TT><DD>The sentence <TT>(decode-float <B>t1</B> <B>t</B>)</TT> is true if and onlyif <TT><B>t</B></TT> denotes the mantissa of the number denoted by<TT><B>t1</B></TT>.<P><DT><TT>denominator</TT><DD>The sentence <TT>(cos <B>t1</B> <B>t</B>)</TT> is true if and only if<TT><B>t</B></TT> denotes the denominator of the canonical reduced form of thenumber denoted by <TT><B>t1</B></TT>.<P><DT><TT>exp</TT><DD>The sentence <TT>(exp <B>t1</B> <B>t</B>)</TT> is true if and only if<TT><B>t</B></TT> denotes the number obtained by raising <B>e</B> to thepower of the numer denoted by <TT><B>t1</B></TT>.<P><DT><TT>expt</TT><DD>The sentence <TT>(expt <B>t1</B> <B>t2</B> <B>t</B>)</TT> is true if andonly if <TT><B>t</B></TT> denotes the number obtained by raising the numberdenoted by <B>t1</B> to the power of the number denoted by<TT><B>t2</B></TT>.<P><DT><TT>fceiling</TT><DD>The sentence <TT>(fceiling <B>t1</B> <B>t</B>)</TT> is true if and only if<TT><B>t</B></TT> denotes the smallest integer (as a floating point number)greater than the number denoted by <TT><B>t1</B></TT>.<P><DT><TT>ffloor</TT><DD>The sentence <TT>(ffloor <B>t1</B> <B>t</B>)</TT> is true if and only if<TT><B>t</B></TT> denotes the largest integer (as a floating point number) lessthan the number denoted by <TT><B>t1</B></TT>.<P><DT><TT>float</TT><DD>The sentence <TT>(float <B>t1</B> <B>t</B>)</TT> is true if and only if<TT><B>t</B></TT> denotes the floating point number equal to the number denotedby <TT><B>t1</B></TT>.<P><DT><TT>float-digits</TT><DD>The sentence <TT>(float-digits <B>t1</B> <B>t</B>)</TT> is true if and onlyif <TT><B>t</B></TT> denotes the number of digits used in the representation ofthe floating point number denoted by <TT><B>t1</B></TT>.<P><DT><TT>float-precision</TT><DD>The sentence <TT>(float-precision <B>t1</B> <B>t</B>)</TT> is true if andonly if <TT><B>t</B></TT> denotes the number of significant digits in thefloating point number denoted by <TT><B>t1</B></TT>.<P><DT><TT>float-radix</TT><DD>The sentence <TT>(float-radix <B>t1</B> <B>t</B>)</TT> is true if andonly if <TT><B>t</B></TT> denotes the radix of the floating point number denoted by<TT><B>t1</B></TT>. The most common values are <B>2</B> and <B>16</B>.<P><DT><TT>float-sign</TT><DD>The sentence <TT>(float-sign <B>t1</B> <B>t2</B> <B>t</B>)</TT> is true ifand only if <TT><B>t</B></TT> denotes the floating-point number with the samesign as the number denoted by <TT><B>t1</B></TT> and the same absolute value asthe number denoted by <TT><B>t2</B></TT>.<P><DT><TT>floor</TT><DD>The sentence <TT>(floor <B>t1</B> <B>t</B>)</TT> is true if and only if<TT><B>t</B></TT> denotes the largest integer less than the number denoted by<TT><B>t1</B></TT>.<P><DT><TT>fround</TT><DD>The sentence <TT>(fround <B>t1</B> <B>t</B>)</TT> is true if and only if<TT><B>t</B></TT> denotes the integer (as a floating point number) closestto the number denoted by <TT><B>t1</B></TT>.  Ties are broken in the directionof the closest even number.<P><DT><TT>ftruncate</TT><DD>The sentence <TT>(ftruncate <B>t1</B> <B>t</B>)</TT> is true if and only if<TT><B>t</B></TT> denotes the largest positive integer (as a floating pointnumber) greater than or equal to the number denoted by <TT><B>t1</B></TT> (when<TT><B>t1</B></TT> is a positive number or zero) ; and it denotes the smallestnegative integer (as a floating point number) larger than <TT><B>t1</B></TT>(when <TT><B>t1</B></TT> is a negative number).<P><DT><TT>gcd</TT><DD>The sentence <TT>(gcd <B>t1</B> ... <B>tn</B> <B>t</B>)</TT> is true if andonly if <TT><B>t</B></TT> denotes the greatest common divisor of the numbersdenoted by <TT><B>t1</B></TT> through <TT><B>tn</B></TT>.<P><DT><TT>imagpart</TT><DD>The sentence <TT>(imagpart <B>t1</B> <B>t</B>)</TT> is true if and only if<TT><B>t</B></TT> denotes the imaginary part of the number denoted by<TT><B>t1</B></TT>.<P><DT><TT>integer-decode-float</TT><DD>The sentence <TT>(integer-decode-float <B>t1</B> <B>t</B>)</TT> is true ifand only if <TT><B>t</B></TT> denotes the significand of the number denoted by<TT><B>t1</B></TT>.<P><DT><TT>integer-length</TT><DD>The sentence <TT>(integer-length <B>t1</B> <B>t</B>)</TT> is true if andonly if <TT><B>t</B></TT> denotes the number of bits required to store theabsolute magnitude of the number denoted by <TT><B>t1</B></TT>.<P><DT><TT>isqrt</TT><DD>The sentence <TT>(isqrt <B>t1</B> <B>t</B>)</TT> is true if and only if<TT><B>t</B></TT> denotes the integer square root of the number denoted by<TT><B>t1</B></TT>.<P><DT><TT>lcm</TT><DD>The sentence <TT>(lcm <B>t1</B> ... <B>tn</B> <B>t</B>)</TT> is true if andonly if <TT><B>t</B></TT> denotes the least common multiple of the numbersdenoted by <B>t1</B>,...,<B>tn</B>.<P><DT><TT>log</TT><DD>The sentence <TT>(log <B>t1</B> <B>t2</B> <B>t</B>)</TT> is true if andonly if <TT><B>t</B></TT> denotes the the logarithm of thenumber denoted by <TT><B>t1</B></TT> in the base denoted by<TT><B>t2</B></TT>.<P><DT><TT>logand</TT><DD>The sentence <TT>(lcm <B>t1</B> ... <B>tn</B> <B>t</B>)</TT> is true if andonly if <TT><B>t</B></TT> denotes the bit-wise logical <I>and</I> of the numbersdenoted by <TT><B>t1</B></TT> through <TT><B>tn</B></TT>.  It returns -1 if there areno arguments.<P><DT><TT>logandc1</TT><DD>The sentence <TT>(logandc1 <B>t1</B> <B>t2</B> <B>t</B>)</TT> is equivalentto the logical <I>and</I> of the logical negation of <TT><B>t1</B></TT> and<TT><B>t2</B></TT>.<P><DT><TT>logandc2</TT><DD>The sentence <TT>(logandc1 <B>t1</B> <B>t2</B> <B>t</B>)</TT> is equivalentto the logical <I>and</I> of <TT><B>t1</B></TT> and the logical negation of<TT><B>t2</B></TT>.<P><DT><TT>logcount</TT><DD>The sentence <TT>(logandc1 <B>t1</B> <B>t2</B> <B>t</B>)</TT> is true if and onlyif <TT><B>t</B></TT> denotes the number of <I>on</I> bits in the number denoted by<TT><B>t</B></TT>. If the number denoted by <TT><B>t</B></TT> is positive, then theone bits are counted; otherwise, the zero bits in the twos-complement representationare counted.<P><DT><TT>logeqv</TT><DD>The sentence <TT>(logeqv <B>t1</B> ... <B>tn</B> <B>t</B>)</TT> is true ifand only if <TT><B>t</B></TT> denotes the bit-wise logical equivalence of thenumbers denoted by <TT><B>t1</B></TT> through <TT><B>tn</B></TT>.<P><DT><TT>logior</TT><DD>The sentence <TT>(logior <B>t1</B> ... <B>tn</B> <B>t</B>)</TT> is true ifand only if <TT><B>t</B></TT> denotes the bit-wise logical inclusive <I>or</I> ofthe numbers denoted by <TT><B>t1</B></TT> through <TT><B>tn</B></TT>. It denotes 0 ifthere are no arguments.<P><DT><TT>lognand</TT><DD>The sentence <TT>(lognand <B>t1</B> <B>t2</B> <B>t</B>)</TT> is equivalentto the logical negation of the inclusive <I>and</I> of <TT><B>t1</B></TT> and<TT><B>t2</B></TT>.<P><DT><TT>lognor</TT><DD>The sentence <TT>(lognor <B>t1</B> <B>t2</B> <B>t</B>)</TT> is equivalentto the logical negation of the inclusive <I>or</I> of <TT><B>t1</B></TT> and<TT><B>t2</B></TT>.<P><DT><TT>lognot</TT><DD>The sentence <TT>(lognot <B>t1</B> <B>t</B>)</TT> is true if and only if<TT><B>t</B></TT> denotes the bit-wise logical negation of <TT><B>t1</B></TT>.<P><DT><TT>logorc1</TT><DD>The sentence <TT>(logorc1 <B>t1</B> <B>t2</B> <B>t</B>)</TT> is equivalentto the logical <I>or</I> of the logical negation of <TT><B>t1</B></TT> and<TT><B>t2</B></TT>.<P><DT><TT>logorc2</TT><DD>The sentence <TT>(logorc1 <B>t1</B> <B>t2</B> <B>t</B>)</TT> is equivalentto the logical <I>or</I> of <TT><B>t1</B></TT> and the logical negation of<TT><B>t2</B></TT>.<P><DT><TT>logxor</TT><DD>The sentence <TT>(logxor <B>t1</B> ... <B>tn</B> <B>t</B>)</TT> is true ifand only if <TT><B>t</B></TT> denotes the bit-wise logical <I>exclusive or</I>of the numbers denoted by <TT><B>t1</B></TT> through <TT><B>tn</B></TT>. It denotes 0 if there are no arguments.<P><DT><TT>max</TT><DD>The sentence <TT>(max <B>t1</B> ... <B>t1</B> <B>t</B>)</TT> is true if andonly if <TT><B>t</B></TT> denotes the largest of the numbersdenoted by <TT><B>t1</B></TT> through <TT><B>tn</B></TT>.<P><DT><TT>min</TT><DD>The sentence <TT>(min <B>t1</B> ... <B>t1</B> <B>t</B>)</TT> is true if andonly if <TT><B>t</B></TT> denotes the largest of the numbersdenoted by <TT><B>t1</B></TT> through <TT><B>tn</B></TT>.<P><DT><TT>mod</TT><DD>The sentence <TT>(mod <B>t1</B> <B>t2</B> <B>t</B>)</TT> is true if andonly if <TT><B>t</B></TT> denotes the number denoted by <TT><B>t1</B></TT>modulo the number denoted by <TT><B>t2</B></TT>. The result will have the samesign as denoted by <TT><B>t1</B></TT>.<P><DT><TT>numerator</TT><DD>The sentence <TT>(numerator <B>t1</B> <B>t</B>)</TT> is true if and only if<TT><B>t</B></TT> denotes the numerator of the canonical reduced form ofthe number denoted by <TT><B>t</B></TT>.<P><DT><TT>phase</TT><DD>The sentence <TT>(phase <B>t1</B> <B>t</B>)</TT> is true if and only if<TT><B>t</B></TT> denotes the angle part of the polar representation of the number denoted by <TT><B>t1</B></TT> (in radians).<P><DT><TT>rationalize</TT><DD>The sentence <TT>(rationalize <B>t1</B> <B>t</B>)</TT> is true if and only if<TT><B>t</B></TT> denotes the rational representation of the number denoted by<TT><B>t1</B></TT>.<P><DT><TT>realpart</TT><DD>The sentence <TT>(realpart <B>t1</B> <B>t</B>)</TT> is true if and only if<TT><B>t</B></TT> denotes the real part of the number denoted by<TT><B>t1</B></TT>.<P><DT><TT>rem</TT><DD>The sentence <TT>(rem <B>t1</B> <B>t2</B> <B>t</B>)</TT> is true if and onlyif <TT><B>t</B></TT> denotes the remainder of the number denoted by<TT><B>t1</B></TT> divided by the number denoted by <TT><B>t2</B></TT>. Theresult has the same sign as the number denoted by <TT><B>t2</B></TT>.<P><DT><TT>round</TT><DD>The sentence <TT>(round <B>t1</B> <B>t</B>)</TT> is true if and only if<TT><B>t</B></TT> denotes the integer closest to the number denoted by<TT><B>t1</B></TT>.  Ties are broken in the direction of the closest evennumber.<P><DT><TT>scale-float</TT><DD>The sentence <TT>(scale-float <B>t1</B> <B>t2</B> <B>t</B>)</TT> is true ifand only if <TT><B>t</B></TT> denotes the floating-point number that is therepresentational radix of the number denoted by <TT><B>t1</B></TT> raised to theinteger denoted by <TT><B>t2</B></TT>.<P><DT><TT>signum</TT><DD>The sentence <TT>(signum <B>t1</B> <B>t</B>)</TT> is true if and only if<TT><B>t</B></TT> denotes the sign of the number denoted by <TT><B>t</B></TT>.This is one of -1, 1, or 0 for rational numbers, and one of -1.0, 1.0, or 0.0for floating point numbers.<P><DT><TT>sin</TT><DD>The sentence <TT>(tan <B>t1</B> <B>t</B>)</TT> is true if and only if<TT><B>t</B></TT> denotes the sine of the number denoted by <TT><B>t1</B></TT>.<P><DT><TT>sinh</TT><DD>The sentence <TT>(sinh <B>t1</B> <B>t</B>)</TT> is true if and only if<TT><B>t</B></TT> denotes the hyperbolic sine of the number denotedby <TT><B>t1</B></TT>.<P><DT><TT>sqrt</TT><DD>The sentence <TT>(sqrt <B>t1</B> <B>t</B>)</TT> is true if and only if<TT><B>t</B></TT> denotes the square root of the number denotedby <TT><B>t1</B></TT>.<P><DT><TT>tan</TT><DD>The sentence <TT>(tan <B>t1</B> <B>t</B>)</TT> is true if and only if<TT><B>t</B></TT> denotes the tangent of the number denotedby <TT><B>t1</B></TT>.<P><DT><TT>tanh</TT><DD>The sentence <TT>(tanh <B>t1</B> <B>t</B>)</TT> is true if and only if<TT><B>t</B></TT> denotes the hyperbolic tangent of the number denotedby <TT><B>t1</B></TT>.<P><DT><TT>truncate</TT><DD>The sentence <TT>(truncate <B>t1</B> <B>t</B>)</TT> is true if and only if<TT><B>t</B></TT> denotes the largest positive integer greater than or equal tothe number denoted by <TT><B>t1</B></TT> (when <TT><B>t1</B></TT> is a positivenumber or zero) ; and it denotes the smallest negative integer larger than<TT><B>t1</B></TT> (when <TT><B>t1</B></TT> is a negative number).</DL><H3>Relations on Numbers</H3><DL><P><DT><TT>integer</TT><DD>The sentence <TT>(integer <TT><B>t</B></TT>)</TT> is true if<TT><B>t</B></TT> denotes an integer.<P><DT><TT>real</TT><DD>The sentence <TT>(real <TT><B>t</B></TT>)</TT> is true if <TT><B>t</B></TT>denotes a real number.<P><DT><TT>complex</TT><DD>The sentence <TT>(complex <TT><B>t</B></TT>)</TT> is trueif <TT><B>t</B></TT> denotes a complex number.<P><DT><TT>number</TT><DD>The sentence <TT>(number <TT><B>t</B></TT>)</TT> is trueif <TT><B>t</B></TT> denotes a number.<P><DT><TT>natural</TT><DD>The sentence <TT>(natural <TT><B>t</B></TT>)</TT> is trueif <TT><B>t</B></TT> denotes a natural number (i.e. 1, 2, ...).<P><DT><TT>rational</TT><DD>The sentence <TT>(natural <TT><B>t</B></TT>)</TT> is trueif <TT><B>t</B></TT> denotes a rational number.<P><DT><TT>&lt;</TT><DD>The sentence <TT>(< <TT><B>t1</B></TT> <TT><B>t2</B></TT>)</TT> is true if and only if the number denoted by<TT><B>t1</B></TT> is less than the number denoted by <TT><B>t2</B></TT>.<P><DT><TT>&gt;</TT><DD>The sentence <TT>(&gt; <TT><B>t1</B></TT> <TT><B>t2</B></TT>)</TT> is trueif and only if the number denoted by <TT><B>t1</B></TT> is greater than thenumber denoted by <TT><B>t2</B></TT>.<P><DT><TT>&gt;=</TT><DD>The sentence <TT>(&gt;= <TT><B>t1</B></TT> <TT><B>t2</B></TT>)</TT> is trueif and only if the number denoted by <TT><B>t1</B></TT> is greater than or equalto the number denoted by <TT><B>t2</B></TT>.<P><DT><TT>=&lt;</TT><DD>The sentence <TT>(=&lt; <TT><B>t1</B></TT> <TT><B>t2</B></TT>)</TT> is trueif and only if the number denoted by <TT><B>t1</B></TT> is equal to or less thanthe number denoted by <TT><B>t2</B></TT>.<P><DT><TT>positive</TT><DD>The sentence <TT>(positive <TT><B>t</B></TT>)</TT> is true if only if<TT><B>t</B></TT> denotes a number greater than zero.<P><DT><TT>negative</TT><DD>The sentence <TT>(negative <TT><B>t</B></TT>)</TT> is true if<TT><B>t</B></TT> denotes a number less than zero.<P><DT><TT>zero</TT><DD>The sentence <TT>(zero <B>t</B>)</TT> is true if<TT><B>t</B></TT> denotes zero (fixed or floating point).<P><DT><TT>odd</TT><DD>The sentence <TT>(odd <B>t</B>)</TT> is true if<TT><B>t</B></TT> denotes an odd number.<P><DT><TT>even</TT><DD>The sentence <TT>(even <B>t</B>)</TT> is true if<TT><B>t</B></TT> denotes an even number.<P><DT><TT>logbit</TT><DD>The sentence <TT>(logbit <TT><B>t1</B></TT> <TT><B>t2</B></TT>)</TT> is true if bit <TT><B>t2</B></TT>of <TT><B>t1</B></TT> is 1.<P><DT><TT>logtest</TT><DD>The sentence <TT>(logtest <TT><B>t1</B></TT> <TT><B>t2</B></TT>)</TT> is trueif the logical <I>and</I> of the two's-complement representation of the integers<TT><B>t1</B></TT> and <TT><B>t2</B></TT> is not zero.</DL><HR><H2>5. Characters and Strings</H2><H3>Characters</H3>A character is a printed symbol, such as a digit or a letter.  There are128 distinct characters known to KIF, corresponding to the 128 possiblecombinations of bits in the ASCII encoding.  In KIF, there are two ways torefer to characters.<P>The first method is use of <TT><B>charref</B></TT> syntax, i.e. thecharacters <TT>#</TT> and <TT>\</TT>, followed by the character to berepresented.<P>While this method works for all 128 characters, it is less than ideal fordocuments like this one, because of the difficulty of writing outnon-printing characters.  Using this method, it is also difficult to assertproperties of some classes of characters.  For this reason, KIF supports analternative method of specification, viz. the use of the 7 bit codecorresponding to the character.The following paragraphs describe the relations relevant to characters.<P><DT><TT>character</TT><DD>The sentence <TT>(character <B>t</B>)</TT> is trueif and only if <TT><B>t</B></TT> denotes a character.<P><DT><TT>alphabetic</TT><DD>The sentence <TT>(alphabetic <B>t</B>)</TT> is trueif and only if <TT><B>t</B></TT> denotes an alphabetic character.<P><DT><TT>uppercase</TT><DD>The sentence <TT>(uppercase <B>t</B>)</TT> is trueif and only if <TT><B>t</B></TT> denotes an upper case character.<P><DT><TT>lowercase</TT><DD>The sentence <TT>(lowercase <B>t</B>)</TT> is trueif and only if <TT><B>t</B></TT> denotes a lower case character.<P><DT><TT>digit</TT><DD>The sentence <TT>(digit <B>t</B>)</TT> is trueif and only if <TT><B>t</B></TT> denotes a digit.<P><DT><TT>alphanumeric</TT><DD>The sentence <TT>(alphanumeric <B>t</B>)</TT> is trueif and only if <TT><B>t</B></TT> denotes an alphanumeric character.<P><DT><TT>chargreater</TT><DD>The sentence <TT>(chargreater <B>t1</B> <B>t2</B>)</TT> is trueif and only if the character denoted by <TT><B>t1</B></TT> lexicographicallysucceeds the character denoted by <TT><B>t2</B></TT>.<P><DT><TT>charless</TT><DD>The sentence <TT>(charless <B>t1</B> <B>t2</B>)</TT> is trueif and only if the character denoted by <TT><B>t1</B></TT> lexicographicallyprecedes the character denoted by <TT><B>t2</B></TT>.</DL><H3>Strings</H3>A <I>string</I> is a list of characters.<P>One way of referring to strings is through the use of the<TT><B>string</B></TT> syntax described in chapter 2.  In thismethod, we refer to the string <TT>abc</TT> by enclosing it in doublequotes, i.e. <TT>"abc"</TT>.<P>A second way is through the use of character blocks, the<TT><B>block</B></TT> syntax described in chapter 2.  In thismethod, we refer to the string <TT>abc</TT> by prefixing with thecharacter <TT>#</TT>, a positive integer indicating the length, the letter<TT>q</TT>, and the characters of the string, i.e. <TT>#3qabc</TT>.The following paragraphs describe the relations relevant to strings.<DL><P><DT><TT>makestring</TT><DD>The sentence <TT>(makestring <B>t1</B> <B>t</B>)</TT> is true if and only if<TT><B>t</B></TT> denotes the string corresponding to the expression<TT><B>t1</B></TT>.<P><DT><TT>expression</TT><DD>The sentence <TT>(expression <B>t1</B> <B>t</B>)</TT> is true if and only if<TT><B>t</B></TT> is the expression corresponding to the string denoted by<TT><B>t1</B></TT>.<P><DT><TT>stralphanumeric</TT><DD>The sentence <TT>(strappend <B>t1</B> <B>t</B>)</TT> is trueif and only if <B>t</B> denotes the string composed of the alphanumericcharacters in <TT><B>t1</B></TT>.<P><DT><TT>strappend</TT><DD>The sentence <TT>(strappend <B>t1</B> ... <B>tn</B> <B>t</B>)</TT> is trueif and only if <B>t</B> denotes the concatenation of the strings denoted by <TT><B>t1</B></TT> ... <B>tn</B>.<P><DT><TT>strcapitalize</TT><DD>The sentence <TT>(strcapitalize <B>t1</B> <B>t</B>)</TT> is trueif and only if <B>t</B> denotes a copy of the string denoted by<TT><B>t1</B></TT> in which the initial character of every word is capitalized.<P><DT><TT>strcharpos</TT><DD>The sentence <TT>(strcharpos <B>t1</B> <B>t2</B> <B>t</B>)</TT> is trueif and only if <B>t</B> denotes the position of the character denoted by <TT><B>t1</B></TT> in the string denoted by <TT><B>t2</B></TT>.<P><DT><TT>strdowncase</TT><DD>The sentence <TT>(strdowncase <B>t1</B> <B>t</B>)</TT> is trueif and only if <B>t</B> denotes a copy of the string denoted by<TT><B>t1</B></TT> in which all alphbetic characters are lower case.<P><DT><TT>strelement</TT><DD>The sentence <TT>(strelement <B>t1</B> <B>t2</B> <B>t</B>)</TT> is trueif and only if <B>t</B> denotes the character found in the string denoted by<TT><B>t1</B></TT> at the position denoted by <TT><B>t2</B></TT>.<P><DT><TT>strgreater</TT><DD>The sentence <TT>(strgreater <B>t1</B> <B>t2</B>)</TT> is trueif and only if the string denoted by <TT><B>t1</B></TT> lexicographicallysucceeds the string denoted by <TT><B>t2</B></TT>.<P><DT><TT>string</TT><DD>The sentence <TT>(string <B>t</B>)</TT> is trueif and only if <TT><B>t</B></TT> denotes a string.<P><DT><TT>strlength</TT><DD>The sentence <TT>(strlength <B>t1</B> <B>t</B>)</TT> is trueif and only if <TT><B>t</B></TT> denotes the length of the string denoted by<TT><B>t1</B></TT>.<P><DT><TT>strless</TT><DD>The sentence <TT>(strless <B>t1</B> <B>t2</B>)</TT> is trueif and only if the string denoted by <TT><B>t1</B></TT> lexicographicallyprecedes the string denoted by <TT><B>t2</B></TT>.<P><DT><TT>strposition</TT><DD>The sentence <TT>(strposition <B>t1</B> <B>t2</B> <B>t</B>)</TT> is trueif and only if <TT><B>t</B></TT> denotes the string consisting of thecharacters from the string denoted by <TT><B>t1</B></TT> starting at theposition denoted by <TT><B>t2</B></TT> and ending at the position denoted by<TT><B>t3</B></TT>.<P><DT><TT>strsubseq</TT><DD>The sentence <TT>(strsubseq <B>t1</B> <B>t2</B> <B>t3</B> <B>t</B>)</TT> istrue if and only if the string denoted by <TT><B>t1</B></TT> lexicographicallyprecedes the string denoted by <TT><B>t2</B></TT>.<P><DT><TT>strsubstitute</TT><DD>The sentence <TT>(strsubstitute <B>t1</B> <B>t2</B> <B>t3</B> <B>t</B>)</TT>is true if and only if <TT><B>t</B></TT> denotes a copy of the string denotedby <TT><B>t3</B></TT> in which the character denoted by <TT><B>t1</B></TT>replaces every occurrence of the character denoted by <TT><B>t2</B></TT>.<P><DT><TT>strupcase</TT><DD>The sentence <TT>(strupcase <B>t1</B> <B>t</B>)</TT> is trueif and only if <B>t</B> denotes a copy of the string denoted by<TT><B>t1</B></TT> in which all alphbetic characters are upper case.<P><DT><TT>substring</TT><DD>The sentence <TT>(strless <B>t1</B> <B>t2</B>)</TT> is trueif and only if the string denoted by <TT><B>t1</B></TT> is a substring of thestring denoted by <TT><B>t2</B></TT>.</DL><HR><ADDRESS><A HREF="mailto:genesereth@cs.stanford.edu">Michael R. Genesereth</A></ADDRESS></BODY></HTML>