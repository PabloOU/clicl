<HTML><HEAD><TITLE>Numbers</TITLE></HEAD><BODY><HR><H2>Standard Information Format Specification</H2><H2>Chapter 4: Numbers </H2><HR><H3>Introduction</H3><P>The referent of every numerical constant in KIF is assumed to be the numberfor which that constant is the base 10 representation.  Among other things,this means that we can infer inequality of all distinct numerical constants.<P>We use the intended meaning of numerical constants in defining the numericalrelations in this chapter.  In effect, we require that theserelations behave correctly on all numbers represented in thisway.<P>Remember that SIF does not allow sentences containing complex arithmeticexpressions.  For example. we cannot write the mathematical sentence 2*(3+4)=14directly.  Rather, this must be written using the underlying relations withoutcomplex terms.  For example, the preceding sentence would be written <TT>(<= (*2 ?x 14) (+ 3 4 ?x))</TT>.<P>Since such terms cannot be written in SIF, in SIF there is no distinctionbetween function constants (which can usually be used in such expressions) andrelation constants (which cannot).  Nevertheless, there is still a distinctionbetween arithmetic relations that are functional (e.g. + and *) and those thatare purely relational (e.g. &lt; and &gt;).  In this section, these two classesof arithmetic relations.<H3>Functions on Numbers</H3><DL><P><DT><TT>*</TT><DD>The sentence <TT>(* <B>t1</B> ... <B>tn</B> <B>t</B>)</TT> is true ifand only if <B>t</B> denotes the product of the numbers denoted by <B>t1</B> ...<B>tn</B>.<P><DT><TT>+</TT><DD>The sentence <TT>(+ <B>t1</B> ... <B>tn</B> <B>t</B>)</TT> is true ifand only if <B>t</B> denotes the sum of the numbers denoted by <B>t1</B> ...<B>tn</B>.<P><DT><TT>-</TT><DD>The sentence <TT>(- <B>t1</B> ... <B>tn</B> <B>t</B>)</TT> is true ifand only if <B>t</B> denotes the difference of the number denoted by <B>t1</B>and the numbers denoted by <TT><B>t2</B></TT> ... <B>tn</B>.  An exceptionoccurs when <B>n=1</B>, in which case <B>t</B> denotes the negation of thenumber denoted by <TT><B>t1</B></TT>.<P><DT><TT>/</TT><DD>The sentence <TT>(/ <B>t1</B> ... <B>tn</B> <B>t</B>)</TT> is true ifand only if <B>t</B> denotes the quotient of the number denoted by <B>t1</B>and the numbers denoted by <TT><B>t2</B></TT> ... <B>tn</B>.  An exceptionoccurs when <B>n=1</B>, in which case <B>t</B> denotes the reciprocal of thenumber denoted by <TT><B>t1</B></TT>.<P><DT><DT><TT>1+</TT><DD>The sentence <TT>(1+ <B>t1</B> <B>t</B>)</TT> is true ifand only if <B>t</B> denotes the sum of 1 and the number denoted by <B>t1</B>.<P><DT><TT>1-</TT><DD>The sentence <TT>(1- <B>t1</B> <B>t</B>)</TT> is true ifand only if <B>t</B> denotes the difference the number denoted by<B>t1</B> and 1.<DT><P><DT><TT>abs</TT><DD>The sentence <TT>(abs <B>t1</B> <B>t</B>)</TT> is true if and only if<TT><B>t</B></TT> denotes the absolute value of the number denoted by<TT><B>t1</B></TT>. <P><P><DT><TT>acos</TT><DD>The sentence <TT>(acos <B>t1</B> <B>t</B>)</TT> is true if and only if<TT><B>t</B></TT> denotes the arc cosine of the number denoted by<TT><B>t1</B></TT>.<P><DT><TT>acosh</TT><DD>The sentence <TT>(acosh <B>t1</B> <B>t</B>)</TT> is true if and only if<TT><B>t</B></TT> denotes the hyperbolic arc cosine of the number denoted by<TT><B>t1</B></TT>.<P><DT><TT>ash</TT><DD>The sentence <TT>(ash <B>t1</B> <B>t2</B> <B>t</B>)</TT> is true if and onlyif <TT><B>t</B></TT> denotes the result of arithmetically shifting the two'scomplement representation of the number denoted by <TT><B>t1</B></TT> by thenumber of bits denoted by <TT><B>t2</B></TT> (left or right shifting dependingon the whether <TT><B>t2</B></TT> is positive or negative).<P><DT><TT>asin</TT><DD>The sentence <TT>(asin <B>t1</B> <B>t</B>)</TT> is true if and only if<TT><B>t</B></TT> denotes the arc sin of the number denoted by<TT><B>t1</B></TT>.<P><DT><TT>asinh</TT><DD>The sentence <TT>(asinh <B>t1</B> <B>t</B>)</TT> is true if and only if<TT><B>t</B></TT> denotes the hyperbolic arc sine of the number denoted by<TT><B>t1</B></TT>.<P><DT><TT>atan</TT><DD>The sentence <TT>(atan <B>t1</B> <B>t</B>)</TT> is true if and only if<TT><B>t</B></TT> denotes the arc tangent of the number denoted by<TT><B>t1</B></TT>.<P><DT><TT>atanh</TT><DD>The sentence <TT>(atanh <B>t1</B> <B>t</B>)</TT> is true if and only if<TT><B>t</B></TT> denotes the hyperbolic arc tangent of the number denoted by<TT><B>t1</B></TT>.<P><DT><TT>boole</TT><DD>The sentence <TT>(boole <B>t1</B> <B>t2</B> <B>t3</B> <B>t</B>)</TT> is trueif and only if <TT><B>t</B></TT> denotes the result of applying the operationdenoted by the number denoted by <TT><B>t1</B></TT> to the numbers denoted by<TT><B>t2</B></TT> and <TT><B>t3</B></TT>.<P><DT><TT>ceiling</TT><DD>The sentence <TT>(ceiling <B>t1</B> <B>t</B>)</TT> is true if and only if<TT><B>t</B></TT> denotes the smallest integer greater than or equal tothe number denoted by <TT><B>t1</B></TT>.<P><DT><TT>cis</TT><DD>The sentence <TT>(cis <B>t1</B> <B>t</B>)</TT> is true if and only if<TT><B>t</B></TT> denotes the complex number <B>cos(t1) + i sin(t1)</B>. Theargument is any non-complex number of radians.<P><DT><TT>conjugate</TT><DD>The sentence <TT>(conjugate <B>t1</B> <B>t</B>)</TT> is true if and only if<TT><B>t</B></TT> denotes the complex conjugate of the number denoted by<TT><B>t1</B></TT>.<P><DT><TT>cos</TT><DD>The sentence <TT>(cos <B>t1</B> <B>t</B>)</TT> is true if and only if<TT><B>t</B></TT> denotes the cosine of the number denoted by<TT><B>t1</B></TT> (in radians).<P><DT><TT>cosh</TT><DD>The sentence <TT>(cosh <B>t1</B> <B>t</B>)</TT> is true if and only if<TT><B>t</B></TT> denotes the hyperbolic cosine of the number denoted by<TT><B>t1</B></TT> (in radians).<P><DT><TT>decode-float</TT><DD>The sentence <TT>(decode-float <B>t1</B> <B>t</B>)</TT> is true if and onlyif <TT><B>t</B></TT> denotes the mantissa of the number denoted by<TT><B>t1</B></TT>.<P><DT><TT>denominator</TT><DD>The sentence <TT>(cos <B>t1</B> <B>t</B>)</TT> is true if and only if<TT><B>t</B></TT> denotes the denominator of the canonical reduced form of thenumber denoted by <TT><B>t1</B></TT>.<P><DT><TT>exp</TT><DD>The sentence <TT>(exp <B>t1</B> <B>t</B>)</TT> is true if and only if<TT><B>t</B></TT> denotes the number obtained by raising <B>e</B> to thepower of the numer denoted by <TT><B>t1</B></TT>.<P><DT><TT>expt</TT><DD>The sentence <TT>(expt <B>t1</B> <B>t2</B> <B>t</B>)</TT> is true if andonly if <TT><B>t</B></TT> denotes the number obtained by raising the numberdenoted by <B>t1</B> to the power of the number denoted by<TT><B>t2</B></TT>.<P><DT><TT>fceiling</TT><DD>The sentence <TT>(fceiling <B>t1</B> <B>t</B>)</TT> is true if and only if<TT><B>t</B></TT> denotes the smallest integer (as a floating point number)greater than the number denoted by <TT><B>t1</B></TT>.<P><DT><TT>ffloor</TT><DD>The sentence <TT>(ffloor <B>t1</B> <B>t</B>)</TT> is true if and only if<TT><B>t</B></TT> denotes the largest integer (as a floating point number) lessthan the number denoted by <TT><B>t1</B></TT>.<P><DT><TT>float</TT><DD>The sentence <TT>(float <B>t1</B> <B>t</B>)</TT> is true if and only if<TT><B>t</B></TT> denotes the floating point number equal to the number denotedby <TT><B>t1</B></TT>.<P><DT><TT>float-digits</TT><DD>The sentence <TT>(float-digits <B>t1</B> <B>t</B>)</TT> is true if and onlyif <TT><B>t</B></TT> denotes the number of digits used in the representation ofthe floating point number denoted by <TT><B>t1</B></TT>.<P><DT><TT>float-precision</TT><DD>The sentence <TT>(float-precision <B>t1</B> <B>t</B>)</TT> is true if andonly if <TT><B>t</B></TT> denotes the number of significant digits in thefloating point number denoted by <TT><B>t1</B></TT>.<P><DT><TT>float-radix</TT><DD>The sentence <TT>(float-radix <B>t1</B> <B>t</B>)</TT> is true if andonly if <TT><B>t</B></TT> denotes the radix of the floating point number denoted by<TT><B>t1</B></TT>. The most common values are <B>2</B> and <B>16</B>.<P><DT><TT>float-sign</TT><DD>The sentence <TT>(float-sign <B>t1</B> <B>t2</B> <B>t</B>)</TT> is true ifand only if <TT><B>t</B></TT> denotes the floating-point number with the samesign as the number denoted by <TT><B>t1</B></TT> and the same absolute value asthe number denoted by <TT><B>t2</B></TT>.<P><DT><TT>floor</TT><DD>The sentence <TT>(floor <B>t1</B> <B>t</B>)</TT> is true if and only if<TT><B>t</B></TT> denotes the largest integer less than the number denoted by<TT><B>t1</B></TT>.<P><DT><TT>fround</TT><DD>The sentence <TT>(fround <B>t1</B> <B>t</B>)</TT> is true if and only if<TT><B>t</B></TT> denotes the integer (as a floating point number) closestto the number denoted by <TT><B>t1</B></TT>.  Ties are broken in the directionof the closest even number.<P><DT><TT>ftruncate</TT><DD>The sentence <TT>(ftruncate <B>t1</B> <B>t</B>)</TT> is true if and only if<TT><B>t</B></TT> denotes the largest positive integer (as a floating pointnumber) greater than or equal to the number denoted by <TT><B>t1</B></TT> (when<TT><B>t1</B></TT> is a positive number or zero) ; and it denotes the smallestnegative integer (as a floating point number) larger than <TT><B>t1</B></TT>(when <TT><B>t1</B></TT> is a negative number).<P><DT><TT>gcd</TT><DD>The sentence <TT>(gcd <B>t1</B> ... <B>tn</B> <B>t</B>)</TT> is true if andonly if <TT><B>t</B></TT> denotes the greatest common divisor of the numbersdenoted by <TT><B>t1</B></TT> through <TT><B>tn</B></TT>.<P><DT><TT>imagpart</TT><DD>The sentence <TT>(imagpart <B>t1</B> <B>t</B>)</TT> is true if and only if<TT><B>t</B></TT> denotes the imaginary part of the number denoted by<TT><B>t1</B></TT>.<P><DT><TT>integer-decode-float</TT><DD>The sentence <TT>(integer-decode-float <B>t1</B> <B>t</B>)</TT> is true ifand only if <TT><B>t</B></TT> denotes the significand of the number denoted by<TT><B>t1</B></TT>.<P><DT><TT>integer-length</TT><DD>The sentence <TT>(integer-length <B>t1</B> <B>t</B>)</TT> is true if andonly if <TT><B>t</B></TT> denotes the number of bits required to store theabsolute magnitude of the number denoted by <TT><B>t1</B></TT>.<P><DT><TT>isqrt</TT><DD>The sentence <TT>(isqrt <B>t1</B> <B>t</B>)</TT> is true if and only if<TT><B>t</B></TT> denotes the integer square root of the number denoted by<TT><B>t1</B></TT>.<P><DT><TT>lcm</TT><DD>The sentence <TT>(lcm <B>t1</B> ... <B>tn</B> <B>t</B>)</TT> is true if andonly if <TT><B>t</B></TT> denotes the least common multiple of the numbersdenoted by <B>t1</B>,...,<B>tn</B>.<P><DT><TT>log</TT><DD>The sentence <TT>(log <B>t1</B> <B>t2</B> <B>t</B>)</TT> is true if andonly if <TT><B>t</B></TT> denotes the the logarithm of thenumber denoted by <TT><B>t1</B></TT> in the base denoted by<TT><B>t2</B></TT>.<P><DT><TT>logand</TT><DD>The sentence <TT>(lcm <B>t1</B> ... <B>tn</B> <B>t</B>)</TT> is true if andonly if <TT><B>t</B></TT> denotes the bit-wise logical <I>and</I> of the numbersdenoted by <TT><B>t1</B></TT> through <TT><B>tn</B></TT>.  It returns -1 if there areno arguments.<P><DT><TT>logandc1</TT><DD>The sentence <TT>(logandc1 <B>t1</B> <B>t2</B> <B>t</B>)</TT> is equivalentto the logical <I>and</I> of the logical negation of <TT><B>t1</B></TT> and<TT><B>t2</B></TT>.<P><DT><TT>logandc2</TT><DD>The sentence <TT>(logandc1 <B>t1</B> <B>t2</B> <B>t</B>)</TT> is equivalentto the logical <I>and</I> of <TT><B>t1</B></TT> and the logical negation of<TT><B>t2</B></TT>.<P><DT><TT>logcount</TT><DD>The sentence <TT>(logandc1 <B>t1</B> <B>t2</B> <B>t</B>)</TT> is true if and onlyif <TT><B>t</B></TT> denotes the number of <I>on</I> bits in the number denoted by<TT><B>t</B></TT>. If the number denoted by <TT><B>t</B></TT> is positive, then theone bits are counted; otherwise, the zero bits in the twos-complement representationare counted.<P><DT><TT>logeqv</TT><DD>The sentence <TT>(logeqv <B>t1</B> ... <B>tn</B> <B>t</B>)</TT> is true ifand only if <TT><B>t</B></TT> denotes the bit-wise logical equivalence of thenumbers denoted by <TT><B>t1</B></TT> through <TT><B>tn</B></TT>.<P><DT><TT>logior</TT><DD>The sentence <TT>(logior <B>t1</B> ... <B>tn</B> <B>t</B>)</TT> is true ifand only if <TT><B>t</B></TT> denotes the bit-wise logical inclusive <I>or</I> ofthe numbers denoted by <TT><B>t1</B></TT> through <TT><B>tn</B></TT>. It denotes 0 ifthere are no arguments.<P><DT><TT>lognand</TT><DD>The sentence <TT>(lognand <B>t1</B> <B>t2</B> <B>t</B>)</TT> is equivalentto the logical negation of the inclusive <I>and</I> of <TT><B>t1</B></TT> and<TT><B>t2</B></TT>.<P><DT><TT>lognor</TT><DD>The sentence <TT>(lognor <B>t1</B> <B>t2</B> <B>t</B>)</TT> is equivalentto the logical negation of the inclusive <I>or</I> of <TT><B>t1</B></TT> and<TT><B>t2</B></TT>.<P><DT><TT>lognot</TT><DD>The sentence <TT>(lognot <B>t1</B> <B>t</B>)</TT> is true if and only if<TT><B>t</B></TT> denotes the bit-wise logical negation of <TT><B>t1</B></TT>.<P><DT><TT>logorc1</TT><DD>The sentence <TT>(logorc1 <B>t1</B> <B>t2</B> <B>t</B>)</TT> is equivalentto the logical <I>or</I> of the logical negation of <TT><B>t1</B></TT> and<TT><B>t2</B></TT>.<P><DT><TT>logorc2</TT><DD>The sentence <TT>(logorc1 <B>t1</B> <B>t2</B> <B>t</B>)</TT> is equivalentto the logical <I>or</I> of <TT><B>t1</B></TT> and the logical negation of<TT><B>t2</B></TT>.<P><DT><TT>logxor</TT><DD>The sentence <TT>(logxor <B>t1</B> ... <B>tn</B> <B>t</B>)</TT> is true ifand only if <TT><B>t</B></TT> denotes the bit-wise logical <I>exclusive or</I>of the numbers denoted by <TT><B>t1</B></TT> through <TT><B>tn</B></TT>. It denotes 0 if there are no arguments.<P><DT><TT>max</TT><DD>The sentence <TT>(max <B>t1</B> ... <B>t1</B> <B>t</B>)</TT> is true if andonly if <TT><B>t</B></TT> denotes the largest of the numbersdenoted by <TT><B>t1</B></TT> through <TT><B>tn</B></TT>.<P><DT><TT>min</TT><DD>The sentence <TT>(min <B>t1</B> ... <B>t1</B> <B>t</B>)</TT> is true if andonly if <TT><B>t</B></TT> denotes the largest of the numbersdenoted by <TT><B>t1</B></TT> through <TT><B>tn</B></TT>.<P><DT><TT>mod</TT><DD>The sentence <TT>(mod <B>t1</B> <B>t2</B> <B>t</B>)</TT> is true if andonly if <TT><B>t</B></TT> denotes the number denoted by <TT><B>t1</B></TT>modulo the number denoted by <TT><B>t2</B></TT>. The result will have the samesign as denoted by <TT><B>t1</B></TT>.<P><DT><TT>numerator</TT><DD>The sentence <TT>(numerator <B>t1</B> <B>t</B>)</TT> is true if and only if<TT><B>t</B></TT> denotes the numerator of the canonical reduced form ofthe number denoted by <TT><B>t</B></TT>.<P><DT><TT>phase</TT><DD>The sentence <TT>(phase <B>t1</B> <B>t</B>)</TT> is true if and only if<TT><B>t</B></TT> denotes the angle part of the polar representation of the number denoted by <TT><B>t1</B></TT> (in radians).<P><DT><TT>rationalize</TT><DD>The sentence <TT>(rationalize <B>t1</B> <B>t</B>)</TT> is true if and only if<TT><B>t</B></TT> denotes the rational representation of the number denoted by<TT><B>t1</B></TT>.<P><DT><TT>realpart</TT><DD>The sentence <TT>(realpart <B>t1</B> <B>t</B>)</TT> is true if and only if<TT><B>t</B></TT> denotes the real part of the number denoted by<TT><B>t1</B></TT>.<P><DT><TT>rem</TT><DD>The sentence <TT>(rem <B>t1</B> <B>t2</B> <B>t</B>)</TT> is true if and onlyif <TT><B>t</B></TT> denotes the remainder of the number denoted by<TT><B>t1</B></TT> divided by the number denoted by <TT><B>t2</B></TT>. Theresult has the same sign as the number denoted by <TT><B>t2</B></TT>.<P><DT><TT>round</TT><DD>The sentence <TT>(round <B>t1</B> <B>t</B>)</TT> is true if and only if<TT><B>t</B></TT> denotes the integer closest to the number denoted by<TT><B>t1</B></TT>.  Ties are broken in the direction of the closest evennumber.<P><DT><TT>scale-float</TT><DD>The sentence <TT>(scale-float <B>t1</B> <B>t2</B> <B>t</B>)</TT> is true ifand only if <TT><B>t</B></TT> denotes the floating-point number that is therepresentational radix of the number denoted by <TT><B>t1</B></TT> raised to theinteger denoted by <TT><B>t2</B></TT>.<P><DT><TT>signum</TT><DD>The sentence <TT>(signum <B>t1</B> <B>t</B>)</TT> is true if and only if<TT><B>t</B></TT> denotes the sign of the number denoted by <TT><B>t</B></TT>.This is one of -1, 1, or 0 for rational numbers, and one of -1.0, 1.0, or 0.0for floating point numbers.<P><DT><TT>sin</TT><DD>The sentence <TT>(tan <B>t1</B> <B>t</B>)</TT> is true if and only if<TT><B>t</B></TT> denotes the sine of the number denoted by <TT><B>t1</B></TT>.<P><DT><TT>sinh</TT><DD>The sentence <TT>(sinh <B>t1</B> <B>t</B>)</TT> is true if and only if<TT><B>t</B></TT> denotes the hyperbolic sine of the number denotedby <TT><B>t1</B></TT>.<P><DT><TT>sqrt</TT><DD>The sentence <TT>(sqrt <B>t1</B> <B>t</B>)</TT> is true if and only if<TT><B>t</B></TT> denotes the square root of the number denotedby <TT><B>t1</B></TT>.<P><DT><TT>tan</TT><DD>The sentence <TT>(tan <B>t1</B> <B>t</B>)</TT> is true if and only if<TT><B>t</B></TT> denotes the tangent of the number denotedby <TT><B>t1</B></TT>.<P><DT><TT>tanh</TT><DD>The sentence <TT>(tanh <B>t1</B> <B>t</B>)</TT> is true if and only if<TT><B>t</B></TT> denotes the hyperbolic tangent of the number denotedby <TT><B>t1</B></TT>.<P><DT><TT>truncate</TT><DD>The sentence <TT>(truncate <B>t1</B> <B>t</B>)</TT> is true if and only if<TT><B>t</B></TT> denotes the largest positive integer greater than or equal tothe number denoted by <TT><B>t1</B></TT> (when <TT><B>t1</B></TT> is a positivenumber or zero) ; and it denotes the smallest negative integer larger than<TT><B>t1</B></TT> (when <TT><B>t1</B></TT> is a negative number).</DL><H3>Relations on Numbers</H3><DL><P><DT><TT>integer</TT><DD>The sentence <TT>(integer <TT><B>t</B></TT>)</TT> is true if<TT><B>t</B></TT> denotes an integer.<P><DT><TT>real</TT><DD>The sentence <TT>(real <TT><B>t</B></TT>)</TT> is true if <TT><B>t</B></TT>denotes a real number.<P><DT><TT>complex</TT><DD>The sentence <TT>(complex <TT><B>t</B></TT>)</TT> is trueif <TT><B>t</B></TT> denotes a complex number.<P><DT><TT>number</TT><DD>The sentence <TT>(number <TT><B>t</B></TT>)</TT> is trueif <TT><B>t</B></TT> denotes a number.<P><DT><TT>natural</TT><DD>The sentence <TT>(natural <TT><B>t</B></TT>)</TT> is trueif <TT><B>t</B></TT> denotes a natural number (i.e. 1, 2, ...).<P><DT><TT>rational</TT><DD>The sentence <TT>(natural <TT><B>t</B></TT>)</TT> is trueif <TT><B>t</B></TT> denotes a rational number.<P><DT><TT>&lt;</TT><DD>The sentence <TT>(< <TT><B>t1</B></TT> <TT><B>t2</B></TT>)</TT> is true if and only if the number denoted by<TT><B>t1</B></TT> is less than the number denoted by <TT><B>t2</B></TT>.<P><DT><TT>&gt;</TT><DD>The sentence <TT>(&gt; <TT><B>t1</B></TT> <TT><B>t2</B></TT>)</TT> is trueif and only if the number denoted by <TT><B>t1</B></TT> is greater than thenumber denoted by <TT><B>t2</B></TT>.<P><DT><TT>&gt;=</TT><DD>The sentence <TT>(&gt;= <TT><B>t1</B></TT> <TT><B>t2</B></TT>)</TT> is trueif and only if the number denoted by <TT><B>t1</B></TT> is greater than or equalto the number denoted by <TT><B>t2</B></TT>.<P><DT><TT>=&lt;</TT><DD>The sentence <TT>(=&lt; <TT><B>t1</B></TT> <TT><B>t2</B></TT>)</TT> is trueif and only if the number denoted by <TT><B>t1</B></TT> is equal to or less thanthe number denoted by <TT><B>t2</B></TT>.<P><DT><TT>positive</TT><DD>The sentence <TT>(positive <TT><B>t</B></TT>)</TT> is true if only if<TT><B>t</B></TT> denotes a number greater than zero.<P><DT><TT>negative</TT><DD>The sentence <TT>(negative <TT><B>t</B></TT>)</TT> is true if<TT><B>t</B></TT> denotes a number less than zero.<P><DT><TT>zero</TT><DD>The sentence <TT>(zero <B>t</B>)</TT> is true if<TT><B>t</B></TT> denotes zero (fixed or floating point).<P><DT><TT>odd</TT><DD>The sentence <TT>(odd <B>t</B>)</TT> is true if<TT><B>t</B></TT> denotes an odd number.<P><DT><TT>even</TT><DD>The sentence <TT>(even <B>t</B>)</TT> is true if<TT><B>t</B></TT> denotes an even number.<P><DT><TT>logbit</TT><DD>The sentence <TT>(logbit <TT><B>t1</B></TT> <TT><B>t2</B></TT>)</TT> is true if bit <TT><B>t2</B></TT>of <TT><B>t1</B></TT> is 1.<P><DT><TT>logtest</TT><DD>The sentence <TT>(logtest <TT><B>t1</B></TT> <TT><B>t2</B></TT>)</TT> is trueif the logical <I>and</I> of the two's-complement representation of the integers<TT><B>t1</B></TT> and <TT><B>t2</B></TT> is not zero.</DL><HR><ADDRESS><A HREF="mailto:genesereth@cs.stanford.edu">Michael R. Genesereth</A></ADDRESS></BODY></HTML>