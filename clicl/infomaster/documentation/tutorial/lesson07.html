<html><head><title>Infomaster Tutorial - Lesson 1</title></head><body bgcolor="#FFFFFF" vlink="#660066" alink="990033" text="#000000" link="#000099"><table cellspacing=0 cellpadding=0 width="100%" border=0>  <tbody>   <tr>     <td noWrap width=150 ALIGN=CENTER><img src="file:///gullible/infomaster/images/infomaster.jpg" height=80 width=112 border=0></td>    <td noWrap width=* ALIGN=CENTER bgcolor=white>      <FONT COLOR=#113399>        <H1>Infomaster Tutorial</H1>        <H2>Lesson 7: Mediators</H2>      </FONT></td>    <td noWrap width=150 ALIGN=CENTER>&nbsp;</td>  </tr>  </tbody> </table><HR/><H3>7.1 Biphasic Deduction</H3><P>The approach to deriving results described in the last lesson is<I>monophasic</I>.  Data and rules are commingled and and rule are interpretedrepeatedly for each data item.  This can be very inefficient.<P><I>Biphasic</I> deduction eliminates this inefficiency.  In answering a query,biphasic deduction <I>first</I> uses rules to reduce a question to an expressionin terms of data relations and <I>then</I> it answers this reduced question. This means that the rules are applied only once rather than on every piece ofdata.  For large databases, this approach can be much more efficient thanmonophasic deduction.In Infomaster, Biphasic deduction is implemented through the use oftranslators, transfomers, and facilitators.  We will see more about facilitatorsin the next lesson.  Translators and Transformers are described below.<H3>5.2 Translators</H3><P>A translator is an Infomaster agent that implements biphasic deduction.  Ithas associated with it two agents, a "rulebase" containing rules and a"target" containing data.  On receiving a query or an update, a translator firstuses the rules in its rulebase to reduce the query or update and then submitsthe reduced query or update to the target agent, where the reduced query isanswered without looking at the rules.<P>In order to see how this work, consider the rules shown below.  Here,grandparent is defined in terms of parent and parent is defined in terms offather and mother.<XMP>(<= (parent ?x ?y)    (father ?x ?y))(<= (parent ?x ?y)    (mother ?x ?y))(<= (grandparent ?x ?z)    (parent ?x ?y)    (parent ?y ?z))</XMP><P>Now, imagine a translator with these rules in its rulebase, and suppose thatthe translator were to receive a request to find all ?x and ?y such that(grandparent ?x ?y) is true.  It would first "apply" these rules, substitutingthe body of each rule for the head in the query, until no more substitutions arepossible.  In this case teh result would be the query shown below.<XMP>(and (or (father ?x ?y) (mother ?x ?y))     (or (father ?y ?z) (mother ?y ?z)))</XMP><P>Having done this reduction, the translator would send this query on to itstarget.  It would then return any answers it receives to its requestor.<H3>5.3 Transformers</H3><P>A transformer is similar to a translator in that it first uses the rules inits rulebase to reduce a query or update and then submits the result to thetarget agent.  The primary difference is in the condition used to determinewhether or not a subexpression is passed on to the target.<P>In the case of a translator, a subgoal of a query is passed on to the targetwhenever there is no rule in the database that applies to the subgoal.  Inthe case of a transformer, a subgoal is passed on to the target if and only ifthe relation in the expression is known to be a "specialty" of the target, asrecorded in the manager.<P>In the case of a translator, a consequence is passed on to the target wheneverthere is no rule in the database that applies to the consequence.  In the caseof a transformer, a consequence is passed on to the target if and only if therelation in the expression is known to be an "interest" of the target, asrecorded in the manager.<P>In order to see how this work, once again consider the rules from thepreceding section.  If the manager contained information specifying father andmother as specialties of the target, the reduced query would be the same.  Inother cases, there would be a difference.<P>Let us start with the case in which the manager has the specialty informationshown below and that is all.  In particular, suppose that mother is NOT listedas a specialty.<XMP>(specialty myfastserver father)</XMP><P>As with a translator, a transformer would apply the rules to reduce a query. However, unlike a translator, a transformer would retain only those cases wherethe traget is known to have a specialty.  In this case, the result would be thequery shown below.  The mother case is dropped, since the target is not known tohave information about this relation.<XMP>(and (father ?x ?y) (father ?y ?z))</XMP><P>Now consider the case in which the manager has the specialty informationshown below.<XMP>(specialty myfastserver parent)</XMP><P>Again, a transformer would apply the rules to reduce a query. However, it woudl stop the reduction on reaching any relation that is known tobe a specialty, leading to the query shown below.  Further reduction is notnecessary, as the target is known to store th parent relation.<XMP>(and (parent ?x ?y) (parent ?y ?z))</XMP><P>Specialties and interests in the Manager can be tedious (and annoying whenyou forget to include them).  However, they give much greater control over tehinferential process than is possible without them.<H3>5.4 Facilitators</H3><P>A facilitator is an Infomaster agent that integrates data from multiple,heterogeneous data sources and disseminates that data to multiple, heterogeneousdata consumers.<P>The behavior of a facilitator is similar to that of a transformer.  The primarydifference between a facilitator and a transformer is that a facilitator can havemany targets whereas a transformer has just oe t.  Moreover, a facilitator's targetsare not explicitly specified as such; instead, a facilitator accesses any agentshaving appropriate specialties and interests.<P>On receiving a query, a facilitator first uses the rules in its rulebase to reducethe query or update to a query involving only relations that are the spcialties ofsome agent known to the system.  The components of the resulting query are then sentto the specialty agents to get their answers.  Note that the answers to differentparts of a query may come from different agents.  The facililitator manages thiscommunication.<P>Note that there may be more than one specialist for a given relation.  In such acase, a facilitator chooses one and only one to handle that portion of the query. The concept of specialty means that an agent has all of the answers of the specialtyrelation, and so no other agent need be consulted.  Cases where different agentscontribute different portions of a relation are handled by defining subrelations foreach such agent, listing the subrelations as specialties, and then writing rules torelate these subrelations to the original relation.<P>On receiving an update, a facilitator first uses the rules in its rulebase toderive all consequences of update that involve relations that are the interests ofsome agent known to the system.  The components of the resulting updates are thensent to the intrerested agents.<P>There is one important difference between updates and queries.  In the case ofqueries, only one specialist is consulted.  In the case of updates, all interestedparties are notified.<H3>6.2 Integrating Multiple Data Sources</H3><P>Multiple data sources can be "aggregated" simply by specifying their specialtiesand interests to the Manager in an Infomaster system.  Once this is done, anyrunning facilitator will use this information to retrieve information from thosedata sources.<P>Data integration refers to the task of merging data in sources in the face ofdifferences in schema or vocabulary.<P>In Infomaster this job is accomplished by writing rules to relate the concepts inone schema to the concepts in another.<P>If there are n schemas, this can lead to n^2 mappings.  To avoid this problem, itis customary to devise a master schema (also called a pivot schema or referenceschema) and then write mapping rules for the concepts in other schemas to theconcepts in this master schema.  This requires at most 2n mappings.<H3>5.5 Data repositories</H3><P>A data repository is an agent that serves as a repository for data - it storesdata, accepts updates, and answers queries.  We have already seen severaldata repositories in Infomaster, viz. the Warehouse and the Manager.<P>There are several different types of data repositories, which differ in howdata is "indexed" and what kind of "inference" is done in answering queries andperforming updates.<P>A sentences is said to be indexed on a word if and only if there is a pointerfrom that word to the sentence.  Infomaster repositories offer multiple indexingstrategies.  Fullindexing means that every sentence is indexed on every word inthe sentence.  Relationalindexing means that every sentence is indexed only onthe relation.  Noindexing means that sentences are not indexed at all.  Indexingis generally good for lookup but slow for adding and deleting facts.<P>Inference refers to the procedure used to perform inference on a datarepository. Fastservers and dataservers do not use rules at all.  Fastservers do their work"interpretively"; dataservers first compile their activity and then run thecompiled code.  Fastservers are faster on small databases (since there is nocompiling overhead), while dataservers are faster on large databases (wherecompiling pays for itself).  Ruleservers use rules as contained in the databasewithout change.  Fullservers add contrapositives to rules and goals.<P>In building pure databases (without rules), it is customary to use either afastserver or a dataserver.  In building rule bases,such as the Library, it is customary to use a ruleserver.<H3>5.5 Materializing Relations</H3><P>One diadvantage of encoding information in the form of rules rather thantables is greater search cost.  This search cost can be diminished by"materializing" relations, i.e. using the rules to precompute all instances ofthe relation and explicitly storing those instances.<P>The <TT>Materialize</TT> operation takes as arguments a relation, a sourceagent, and a target agent.  It requests values of the specified relation fromthe source agent, and stores the results in the target agent. <TT>Materialize</TT> is typically called with a translator or transformer orfaciltator as source and with a data repsoitory as target.  Materialize also informsthe manager that the target agent has the relation as a specialty, so thattranslators and facilitators can route subsequent directly to the target ratherthan recomputing at the source.<P>The <TT>Dematerialize</TT> operation takes as arguments a relation and atarget agent.  It eliminates all instances of the specified relation from thetarget agent and deletes the corresponding specialty information from theManager.<P>One disdvantage of materializing relations is that it complicates the processof update.  On each update, we must determine which materialized relations needto be changed and which instances of those relations need to be changed.  Ofcourse, we could recompute all materialized relations, but this would beprohibitively expensive.<P>One solution to this problem is to write implications (forward rules) forrelations in addition to the normal rules for computing those relations in thefirst place.  These implications can then be used by the system to performincremental updates to mateialized relations rather than recomputing them intheir entirety.  More on this later.<H3>Exercises</H3><OL><P><LI>Start a new infomaster system.  Create a fastserver.  Load the files data.kif and rules.kif into your fastserver.<P><LI>Create a translator with Library as Rulebase and Warehouse as Target. Load the file rules.kif into the LIbrary, and load data.kif into the Warehouse.<P><LI>Create a transformer with Library as Rulebase and Warehouse as Target. Load the file rules.kif into the Library, and load data.kif into the Warehouse. Load manager.kif into the manager.  (This defines specialties for the data inthe Warehouse.)<P><LI>Ask your fastserver for all pairs of grandparents and grandchildren.  Dothe same using your translator and your transformer.  You should get the sameanswers in all cases.  However, you should observe a difference inperformance between your fastserver and the other two agents.</OL><OL><P><LI>Start a new infomaster system.  Create a fastserver.  Load the kinship database from Lesson3 into this fastserver.<P><LI>Create a second fastserver.  Populate this database with additional kinship information usinga different schema.  Write data in terms of the binary <TT>p</TT> relation (forparent), the unary <TT>m</TT> (for male), and the unary <TT>f</TT> relation (forfemale).<P><LI>Add specialty information to the Manager for your two fastservers.<P><LI>Use Ask and the predefined facilitator named Integrator to get answers toquestions in either schema.  Note that only information stored in the correspondingschema is available.<P><LI>Define the parent relation in terms of <TT>father</TT> and <TT>mother</TT>. Write a second definition in terms of <TT>p</TT> relation, <TT>m</TT>, and<TT>f</TT>.  Put the rules in the Library agent's database.<P><LI>Use Ask and the predefined facilitator to find parents and children.  Notethat information from both agents is combined in your answers.<H3>Solutions</H3>Manager data in <A HREF="manager.kif"><TT>manager.kif</TT></A>.  Rules are given in<A HREF="library.kif"> <TT>library.kif</TT></A>.  Data for one server in<A HREF="myserver.kif"> <TT>myserver.kif</TT></A>.  Data for the second server in<A HREF="yourserver.kif"> <TT>yourserver.kif</TT></A>.</OL><HR><ADDRESS>(c) Copyright 1997-2002 by<A HREF="mailto:genesereth@stanford.edu">Michael Genesereth</A>.  All rightsreserved.</ADDRESS></BODY></HTML>