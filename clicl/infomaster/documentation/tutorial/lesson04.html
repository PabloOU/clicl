<html><head><title>Infomaster Tutorial - Lesson 3</title></head><body bgcolor="#FFFFFF" vlink="#660066" alink="990033" text="#000000" link="#000099"><table cellspacing=0 cellpadding=0 width="100%" border=0>  <tbody>   <tr>     <td noWrap width=150 ALIGN=CENTER><img src="file:///gullible/infomaster/images/infomaster.jpg" height=80 width=112 border=0></td>    <td noWrap width=* ALIGN=CENTER bgcolor=white>      <FONT COLOR=#113399>        <H1>Infomaster Tutorial</H1>        <H2>Lesson 4: Tables</H2>      </FONT></td>    <td noWrap width=150 ALIGN=CENTER>&nbsp;</td>  </tr>  </tbody> </table><HR/><H3>3.1 Datawebs</H3><P>While it is nice to think of datawebs as graphs, it is often convenient to express themin linear form, e.g. in writing to disk or communicating between computer systems.  InInfomaster, this is done by decomposing a dataweb into its consituent arcs and writingeach as a "sentence" in the form shown below.<CENTER><TT>(&lt;relation&gt &lt;object1&gt ... &lt;objectn&gt;)</TT></CENTER><P>(More precisely, these are "ground, atomic sentences".  They are ground because theycontain no variables.  They are atomic because they do not contain any logical operators. In the next lesson, we will see sentences that are not ground and that are not atomic.)<P>Using this representation, we can encode the network from Figure 1 as the set ofsentences shown below.  The first five sentences give properties of the 5 nodes. The remaining sentences give their interrelationships.<XMP>(person.instance art)(person.instance bob)(office.instance r20)(office.instance r22)(building.instance b12)(person.boss art bob)(person.location art r20)(person.location bob r22)(office.in r20 b12)(office.in r22 b12)</XMP><BR><CENTER>Representation of the dataweb in Lesson 2</CENTER><P>An Infomaster database (i.e. dataweb) is an arbitrary collection of such sentences.<H3>3.2 Viewing Databases</H3><P>The most common way of examining an Infomaster agent's database is through theExamine operation.  To start, type<TT>http://&lt;hostname&gt;:&lt;port&gt;/&lt;agent&gt;/examine?</TT> into a browser.<P>Typing in the name of a concept and pressing the Submit button produces a page showingall sentences that mention that node or relation.  For example, entering unspsc.521518.typebrings a page of all sentences involving that relation.<P>Once a page of sentences is displayed, as in this example, you can move to other pagesof sentences by clicking on the name of a concept.  For example, clicking on a specificproduct produces a page of sentences about that product.<P>Typing ? into the initial Examine page will produce a display of all sentences known tothe agent being examined.<P>The ask operation takes two arguments - a variable or list of variables (called theaspect) and one or more sentences (the query).  It returns a list of instances of the aspectfor which the query is known to be true.<H3>3.4 Making Updates</H3><P>To edit an agent's database using a web browser, the first step is to get a display ofthe data to be edited (using one of the techniques described in the preceding section). Pressing the Edit button at the bottom of the page produces a new version of the page inwhich the sentences are editable.  Changing these sentences and pressing the Update buttonchanges the sentences in the associated database.  (Note that changing the information inyour browser does NOT communicate these changes to the server until you click the Updatebutton.)<P>While it is possible to edit a database in this manual fashion, it is sometimes desirableto make multiple changes all at once (e.g. to give everyone a 10% raise).  This can be doneusing the Xform operation.  To get started using Xform, use your browser to send an Xformrequest to Infomaster.  This produces a page that allows you to define a databasetransformation.  See Illustration.<P>The <TT>Xform</TT> operation takes as argument any number of sentences.  It changesthe agent's database so that the specified sentences are included in the agent's database. Including a negated sentence is tantamount to removing the sentence from the database.<P>Finally, you can empty an agent's database using the <TT>Initialize</TT> operation. This is particularly useful loading and reloading files in order to eliminate past contentsbefore loading updated contents.<H3>3.5 Reading and Writing Data Files</H3><P><TT>Loadfile</TT> is an operation that loads a file into an agent.  It takes asarguments the name of a local file, an agent to use as target, a language, and aboolean indicating whether or not metadata should be adjusted based on thecontents of the file.  (For now, set the language to KIF, and set the last argument toStatic, i.e. no metadata.)<P><TT>Dumpfile</TT> is an operation that dumps the contents of an agent to a file. It takes as arguments an agent to use as source, the name of a target file, and a language.  (For now, set the language to KIF.)<P>Note that Loadfile and Dumpfile differ from Load and Dump.  The latter load anddump an entire Infomaster system.  Loadfile and Dumpfile are restricted to aparticular agent.  They also offer a choice of languages.<H3>3.6 Datawebs</H3><P>The definition of semantic nets given above is very general.  In practice, it is commonfor Infomaster users to work with highly structured semantic nets, called datawebs.  WhileInfomaster supports semantic nets in their full generality, it provides additionalcapabilities for semantic nets with this extra structure.<P>The primary component of this extra structure is the notion of a class.  Intuitively, aclass is a collection of objects that share some common property.  Each class has anassociated predicate relation and zero or more associated attribute relations.<P>(Technical note.  A class is not the same as a set.  Two distinct classes may have thesame members but different properties.  In particular, one class may have attributes that aredifferent from those of another class, even though the members are the same.   We will seeuseful examples of this distinction in the Lesson on User Interface.)<P>The predicate for a class is a unary relation that is true of members of the class andfalse of non-members.  By convention, the predicate for a class is named by appending thename of the class and the string ".instance".  For example, the predicate for the personclass would be named person.instance.<P>The attributes of a class are binary relations that give values for elements of theclass.  By convention, the predicate for a class is named by appending the name of the classand the name of the relation separated by ".".  For example, the father attribute for theperson class would be named person.father.<P>Although this extra level of structure is strictly voluntary, as mentioned above,Infomaster provides additional capabilities that take advantage of semantic nets with suchstructure.  In order for the system to do so, the user must represent this structureexplicitly.  In Infomaster, this is done by encoding metadata.<P>The metadata describing the structure of a dataweb is encoded in Infomaster in the sameway that data is expressed.  In fact, the metadata in Infomaster is itself a dataweb, withclasses and attribute relations and so forth.  In what follows, we first describe thenecessary metalevel concepts.  We then give an example of their use in documenting a normaldataweb.  Finally, we show how to use the metalanguage to document the metalanguage itself.<P>First of all, the set of all classes is itself a class called class.  The attribute<TT>predicate</TT> relates a class to its predicate relation.  The attribute<TT>attribute</TT> relates a class to its attribute relations.<P>Using these metalevel concepts, we can encode metadata for the classes in figure 1as shown below.<XMP>(isa person class)(predicate person person.instance)(attribute person person.location)(attribute person person.boss)(isa office class)(predicate office office.instance)(attribute office office.in)(isa building class)(predicate building building.instance)</XMP><P>Every predicate relation in a dataweb is a member of a class called predicaterelation. Hence, we have the following metadata for the dataweb in figure 1.<XMP>(isa person.instance predicaterelation)(isa office.instance predicaterelation)(isa building.instance predicaterelation)</XMP><P>Every attribute relation is a member of a class called attributerelation.  Everyattribute relation has a domain, the class of objects to which it applies; and it has arange, the class of objects describing the values.  An attribute relation is unique if andonly if there is at most one value for each element of the domain.  It is total if and onlyif there is at least one value for each element of the domain.<P>Using these metalevel concepts, we can encode metadata for the attribute relations infigure 1 as shown below.<XMP>(isa     person.location attributerelation)(domain  person.location person)(range   person.location office)(unique  person.location yes)(total   person.location yes)(isa     person.boss attributerelation)(domain  person.boss person)(range   person.boss person)(unique  person.boss no)(total   person.boss no)(isa     office.in attributerelation)(domain  office.in office)(range   office.in building)(unique  office.in yes)(total   office.in yes)</XMP><P>As we will see later, classes, predicate relations, and attribute relations have otherproperties as well, notably information about which agents store which bits of informationand user interface preferences.<P>It is noteworthy that metadata itself has metadata.  The facts shown below give some ofthe metadata for classes and predicaterelations and attributerelations.<XMP>(isa       class class)(attribute class predicate)(attribute class attribute)(isa       predicaterelation class)(attribute predicaterelation domain)(attribute predicaterelation range)(attribute predicaterelation unique)(attribute predicaterelation total)(isa       attributerelation class)(attribute attributerelation domain)(attribute attributerelation range)(attribute attributerelation unique)(attribute attributerelation total)</XMP><P>It is noteworthy that the metalevel classes here do not have predicate relations. Instead, Infomaster uses the binary relation <TT>isa</TT> to capture class information formetalevel objects.  This is for historical reasons only.   A better version of the systemwould treat these metalevel classes the same as other classes.<H3>3.7 Error Checking</H3><P>One important use metalevel information is to check the integrity of databases.  The usercan take advantage of this ability by invoking the system's error-checking operations.<P>The <TT>checkpredicate</TT> operation takes a predicate relation and an agent asarguments and checks that the predicate relation is used correctly, i.e. each instance hasone and only one argument.<P>The <TT>checkattribute</TT> operation takes an attribute relation and an agent asarguments.  It checks that every instance has two arguments; it checks the domain and range;and it checks that the unique and total properties are not violated.<P>The <TT>checkclass</TT> operation takes a class and an agent as arguments.  It runscheckpredicate and checkattribute on the predicate and attributes of the class.<P>If any of these operations detects an inconsistency between the structure of a databaseand the metalevel information for that database, it prints an appropriate message.<P>NB: For reasons that will become clear later, only the Manager can perform theseoperations, though of course it can be asked to check the databases of other agents.<P>As an example of these operations at work, consider the following database.  This is aslight variation of the database in figure 2.  We have deleted the fact that r22 is anoffice; we have added a second location for art; we have removed bob's location; and we havegiven a location to r20.<XMP>(person.instance art)(person.instance bob)(office.instance r20)(building.instance b12)(person.location art r20)(person.location art r22)(person.location r20 r22)(person.boss art bob)(office.in r20 b12)(office.in r22 b12)</XMP>Running <TT>checkclass</TT> on this database would produce the following warning messages.<XMP>Domain violation -- (PERSON.LOCATION R20 ??)Range violation -- (PERSON.LOCATION ?? R22)Uniqueness violation -- (PERSON.LOCATION ART R20)Uniqueness violation -- (PERSON.LOCATION ART R22)Total violation -- (PERSON.LOCATION BOB ??)</XMP><H3>Exercises</H3><OL><P><LI>Start a new Infomaster.  Load a fresh copy of the Housewares system.<P><LI>Examine the unspsc.521518.type relation in the Tutorial agent.<P><LI>Using Ask, retrieve all unspsc.521518 products of type skillet.<P><LI>Retrieve all pairs of unspsc.521518 product and country of manufacture for everyproduct in the database.  Hint: you will need to mention the relationsunspsc.521518.manufacturer and company.nationality.<P><LI>Examine the corning.521518.material relation.<P><LI>Change the material of 3500115-8in-skillet  to iron.  Delete the material of3500115-10in-skillet.<P><LI>Use the Xform operation to change the material of every aluminum product made bycorning to iron.  Work on the relation corning.521518.material.<P><LI>Examine the metadata for one of the classes in your system.<P><LI>Use the error-checking operations to assess the integrity of the corning.521518 class.</OL><BR/><HR/><CENTER><FONT SIZE=1>(c) Copyright 1997-2003 by<A HREF="mailto:genesereth@stanford.edu">Michael Genesereth</A>.  All rights reserved.</FONT></CENTER></BODY></HTML>