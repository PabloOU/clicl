;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; (c) Copyright 1999-2007 by Michael Genesereth.  All rights reserved.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(eval-when (compile load eval)
  (proclaim '(special *count*)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Performatives
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; fasttablepage
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defmethod process (s (command (eql 'fasttablepage)) postlines)
  (cond ((null postlines) (process-roottablepage s))
        (t (process-fasttablepage s (read-value-string (cdar postlines))))))

(defun process-roottablepage (s)
  (format-html s) (crlf s)
  (output-head s "Fasttablepage") (crlf s)
  (format-body s *bgcolor*) (crlf s)
  (output-header s)
  (format-border s)
  (output-tables s 'true (find-subrelations 'true))
  (finish-border s)
  (output-footer s)
  (finish-body s) (crlf s)
  (finish-html s) (crlf s)
  'done)

(defun process-fasttablepage (s table)
  (format-html s) (crlf s)
  (output-head s "Fasttablepage") (crlf s)
  (format-body s *bgcolor*) (crlf s)
  (output-header s)
  (format-border s)
  (output-tables s table (find-subrelations table))
  (finish-border s)
  (output-footer s)
  (finish-body s) (crlf s)
  (finish-html s) (crlf s)
  'done)

(defmethod output-tables (s table tables)
  (let (count)
    (format s "<br/>
<center>
<table width='800'>
<tr>")
    (setq count (length tables))
    (cond ((> count 18)
           (do ((i 1 (1+ i)))
               ((> i 4))
               (format s "<td width='25%' valign='top'>")
               (cond ((= i 1)
                      (format s "<span style='font-size:16px; font-weight:bold; color:#004488'>~A</span><br/>"
                              (prettify table)))
                     (t (format s "<font size='4'>&nbsp;</font>")))
               (format s "<div style='margin-left: 15px'>")
               (do ((j (ceiling count 4) (1- j)))
                   ((or (= j 0) (null tables)))
                   (format s "<a href='showtable?table=~A'>~A</a><br/>"
                           (car tables) (prettify (car tables)))
                   (setq tables (cdr tables)))
               (format s "</div>")
               (format s "</td>")))
          (t (format s "<td width='25%' valign='top'>")
             (format s "<span style='font-size:16px; font-weight:bold; color:#004488'>~A</span><br/>"
                              (prettify table))
             (format s "<div style='margin-left: 15px'>")
             (dolist (table tables)
               (format s "<a href='showtable?table=~A'>~A</a><br/>"
                       table (prettify table)))
             (format s "</div>")
             (format s "</td>")))
    (format s "</tr>
</table>
</center>
<br/>")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; showtable page
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defmethod process (s (file (eql 'showtable)) postlines)
  (let (table start end)
    (cond ((setq table (getf-post "Table" postlines))
           (setq table (read-user-string table))
           (setq start (or (read-user-string (getf-post "Start" postlines)) 1))
           (setq end (or (read-user-string (getf-post "End" postlines)) *count*))
           (process-showtable s table start end))
          (t (html-message s "<p>No table specified.</p>")))))

(defun process-showtable (s table start end)
  (let (arity columns aspect kif results count)
    (setq arity (arity-of-relation table))
    (setq columns (get-columns table arity))
    (do ((i 1 (1+ i)) (nl))
        ((> i arity) (setq aspect (nreverse nl)))
        (setq nl (cons (decolonize (newindvar)) nl)))
    (setq kif (cons table aspect))
    (setq results (prorequest `(ask-all ,aspect ,kif)))
    (setq count (length results))
    (setq end (min count end))
    (setq results (subseq results 0 end))
    (format-html s) (crlf s)
    (output-head s "Showtable") (crlf s)
    (format-body s *bgcolor*) (crlf s)
    (output-header s)
    (format s "<center>")
    (cond ((= count 0) (format s "<p>There are no answers.</p>"))
          ((= count 1) (format s "<P>There is 1 viewable answer.<P>")
           (output-showtable-inner s table columns results))
          (t (format s "<P>There are ~D viewable answers.  The following table shows answers ~A through ~A.<P>~%"
                     count start end)
             (output-showtable-inner s table columns results)
             (multiple-value-setq (start end) (kerchunk count start end))
             (output-showtable-commands s table start end)))
    (format s "</center>")
    (output-footer s)
    (finish-body s) (crlf s)
    (finish-html s) (crlf s)))

(defun output-showtable-inner (s table columns results)
  (format s "<table cellspacing='0' bgcolor='white' border='1'>")
  (format s "<TR bgcolor='#eeeeee'>")
    (format s "<TH colspan='~A'>~A</th>" (length columns) (prettify table))
  (format s "</TR>")
  (when (> (length columns) 10)
    (format s "<tr>")
    (dolist (column columns)
      (format s "<th>")
      (format s "~a" (iconify column))
      (format s "</th>"))
    (format s "</tr>"))
  (do ((l results (cdr l)) (i 1 (1+ i)))
      ((null l))
      (format s "<tr>")
      (dolist (item (car l))
        (if (numberp item)
          (format s "<td align='right'>")
          (format s "<td>"))
        (output-inner s item)
        (format s "</td>"))
      (format s "</tr>"))
  (format s "</table>"))

(defun output-inner (s obj)
  (cond ((numberp obj) (prin1 obj s))
        ((stringp obj) (prin1 obj s))
        ((symbolp obj)
         (format s "<A HREF='fastinspectpage?Object=~A'><font color='black'>~A</font></A>"
                 (addressify obj) (iconify obj)))
        (t (format s "Unprintable"))))

(defun output-showtable-commands (s table start end)
  (format s "<form action='showtable?' method='post'>")
  (format-hidden s "Table" (stringize table))
  (format-button s "Command" "Display")
  (format s "answers ")
  (format-text s "Start" (princ-to-string start) 5)
  (format s " through ")
  (format-text s "End" (princ-to-string end) 5)
  (format s "<br/>")
  (format s "</form>")
  (format s "<form action='updatetable?' method='post'>")
  (format-hidden s "Table" (stringize table))
  (format-hidden s "Start" (stringize start))
  (format-hidden s "End" (stringize end))
  (format-button s "Command" " Edit ")
  (format s "</form>"))

(defun get-columns (relation arity)
  (do ((i 1 (1+ i)) (cl (find-columns relation) (cdr cl)) (nl))
      ((> i arity) (nreverse nl))
      (setq nl (cons (if cl (car cl) i) nl))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Update table
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defmethod process (s (file (eql 'updatetable)) postlines)
  (let (command)
    (setq command (getf-post "Command" postlines))
    (cond ((null command) (output-update s postlines))
          ((string-equal command " Edit ") (output-update s postlines))
          ((string-equal command "Display") (output-update-display s postlines))
          (t (update-table s postlines)))))

(defun output-update (s postlines)
  (let (relation arity columns aspect kif results count end)
    (setq relation (read-value-string (cdr (pop postlines))))
    (setq arity  (arity-of-relation relation))
    (setq columns (get-columns relation arity))
    (do ((i 1 (1+ i)) (nl))
        ((> i arity) (setq aspect (nreverse nl)))
        (setq nl (cons (decolonize (newindvar)) nl)))
    (setq kif (cons relation aspect))
    (setq results (prorequest `(ask-all ,aspect ,kif)))
    (setq count (length results))
    (setq end (min count 20))
    (setq results (subseq results 0 end))
    (format-html s) (crlf s)
    (output-head s "Update Relation") (crlf s)
    (format-body s *bgcolor*) (crlf s)
    (output-header s)
    (if results (show-update-table s relation columns results count 1 end)
        (format s "<P>No tuples found.  Arity missing or relation empty.<P>"))
    (output-footer s)
    (finish-body s) (crlf s)
    (finish-html s) (crlf s)))

(defun output-update-display (s postlines)
  (let (relation arity columns aspect kif results count start end)
    (setq relation (read-value-string (cdr (pop postlines))))
    (setq start (read-value-string (getf-post "Start" postlines)))
    (setq end (read-value-string (getf-post "End" postlines)))
    (setq arity  (arity-of-relation relation))
    (setq columns (get-columns relation arity))
    (do ((i 1 (1+ i)) (nl))
        ((> i arity) (setq aspect (nreverse nl)))
        (setq nl (cons (decolonize (newindvar)) nl)))
    (setq kif (cons relation aspect))
    (setq results (prorequest `(ask-all ,aspect ,kif)))
    (multiple-value-setq (results count start end) (trim results start end))
    (format-html s) (crlf s)
    (output-head s "Update Relation") (crlf s)
    (format-body s *bgcolor*) (crlf s)
    (output-header s)
    (if results (show-update-table s relation columns results count start end)
        (format s "<P>No tuples found.  Arity missing or relation empty.<P>"))
    (output-footer s)
    (finish-body s) (crlf s)
    (finish-html s) (crlf s)))

(defun update-table (s postlines)
  (let (relation rows results tells untells)
    (setq relation (read-user-string (cdr (pop postlines))))
    (do ((row))
        ((not (string= (caar postlines) "Row")) (setq rows (nreverse rows)))
        (multiple-value-setq (row postlines) (get-row postlines))
        (setq rows (cons row rows)))
    (setq results (read-user-string (getf-post "Results" postlines)))
    (do ((l rows (cdr l)) (m results (cdr m)) (nr))
        ((null l)
         (setq untells (nreverse untells))
         (setq tells (nreverse tells))
         (setq rows (nreverse nr)))
        (cond ((equal (car l) (car m)) (setq nr (cons (car l) nr)))
              ((null (car l)) (setq untells (cons (car m) untells)))
              (t (when (car m) (setq untells (cons (car m) untells)))
                 (setq tells (cons (car l) tells))
                 (setq nr (cons (car l) nr)))))
    (dolist (row untells) (prorequest `(untell ,(cons relation row))))
    (format-html s) (crlf s)
    (output-head s "Update Relation") (crlf s)
    (format-body s *bgcolor*) (crlf s)
    (output-header s)
    (do ((l tells (cdr l)) (dum))
        ((null l))
        (when (stringp (setq dum (prorequest `(tell ,(cons relation (car l))))))
          (do ((m tells (cdr l)))
              ((eq l m))
              (prorequest `(untell ,(cons relation (car l)))))
          (do ((l untells (cdr l)))
              ((null l))
              (prorequest `(tell ,(cons relation (car l)))))
          (http-problem s dum)
          (return nil)))
    (format s "<P>Table Updated.<P>")
    (output-footer s)
    (finish-body s) (crlf s)
    (finish-html s) (crlf s)))

(defun show-update-table (s relation columns results count start end)
  (cond ((= count 1) (format s "<P>There is 1 viewable answer.<P>"))
        (t (format s "<P>There are ~D viewable answers.  The following table shows answers ~A through ~A.<P>~%"
                     count start end)))
  (force-output s)
  (format s "<form action=updatetable? method=post>")
  (format-hidden s "Relation" (stringize relation))
  (format s "<center><table cellspacing='0' cellpadding='0' border>")
  (format s "<TR>")
    (format s "<TH colspan='~A'>~A</th>" (length columns) (prettify relation))
  (format s "</TR>")
#|
  (format s "<TR>")
  (dolist (column columns)
    (format s "<TH>")
    (output-slotlink s column)
    (format s "</TH>"))
  (format s "</TR>~%")
|#
  (do ((l results (cdr l)) (i 1 (1+ i)))
      ((null l))
      (format s "<TR>")
      (format-hidden s "Row" "")
      (loop
        for item in (car l)
        do (if (numberp item)
             (format s "<TD ALIGN=\"RIGHT\">")
             (format s "<TD>"))
        (format-text s "Entry" (stringize item) 20)
        (format s "</TD>~%"))
      (format s "</TR>~%"))
  (format s "<TR>")
  (format-hidden s "Row" "")
  (do ((l columns (cdr l)))
      ((null l))
      (format s "<TD>")
      (format-text s "Entry" "" 20)
      (format s "</TD>"))
  (format s "</TR>~%")
  (format s "</TABLE></CENTER><P>~%")
  (force-output s)
  (format s "<HR>~%")
  (format-hidden s "Columns" (htmlify (format nil "~S" columns)))
  (format-hidden s "Results" (htmlify (format nil "~S" results)))
  (cond ((and (= start 1) (= end count)))
        ((> count end) (setq start (1+ end) end (min count (+ end 20))))
        (t (setq start 1 end (min count 20))))
  (format-button s "Command" "Update")
  (format s "table<BR>")
  (format s "</FORM>")
  (format s "<FORM ACTION=updatetable? METHOD=POST>")
  (format-hidden s "Relation" (stringize relation))
  (format-button s "Command" "Display")
  (format s "answers ")
  (format-text s "Start" (stringize start) 5)
  (format s " through ")
  (format-text s "End" (stringize end) 5)
  (format s "</FORM>"))

(defun get-row (postlines)
  (pop postlines)
  (get-entries "Entry" postlines))

(defun get-entries (slotname pl)
  (do ((l pl (cdr l)) (flag t) (values))
      ((or (null l) (not (string= (caar l) slotname)))
       (values (and flag (nreverse values)) l))
      (cond ((string= (cdar l) "") (setq flag nil))
            (t (setq values (cons (read-value-string (cdar l)) values))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; transform
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(eval-when (compile load eval)
  (proclaim '(special *postlines* *editor*)))

(defmethod process (s (action (eql 'transform)) postlines)
  (let (command (*cells* 0))
    (cond ((null postlines) (transform-empty s))
          ((and (setq command (getf-post "Command" postlines)) nil))
          ((string= command " Add Condition ") (transform-addcondition s postlines))
          ((string= command "Drop Condition ") (transform-dropcondition s postlines))
          ((string= command "Add  Conclusion") (transform-addconclusion s postlines))
          ((string= command "Drop Conclusion") (transform-dropconclusion s postlines))
          ((string= command "Convert to KIF") (transform-kif s postlines))
          ((string= command "Submit") (transform-submit s postlines))
          (t (http-problem s "Obsolete form.")))))

(defun transform-empty (s)
  (format-html s) (crlf s)
  (output-head s "Transform") (crlf s)
  (format-body s *bgcolor*) (crlf s)
  (output-header s)
  (format s "<form action='transform?' method='post'>")
  (format-hidden s "Start" "")
  (format-hidden s "Start" "")
  (format-hidden s "End" "")
  (format-hidden s "Start" "")
  (format-hidden s "End" "")
  (format-hidden s "End" "")
  (format-hidden s "Count" "0")
  (format s "<p>")
  (output-transform-commands s)
  (format s "</form>")
  (output-footer s)
  (finish-body s) (crlf s)
  (finish-html s) (crlf s))

(defun transform-addcondition (s *postlines*)
  (let (rule count relation args (*cells* 0))
    (setq rule (convert-transform))
    (setq count (1+ (read-user-string (getf-post "Count" *postlines*))))
    (setq relation (read-value-string (getf-post "Condition" *postlines*)))
    (setq args (makargs count (arity-of-relation relation)))
    (format-html s) (crlf s)
    (output-head s "Edit Transform") (crlf s)
    (format-body s *bgcolor*) (crlf s)
    (output-header s)
    (format s "<form action='transform?' method='post'>")
    (output-transform s (addcondition (cons relation args) rule))
    (format-hidden s "Count" (htmlify (format nil "~A" count)))
    (format s "<p>")
    (output-transform-commands s)
    (format s "</form>")
    (output-footer s)
    (finish-body s) (crlf s)
    (finish-html s) (crlf s)))

(defun transform-dropcondition (s *postlines*)
  (let (rule count (*cells* 0))
    (setq rule (convert-transform))
    (setq count (read-user-string (getf-post "Count" *postlines*)))
    (format-html s) (crlf s)
    (output-head s "Edit Transform") (crlf s)
    (format-body s *bgcolor*) (crlf s)
    (output-header s)
    (format s "<form action='transform?' method='post'>")
    (output-transform s (dropcondition rule))
    (format-hidden s "Count" (htmlify (format nil "~A" count)))
    (format s "<P>")
    (output-transform-commands s)
    (format s "</FORM>")
    (output-footer s)
    (finish-body s) (crlf s)
    (finish-html s) (crlf s)))

(defun transform-addconclusion (s *postlines*)
  (let (rule count relation args (*var-count* 0) (*cells* 0))
    (setq rule (convert-transform))
    (setq count (1+ (read-user-string (getf-post "Count" *postlines*))))
    (setq relation (read-value-string (getf-post "Conclusion" *postlines*)))
    (setq args (makargs count (arity-of-relation relation)))
    (format-html s) (crlf s)
    (output-head s "Edit Transform") (crlf s)
    (format-body s *bgcolor*) (crlf s)
    (output-header s)
    (format s "<form action='transform?' method='post'>")
    (output-transform s (addconclusion (cons relation args) rule))
    (format-hidden s "count" (htmlify (format nil "~A" count)))
    (format s "<P>")
    (output-transform-commands s)
    (format s "</FORM>")
    (output-footer s)
    (finish-body s) (crlf s)
    (finish-html s) (crlf s)))

(defun transform-dropconclusion (s *postlines*)
  (let (rule count (*cells* 0))
    (setq rule (convert-transform))
    (setq count (read-user-string (getf-post "Count" *postlines*)))
    (format-html s) (crlf s)
    (output-head s "Edit Transform") (crlf s)
    (format-body s *bgcolor*) (crlf s)
    (output-header s)
    (format s "<form action='transform?' method='post'>")
    (output-transform s (dropconclusion rule))
    (format-hidden s "count" (htmlify (format nil "~A" count)))
    (format s "<p>")
    (output-transform-commands s)
    (format s "</form>")
    (output-footer s)
    (finish-body s) (crlf s)
    (finish-html s) (crlf s)))

(defun transform-kif (s *postlines*)
  (let ((*cells* 0))
    (format-html s) (crlf s)
    (output-head s "ACL Request") (crlf s)
    (format-body s *bgcolor*) (crlf s)
    (output-header s)
    (format s "<form action='acl?' method='post'>")
    (format s "<textarea name=message rows=10 cols=70>")
    (print-string s (list 'update (rectify (deselect (convert-transform)))))
    (format s "</textarea><p>~%")
    (format s "<p><input type='submit' name='Command' value='Submit'> this request.<br>")
    (format s "</form>")
    (output-footer s)
    (finish-body s) (crlf s)
    (finish-html s) (crlf s)))

(defun transform-submit (s *postlines*)
  (let (transform)
    (format-html s) (crlf s)
    (output-head s "Submit Transform") (crlf s)
    (format-body s *bgcolor*) (crlf s)
    (output-header s)
    (setq transform (rectify (deselect (convert-transform))))
    (transform (cadr transform) (caddr transform) *agent*)
    (format s "Done") (crlf s)
    (output-footer s)
    (finish-body s) (crlf s)
    (finish-html s) (crlf s)))

(defun rectify (x)
  (cond ((eq '?* x) (table-var))
        ((atom x) x)
        (t (do ((l x (cdr l)) (nl))
               ((null l) (nreverse nl))
               (setq nl (cons (rectify (car l)) nl))))))

(defun output-transform (s sentence)
  (format-hidden s "Start" "")
  (format-hidden s "Start" "")
  (dolist (conjunct (conditions (cadr sentence)))
    (format s "<P>")
    (output-transform-sentence s conjunct))
  (format-hidden s "End" "")
  (format-hidden s "Start" "")
  (format s "<BLOCKQUOTE>") (crlf s)
  (dolist (conjunct (conditions (caddr sentence)))
    (format s "<P>")
    (output-transform-sentence s conjunct))
  (format s "</BLOCKQUOTE>") (crlf s)
  (format-hidden s "End" "")
  (format-hidden s "End" ""))

(defun output-transform-sentence (s x)
  (cond ((atom x))
        ((eq 'selected (car x)) (transform-selection s (cadr x) t))
        ((eq 'unprovable (car x)) (transform-selection s x nil))
        ((eq 'not (car x)) (transform-selection s x nil))
        (t (transform-selection s x nil))))

(defun transform-selection (s x selected)
  (cond ((atom x))
        ((eq 'unprovable (car x)) (transform-atom s (cadr x) nil selected))
        ((eq 'not (car x)) (transform-atom s (cadr x) nil selected))
        (t (transform-atom s x t selected))))

(defun transform-atom (s x positive selected)
  (transform-row-table s x positive selected))

(defun transform-column-table (s x positive selected)
  (format-hidden s "Start" (stringize (incf *cells*)))
  (format-hidden s "Style" "Table")
  (format-hidden s "Relation" (stringize (car x)))
  (format s "<TABLE>")
  (format s "<TR>")
  (format s "<TD></TD><TD>")
  (format-checkbox s "Not" "" (not positive))
  (format s "<B>~A</B><BR>" (prettify (car x)))
  (format s "</TD></TR><TR><TD>")
  (when *editor* (format-radiobutton s "Select" "" selected))
  (format s "</TD><TD>")
  (format s "<TABLE BORDER>")
  (do ((l (cdr x) (cdr l)) (columns (columns (car x)) (cdr columns)))
      ((null l))
      (format s "<TR><TH ALIGN=LEFT>")
      (format s (prettify (or (car columns) "")))
      (format s "</TH>")
      (format s "<TD>")
      (format-text s "Val" (stringize (car l)) 30)
      (format s "</TD></TR>"))
  (format s "</TABLE>")
  (format s "</TD></TR></TABLE>")
  (format-hidden s "End" ""))

(defun transform-row-table (s x positive selected)
  (format-hidden s "Start" (stringize (incf *cells*)))
  (format-hidden s "Style" "Table")
  (format-hidden s "Relation" (stringize (car x)))
  (format s "<TABLE>")
  (format s "<TR>")
  (format s "<TD></TD><TD>")
  (format s "<B>~A</B><BR>" (prettify (car x)))
  (format s "</TD></TR><TR><TD>")
  (when *editor* (format-radiobutton s "Select" "" selected))
  (format s "</TD><TD>")
  (format s "<TABLE BORDER>")
  (format s "<TR>")
  (format s "<TD></TD>")
  (do ((l (cdr x) (cdr l)) (columns (columns (car x)) (cdr columns)))
      ((null l))
      (format s "<TH>")
      (format s (prettify (or (car columns) "")))
      (format s "</TH>"))
  (format s "</TR>")
  (format s "<TR>")
  (format s "<TD>")
  (format-checkbox s "Not" "" (not positive))
  (format s "</TD>")
  (do ((l (cdr x) (cdr l)))
      ((null l))
      (format s "<TD>")
      (format-text s "Val" (stringize (car l)) 15)
      (format s "</TD>"))
  (format s "</TR>")
  (format s "</TABLE>")
  (format s "</TD></TR></TABLE>")
  (format-hidden s "End" ""))

(defun output-transform-commands (s)
  (let ((relations (sort (find-relations) #'lessp))
        (attributes (sort (get-attributes) #'lessp)))
    (format s "<BR>")
    (format s "<TABLE WIDTH=100%><TR>")
    (format s "<TD WIDTH=25% VALIGN=TOP>")
    (format-button s "Command" "Submit")
    (format s "</TD><TD WIDTH=25% VALIGN=TOP>")
    (format-button s "Command" "Convert to KIF")
    (format s "</TD><TD WIDTH=50% VALIGN=TOP>")
    (format-button s "Command" " Add Condition ")
    (format s "<SELECT NAME=Condition>")
    (format s "<OPTION SELECTED>~A~%" (stringize (car relations)))
    (dolist (relation (cdr relations))
      (format s "<OPTION>~A~%" (stringize relation)))
    (format s "</SELECT>")
    (format s "<BR>")
    (format-button s "Command" "Drop Condition ")
    (format s "<BR>")
    (format-button s "Command" "Add  Conclusion")
    (format s "<SELECT NAME=Conclusion>")
    (format s "<OPTION SELECTED>~A~%" (stringize (car attributes)))
    (dolist (attribute (cdr attributes))
      (format s "<OPTION>~A~%" (stringize attribute)))
    (format s "</SELECT>")
    (format s "<BR>")
    (format-button s "Command" "Drop Conclusion")
    (format s "</TD></TR></TABLE>")))

(defun addcondition (literal transform)
  `(==> ,(maksand (addit literal (cadr transform))) ,(caddr transform)))

(defun dropcondition (transform)
  `(==> ,(maksand (deletem (cadr transform))) ,(caddr transform)))

(defun addconclusion (literal transform)
  `(==> ,(cadr transform) ,(maksand (addit literal (caddr transform)))))

(defun dropconclusion (transform)
  `(==> ,(cadr transform) ,(maksand (deletem (caddr transform)))))

(defun addit (literal sentence)
  (setq sentence (cons 'and (conditions sentence)))
  (do ((l (cdr sentence) (cdr l)))
      ((null l) (maksand (cons `(selected ,literal) (cdr sentence))))
      (when (and (listp (car l)) (eq 'selected (caar l)))
        (rplaca l (cadar l))
        (rplacd l (cons `(selected ,literal) (cdr l)))
        (return sentence))))

(defun deletem (sentence)
  (do ((l (conditions sentence) (cdr l)) (nl))
      ((null l) (nreverse nl))
      (unless (and (listp (car l)) (eq 'selected (caar l)))
        (setq nl (cons (car l) nl)))))

(defun conditions (p)
  (cond ((atom p) (list p))
        ((eq (car p) 'and) (cdr p))
        (t (list p))))

(defun convert-transform ()
  (let (left right)
    (pop *postlines*)
    (setq left (convert-side))
    (setq right (convert-side))
    (pop *postlines*)
    `(==> ,left ,right)))

(defun convert-side ()
  (pop *postlines*)
  (do ((nl))
      ((or (null *postlines*) (string= (caar *postlines*) "End"))
       (pop *postlines*) (maksand (nreverse nl)))
      (setq nl (cons (convert-atom) nl))))

(defun get-attributes ()
  (finds '?r '(or (isa ?r attributerelation) (isa ?r naryrelation)) *interface*))

(defun makargs (count arity)
  (setq count (princ-to-string count))
  (do ((i 1 (1+ i)) (nl))
      ((> i arity) (nreverse nl))
      (setq nl (cons (intern (stringappend "?" count "." (princ-to-string i))) nl))))

(defun transform (before after th)
  (modify (maksand (transformations before after th)) th))

(defun transformations (before after th)
  (asks after before nil th))

(defmethod modify (p (receiver viewserver))
  (cond ((atom p) (insert p receiver))
        ((eq (car p) 'not) (dropit (cadr p) receiver))
        ((eq (car p) 'and) (dolist (p (cdr p)) (modify p receiver)))
        (t (insert p receiver))))

(defun dropit (p th)
  (do ((l (indexps p th) (cdr l)))
      ((null l) nil)
      (when (equalp p (car l)) (uninsert (car l) th) (return t))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
