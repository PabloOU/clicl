;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; fullanswer
;;; fullanswers
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun fullanswer (p *theory*)
  (let (*thing* alist *answer*)
    (setq *unifications* 0)
    (setq *inferences* 0)
    (setq *termination* nil)
    (setq *thing* '(listof @l) p (list p '@l))
    (setq alist (environment))
    (when (fullone p (list p) alist 0 nil) *answer*)))

(defun fullanswers (p *theory*)
  (let (*thing* alist *answers*)
    (setq *unifications* 0)
    (setq *inferences* 0)
    (setq *termination* nil)
    (setq *thing* '(listof @l) p (list p '@l))
    (setq alist (environment))
    (fullall p (list p) alist 0 nil)
    (nreverse (uniquify *answers*))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; fullresidue
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defmethod fullresidue (x p *theory* &optional (*filter* #'basep) (*test* #'success))
  (let (th answer)
    (setq th (make-instance 'theory))
    (includes th *theory*)
    (dolist (p (contrapositives `(<= (goal ,x) ,p))) (insert p th))
    (setq answer (fullreduction 'goal th *filter* *test*))
    (empty th)
    (unincludes th *theory*)
    (when answer (maksand (cddr answer)))))


; for recursion in fullresidueancestor?
;            ((eq (operator (caar l)) (operator p))
;             (setq p (plugstdexp p al))
;             (setq *residue* (cons p *residue*))
;             (return (fullresidueexit pl al depth cont))))))

;;; fullresidues
    (do ((l *answers* (cdr l)) (nl))
        ((null l) nl)
        (if (every #'(lambda (x) (funcall *test* x)) (cddar l))
            (setq nl (adjoin (car l) nl :test #'equal))))

(defun fullresiduesassumption (p pl al depth cont)
  (let (dum)
    (cond ((and (groundishp (setq dum (plugstdexp p al)))
                (knownp dum *theory*))
           (fullresiduesexit pl al depth cont))
          ((funcall *test* (setq dum (plugstdexp p al)))
           (fullresiduesassume dum pl al depth cont))
          (t (fullfail pl al depth)))))

(defun fullresidueassumption (p pl al depth cont)
  (let (dum)
    (cond ((fullknownrs p pl al depth cont))
          ((funcall *test* (setq dum (plugstdexp p al)))
           (fullresidueassume dum pl al depth cont))
          (t (fullfail pl al depth)))))

(defun fullresidueassume (p pl al depth cont)
  (when (or (not *consistency*)
            (not (or (rebuttalp p *residue*) (rebuttheoryp p *theory*)))
            (consistentp p *residue*))
    (let ((*residue* (adjoin p *residue* :test #'equalp)))
      (or (fullresidueexit pl al depth cont) (fullfail pl al depth)))))

(defun fullknownrs (p pl al depth cont)
  (cond ((fullknownreduce p pl al depth cont))
        (*termination* nil)
        (t (fullknowndb p pl al depth cont *theory*))))

(defun fullknownreduce (p pl al depth cont)
  (do ((l cont (cdr l)) (ol))
      ((null l))
      (cond ((not (setq ol (unify (maknot (caaar l)) (cadar l) p al))))
            ((fullresidueexit pl al depth cont) (backup ol) (return t))
            (t (backup ol)))))

(defun fullknowndb (p pl al depth cont th)
  (fullknownth p pl al depth cont th)
  (do ((l (includees th) (cdr l)))
      ((null l))
      (fullknowndb p pl al depth cont (car l))))

(defun fullknownth (p pl al depth cont th)
  (do ((l (envindexps p al th) (cdr l)) (bl (environment)) (ol))
      ((null l) nil)
      (cond ((not (setq ol (unify (car l) bl p al))))
            ((fullresidueexit pl al depth cont) (backup ol) (return t))
            (t (backup ol)))))


(defun fullresidueexp (p pl al depth cont)
  (cond ((atom p) (fullresidueconstant p pl al depth cont))
        ((eq 'not (car p)) (fullresiduenot (cadr p) pl al depth cont))
        ((eq 'and (car p)) (fullresidueand p pl al depth cont))
        ((eq 'or (car p)) (fullresidueor p pl al depth cont))
        ((eq 'oneof (car p)) (fullresidueoneof p pl al depth cont))
        ((eq 'member (car p)) (fullresiduemember p pl al depth cont))
        ((eq 'same (car p)) (fullresiduesame p pl al depth cont))
        ((eq 'distinct (car p)) (fullresiduedistinct p pl al depth cont))
	((eq 'ground (car p)) (fullresidueground p pl al depth cont))
	((eq 'nonground (car p)) (fullresiduenonground p pl al depth cont))
	((eq 'primitive (car p)) (fullresidueprimitive p pl al depth cont))
	((eq 'nonprimitive (car p)) (fullresiduenonprimitive p pl al depth cont))
	((eq '== (car p)) (fullresiduevalue p pl al depth cont))
	((eq 'value (car p)) (fullresiduevalue p pl al depth cont))
        ((eq 'execute (car p)) (fullresidueexecute p pl al depth cont))
        ((eq 'evaluate (car p)) (fullresidueevaluate p pl al depth cont))
        ((eq 'unprovable (car p)) (fullresidueunprovable p pl al depth cont))
        ((eq 'choose (car p)) (fullresiduechoose p pl al depth cont))
        ((eq 'bagofall (car p)) (fullresiduebagofall p pl al depth cont))
        ((eq 'stringmatch (car p)) (fullresiduestrmatch p pl al depth cont))
	((get (car p) 'basicval) (fullresiduebasicvalue p pl al depth cont))
        ((get (car p) 'basic) (fullresiduebasic p pl al depth cont))
        ((and (eq 'doit (car p)) (funcall *filter* (operator (cadr p))))
         (fullresidueassumption p pl al depth cont))
        ((funcall *filter* (operator p)) (fullresidueassumption p pl al depth cont))
        (t (fullresiduers p pl al depth cont))))

(defun fullresiduenot (p pl al depth cont)
  (cond ((atom p) (fullresiduenotconstant p pl al depth cont))
        ((eq 'not (car p)) (fullresidueexp (cadr p) pl al depth cont))
        ((eq 'and (car p)) (fullresiduenotand p pl al depth cont))
        ((eq 'or (car p)) (fullresiduenotor p pl al depth cont))
        ((eq 'oneof (car p)) nil)
        ((eq 'same (car p)) nil)
        ((eq 'distinct (car p)) nil)
	((eq 'ground (car p)) nil)
	((eq 'nonground (car p)) nil)
	((eq 'primitive (car p)) nil)
	((eq 'nonprimitive (car p)) nil)
	((eq '== (car p)) (fullresiduenotvalue p pl al depth cont))
	((eq 'value (car p)) (fullresiduenotvalue p pl al depth cont))
        ((eq 'execute (car p)) (fullresiduenotexecute p pl al depth cont))
        ((eq 'evaluate (car p)) (fullresiduenotevaluate p pl al depth cont))
        ((eq 'unprovable (car p)) (fullresidueexp (cadr p) pl al depth cont))
        ((eq 'choose (car p)) (fullresiduenotchoose p pl al depth cont))
        ((eq 'bagofall (car p)) (fullresiduenotbagofall p pl al depth cont))
        ((eq 'stringmatch (car p)) (fullresiduenotstrmatch p pl al depth cont))
	((get (car p) 'basicval) (fullresiduenotbasicvalue p pl al depth cont))
        ((get (car p) 'basic) (fullresiduenotbasic p pl al depth cont))
        ((and (eq 'doit (car p)) (funcall *filter* (operator (cadr p))))
         (fullresidueassumption `(not ,p) pl al depth cont))
        ((funcall *filter* (operator p)) (fullresidueassumption `(not ,p) pl al depth cont))
        (t (fullresiduers `(not ,p) pl al depth cont))))

(defun fullresiduesexp (p pl al depth cont)
  (cond ((atom p) (fullresiduesconstant p pl al depth cont))
        ((eq 'not (car p)) (fullresiduesnot (cadr p) pl al depth cont))
        ((eq 'and (car p)) (fullresiduesand p pl al depth cont))
        ((eq 'or (car p)) (fullresiduesor p pl al depth cont))
        ((eq 'oneof (car p)) (fullresiduesoneof p pl al depth cont))
        ((eq 'member (car p)) (fullresiduesmember p pl al depth cont))
        ((eq 'same (car p)) (fullresiduessame p pl al depth cont))
        ((eq 'distinct (car p)) (fullresiduesdistinct p pl al depth cont))
	((eq 'ground (car p)) (fullresiduesground p pl al depth cont))
	((eq 'nonground (car p)) (fullresiduesnonground p pl al depth cont))
	((eq 'primitive (car p)) (fullresiduesprimitive p pl al depth cont))
	((eq 'nonprimitive (car p)) (fullresiduesnonprimitive p pl al depth cont))
	((eq '== (car p)) (fullresiduesvalue p pl al depth cont))
	((eq 'value (car p)) (fullresiduesvalue p pl al depth cont))
        ((eq 'execute (car p)) (fullresiduesexecute p pl al depth cont))
        ((eq 'evaluate (car p)) (fullresiduesevaluate p pl al depth cont))
        ((eq 'unprovable (car p)) (fullresiduesunprovable p pl al depth cont))
        ((eq 'choose (car p)) (fullresidueschoose p pl al depth cont))
        ((eq 'bagofall (car p)) (fullresiduesbagofall p pl al depth cont))
        ((eq 'stringmatch (car p)) (fullresiduesstrmatch p pl al depth cont))
	((get (car p) 'basicval) (fullresiduesbasicvalue p pl al depth cont))
        ((get (car p) 'basic) (fullresiduesbasic p pl al depth cont))
        ((and (eq 'doit (car p)) (funcall *filter* (operator (cadr p))))
         (fullresiduesassumption p pl al depth cont))
        ((funcall *filter* (operator p)) (fullresiduesassumption p pl al depth cont))
        (t (fullresiduesrs p pl al depth cont))))

(defun fullresiduesnot (p pl al depth cont)
  (cond ((atom p) (fullresiduesnotconstant p pl al depth cont))
        ((eq 'not (car p)) (fullresiduesexp (cadr p) pl al depth cont))
        ((eq 'and (car p)) (fullresiduesnotand p pl al depth cont))
        ((eq 'or (car p)) (fullresiduesnotor p pl al depth cont))
        ((eq 'oneof (car p)) nil)
        ((eq 'same (car p)) nil)
        ((eq 'distinct (car p)) nil)
	((eq 'ground (car p)) nil)
	((eq 'nonground (car p)) nil)
	((eq 'primitive (car p)) nil)
	((eq 'nonprimitive (car p)) nil)
	((eq '== (car p)) (fullresiduesnotvalue p pl al depth cont))
	((eq 'value (car p)) (fullresiduesnotvalue p pl al depth cont))
        ((eq 'execute (car p)) (fullresiduesnotexecute p pl al depth cont))
        ((eq 'evaluate (car p)) (fullresiduesnotevaluate p pl al depth cont))
        ((eq 'unprovable (car p)) (fullresiduesexp (cadr p) pl al depth cont))
        ((eq 'choose (car p)) (fullresiduesnotchoose p pl al depth cont))
        ((eq 'bagofall (car p)) (fullresiduesnotbagofall p pl al depth cont))
        ((eq 'stringmatch (car p)) (fullresiduesnotstrmatch p pl al depth cont))
	((get (car p) 'basicval) (fullresiduesnotbasicvalue p pl al depth cont))
        ((get (car p) 'basic) (fullresiduesnotbasic p pl al depth cont))
        ((and (eq 'doit (car p)) (funcall *filter* (operator (cadr p))))
         (fullresiduesassumption `(not ,p) pl al depth cont))
        ((funcall *filter* (operator p)) (fullresiduesassumption `(not ,p) pl al depth cont))
        (t (fullresiduesrs `(not ,p) pl al depth cont))))


(defparameter *ids* nil)

(defparameter *tuples* nil)

(defun sxmlinsert (tree source meta)
  (let (*ids*)
    (dolist (object (cdr tree)) (sxmlinsertobject object source meta))
    'done))

(defun sxmlinsertobject (tree source meta)
  (let (class id slot val)
    (setq class (caar tree))
    (setq id (sxmlname (car tree)))
    (fancycreate id class source meta)
    (dolist (cell (cdr tree))
      (setq slot (caar cell))
      (setq val (sxmlsubobject (cadr cell) source meta))
      (fancysave class slot id val source meta))
    id))

(defun sxmlsubobject (tree source meta)
  (cond ((atom tree) tree)
        ((listp (car tree)) (sxmlinsertobject tree source meta))
        (t (sxmlname tree))))

(defun fancycreate (obj class source meta)
  (let ((sub (prefix (name source) class)))
    (when (eq meta 'dynamic)
      (telladministrator `(isa ,sub class))
      (when (findp `(isa ,class class) *manager*)
        (telladministrator `(superclass ,sub ,class)))
      (telladministrator `(rootclass ,(name source) ,sub))
      (telladministrator `(isa ,sub relation))
      (telladministrator `(arity ,sub 1))
      (telladministrator `(specialty ,(name source) ,sub))
      (telladministrator `(rootrelation ,(name source) ,sub)))
    (save `(isa ,obj ,sub) source)
    (save (makpred obj sub source) source)))

(defun fancysave (class relation object value source meta)
  (let ((rel (prefix (name source) relation)) (sub (prefix (name source) class)))
    (when (eq meta 'dynamic)
      (telladministrator `(attribute ,sub ,rel))
      (telladministrator `(isa ,rel relation))
      (when (findp `(isa ,relation relation) *manager*)
        (telladministrator `(superrelation ,rel ,relation)))
      (telladministrator `(arity ,rel 2))
      (telladministrator `(domain ,rel ,sub))
      (when (setq class (find-range relation))
        (telladministrator `(range ,rel ,class)))
      (telladministrator `(rootrelation ,(name source) ,rel)))
    (save `(,rel ,object ,value) source)))


(defun sxmluninsert (tree source meta)
  (let (*ids*)
    (dolist (object (cdr tree)) (sxmluninsertobject object source meta))
    'done))

(defun sxmluninsertobject (tree source meta)
  (let (class id slot val)
    (setq class (caar tree))
    (setq id (sxmlname (car tree)))
    (fancydestroy id class source meta)
    (dolist (cell (cdr tree))
      (setq slot (caar cell))
      (setq val (sxmluninsertold (cadr cell) source meta))
      (fancydrop class slot id val source meta))
    id))

(defun sxmluninsertold (tree source meta)
  (cond ((atom tree) tree)
        ((listp (car tree)) (sxmlinsertobject tree source meta))
        (t (sxmlname tree))))

(defun fancydestroy (obj class source meta)
  (let ((sub (prefix (name source) class)))
    (when (eq meta 'dynamic)
      (untelladministrator `(isa ,sub class))
      (untelladministrator `(superclass ,sub ,class))
      (untelladministrator `(rootclass ,(name source) ,sub))
      (untelladministrator `(isa ,sub relation))
      (untelladministrator `(arity ,sub 1))
      (untelladministrator `(specialty ,(name source) ,sub))
      (untelladministrator `(rootrelation ,(name source) ,sub)))
    (drop `(isa ,obj,sub) source)
    (drop (makpred obj sub source) source)))

(defun fancydrop (class relation object value source meta)
  (let ((rel (prefix (name source) relation))
        (sub (prefix (name source) class)))
    (when (eq meta 'dynamic)
      (untelladministrator `(attribute ,sub ,rel))
      (untelladministrator `(isa ,rel relation))
      (untelladministrator `(superrelation ,rel ,relation))
      (untelladministrator `(arity ,rel 2))
      (untelladministrator `(domain ,rel ,sub))
      (untelladministrator `(specialty ,(name source) ,rel))
      (untelladministrator `(rootrelation ,(name source) ,rel)))
    (drop `(,rel ,object ,value) source)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun old-top (s)
  (let (classes tables editors actions listeners)
    (output-prolog s 200)
    (output-header s "Dispatch")
    (when (setq classes (find-frames *gui*))
      (output-class-dispatch s classes))
    (when (setq tables (find-tables *gui*))
      (output-table-dispatch s tables))
    (when (setq editors (find-editors *gui*))
      (output-sentence-dispatch s editors))
    (when (setq actions (find-buttons *gui*))
      (output-action-menu s actions))
    (when (setq listeners (find-listeners *gui*))
      (output-listener-dispatch s listeners))
    (unless (findp `(nocommand ,*gui* apropos) *interface*)
      (output-apropos s))
    (output-footer s)))

(defun output-class-dispatch (s classes)
  (format s "<P><CENTER><TABLE BORDER>~%")
  (dolist (class classes)
    (cond ((find-visible-subclass class)
           (format s "<TR><TH ALIGN=LEFT><A HREF=\"DISPATCH?class=~A\">~A</A></TH>"
                   (addressify class) (iconify class)))
          (t (format s "<TR><TH ALIGN=LEFT>~A</TH>" (iconify class))))
    (cond ((findp `(nocount ,*gui* ,class) *interface*)
           (format s "<TD></TD>"))
          (t (format s "<TD ALIGN=RIGHT>~A</A></TD>"
                     (or (prorequest `(length (ask-all ?x ,(makpred '?x class *gui*)))) 0))))
    (cond ((not (findp `(nosearch ,*gui* ,class) *interface*))
           (format s "<TD><A HREF=\"SEARCH?Class=~A\">Find</A></TD>" ; ~:(~A~)
                   (addressify class)))
          (t (format s "<TD></TD>")))
    (cond ((not (findp `(nocreate ,*gui* ,class) *interface*))
           (format s "<TD><A HREF=\"CREATE?Class=~A\">Create</A></TD>" ; ~:(~A~)
                   (addressify class)))
          (t (format s "<TD></TD>")))
    (format s "</TR>~%"))
  (format s "</TABLE></CENTER><P>~%"))

(defun output-table-dispatch (s relations)
  (let (arityflag)
    (format s "<P><CENTER><TABLE BORDER>~%")
    (dolist (relation relations)
      (cond ((findp `(superrelation ?x ,relation) *interface*)
             (format s "<TR><TH><A HREF=\"DISPATCH?relation=~A\">~A</A></TH>"
                     (addressify relation) (prettify relation)))
            (t (format s "<TR><TH>~A</TH>" (prettify relation))))
      (cond ((setq arityflag (findp `(arity ,relation ?x) *interface*))
             (format s "<TD><A HREF=\"TABLE?relation=~A\">Find</A></TD>"
                     (addressify relation) (prettify relation)))
            (t (format s "<TD></TD>")))
      (cond ((and arityflag
                  (not (findp `(noupdate ,(name *gui*) ,relation) *interface*)))
             (format s "<TD><A HREF=\"INSERT?relation=~A\">Insert</A></TD>"
                     (addressify relation) (prettify relation))
             (format s "<TD><A HREF=\"DELETE?relation=~A\">Delete</A></TD>"
                     (addressify relation) (prettify relation))
             (format s "<TD><A HREF=\"UPDATE?relation=~A\">Update</A></TD>"
                     (addressify relation) (prettify relation)))
            (t (format s "<TD></TD><TD></TD>")))
      (format s "</TR>~%"))
    (format s "</TABLE></CENTER><P>~%")))

(defun output-action-menu (s actions)
  (format s "<FORM NAME=\"actions\" ACTION=\"Run?\" METHOD=\"POST\">")
  (format s "<CENTER>")
  (format s "<SELECT NAME=\"ACTION\" onChange='window.document.actions.submit()'>")
  (format s "<OPTION>")
  (dolist (action actions)
    (format s "<OPTION>~A~%" (stringify action)))
  (format s "</SELECT>")
  (format s "</CENTER>")
  (format s "</FORM>"))

(defun output-listener-dispatch (s listeners)
  (format s "<P><DL>~%")
  (format s "<CENTER>")
  (dolist (listener listeners)
    (format s "<DD><A HREF=\"~A?\">~A Listener</A>~%"
            (addressify listener) (stringify listener)))
  (format s "</CENTER>")
  (format s "</DL><P>~%"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defmethod nonemptyp (class agent)
  (neap class agent))

(defmethod nonemptyp (class (agent symbol))
  (cond ((and (boundp agent) (not (symbolp (symbol-value agent))))
         (nonemptyp class (symbol-value agent)))
        (t (call-next-method class agent))))

(defmethod nonemptyp (class (agent interface))
  (nonemptyp class (find-target (name agent))))

(defmethod nonemptyp (class (agent facilitator))  
  (dolist (a (finds '?a '(specialty ?a ?r) *manager*))
    (when (nonemptyp class a) (return t))))

(defmethod nonemptyp (class (agent transformer))  
  (netp class agent (find-target (name agent))))

(defmethod nonemptyp (class (agent translator))
  (netp class agent (find-target (name agent))))

(defmethod nonemptyp (class (agent fastserver))
  (nedp class agent))

(defmethod nonemptyp (class (agent dataserver))
  (nedp class agent))

(defmethod nonemptyp (class (agent ruleserver))
  (nedp class agent))

(defmethod nonemptyp (class (agent fullserver))
  (nedp class agent))

(defun neap (class agent)
  (let (classes)
    (cond ((setq classes (find-subclasses class))
           (some #'(lambda (x) (neap x agent)) classes))
          (t (request `(ask-one t ,(makpred '?x class agent)) nil agent)))))

(defun netp (class agent target)
  (let (classes)
    (cond ((setq classes (find-subclasses class))
           (some #'(lambda (x) (netp x agent target)) classes))
          (t (nonemptyp class target)))))

(defun nefp (class agent targets)
  (let (classes)
    (cond ((setq classes (find-subclasses class))
           (some #'(lambda (x) (netp x agent targets)) classes))
          (t (dolist (a targets) (when (nonemptyp class a) (return t)))))))

(defun nedp (class agent)
  (let (subclasses predicate)
    (setq subclasses (find-subclasses class))
    (cond (subclasses (some #'(lambda (x) (nedp x agent)) subclasses))
          ((setq predicate (find-predicate class))
           (do ((l (indexees predicate agent) (cdr l)))
               ((null l) nil)
               (when (and (listp (car l)) (eq (caar l) predicate)) (return t))))
          (t (do ((l (indexees class agent) (cdr l)))
                 ((null l) nil)
                 (cond ((atom (car l)))
                       ((and (eq (caar l) 'isa) (eq (caddar l) class))
                        (return t))))))))

;;;;

 
    (isa           viewable attributerelation)
    (superrelation viewable true)
    (arity         viewable 2)
    (domain        viewable user)
    (range         viewable thing)
    (unique        viewable no)
    (total         viewable no)
    (changestyle   viewable typein)
    (searchstyle   viewable typein)
    (comparestyle  viewable glyph)
    (inspectstyle  viewable glyph)
    (documentation viewable "Object viewable by a user.")

    (isa           editable attributerelation)
    (superrelation editable true)
    (arity         editable 2)
    (domain        editable user)
    (range         editable thing)
    (unique        editable no)
    (total         editable no)
    (changestyle   editable typein)
    (searchstyle   editable typein)
    (comparestyle  editable noshow)
    (inspectstyle  editable glyph)
    (documentation editable "Object editable by a user.")

;;;;

(defun html-handler (s dir file postline)
  (let (postlines)
    (setq postlines (parse-post-data postline))
    (cond ((substringp "MSIE 4" *browser*)
           (garbage-handler s dir file postlines))
          ((substringp "MSIE 3" *browser*)
           (crap-handler s dir file postlines))
          (t (post-handler s dir file postlines)))))

(defun post-handler (s dir file postlines)
  (let (*gui* *security* *interface* *agent* *inspector*)
    (cond ((string= dir "/") (setq *gui* 'standard))
          ((startstringp "/documents/" dir)
           (setq dir (subseq dir 10))
           (setq *gui* (read-from-string dir)))
          (t (setq *gui* (string-left-trim '(#\/) dir))
             (setq *gui* (string-right-trim '(#\/) *gui*))
             (setq *gui* (read-from-string *gui*))))
    (setq *security* (find-infobase *gui*))
    (setq *interface* (find-formbase *gui*))
    (setq *agent* *gui*)
    (setq *inspector* (findp `(nocommand ,*gui* inspect) *interface*))
    (cond ((not (findp `(isa ,*gui* agent) *interface*))
           (serve-document s (stringappend *homedir* (macify dir) (cdar postlines))))
          ((not *security*) (process s (read-value-string file) postlines))
          ((not (accessiblep *gui* *remote*))
           (http-problem s "This interface is not accessible from your IP address."))
          ;((string-equal "Logout" file)
          ; (format s "HTTP/1.0 200 OK") (crlf s)
          ; (format s "Set-Cookie: ~A=~D; path=/" (addressify *gui*) 0) (crlf s)
          ; (crlf s)
          ; (html-message s "Logout successful."))
          ((not (chkpwd *client* *password*))
           (format s "HTTP/1.0 401 Unauthorized") (crlf s)
           (format s "WWW-Authenticate: Basic realm=\"Infomaster\"") (crlf s)
           (format s "Set-Cookie: ~A=~D; path=/" (addressify *gui*) (get-universal-time)) (crlf s)
           (crlf s)
           (html-message s "Bad password."))
          ;((not (chkcookie *client* (getf-post (addressify *gui*) *cookies*)))
          ; (format s "HTTP/1.0 401 Unauthorized") (crlf s)
          ; (format s "WWW-Authenticate: Basic realm=\"Infomaster\"") (crlf s)
          ; (format s "Set-Cookie: ~A=~D; path=/" (addressify *gui*) (get-universal-time)) (crlf s)
          ; (crlf s)
          ; (html-message s "Session terminated."))
          (t (process s (read-value-string file) postlines)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Explorer up to version 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun crap-handler (s dir file postlines)
  (let (*gui* *security* *interface* *agent*)
    (cond ((string= dir "/") (setq *gui* 'standard))
          (t (setq dir (string-left-trim '(#\/) dir))
             (setq dir (string-right-trim '(#\/) dir))
             (setq *gui* (read-from-string dir))))
    (setq *security* (find-infobase *gui*))
    (setq *interface* (find-formbase *gui*))
    (setq *agent* *gui*)
    (setq *client* (read-value-string (getf-post "User" *cookies*)))
    (cond ((not *security*) (process s (read-value-string file) postlines))
          ((not (accessiblep *gui* *remote*))
           (http-problem s "This interface is not accessible from your IP address."))
          ((string-equal "Login" file) (post-login s postlines))
          ((string-equal "Logout" file) (post-logout s))
;          ((not (chkcookie *client* (getf-post (addressify *gui*) *cookies*)))
;           (post-login s nil))
          (t (process s (read-value-string file) postlines)))))

(defun post-login (s postlines)
  (cond ((null postlines) (post-login-page s))
        (t (post-login-doit s postlines))))

(defun post-login-page (s)
  (format s "HTTP/1.0 200 OK") (crlf s)
  (format s "Pragma: no-cache") (crlf s)
  (format s "Content-type: text/html") (crlf s)
  (crlf s)
  (output-header s "Login")
  (format s "<FORM ACTION=\"Login?\" METHOD=\"POST\">")
  (format s "<CENTER><TABLE>")
  (format s "<TR><TH>User</TH><TD><INPUT TYPE=\"TEXT\" NAME=\"User\" SIZE=40></TD></TR>")
  (format s "<TR><TH>Password</TH><TD><INPUT TYPE=\"PASSWORD\" NAME=\"Password\" SIZE=40></TD></TR>")
  (format s "<TR><TH></TH><TD><INPUT TYPE=\"SUBMIT\" VALUE=\"Login\"></TD></TR>")
  (format s "</TABLE></CENTER>")
  (format s "</FORM>")
  (output-footer s))

(defun post-login-doit (s postlines)
  (setq *client* (or (read-value-string (getf-post "User" postlines)) 'anonymous))
  (setq *password* (getf-post "Password" postlines))
  (cond ((chkpwd *client* *password*)
         (format s "HTTP/1.0 200 OK") (crlf s)
         (format s "Pragma: no-cache") (crlf s)
         (format s "Set-Cookie: ~A=~D; path=/" (addressify *gui*) (get-universal-time)) (crlf s)
         (format s "Set-Cookie: User=~A; path=/" (addressify *client*)) (crlf s)
         (format s "Content-type: text/html") (crlf s)
         (crlf s)
         (html-message s "Thank you.  Press the Back button to continue."))
        (t (format s "HTTP/1.0 200 OK") (crlf s)
           (format s "Pragma: no-cache") (crlf s)
           (format s "Set-Cookie: ~A=~D; path=/" (addressify *gui*) 0) (crlf s)
           (format s "Set-Cookie: User=Anonymous; path=/") (crlf s)
           (format s "Content-type: text/html") (crlf s)
           (crlf s)
           (html-message s "Bad login."))))

(defun post-logout (s)
  (format s "HTTP/1.0 200 OK") (crlf s)
  (format s "Set-Cookie: ~A=~D; path=/" (addressify *gui*) 0) (crlf s)
  (format s "Set-Cookie: User=Anonymous; path=/") (crlf s)
  (crlf s)
  (html-message s "Logout successful."))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Explorer version 4
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun garbage-handler (s dir file postlines)
  (let (*gui* *security* *interface* *agent*)
    (cond ((string= dir "/") (setq *gui* 'standard))
          (t (setq dir (string-left-trim '(#\/) dir))
             (setq dir (string-right-trim '(#\/) dir))
             (setq *gui* (read-from-string dir))))
    (setq *security* (find-infobase *gui*))
    (setq *interface* (find-formbase *gui*))
    (setq *agent* *gui*)
    (setq *client* (read-value-string (getf-post "User" *cookies*)))
    (cond ((not *security*) (process s (read-value-string file) postlines))
          ((not (accessiblep *gui* *remote*))
           (http-problem s "This interface is not accessible from your IP address."))
          ((string-equal "Login" file) (garbage-login s postlines))
          ((string-equal "Logout" file) (post-logout s))
;          ((not (chkcookie *client* (getf-post (addressify *gui*) *cookies*)))
;           (post-login s nil))
          (t (process s (read-value-string file) postlines)))))

(defun garbage-login (s postlines)
  (cond ((null postlines) (garbage-login-page s))
        (t (garbage-login-doit s postlines))))

(defun garbage-login-page (s)
  (format s "HTTP/1.1 205 Reset Content") (crlf s)
  (format s "Cache-Control: no-cache") (crlf s)
  (format s "Pragma: no-cache") (crlf s)
  (format s "Content-type: text/html") (crlf s)
  (crlf s)
  (output-header s "Login")
  (format s "<FORM ACTION=\"Login?\" METHOD=\"POST\">")
  (format s "<CENTER><TABLE>")
  (format s "<TR><TH>User</TH><TD><INPUT TYPE=\"TEXT\" NAME=\"User\" SIZE=40></TD></TR>")
  (format s "<TR><TH>Password</TH><TD><INPUT TYPE=\"PASSWORD\" NAME=\"Password\" SIZE=40></TD></TR>")
  (format s "<TR><TH></TH><TD><INPUT TYPE=\"SUBMIT\" VALUE=\"Login\"></TD></TR>")
  (format s "</TABLE></CENTER>")
  (format s "</FORM>")
  (output-footer s))

(defun garbage-login-doit (s postlines)
  (setq *client* (or (read-value-string (getf-post "User" postlines)) 'anonymous))
  (setq *password* (getf-post "Password" postlines))
  (cond ((chkpwd *client* *password*)
         (format s "HTTP/1.1 205 Reset Content") (crlf s)
         (format s "Cache-Control: no-cache") (crlf s)
         (format s "Pragma: no-cache") (crlf s)
         (format s "Set-Cookie: ~A=~D; path=/" (addressify *gui*) (get-universal-time)) (crlf s)
         (format s "Set-Cookie: User=~A; path=/" (addressify *client*)) (crlf s)
         (format s "Content-type: text/html") (crlf s)
         (crlf s)
         (html-message s "Thank you.  Press the Back button to continue.  If your
browser is still showing the Login page, press the Refresh button as well."))
        (t (format s "HTTP/1.1 200 OK") (crlf s)
           (format s "Set-Cookie: ~A=~D; path=/" (addressify *gui*) 0) (crlf s)
           (format s "Set-Cookie: User=Anonymous; path=/") (crlf s)
           (format s "Content-type: text/html") (crlf s)
           (crlf s)
           (html-message s "Bad login."))))

(defun chkcookie (client cookie)
  (let (old new)
    (setq old (or (read-value-string cookie) 0))
    (setq new (get-universal-time))
    (request `(ask-if (recent ,client ,(- new old))) *client* *security*)))

(defun expiration (client)
  (let (timeout)
    (setq timeout (request `(ask-one ?x (timeout ,client ?x)) *client* *security*))
    (cookietime (+ (get-universal-time) (if (integerp timeout) timeout 300)))))

(defun termination ()
  (cookietime (- (get-universal-time) 1000)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; fullresidue
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defparameter *variables* nil)

(defun fullresidue (p *theory* &optional (*filter* #'basep) (*test* #'success))
  (let (alist *residue* *answer* tracecalls)
    (setq *unifications* 0)
    (setq *inferences* 0)
    (setq *termination* nil)
    (setq alist (environment))
    (setq *variables* (vars p))
    (when (fullresiduedepth p (list p) alist 0 nil) *answer*)))

(defun fullresiduedepth (p pl al depth cont)
  (setq *inferences* (1+ *inferences*))
  (fullcall p al depth)
  (cond ((>= *inferences* *limit*) (setq *termination* t) (fullstop pl al depth))
        ((>= depth *depth*) (setq *termination* t) (fullstop pl al depth))
        (t (fullresidueexp p pl al depth cont))))

(defun fullresidueexp (p pl al depth cont)
  (cond ((atom p) (fullresidueconstant p pl al depth cont))
        ((eq 'not (car p)) (fullresiduenot (cadr p) pl al depth cont))
        ((eq 'and (car p)) (fullresidueand p pl al depth cont))
        ((eq 'or (car p)) (fullresidueor p pl al depth cont))
        ((eq 'oneof (car p)) (fullresidueassumption p pl al depth cont))
        ((eq 'member (car p)) (fullresiduemember p pl al depth cont))
        ((eq 'same (car p)) (fullresiduesame p pl al depth cont))
        ((eq 'distinct (car p)) (fullresiduedistinct p pl al depth cont))
	((eq 'ground (car p)) (fullresidueground p pl al depth cont))
	((eq 'nonground (car p)) (fullresiduenonground p pl al depth cont))
	((eq 'primitive (car p)) (fullresidueprimitive p pl al depth cont))
	((eq 'nonprimitive (car p)) (fullresiduenonprimitive p pl al depth cont))
	((eq '== (car p)) (fullresiduevalue p pl al depth cont))
	((eq 'value (car p)) (fullresiduevalue p pl al depth cont))
        ((eq 'execute (car p)) (fullresidueexecute p pl al depth cont))
        ((eq 'evaluate (car p)) (fullresidueevaluate p pl al depth cont))
        ((eq 'unprovable (car p)) (fullresidueunprovable p pl al depth cont))
        ((eq 'choose (car p)) (fullresiduechoose p pl al depth cont))
        ((eq 'bagofall (car p)) (fullresiduebagofall p pl al depth cont))
        ((eq 'stringmatch (car p)) (fullresiduestrmatch p pl al depth cont))
	((get (car p) 'basicval) (fullresiduebasicvalue p pl al depth cont))
        ((get (car p) 'basic) (fullresiduebasic p pl al depth cont))
        ((funcall *filter* (operator p)) (fullresidueassumption p pl al depth cont))
        (t (fullresiduers p pl al depth cont))))

(defun fullresiduenot (p pl al depth cont)
  (cond ((atom p) (fullresiduenotconstant p pl al depth cont))
        ((eq 'not (car p)) (fullresidueexp (cadr p) pl al depth cont))
        ((eq 'and (car p)) (fullresiduenotand p pl al depth cont))
        ((eq 'or (car p)) (fullresiduenotor p pl al depth cont))
        ((eq 'oneof (car p)) nil)
        ((eq 'same (car p)) nil)
        ((eq 'distinct (car p)) nil)
	((eq 'ground (car p)) nil)
	((eq 'nonground (car p)) nil)
	((eq 'primitive (car p)) nil)
	((eq 'nonprimitive (car p)) nil)
	((eq '== (car p)) (fullresiduenotvalue p pl al depth cont))
	((eq 'value (car p)) (fullresiduenotvalue p pl al depth cont))
        ((eq 'execute (car p)) (fullresiduenotexecute p pl al depth cont))
        ((eq 'evaluate (car p)) (fullresiduenotevaluate p pl al depth cont))
        ((eq 'unprovable (car p)) (fullresidueexp (cadr p) pl al depth cont))
        ((eq 'choose (car p)) (fullresiduenotchoose p pl al depth cont))
        ((eq 'bagofall (car p)) (fullresiduenotbagofall p pl al depth cont))
        ((eq 'stringmatch (car p)) (fullresiduenotstrmatch p pl al depth cont))
	((get (car p) 'basicval) (fullresiduenotbasicvalue p pl al depth cont))
        ((get (car p) 'basic) (fullresiduenotbasic p pl al depth cont))
        ((funcall *filter* (operator p)) (fullresidueassumption `(not ,p) pl al depth cont))
        (t (fullresiduers `(not ,p) pl al depth cont))))

(defun fullresidueconstant (p pl al depth cont)
  (cond ((eq 'true p) (fullresiduelast pl al depth cont))
        ((eq 'false p) (fullfail pl al depth))
        (t (fullresiduers p pl al depth cont))))

(defun fullresiduenotconstant (p pl al depth cont)
  (cond ((eq 'true p) (fullfail pl al depth))
        ((eq 'false p) (fullresiduelast pl al depth cont))
        (t (fullresiduers `(not ,p) pl al depth cont))))

(defun fullresidueand (p pl al depth cont)
  (cond ((null (cdr p)) (fullresiduelast pl al depth cont))
        ((fullresiduedepth (cadr p) (cdr p) al depth (cons (list pl al depth) cont)))
        (t (fullfail pl al depth))))

(defun fullresiduenotand (p pl al depth cont)
  (setq cont (cons (list pl al depth) cont))
  (do ((l (cdr p) (cdr l)))
      ((null l) (fullfail pl al depth))
      (when (fullresiduedepth (maknot (car l)) (list (maknot (car l))) al depth cont)
        (fullresidueexit pl al depth cont))))

(defun fullresidueor (p pl al depth cont)
  (setq cont (cons (list pl al depth) cont))
  (do ((l (cdr p) (cdr l)))
      ((null l) (fullfail pl al depth))
      (when (fullresiduedepth (car l) (list (car l)) al depth cont)
        (fullresidueexit pl al depth cont))))

(defun fullresiduenotor (p pl al depth cont)
  (cond ((null (cdr p)) (fullresiduelast pl al depth cont))
        ((fullresiduedepth (maknot (cadr p)) (mapcar #'maknot (cdr p))
                           al depth (cons (list pl al depth) cont)))
        (t (fullfail pl al depth))))

(defun fullresidueoneof (p pl al depth cont)
  (when (seqvarp (caddr p)) (setq p (plug p al)))
  (do ((l (cddr p) (cdr l)) (ol))
      ((null l) (fullfail pl al depth))
      (cond ((not (setq ol (unify (cadr p) al (car l) al))))
            ((fullresidueexit pl al depth cont) (backup ol) (return t))
            (t (backup ol)))))

(defun fullresiduemember (p pl al depth cont)
  (do ((l (cdaddr p) (cdr l)) (ol))
      ((null l) (fullfail pl al depth))
      (cond ((not (setq ol (unify (cadr p) al (car l) al))))
            ((fullresidueexit pl al depth cont) (backup ol) (return t))
            (t (backup ol)))))

(defun fullresiduesame (p pl al depth cont)
  (let (ol)
    (cond ((setq ol (unify (cadr p) al (caddr p) al))
           (prog1 (fullresiduelast pl al depth cont) (backup ol)))
          (t (fullfail pl al depth)))))

(defun fullresiduedistinct (p pl al depth cont)
  (let ((ol))
    (cond ((setq ol (unify (cadr p) al (caddr p) al))
           (backup ol) (fullfail pl al depth))
          (t (fullresiduelast pl al depth cont)))))

(defun fullresidueground (p pl al depth cont)
  (cond ((and (groundp (plug (cadr p) al))) (fullresiduelast pl al depth cont))
        (t (fullfail pl al depth))))

(defun fullresiduenonground (p pl al depth cont)
  (cond ((groundp (plug (cadr p) al)) (fullfail pl al depth))
        (t (fullresiduelast pl al depth cont))))

(defun fullresidueprimitive (p pl al depth cont)
  (cond ((and (primitivep (plug (cadr p) al))) (fullresiduelast pl al depth cont))
        (t (fullfail pl al depth))))

(defun fullresiduenonprimitive (p pl al depth cont)
  (cond ((primitivep (plug (cadr p) al)) (fullfail pl al depth))
        (t (fullresiduelast pl al depth cont))))

(defun fullresiduevalue (p pl al depth cont)
  (let (x y ol)
    (setq p (plug p al) x (cadr p) y (caddr p))
    (cond ((atom x))
          ((eq 'bagofall (car x))
           (setq x (cons 'listof (fullfinds (cadr x) (caddr x) *theory*))))
          ((and (groundp x) (every #'primitivep (cdr x)))
           (setq x (funcall (get (car x) 'basicval) x))))
    (cond ((setq ol (unify x al y al))
           (prog1 (fullresiduelast pl al depth cont) (backup ol)))
          (t (fullfail pl al depth)))))

(defun fullresiduenotvalue (p pl al depth cont)
  (let (x y ol)
    (setq p (plug p al) x (cadr p) y (caddr p))
    (cond ((atom x))
          ((eq 'bagofall (car x))
           (setq x (cons 'listof (fullfinds (cadr x) (caddr x) *theory*))))
          ((and (groundp x) (every #'primitivep (cdr x)))
           (setq x (funcall (get (car x) 'basicval) x))))
    (cond ((setq ol (unify x al y al)) (backup ol) (fullfail pl al depth))
          (t (fullresiduelast pl al depth cont)))))

(defun fullresidueexecute (p pl al depth cont)
  (let (values ol)
    (setq p (plug p al))
    (cond ((null (cddr p))
           (cond ((ignore-errors (eval (cadr p)))
                  (fullresiduelast pl al depth cont))
                 (t (fullfail pl al depth))))
          ((and (car (setq values (ignore-errors (multiple-value-list (eval (cadr p))))))
                (setq ol (matchify `(listof . ,(cddr p)) al `(listof . ,(mapcar #'quotify values)) al)))
           (prog1 (fullresiduelast pl al depth cont) (backup ol)))
          (t (fullfail pl al depth)))))

(defun fullresiduenotexecute (p pl al depth cont)
  (let (values ol)
    (setq p (plug p al))
    (cond ((null (cddr p))
           (cond ((ignore-errors (not (eval (cadr p))))
                  (fullresiduelast pl al depth cont))
                 (t (fullfail pl al depth))))
          ((and (car (setq values (ignore-errors (multiple-value-list (eval (cadr p))))))
                (not (setq ol (matchify `(listof . ,(cddr p)) al `(listof . ,(mapcar #'quotify values)) al)))
           (fullresiduelast pl al depth cont)))
          (t (backup ol) (fullfail pl al depth)))))          

(defun fullresidueevaluate (p pl al depth cont)
  (let (values ol)
    (setq p (plug p al))
    (cond ((null (cddr p))
           (cond ((ignore-errors (apply (caadr p) (cdadr p)))
                  (fullresiduelast pl al depth cont))
                 (t (fullfail pl al depth))))
          ((and (car (setq values (ignore-errors (multiple-value-list (apply (caadr p) (cdadr p))))))
                (setq ol (matchify `(listof . ,(cddr p)) al `(listof . ,values) al)))
           (prog1 (fullresiduelast pl al depth cont) (backup ol)))
          (t (fullfail pl al depth)))))

(defun fullresiduenotevaluate (p pl al depth cont)
  (let (values ol)
    (setq p (plug p al))
    (cond ((null (cddr p))
           (cond ((ignore-errors (not (apply (caadr p) (cdadr p))))
                  (fullresiduelast pl al depth cont))
                 (t (fullfail pl al depth))))
          ((and (car (setq values (ignore-errors (multiple-value-list (apply (caadr p) (cdadr p))))))
                (not (setq ol (matchify `(listof . ,(cddr p)) al `(listof . ,values) al))))
           (fullresiduelast pl al depth cont))
          (t (backup ol) (fullfail pl al depth)))))

(defun fullresidueunprovable (p pl al depth cont)
  (cond ((fullone (cadr p) (cdr p) al depth nil) (fullfail pl al depth))
        (t (fullonelast pl al depth cont))))

(defun fullresiduechoose (p pl al depth cont)
  (let (x ol)
    (setq p (plugstdexp p al))
    (setq x (findx (cadr p) (caddr p) *theory*))
    (cond ((and (not (null x)) (setq ol (unify (cadr p) alist x alist)))
           (prog1 (fullresiduelast pl al depth cont) (backup ol)))
          (t (fullfail pl al depth)))))

(defun fullresiduenotchoose (p pl al depth cont)
  (setq p (plugstdexp p al))
  (cond ((findp (caddr p) *theory*) (fullfail pl al depth))
        (t (fullresiduelast pl al depth cont))))

(defun fullresiduebagofall (p pl al depth cont)
  (fullresiduevalue `(value ,(butlast p) ,(cadddr p)) pl al depth cont))

(defun fullresiduenotbagofall (p pl al depth cont)
  (fullresiduenotvalue `(value ,(butlast p) ,(cadddr p)) pl al depth cont))

(defun fullresiduestrmatch (p pl al depth cont)
  (fullresidueexp `(execute (strmatches ,(cadr p) ,(caddr p)) ? . ,(cdddr p)) pl al depth cont))

(defun fullresiduenotstrmatch (p pl al depth cont)
  (fullresiduenot `(execute (strmatches ,(cadr p) ,(caddr p)) ? . ,(cdddr p)) pl al depth cont))

(defun fullresiduebasicvalue (p pl al depth cont)
  (let (x y ol)
    (setq x (butlast p) y (car (last p)))
    (cond ((and (setq x (groundplugstdexp x al)) (every #'primitivep (cdr x)))
           (setq x (funcall (get (car x) 'basicval) x))
           (if (and (not (null x)) (setq ol (unify y al x al)))
             (prog1 (fullresiduelast pl al depth cont) (backup ol))
             (fullfail pl al depth)))
          (t (fullresidueassumption p pl al depth cont)))))

(defun fullresiduenotbasicvalue (p pl al depth cont)
  (let (x y ol)
    (setq x (butlast p) y (car (last p)))
    (cond ((and (setq x (groundplugstdexp x al)) (every #'primitivep (cdr x)))
           (setq x (funcall (get (car x) 'basicval) x))
           (cond ((null x) (fullfail pl al depth))
                 ((setq ol (unify y al x al)) (backup ol) (fullfail pl al depth))
                 (t (fullresiduelast pl al depth cont))))
          (t (fullresidueassumption `(not ,p) pl al depth cont)))))

(defun fullresiduebasic (p pl al depth cont)
  (setq p (plug p al))
  (cond ((and (groundp p) (apply (get (car p) 'basic) (cdr p)))
         (fullresiduelast pl al depth cont))
        (t (fullfail pl al depth))))

(defun fullresiduenotbasic (p pl al depth cont)
  (setq p (plug p al))
  (cond ((and (groundp p) (not (apply (get (car p) 'basic) (cdr p))))
         (fullresiduelast pl al depth cont))
        (t (fullfail pl al depth))))

(defun fullresidueassumption (p pl al depth cont)
  (setq p (plugstdexp p al))
  (cond ((not (funcall *test* p)) (fullfail pl al depth))
        ((find p *residue* :test #'equalp) (fullresiduelast pl al depth cont))
        ((or (not *consistency*)
             (not (or (rebuttalp p *residue*) (rebuttheoryp p *theory*)))
             (consistentp p *residue*))
         (let ((*residue* (cons p *residue*))) (fullresiduelast pl al depth cont)))
        (t  (fullfail pl al depth))))

(defun fullresiduers (p pl al depth cont)
  (cond ((and *ancestry* (fullresidueancestor p al cont)) (fullfail pl al depth))
        ((and *reduction* (fullresiduereduce p pl al depth cont)))
        ((fullresiduedb p pl al depth cont *theory*))
        (t (fullfail pl al depth))))

(defun fullresidueancestor (p al cont)
  (do ((l cont (cdr l)))
      ((null l) nil)
      (when (identify (caaar l) (cadar l) p al) (return t))))

(defun fullresiduereduce (p pl al depth cont)
  (do ((l cont (cdr l)) (ol))
      ((null l))
      (cond ((not (setq ol (unify (maknot (caaar l)) (cadar l) p al))))
            ((fullresidueexit pl al depth cont) (backup ol) (return t))
            (t (backup ol)))))

(defun fullresiduedb (p pl al depth cont th)
  (cond ((fullresidueth p pl al depth cont th))
        (t (do ((l (includees th) (cdr l)))
               ((null l) nil)
               (when (fullresiduedb p pl al depth cont (car l)) (return t))))))

(defun fullresidueth (p pl al depth cont th)
  (do ((l (envindexps p al th) (cdr l)) (bl (environment)) (ol))
      ((null l))
      (cond ((and (listp (car l)) (eq '<= (caar l)) (null (cddar l)))
             (cond ((not (setq ol (unify (cadar l) bl p al))))
                   ((fullresidueexit pl al depth cont)
                    (backup ol)
                    (return t))
                   ((subolp ol (alist bl)) (backup ol) (return nil))
                   (t (backup ol))))
            ((and (listp (car l)) (eq '<= (caar l)))
             (cond ((not (setq ol (unify (cadar l) bl p al))))
                   ((fullresiduedepth (caddar l) (cddar l) bl
                                      (1+ depth) (cons (list pl al depth) cont))
                    (backup ol) (return  t))
                   (t (backup ol))))
            ((setq ol (unify (car l) bl p al))
             (cond ((fullresidueexit pl al depth cont)
                    (backup ol)
                    (return t))
                   ((subolp ol (alist bl)) (backup ol) (return nil))
                   (t (backup ol)))))))

(defun fullresidueexit (pl al depth cont)
  (let (dum ans)
    (fullexit pl al depth)
    (cond ((cdr pl) (setq ans (fullresiduedepth (cadr pl) (cdr pl) al depth cont)))
          (cont (setq ans (fullresidueexit (caar cont) (cadar cont) (caddar cont) (cdr cont))))
          (t (setq ans (plugstdexp *residue* alist))
             (dolist (var *variables*)
               (unless (eq (setq dum (plugstdexp var alist)) var)
                 (setq ans (cons `(same ,var ,dum) ans))))
             (setq *answer* (maksand ans) ans t)))
    (if ans t (fullredo pl al depth))))

(defun fullresiduelast (pl al depth cont)
  (let (dum ans)
    (fullexit pl al depth)
    (cond ((cdr pl) (fullresiduedepth (cadr pl) (cdr pl) al depth cont))
          (cont (fullresidueexit (caar cont) (cadar cont) (caddar cont) (cdr cont)))
          (t (setq ans (plugstdexp *residue* alist))
             (dolist (var *variables*)
               (unless (eq (setq dum (plugstdexp var alist)) var)
                 (setq ans (cons `(same ,var ,dum) ans))))
             (setq *answer* (maksand ans)) t))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; fullresidues
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun fullresidues (p *theory* &optional (*filter* #'basep) (*test* #'success))
  (let (alist *variables* *residue* *answers* tracecalls)
    (setq *unifications* 0)
    (setq *inferences* 0)
    (setq *termination* nil)
    (setq alist (environment))
    (setq *variables* (vars p))
    (fullresiduesdepth p (list p) alist 0 nil)
    (nreverse *answers*)))

(defun fullresiduesdepth (p pl al depth cont)
  (setq *inferences* (1+ *inferences*))
  (fullcall p al depth)
  (cond ((>= *inferences* *limit*) (setq *termination* t) (fullstop pl al depth))
        ((>= depth *depth*) (setq *termination* t) (fullstop pl al depth))
        (t (fullresiduesexp p pl al depth cont))))

(defun fullresiduesexp (p pl al depth cont)
  (cond ((atom p) (fullresiduesconstant p pl al depth cont))
        ((eq 'not (car p)) (fullresiduesnot (cadr p) pl al depth cont))
        ((eq 'and (car p)) (fullresiduesand p pl al depth cont))
        ((eq 'or (car p)) (fullresiduesor p pl al depth cont))
        ((eq 'oneof (car p)) (fullresiduesassumption p pl al depth cont))
        ((eq 'member (car p)) (fullresiduesmember p pl al depth cont))
        ((eq 'same (car p)) (fullresiduessame p pl al depth cont))
        ((eq 'distinct (car p)) (fullresiduesdistinct p pl al depth cont))
	((eq 'ground (car p)) (fullresiduesground p pl al depth cont))
	((eq 'nonground (car p)) (fullresiduesnonground p pl al depth cont))
	((eq 'primitive (car p)) (fullresiduesprimitive p pl al depth cont))
	((eq 'nonprimitive (car p)) (fullresiduesnonprimitive p pl al depth cont))
	((eq '== (car p)) (fullresiduesvalue p pl al depth cont))
	((eq 'value (car p)) (fullresiduesvalue p pl al depth cont))
        ((eq 'execute (car p)) (fullresiduesexecute p pl al depth cont))
        ((eq 'evaluate (car p)) (fullresiduesevaluate p pl al depth cont))
        ((eq 'unprovable (car p)) (fullresiduesunprovable p pl al depth cont))
        ((eq 'choose (car p)) (fullresidueschoose p pl al depth cont))
        ((eq 'bagofall (car p)) (fullresiduesbagofall p pl al depth cont))
        ((eq 'stringmatch (car p)) (fullresiduesstrmatch p pl al depth cont))
	((get (car p) 'basicval) (fullresiduesbasicvalue p pl al depth cont))
        ((get (car p) 'basic) (fullresiduesbasic p pl al depth cont))
        ((funcall *filter* (operator p)) (fullresiduesassumption p pl al depth cont))
        (t (fullresiduesrs p pl al depth cont))))

(defun fullresiduesnot (p pl al depth cont)
  (cond ((atom p) (fullresiduesnotconstant p pl al depth cont))
        ((eq 'not (car p)) (fullresiduesexp (cadr p) pl al depth cont))
        ((eq 'and (car p)) (fullresiduesnotand p pl al depth cont))
        ((eq 'or (car p)) (fullresiduesnotor p pl al depth cont))
        ((eq 'oneof (car p)) nil)
        ((eq 'same (car p)) nil)
        ((eq 'distinct (car p)) nil)
	((eq 'ground (car p)) nil)
	((eq 'nonground (car p)) nil)
	((eq 'primitive (car p)) nil)
	((eq 'nonprimitive (car p)) nil)
	((eq '== (car p)) (fullresiduesnotvalue p pl al depth cont))
	((eq 'value (car p)) (fullresiduesnotvalue p pl al depth cont))
        ((eq 'execute (car p)) (fullresiduesnotexecute p pl al depth cont))
        ((eq 'evaluate (car p)) (fullresiduesnotevaluate p pl al depth cont))
        ((eq 'unprovable (car p)) (fullresiduesexp (cadr p) pl al depth cont))
        ((eq 'choose (car p)) (fullresiduesnotchoose p pl al depth cont))
        ((eq 'bagofall (car p)) (fullresiduesnotbagofall p pl al depth cont))
        ((eq 'stringmatch (car p)) (fullresiduesnotstrmatch p pl al depth cont))
	((get (car p) 'basicval) (fullresiduesnotbasicvalue p pl al depth cont))
        ((get (car p) 'basic) (fullresiduesnotbasic p pl al depth cont))
        ((funcall *filter* (operator p)) (fullresiduesassumption `(not ,p) pl al depth cont))
        (t (fullresiduesrs `(not ,p) pl al depth cont))))

(defun fullresiduesconstant (p pl al depth cont)
  (cond ((eq 'true p) (fullresidueslast pl al depth cont))
        ((eq 'false p) (fullfail pl al depth))
        (t (fullresiduesrs p pl al depth cont))))

(defun fullresiduesnotconstant (p pl al depth cont)
  (cond ((eq 'true p) (fullfail pl al depth))
        ((eq 'false p) (fullresidueslast pl al depth cont))
        (t (fullresiduesrs `(not ,p) pl al depth cont))))

(defun fullresiduesand (p pl al depth cont)
  (cond ((null (cdr p)) (fullresidueslast pl al depth cont))
        ((fullresiduesexp (cadr p) (cdr p) al depth (cons (list pl al depth) cont)))
        (t (fullfail pl al depth))))

(defun fullresiduesnotand (p pl al depth cont)
  (setq cont (cons (list pl al depth) cont))
  (do ((l (cdr p) (cdr l)))
      ((null l) (fullfail pl al depth))
      (fullresiduesexp (maknot (car l)) (list (maknot (car l))) al depth cont)))

(defun fullresiduesor (p pl al depth cont)
  (setq cont (cons (list pl al depth) cont))
  (do ((l (cdr p) (cdr l)))
      ((null l) (fullfail pl al depth))
      (fullresiduesexp (car l) (list (car l)) al depth cont)))

(defun fullresiduesnotor (p pl al depth cont)
  (cond ((null (cdr p)) (fullresidueslast pl al depth cont))
        ((fullresiduesexp (maknot (cadr p)) (mapcar #'maknot (cdr p)) al depth
                  (cons (list pl al depth) cont)))
        (t (fullfail pl al depth))))

(defun fullresiduesoneof (p pl al depth cont)
  (when (seqvarp (caddr p)) (setq p (plug p al)))
  (do ((l (cddr p) (cdr l)) (ol))
      ((null l) (fullfail pl al depth))
      (when (setq ol (unify (cadr p) al (car l) al))
        (fullresiduesexit pl al depth cont)
        (backup ol))))

(defun fullresiduesmember (p pl al depth cont)
  (do ((l (cdaddr p) (cdr l)) (ol))
      ((null l) (fullfail pl al depth))
      (when (setq ol (unify (cadr p) al (car l) al))
        (fullresiduesexit pl al depth cont)
        (backup ol))))

(defun fullresiduessame (p pl al depth cont)
  (let (ol)
    (cond ((setq ol (unify (cadr p) al (caddr p) al))
           (prog1 (fullresidueslast pl al depth cont) (backup ol)))
          (t (fullfail pl al depth)))))

(defun fullresiduesdistinct (p pl al depth cont)
  (let ((ol))
    (cond ((setq ol (unify (cadr p) al (caddr p) al))
           (backup ol) (fullfail pl al depth))
          (t (fullresidueslast pl al depth cont)))))

(defun fullresiduesground (p pl al depth cont)
  (cond ((and (groundp (plug (cadr p) al))) (fullresidueslast pl al depth cont))
        (t (fullfail pl al depth))))

(defun fullresiduesnonground (p pl al depth cont)
  (cond ((groundp (plug (cadr p) al)) (fullfail pl al depth))
        (t (fullresidueslast pl al depth cont))))

(defun fullresiduesprimitive (p pl al depth cont)
  (cond ((and (primitivep (plug (cadr p) al))) (fullresidueslast pl al depth cont))
        (t (fullfail pl al depth))))

(defun fullresiduesnonprimitive (p pl al depth cont)
  (cond ((primitivep (plug (cadr p) al)) (fullfail pl al depth))
        (t (fullresidueslast pl al depth cont))))

(defun fullresiduesvalue (p pl al depth cont)
  (let (x y ol)
    (setq p (plug p al) x (cadr p) y (caddr p))
    (cond ((atom x))
          ((eq 'bagofall (car x))
           (setq x (cons 'listof (fullfinds (cadr x) (caddr x) *theory*))))
          ((and (groundp x) (every #'primitivep (cdr x)))
           (setq x (funcall (get (car x) 'basicval) x))))
    (cond ((setq ol (unify x al y al))
           (prog1 (fullresidueslast pl al depth cont) (backup ol)))
          (t (fullfail pl al depth)))))

(defun fullresiduesnotvalue (p pl al depth cont)
  (let (x y ol)
    (setq p (plug p al) x (cadr p) y (caddr p))
    (cond ((atom x))
          ((eq 'bagofall (car x))
           (setq x (cons 'listof (fullfinds (cadr x) (caddr x) *theory*))))
          ((and (groundp x) (every #'primitivep (cdr x)))
           (setq x (funcall (get (car x) 'basicval) x))))
    (cond ((setq ol (unify x al y al)) (backup ol) (fullfail pl al depth))
          (t (fullresidueslast pl al depth cont)))))

(defun fullresiduesexecute (p pl al depth cont)
  (let (values ol)
    (setq p (plug p al))
    (cond ((null (cddr p))
           (cond ((ignore-errors (eval (cadr p))) (fullresidueslast pl al depth cont))
                 (t (fullfail pl al depth))))
          ((and (car (setq values (ignore-errors (multiple-value-list (eval (cadr p))))))
                (setq ol (matchify `(listof . ,(cddr p)) al `(listof . ,(mapcar #'quotify values)) al)))
           (prog1 (fullresidueslast pl al depth cont) (backup ol)))
          (t (fullfail pl al depth)))))

(defun fullresiduesnotexecute (p pl al depth cont)
  (let (values ol)
    (setq p (plug p al))
    (cond ((null (cddr p))
           (cond ((ignore-errors (not (eval (cadr p)))) (fullresidueslast pl al depth cont))
                 (t (fullfail pl al depth))))
          ((and (car (setq values (ignore-errors (multiple-value-list (eval (cadr p))))))
                (not (setq ol (matchify `(listof . ,(cddr p)) al `(listof . ,(mapcar #'quotify values)) al)))
           (fullresidueslast pl al depth cont)))
          (t (backup ol) (fullfail pl al depth)))))          

(defun fullresiduesevaluate (p pl al depth cont)
  (let (values ol)
    (setq p (plug p al))
    (cond ((null (cddr p))
           (cond ((ignore-errors (apply (caadr p) (cdadr p))) (fullresidueslast pl al depth cont))
                 (t (fullfail pl al depth))))
          ((and (car (setq values (ignore-errors (multiple-value-list (apply (caadr p) (cdadr p))))))
                (setq ol (matchify `(listof . ,(cddr p)) al `(listof . ,values) al)))
           (prog1 (fullresidueslast pl al depth cont) (backup ol)))
          (t (fullfail pl al depth)))))

(defun fullresiduesnotevaluate (p pl al depth cont)
  (let (values ol)
    (setq p (plug p al))
    (cond ((null (cddr p))
           (cond ((ignore-errors (not (apply (caadr p) (cdadr p)))) (fullresidueslast pl al depth cont))
                 (t (fullfail pl al depth))))
          ((and (car (setq values (ignore-errors (multiple-value-list (apply (caadr p) (cdadr p))))))
                (not (setq ol (matchify `(listof . ,(cddr p)) al `(listof . ,values) al))))
           (fullresidueslast pl al depth cont))
          (t (backup ol) (fullfail pl al depth)))))

(defun fullresiduesunprovable (p pl al depth cont)
  (cond ((fullone (cadr p) pl al depth cont) (fullfail pl al depth))
        (t (fullresidueslast pl al depth cont))))

(defun fullresidueschoose (p pl al depth cont)
  (let (x ol)
    (setq p (plugstdexp p al))
    (setq x (findx (cadr p) (caddr p) *theory*))
    (cond ((and (not (null x)) (setq ol (unify (cadr p) alist x alist)))
           (prog1 (fullresidueslast pl al depth cont) (backup ol)))
          (t (fullfail pl al depth)))))

(defun fullresiduesnotchoose (p pl al depth cont)
  (setq p (plugstdexp p al))
  (cond ((findp (caddr p) *theory*) (fullfail pl al depth))
        (t (fullresidueslast pl al depth cont))))

(defun fullresiduesbagofall (p pl al depth cont)
  (fullresiduesvalue `(value ,(butlast p) ,(cadddr p)) pl al depth cont))

(defun fullresiduesnotbagofall (p pl al depth cont)
  (fullresiduesnotvalue `(value ,(butlast p) ,(cadddr p)) pl al depth cont))

(defun fullresiduesstrmatch (p pl al depth cont)
  (fullresiduesexp `(execute (strmatches ,(cadr p) ,(caddr p)) ? . ,(cdddr p)) pl al depth cont))

(defun fullresiduesnotstrmatch (p pl al depth cont)
  (fullresiduesnot `(execute (strmatches ,(cadr p) ,(caddr p)) ? . ,(cdddr p)) pl al depth cont))

(defun fullresiduesbasicvalue (p pl al depth cont)
  (let (x y ol)
    (setq x (butlast p) y (car (last p)))
    (cond ((and (setq x (groundplugstdexp x al)) (every #'primitivep (cdr x)))
           (setq x (funcall (get (car x) 'basicval) x))
           (if (and (not (null x)) (setq ol (unify y al x al)))
             (prog1 (fullresidueslast pl al depth cont) (backup ol))
             (fullfail pl al depth)))
          (t (fullresiduesassumption p pl al depth cont)))))

(defun fullresiduesnotbasicvalue (p pl al depth cont)
  (let (x y ol)
    (setq x (butlast p) y (car (last p)))
    (cond ((and (setq x (groundplugstdexp x al)) (every #'primitivep (cdr x)))
           (setq x (funcall (get (car x) 'basicval) x))
           (cond ((null x) (fullfail pl al depth))
                 ((setq ol (unify y al x al)) (backup ol) (fullfail pl al depth))
                 (t (fullresidueslast pl al depth cont))))
          (t (fullresiduesassumption `(not ,p) pl al depth cont)))))

(defun fullresiduesbasic (p pl al depth cont)
  (setq p (plugstdexp p al))
  (cond ((and (groundp p) (apply (get (car p) 'basic) (cdr p)))
         (fullresidueslast pl al depth cont))
        (t (let ((*residue* (cons p *residue*))) (fullresidueslast pl al depth cont)))))

(defun fullresiduesnotbasic (p pl al depth cont)
  (setq p (plug p al))
  (cond ((and (groundp p) (not (apply (get (car p) 'basic) (cdr p))))
         (fullresidueslast pl al depth cont))
        (t (let ((*residue* (cons `(not ,p) *residue*))) (fullresidueslast pl al depth cont)))))

(defun fullresiduesassumption (p pl al depth cont)
  (setq p (plugstdexp p al))
  (cond ((not (funcall *test* p)) (fullfail pl al depth))
        ((find p *residue* :test #'equalp) (fullresidueslast pl al depth cont))
        ((or (not *consistency*)
             (not (or (rebuttalp p *residue*) (rebuttheoryp p *theory*)))
             (consistentp p *residue*))
         (let ((*residue* (cons p *residue*))) (fullresidueslast pl al depth cont)))
        (t  (fullfail pl al depth))))

(defun fullresiduesrs (p pl al depth cont)
  (cond ((and *ancestry* (fullresiduesancestor p al cont)) (fullfail pl al depth))
        ((and *reduction* (fullresiduesreduce p pl al depth cont)))
        ((fullresiduesdb p pl al depth cont *theory*))
        (t (fullfail pl al depth))))

(defun fullresiduesancestor (p al cont)
  (do ((l cont (cdr l)))
      ((null l) nil)
      (if (identify (caaar l) (cadar l) p al) (return t))))

(defun fullresiduesreduce (p pl al depth cont)
  (do ((l cont (cdr l)) (ol))
      ((null l))
      (when (setq ol (unify (maknot (caaar l)) (cadar l) p al))
        (fullresiduesexit pl al depth cont)
        (backup ol))))

(defun fullresiduesdb (p pl al depth cont th)
  (fullresiduesth p pl al depth cont th)
  (do ((l (includees th) (cdr l)))
      ((null l) nil)
      (fullresiduesdb p pl al depth cont (car l))))

(defun fullresiduesth (p pl al depth cont th)
  (do ((l (envindexps p al th) (cdr l)) (bl (environment)) (ol))
      ((null l))
      (cond ((and (listp (car l)) (eq '<= (caar l)) (null (cddar l)))
             (when (setq ol (unify (cadar l) bl p al))
               (fullresiduesexit pl al depth cont)
               (cond ((subolp ol (alist bl)) (backup ol) (return nil))
                   (t (backup ol)))))
            ((and (listp (car l)) (eq '<= (caar l)))
             (when (setq ol (unify (cadar l) bl p al))
               (fullresiduesdepth (caddar l) (cddar l) bl
                                  (1+ depth) (cons (list pl al depth) cont))
               (backup ol)))
            ((setq ol (unify (car l) bl p al))
             (fullresiduesexit pl al depth cont)
             (cond ((subolp ol (alist bl)) (backup ol) (return nil))
                   (t (backup ol)))))))

(defun fullresiduesexit (pl al depth cont)
  (let (dum ans)
    (fullexit pl al depth)
    (cond ((cdr pl) (fullresiduesdepth (cadr pl) (cdr pl) al depth cont))
          (cont (fullresiduesexit (caar cont) (cadar cont) (caddar cont) (cdr cont)))
          (t (setq ans (plugstdexp (reverse *residue*) alist))
             (dolist (var *variables*)
               (unless (eq (setq dum (plugstdexp var alist)) var)
                 (setq ans (cons `(same ,var ,dum) ans))))
             (setq *answers* (cons (maksand ans) *answers*))))
    (fullredo pl al depth)))

(defun fullresidueslast (pl al depth cont)
  (let (dum ans)
    (fullexit pl al depth)
    (cond ((cdr pl) (fullresiduesdepth (cadr pl) (cdr pl) al depth cont))
          (cont (fullresiduesexit (caar cont) (cadar cont) (caddar cont) (cdr cont)))
          (t (setq ans (plugstdexp (reverse *residue*) alist))
             (dolist (var *variables*)
               (unless (eq (setq dum (plugstdexp var alist)) var)
                 (setq ans (cons `(same ,var ,dum) ans))))
             (setq *answers* (cons (maksand ans) *answers*))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun showreduction-acl (s postlines)
  (let ((message (read-from-post-data "Message" postlines)))
    (output-prolog s 200)
    (output-header s "ACL Reduction")
    (force-output s)
    (format s "<XMP>~%")
    (print-acl s (reduction message *client* *agent*))
    (format s "</XMP>~%")
    (output-footer s)))

(defun showexpansion-acl (s postlines)
  (let ((message (read-from-post-data "Message" postlines)))
    (output-prolog s 200)
    (output-header s "ACL Expansion")
    (force-output s)
    (format s "<XMP>~%")
    (print-acl s (expansion message *client* *agent*))
    (format s "</XMP>~%")
    (output-footer s)))

(defun showoptimization-acl (s postlines)
  (let ((message (read-from-post-data "Message" postlines)))
    (output-prolog s 200)
    (output-header s "ACL Optimization")
    (force-output s)
    (format s "<XMP>~%")
    (print-acl s (optimization message *client* *agent*))
    (format s "</XMP>~%")
    (output-footer s)))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Reduction
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Reduction
;;;  This step takes a global behavioral description as input and
;;;  outputs a description of a behavior that implements the input behavior
;;;  with the added feature that all steps have executors (not specified).
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun aclreduction (x)
  (cond ((atom x) (reduction-atom x))
        ((eq 'tell (car x)) (reduction-tell x))
        ((eq 'untell (car x)) (reduction-untell x))
        ((eq 'eliminate (car x)) (reduction-eliminate x))
        ((eq 'ask-if (car x)) (reduction-ask-if x))
        ((eq 'ask-one (car x)) (reduction-ask-one x))
        ((eq 'ask-all (car x)) (reduction-ask-all x))
        ((eq 'ask-table (car x)) (reduction-ask-table x))
        ((eq 'ask-about (car x)) `(askfacts ',x))
        ((eq 'quote (car x)) x)
        ((macro-function (car x)) (aclreduction (macroexpand x)))
        ((fboundp (car x)) (reduction-call x))
        ((findp `(responds ?a ,(car x)) *manager*) (reduction-message x))
        ((findp `(performs ?a ,(car x)) *manager*) (reduction-request x))))

(defun reduction-atom (x)
  (cond ((numberp x) x)
        ((characterp x) x)
        ((stringp x) x)
        ((symbolp x) (if (boundp x) x (delegation x)))))

(defun reduction-tell (x)
  `(catch 'assume (assumeall ',(cadr x) ',(name *receiver*))))

(defun reduction-untell (x)
  `(catch 'forget (forgetall ',(cadr x) ',(name *receiver*))))

;;; here we need to compute consequences, THEN do authorization testing.

(defun reduction-eliminate (x)
 `(discard ',(cadr x) ,(name *receiver*)))

(defun reduction-ask-if (x)
  (reduction-ask-one `(ask-one t ,(cadr x))))

(defun reduction-ask-one (msg)
  (let ((ans))
    (setq ans (unwind (cadr msg) (caddr msg) *library* #'specialp #'identity))
    (makaskone (cadr msg) ans)))

(defun reduction-ask-all (msg)
  (let ((ans))
    (setq ans (unwind (cadr msg) (caddr msg) *library* #'specialp #'identity))
    (setq ans (decolonize ans))
    (makaskall (cadr msg) ans)))

(defun makaskone (x p)
  (cond ((null p) nil)
        (t (decolonize `(ask-one ,x ,p)))))

(defun makaskall (x p)
  (cond ((null p) nil)
        (t (decolonize `(ask-all ,x ,p)))))

(defun reduction-ask-table (x)
  (do ((l (caddr x) (cdr l)) (nl))
      ((null l) `(invert-table ,(cons 'list (nreverse nl))))
      (setq nl (cons (reduction-ask-column (car l) (cadr x)) nl))))

(defun reduction-ask-column (slot items)
  `(extract-values ',items
     ,(reduction-ask-all `(ask-all (?x ?y)
                                   (and (oneof ?x . ,items) (,slot ?x ?y))))))

(defun reduction-call (x)
  (cons (car x) (mapcar #'reduction (cdr x))))

(defun reduction-message (x)
  (distribution (cons (car x) (mapcar #'reduction (cdr x)))))

(defun reduction-request (x)
  (delegation (cons (car x) (mapcar #'reduction (cdr x)))))

(defun distribution (x)
  (do ((l (finds '?a `(responds ?a ,(operator x)) *manager*) (cdr l)) (nl))
      ((null l) (maksprogn (nreverse nl)))
      (cond ((and (eq (car l) *sender*) (equal x *message*)))
            (t (setq nl (cons `(message ',x *receiver* ',(car l)) nl))))))

(defun delegation (x)
  (do ((l (finds '?a `(performs ?a ,(operator x)) *manager*) (cdr l)))
      ((null l) nil)
      (cond ((and (eq (car l) *sender*) (equal x *message*)))
            (t (return `(request ',x *receiver* ',(car l)))))))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Expansion
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun aclexpand (c)
  (cond ((atom c) (aclexpand-atom c))
        ((eq 'tell (car c)) (aclexpand-tell c))
        ((eq 'untell (car c)) (aclexpand-untell c))
        ((eq 'eliminate (car c)) (aclexpand-eliminate c))
        ((eq 'ask-if (car c)) (aclexpand-ask-if c))
        ((eq 'ask-one (car c)) (aclexpand-ask-one c))
        ((eq 'ask-all (car c)) (aclexpand-ask-all c))
        ((eq 'ask-table (car c)) (aclexpand-ask-table c))
        ((eq 'ask-about (car c)) `(aclabout ',c))
        ((eq 'quote (car c)) c)
        ((macro-function (car c)) (aclexpand (macroexpand c)))
        ((fboundp (car c)) (aclexpand-call c))
        ((findp `(responds ?a ,(car c)) *manager*) (aclexpand-message c))
        ((findp `(performs ?a ,(car c)) *manager*) (aclexpand-request c))))

(defun aclexpand-atom (x)
  (cond ((numberp x) x)
        ((characterp x) x)
        ((stringp x) x)
        ((symbolp x) (if (boundp x) x (aclexpand-request x)))))

(defun aclexpand-tell (x)
  `(catch 'assume (assumeall ',(cadr x) ',(name *receiver*))))

(defun aclexpand-untell (x)
  `(catch 'forget (forgetall ',(cadr x) ',(name *receiver*))))

;;; here we need to compute consequences, THEN do autorization testing.

(defun aclexpand-eliminate (x)
  `(discard ',(cadr x) ,(name *receiver*)))

(defun aclexpand-ask-if (x)
  (aclexpand-ask-one `(ask-one t ,(cadr x))))

(defun aclexpand-ask-one (x)
  (makaskone (cadr x) (plan-ask-all (cadr x) (caddr x))))

(defun aclexpand-ask-all (x)
  (makaskall (cadr x) (plan-ask-all (cadr x) (caddr x))))

(defun aclexpand-ask-table (x)
  (do ((l (caddr x) (cdr l)) (nl))
      ((null l) `(invert-table ,(cons 'list (nreverse nl))))
      (setq nl (cons (aclexpand-ask-column (car l) (cadr x)) nl))))

(defun aclexpand-ask-column (slot items)
  `(extract-values ',items
                   ,(makaskemall '(?x ?y)
                      (plan-ask-all '(?x ?y)
                                    `(and (oneof ?x . ,items) (,slot ?x ?y))))))

(defun aclexpand-call (x)
  (cons (car x) (mapcar #'(lambda (x) (aclexpand x)) (cdr x))))

(defun aclexpand-message (x)
  (acldistribution (cons (car x) (mapcar #'(lambda (x) (aclexpand x)) (cdr x)))))

(defun aclexpand-request (x)
  (acldelegation (cons (car x) (mapcar #'(lambda (x) (aclexpand x)) (cdr x)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Authorization
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defparameter *authorization* t)

(defclass authorizer (agent) ())

(defmethod message-handler (*message* *sender* (*receiver* authorizer))
  (let ((*target*))
    (when (and *authorization* (setq *target* (find-target (name *receiver*))))
      (request (authorization *message* *sender*) *receiver* *target*))))

(defun find-target (x)
  (findx '?x `(recipient ,(name x) ?x) *manager*))

(defun find-targets (x)
  (finds '?x `(recipient ,x ?x) *manager*))

(defun authorization (msg sender)
  (cond ((atom msg) msg)
        ((eq 'tell (car msg)) `(tell ,(authorized-update (cadr msg) sender)))
        ((eq 'untell (car msg)) `(untell ,(authorized-update (cadr msg) sender)))
        ((eq 'eliminate (car msg)) nil) ;(eliminations (cadr msg) sender))
        ((eq 'ask-if (car msg)) `(ask-if ,(authorized-query (cadr msg) sender)))
        ((eq 'ask-one (car msg))
         `(ask-one ,(cadr msg) ,(authorized-query (caddr msg) sender)))
        ((eq 'ask-all (car msg))
         `(ask-all ,(cadr msg) ,(authorized-query (caddr msg) sender)))
        ((eq 'ask-table (car msg))
         (do ((l (caddr msg) (cdr l)) (nl))
             ((null l) (list 'quote (invert-table (nreverse nl))))
             (setq nl (cons (newaskvalue (car l) (cadr msg)) nl))))
        ((eq 'ask-about (car msg)) nil) ; `(screens (ask-about ,(cadr msg)) ',sender))
        ((eq 'quote (car msg)) (cadr msg))
        ((macro-function (car msg)) (authorization (macroexpand msg) sender))
        (t (authorization-call msg sender))))

(defun authorization-call (msg sender)
  (cons (car msg) (mapcar #'(lambda (x) (authorization x sender)) (cdr msg))))


(defun authorized-query (p sender)
  (let (vr)
    (cond ((atom p) p)
          ((eq 'and (car p)) (authorized-query-and p sender))
          ((eq 'or (car p)) (authorized-query-or p sender))
          ((setq vr (find-viewrelation (operator p)))
           (list* vr sender (cdr p)))
          (t p))))

(defun authorized-query-and (p sender)
  (do ((l (cdr p) (cdr l)) (nl))
      ((null l) (maksand (nreverse nl)))
      (setq nl (cons (authorized-query (car l) sender) nl))))

(defun authorized-query-or (p sender)
  (do ((l (cdr p) (cdr l)) (nl))
      ((null l) (maksor (nreverse nl)))
      (setq nl (cons (authorized-query (car l) sender) nl))))

(defun find-viewrelation (r)
  (findx '?x `(viewrelation ,r ?x) *manager*))


(defun authorized-update (p sender)
  (let (ur)
    (cond ((atom p) p)
          ((eq 'and (car p)) (authorized-update-and p sender))
          ((eq 'or (car p)) (authorized-update-or p sender))
          ((setq ur (find-updaterelation (operator p)))
           (list* ur sender (cdr p)))
          (t p))))

(defun authorized-update-and (p sender)
  (do ((l (cdr p) (cdr l)) (nl))
      ((null l) (maksand (nreverse nl)))
      (setq nl (cons (authorized-update (car l) sender) nl))))

(defun authorized-update-or (p sender)
  (do ((l (cdr p) (cdr l)) (nl))
      ((null l) (maksor (nreverse nl)))
      (setq nl (cons (authorized-update (car l) sender) nl))))

(defun find-updaterelation (r)
  (findx '?x `(updaterelation ,r ?x) *manager*))


(defun screens (nl sender)
  (setq nl (authorized-view (cons 'and nl) sender))
  (cond ((eq 'true nl) nil)
        ((and (listp nl) (eq 'and (car nl))) (cdr nl))
        (t (list nl))))

(defun eliminations (x sender)
  (maksprogn
   (mapcar #'(lambda (p) `(untell ,p))
           (screens (request `(ask-about ,x) *receiver* *target*) sender))))

(defun authorized-view (p sender)
  (cond ((atom p) p)
        ((eq 'and (car p)) (authorized-view-and p sender))
        ((eq 'or (car p)) (authorized-view-or p sender))
        ((findp `(view-restriction ,(operator p)) *manager*)
         (cond ((or (findp `(viewable ,sender ,(operator p)) *manager*)
                    (can-see-p p sender))
                p)
               (t 'true)))
        (t p)))

(defun can-see-p (p sender)
  (impliesp p `(can-see ,sender ,p) *manager*))

(defun impliesp (p q th)
  (decludes 'infotheory)
  (empty 'infotheory)
  (includes 'infotheory th)
  (save p 'infotheory)
  (findp (skolemize q) 'infotheory))

(defun authorized-view-and (p sender)
  (do ((l (cdr p) (cdr l)) (new 'true))
      ((null l) new)
      (setq new (makand new (authorized-view (car l) sender)))))

(defun authorized-view-or (p sender)
  (do ((l (cdr p) (cdr l)) (new 'false))
      ((null l) new)
      (setq new (makor new (authorized-view (car l) sender)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
#|
(defun source-and (p)
  (do ((l (mapcar #'sources (cdr p))) (sources) (dum) (nl))
      ((null l)
       (cond ((null (cdr nl)) (car nl))
             (t (mapc #'remedy nl) (cons 'and (nreverse nl)))))
      (cond ((not (eq 'ask (caar l))) (setq nl (cons (car l) nl) l (cdr l)))
            (t (setq sources (cadar l))
               (do ((m (cdr l) (cdr m)) (nc (list (caddar l))) (nm))
                   ((null m)
                    (setq nl (cons `(ask ,sources ,(maksand (nreverse nc))) nl))
                    (setq l nm))
                 (cond ((and (eq 'ask (caar m))
                             (setq dum (intersect sources (cadar m))))
                        (setq sources dum nc (cons (caddar m) nc)))
                       (t (setq nm (cons (car m) nm)))))))))

(defun source-or (p)
  (do ((l (mapcar #'sources (cdr p))) (sources) (dum) (nl))
      ((null l)
       (cond ((null (cdr nl)) (car nl))
             (t (mapc #'remedy nl) (cons 'or (nreverse nl)))))
      (cond ((not (eq 'ask (caar l))) (setq nl (cons (car l) nl) l (cdr l)))
            (t (setq sources (cadar l))
               (do ((m (cdr l) (cdr m)) (nc (list (caddar l))) (nm))
                   ((null m)
                    (setq nl (cons `(ask ,sources ,(maksor (nreverse nc))) nl))
                    (setq l nm))
                 (cond ((and (eq 'ask (caar m))
                             (setq dum (intersect sources (cadar m))))
                        (setq sources dum nc (cons (caddar m) nc)))
                       (t (setq nm (cons (car m) nm)))))))))


(defmethod loadfile (fn (target facilitator) lang meta)
  (let (data warehouse)
    (setq data (read-file-contents fn lang))
    (setq target (name target))
    (setq warehouse (find-recipient target))
    (dolist (sent data) (insert sent (referent warehouse)))
    (when (eq meta 'yes)
      (dolist (sent (guessmetafacts data warehouse target))
        (telladministrator sent)))
    'done))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; code to compute a relation from a source (not yet released)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun codecompute (rel source)
  `(defmethod compute ((rel (eql ',rel)) (source (eql ,source)))
     ,(code (plancompute rel source) source)))

(defun plancompute (rel source)
  (let (arity vars)
    (when (setq arity (find-arity rel))
      (do ((i 1 (1+ i)) (vl))
          ((> i arity) (setq vars (nreverse vl)))
          (setq vl (cons (decolonize (newindvar)) vl)))
      (plan `(ask-all ,vars ,(cons rel vars)) *client* source))))

(defun pattern (rel)
  (let (arity)
    (when (setq arity (find-arity rel))
      (do ((i 1 (1+ i)) (vl))
          ((> i arity) (cons rel (nreverse vl)))
          (setq vl (cons (decolonize (newindvar)) vl))))))

(defmethod code (c agent)
  (declare (ignore agent))
  c)

(defmethod code (c (agent symbol))
  (cond ((boundp agent) (code c (symbol-value agent)))
        (t (call-next-method c agent))))

(defmethod code (c (agent facilitator))
  (cond ((atom c) c)
        ((eq 'quote (car c)) c)
        ((eq 'ask (car c)) (code (caddr c) (cadr c)))
        (t (mapcar #'code c))))

(defmethod code (c (agent dataserver))
  (cond ((atom c) c)
        ((eq 'quote (car c)) c)
        ((eq 'ask-all (car c))
         `(funcall ,(planall (cadr c) (caddr c)) ,(name agent)))
        (t (mapcar #'code c))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; computing classes and options for the interface
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun computeclasses (interface)
  (let (classes)
    (if (stringp interface) (setq interface (read-value-string interface)))
    (setq classes (request `(ask-all ?y (isa ?x ?y)) *client* *agent*))
    (setq classes (sort classes #'lessp))
    (drop `(rootclass ,interface ?x) *manager* #'matchp)
    (dolist (class classes) (insert `(rootclass ,interface ,class) *manager*))
    'done))

(defun computeoptions (slot interface)
  (let (options)
    (if (stringp slot) (setq slot (read-value-string slot)))
    (if (stringp interface) (setq interface (read-value-string interface)))
    (setq options (request `(ask-all ?y (,slot ?x ?y)) *client* *agent*))
    (drop `(option ,slot ?x) *manager* #'matchp)
    (dolist (option (sort options #'lessp))
      (insert `(option ,slot ,option) *manager*))
    'done))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defmethod plan (*message* *sender* (*receiver* facilitator))
  (let ((*agents* (find-agents)))
    (setq *plan* (route (aclreduce *message*)))))

(defun aclreduce (c)
  (cond ((atom c) (aclreduce-atom c))
        ((eq 'update (car c)) (reduceupdate c))
        ((eq 'tell (car c)) (reducetell (cadr c)))
        ((eq 'untell (car c)) (reduceuntell (cadr c)))
        ((eq 'eliminate (car c)) `(acleliminate ',c))
        ((eq 'ask-if (car c)) (aclreduce-ask-if c))
        ((eq 'ask-one (car c)) (aclreduce-ask-one c))
        ((eq 'ask-all (car c)) (aclreduce-ask-all c))
        ((eq 'ask-answers (car c)) (plananswers (cdr c))) ;;;`(findanswers ',(cdr c)))
        ((eq 'ask-table (car c)) (aclreduce-ask-table c))
        ((eq 'ask-about (car c)) `(aclabout ',c))
        ((eq 'ask-consistent (car c)) (reduceaskconsistent c))
        ((eq 'ask-rules (car c)) `(ask (,(name *library*)) (ask-about ,(cadr c))))
        ((eq 'quote (car c)) c)
        ((macro-function (car c)) (aclreduce (macroexpand c)))
        ((fboundp (car c)) (aclreduce-call c))
        ((findp `(responds ?a ,(car c)) *manager*) (aclreduce-message c))
        ((findp `(performs ?a ,(car c)) *manager*) (aclreduce-request c))))

(defun aclreduce-atom (x)
  (cond ((numberp x) x)
        ((characterp x) x)
        ((stringp x) x)
        ((symbolp x) `',x))) ; (if (boundp x) x (aclreduce-request x)))))

(defun reduceupdate (msg)
  (let ((*intensions* t))
    (decludes 'infotheory)
    (empty 'infotheory)
    (includes 'infotheory *library*)
    (do ((l (cdr msg) (cdr l)) (nl))
        ((null l) (when nl (cons 'update (nreverse nl))))
        (cond ((atom (car l)) (setq nl (nreconc (redupdate (car l)) nl)))
              ((eq '==> (caar l))
               (do ((m (residues (vars (caddar l)) (cadar l) 'infotheory #'specialp) (cdr m)))
                   ((null m))
                   (setq nl (cons `(==> ,(car m) ,(caddar l)) nl))))
              (t (setq nl (nreconc (redupdate (car l)) nl)))))))

(defun redupdate (p)
  (do ((l (newconsequences p 'infotheory #'specialp #'interestp) (cdr l)) (nl))
      ((null l) (nreverse nl))
      (cond ((and (listp (car l)) (eq 'execute (caar l)))
             (setq nl (cons (cadar l) nl)))
            ((and (listp (car l)) (eq 'evaluate (caar l)))
             (setq nl (cons `(apply ',(caadar l) ',(cdadar l)) nl)))
            ((and (listp (car l)) (eq '=> (caar l)))
             (setq nl (cons (decolonize `(==> ,(cadar l) ,(caddar l))) nl)))
            (t (setq nl (cons (decolonize (car l)) nl))))))

(defun reducetell (p)
  (cond ((atom p) (newreducetell p))
        ((find (car p) '(<= =>)) `(tellem '(tell ,(list (name *library*)) ,p)))
        ((and (eq 'and (car p)) (cddr p) (listp (cadr p))
              (every #'(lambda (x) (and (listp x) (eq (car x) (caadr p)))) (cdr p)))
         (newreducetelltable (cdr p) *receiver*))
        (t (newreducetell p))))

(defun reduceuntell (p)
  (cond ((atom p) (newreducetell `(not ,p)))
        ((find (car p) '(<= =>)) `(tellem '(untell ,(list (name *library*)) ,p)))
        (t (newreducetell `(not ,p)))))

(defun newreducetell (p)
  (let ((*target* '?) (*ancestry* 1))
    (decludes 'infotheory)
    (empty 'infotheory)
    (includes 'infotheory *library*)
    (do ((l (newconsequences p 'infotheory #'specialtyp #'interestp) (cdr l)) (nl))
        ((null l) `(newtellemall . ,(mapcar #'quotify (nreverse nl))))
        (cond ((and (listp (car l)) (eq 'execute (caar l)))
               (setq nl (cons (cadar l) nl)))
              ((and (listp (car l)) (eq 'evaluate (caar l)))
               (setq nl (cons `(apply ',(caadar l) ',(cdadar l)) nl)))
              ((and (listp (car l)) (eq '=> (caar l)))
               (setq nl (nconc (newtarget2 (decolonize (cadar l)) (decolonize (caddar l))) nl)))
              (t (setq nl (nconc (newtarget1 (decolonize (car l))) nl)))))))

(defun newreducetelltable (sentences receiver)
  (let (pattern rulebase (*target* '?) (*ancestry* 1))
    (setq pattern (patternize (car sentences)))
    (setq rulebase (find-rulebase receiver))
    (decludes 'infotheory)
    (empty 'infotheory)
    (if (and rulebase (symbolp rulebase) (boundp rulebase))
        (includes 'infotheory (eval rulebase)))
    (do ((l (newconsequences pattern 'infotheory #'specialtyp #'interestedp) (cdr l)) (nl))
        ((null l) `(newtellemall . ,(mapcar #'quotify (nreverse nl))))
        (cond ((equal pattern (car l))
               (setq nl (cons `(==> (ask library (oneof ,pattern . ,sentences)) ,(maksand (newtarget1 pattern))) nl)))
              ((and (listp (car l)) (eq 'execute (caar l)))  ;;; wrong order???
               (setq nl (cons `(==> (oneof ,pattern . ,sentences) ,(cadar l)) nl)))
              ((and (listp (car l)) (eq 'evaluate (caar l)))
               (setq nl (cons `(==> (oneof ,pattern . ,sentences) (apply ',(caadar l) ',(cdadar l))) nl)))
              ((and (listp (car l)) (eq '=> (caar l)))
               (setq nl (nconc (newtarget2 (decolonize `(and (oneof ,pattern . ,sentences) ,(cadar l)))
                                           (decolonize (caddar l))) nl)))
              (t (setq nl (cons `(==> (oneof ,pattern . ,sentences)
                                      ,(maksand (newtarget1 (decolonize (car l))))) nl)))))))

(defun newtarget1 (p)
  (do ((l (find-interestees (operator p)) (cdr l)) (nl))
      ((null l) nl)
      (setq nl (cons `(tell ,(car l) ,p) nl))))

(defun newtarget2 (p q)
  (list `(==> ,(remedy (sources p)) ,(targets q))))

(defun aclreduce-tell (x)
  `(catch 'assume (assumeall ',(cadr x) ',(name *receiver*))))

(defun aclreduce-untell (x)
  `(catch 'forget (forgetall ',(cadr x) ',(name *receiver*))))

;;; here we need to compute consequences, THEN do authorization testing.

(defun acleliminate (msg)
  (do ((l (find-agents) (cdr l)))
      ((null l) 'done)
      (cond ((eq (car l) *receiver*))
            ((and (eq (car l) *sender*) (equal msg *message*)))
            (t (request msg *receiver* (car l))))))

(defun plananswers (rules)
  (let ((*ancestry* t))
    (decludes 'infotheory)
    (empty 'infotheory)
    (includes 'infotheory *library*)
    (dolist (x rules) (save x 'infotheory))
    `(findanswers ',(reductions 'answer 'infotheory #'specialp #'identity) integrator)))

(defun aclreduce-ask-if (x)
  (aclreduce-ask-one `(ask-one t ,(cadr x))))

(defun aclreduce-ask-one (x)
  (makaskemone (cadr x) (plan-ask-all (cadr x) (caddr x))))

(defun aclreduce-ask-all (x)
  (makaskemall (cadr x) (plan-ask-all (cadr x) (caddr x))))

(defun aclreduce-ask-table (x)
  (do ((l (caddr x) (cdr l)) (nl))
      ((null l) `(invert-table ,(cons 'list (nreverse nl))))
      (setq nl (cons (aclreduce-ask-column (car l) (cadr x)) nl))))

(defun aclreduce-ask-column (slot items)
  `(extract-values ',items
                   ,(makaskemall '(?x ?y)
                      (plan-ask-all '(?x ?y)
                                    `(and (oneof ?x . ,items) (,slot ?x ?y))))))

(defun oldreduce-ask-table (x)
  (let* ((items (cadr x))
         (slots (caddr x))
         (plans (mapcar
                 #'(lambda (s) (plan-ask-all '(t ?x ?y) `(,s ?x ?y)))
                 slots)))
    (do ((l items (cdr l)) (nl))
        ((null l) (cons 'list (nreverse nl)))
        (do ((p plans (cdr p)) (dum) (vl))
            ((null p) (setq nl (cons (cons 'list (nreverse vl)) nl)))
            (setq dum (subst '?y '(t ?x ?y) (car p) :test #'equal))
            (setq vl (cons (makaskemall '?y (subst (car l) '?x dum)) vl))))))

(defun reduceaskconsistent (msg)
  (let (errors)
    (decludes 'infotheory)
    (empty 'infotheory)
    (includes 'infotheory *library*)
    (dolist (p (cdr msg)) (newsave p 'infotheory))
    (if (setq errors (finds '?x '(error ?x) 'infotheory)) `',errors 't)))

(defun aclreduce-call (x)
  (cons (car x) (mapcar #'(lambda (x) (aclreduce x)) (cdr x))))

(defun aclreduce-message (x)
  (acldistribution (cons (car x) (mapcar #'(lambda (x) (aclreduce x)) (cdr x)))))

(defun aclreduce-request (x)
  (acldelegation (cons (car x) (mapcar #'(lambda (x) (aclreduce x)) (cdr x)))))

(defun acldistribution (x)
  (do ((l (finds '?a `(responds ?a ,(operator x)) *manager*) (cdr l)) (nl))
      ((null l) (maksprogn (nreverse nl)))
      (cond ((and (eq (car l) *sender*) (equal x *message*)))
            (t (setq nl (cons `(message ',x *receiver* ',(car l)) nl))))))

(defun acldelegation (x)
  (do ((l (finds '?a `(performs ?a ,(operator x)) *manager*) (cdr l)))
      ((null l) nil)
      (cond ((and (eq (car l) *sender*) (equal x *message*)))
            (t (return `(request ',x *receiver* ',(car l)))))))

(defun plan-ask-all (x p)
  (unless (eq (setq p (askreduce x p)) 'false)
    (if *collapse* (setq p (collapse x p)))
    ;(if *collapse* (setq p (raisin x p)))
    (setq p (order x p))
    (setq p (source p))
    (if *compress* (setq p (compress p)))
    p))

(defun askreduce (x p)
  (let ((*ancestry* 1))
    (decludes 'infotheory)
    (empty 'infotheory)
    (includes 'infotheory *library*)
    (mapc #'(lambda (x) (save x 'infotheory))
          (contrapositives `(<= (answer ,x) ,p)))
    (decolonize (maksor (residues x `(answer ,x) 'infotheory #'specialp #'identity)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; execute
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defparameter answer nil)

(defmethod findanswers (rules (th facilitator))
  (let (relations)
    (setq relations (linearize rules))
    (progv relations nil
      (do ((l (linearize rules) (cdr l)) (rule))
          ((null l) answer)
          (cond ((recursivep (car l) rules)
                 (setq rule (finddefinition (car l) rules))
                 (do ((old 0) (new 0))
                     (nil)
                     (set (car l) (findalall (cdadr rule) (caddr rule)))
                     (setq new (length (symbol-value (car l))))
                     (if (< old new) (setq old new) (return t))))
                (t (setq rule (finddefinition (car l) rules))
                   (set (car l) (findalall (cdadr rule) (caddr rule)))))))))

(defun findalall (x p)
  (findal x p '(t) '((t))))

(defun findal (x p vl sl)
  (let (agent)
    (cond ((null p) nil)
          ((atom p) (findalproject x vl sl))
          ((eq 'ask (car p)) (findalask x p vl sl))
          ((eq 'and (car p)) (findaland x p vl sl))
          ((eq 'or (car p)) (findalor x p vl sl))
          ((eq 'unprovable (car p)) (findalunprovable x p vl sl))
          ((eq 'bagofall (car p)) (findalbagofall x p vl sl))
          ((setq agent (find-specialist (operator p)))
           (findalask x `(ask ,agent ,p) vl sl))
          ((boundp (operator p)) (findalrelation x p vl sl)))))

(defun findalask (x p vl sl)
  (let* ((db (cadr p)) (query (caddr p)))
    (cond ((or (null vl) (equal vl '(t)))
           (request `(ask-all ,x ,query) *receiver* db))
          (t (setq query (makand `(oneof ,vl . ,sl) query))
             (request `(ask-all ,x ,query) *receiver* db)))))

(defun findalrelation (x p vl sl)
  (cond ((or (null vl) (equal vl '(t)))
         (finds x `(oneof ,x . ,(symbol-value (operator p))) *receiver*))
        (t (setq p (makand `(oneof ,vl . ,sl) `(oneof ,(cdr p) . ,(symbol-value (car p)))))
           (finds x p *receiver*))))

(defun findaland (x p vl sl)
  (cond ((null (cdr p)) sl)
        ((null (cddr p)) (findal x (cadr p) vl sl))
        (t (do ((l (cdr p) (cdr l)) (vs (findalvars x p vl) (cdr vs)))
               ((null l) (if (equal x vl) sl (findalproject x vl sl)))
               (if (setq sl (findal (car vs) (car l) vl sl))
                 (setq vl (car vs))
                 (return nil))))))

(defun findalor (x p vl sl)
  (do ((l (cdr p) (cdr l)) (nl))
      ((null l) (uniquify (nreverse nl)))
      (setq nl (nreconc (findal x (car l) vl sl) nl))))

(defun findalunprovable (x p vl sl)
  (setq sl (set-difference sl (findal vl (cadr p) vl sl) :test #'equalp))
  (if (equal x vl) sl (findalproject x vl sl)))

(defun findalbagofall (x p vl sl)
  (let (ivl answers)
    (setq ivl (unionize vl (vars (cadr p))))
    (setq answers (findal ivl (caddr p) vl sl))
    (do ((l sl (cdr l)) (m answers) (nl))
        ((null l) (findalproject x (append vl (list (cadddr p))) (nreverse nl)))
        (do ((il)) (nil)
            (cond ((or (null m) (not (startp (car l) (car m))))
                   (setq nl (cons (append (car l) (list (cons 'listof (nreverse il)))) nl))
                   (return t))
                  (t (setq il (cons (findalproj (cadr p) ivl (car m)) il))
                     (setq m (cdr m))))))))

(defun findalproj (x vl s)
  (findx x `(same ,vl ,s) *manager*))

(defun findalproject (x vl sl)
  (finds x `(oneof ,vl . ,sl) *manager*))

(defun findalvars (x p vl)
  (cdr (findalvarscdr vl (cdr p) (vars x))))

(defun findalvarscdr (vl pl xl)
  (cond ((null pl) (list xl))
        (t (let (nl)
             (setq nl (findalvarscdr (goodvarsform (car pl) vl) (cdr pl) xl))
             (cons (intersect vl (unionize (vars (car pl)) (car nl))) nl)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defmethod change (p (th facilitator))
  (let (updates errors)
    (setq updates (changes p th))
    (dolist (item updates)
      (when (and (listp item) (eq (car item) 'error))
        (setq errors (cons (cadr item) errors))))
    (cond (errors (nreverse errors))
          ((errorp (setq errors (eval (divvy (cons 'update updates)))))
           errors)
          (t #|(react th)|# errors))))

(defmethod react ((target symbol))
  (cond ((and (boundp target) (not (symbolp (symbol-value target))))
         (react (symbol-value target)))
        (t (call-next-method target))))

(defmethod react (th)
  (request (find-doable th) nil th))

(defun find-doable (th)
  (request '(ask-one ?a (doable ?a)) nil th))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Simple and sometimes incorrect version:
;;; Input:  (ask art (f (ask bob (g 1)) (ask coe (h 2))))
;;; Output: (request `(f ',(request '(g 1) *receiver* 'bob)
;;;                      ',(request '(h 2) *receiver* 'coe))
;;;                  *receiver* 'art))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

#|
(defun unravel (c)
  (cond ((atom c) c)
        ((eq 'quote (car c)) c)
        ((eq 'ask (car c))
         (if (eq (cadr c) *library*) (unravel (caddr c))
             `(request ',(unravel (caddr c)) *receiver* ',(cadr c))))
        (t (cons (car c) (mapcar #'unravel (cdr c))))))
|#

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Correct but more complicated version:
;;; Input:  (ask art (f (ask bob (g 1)) (ask coe (h 2))))
;;; Output: (let ((t1 (request '(g 1) *receiver* 'bob))
;;;               (t2 (request '(h 2) *receiver* 'coe)))
;;;           (request (list 'f t1 t2) *receiver* 'art))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defvar temporaries nil)

(defvar steps nil)

(defun unravel (c)
  (let ((temporaries) (steps))
    (setq steps (cons (unravelexp c) steps))
    (maklet (nreverse temporaries) (nreverse steps))))

(defun unravelexp (c)
  (cond ((atom c) (quotify c))
        ((eq 'quote (car c)) (list 'quote c))
        ((eq 'ask (car c))
         (let ((dum (unravelexp (caddr c))))
           (setq temporaries (cons (gentemp) temporaries))
           (setq steps (cons `(setq ,(car temporaries)
                                    (request ,dum
                                             *receiver*
                                             ',(cadr c))) steps))
           (car temporaries)))
        (t `(list ',(car c) . ,(mapcar #'unravelexp (cdr c))))))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Execution stuff
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun aclabout (msg)
  (do ((l (find-agents) (cdr l)) (nl))
      ((null l) nl)
      (cond ((and (eq (car l) *sender*) (equal msg *message*)))
            ((eq (car l) *receiver*))
            (t (setq nl (unionize nl (request msg *receiver* (car l))))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; translated flat all-at-once execution using oneof but all alists
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun grabemone (x p)
  (setq p (order x p))
  (setq p (adjust x p))
  (ignore-errors (funcall (compiler (prgmone x p)) *library*)))

(defun grabemall (x p)
  (setq p (order x p))
  (setq p (adjust x p))
  (ignore-errors (funcall (compiler (prgmall x p)) *library*)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; prgmone
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun prgmone (x p)
  `(lambda (*theory*) ,(prgmoneexp x p)))

(defun prgmoneexp (x p)
  (cond ((atom p) (prgmoneatom x p))
        ((eq 'ask (car p)) (prgmoneask x p))
        ((eq 'not (car p)) `(car ,(prgmallnot x p)))
        ((eq 'and (car p)) (prgmoneand x p))
        ((eq 'or (car p)) (prgmoneor x p))
        ((eq 'oneof (car p)) (prgmonesame x p))
        ((eq 'same (car p)) (prgmonedistinct x p))
        ((eq 'distinct (car p)) (prgmonedistinct x p))
        ((eq 'ground (car p)) (prgmoneground x p))
        ((eq 'nonground (car p)) (prgmonenonground x p))
        ((eq 'primitive (car p)) (prgmoneprimitive x p))
        ((eq 'nonprimitive (car p)) (prgmonenonprimitive x p))
        ((eq '== (car p)) (prgmonevalue x p))
        ((eq 'value (car p)) (prgmonevalue x p))
        ((eq 'execute (car p)) (prgmoneexecute x p))
        ((eq 'unprovable (car p)) (prgmoneunprovable x p))
        ((get (car p) 'basic) (prgmonebasic x p))
        ((get (car p) 'basicval) (prgmonebasicval x p))
        (t (prgmoneth x p))))

(defun prgmoneatom (x p)
  (cond ((eq 'true p) (makresult x nil))
        ((eq 'cut p) (makresult x nil))
        ((eq 'false p) nil)
        (t `(if (find ',p (indexees ',p *theory*)) ,(makresult x nil)))))

(defun prgmoneask (x p)
  `(asksole ,(quotify x) ,(quotify (caddr p)) ',(name *receiver*) ',(cadr p)))

(defun prgmoneand (x p)
  (cond ((null (cdr p)) (makresult x nil))
        ((null (cddr p)) (prgmoneexp x (cadr p)))
        (t (do ((l (cdr p) (cdr l)) (xl) (vl) (nl))
               ((null (cdr l))
                (setq nl (cons `(car ,(prgmandexp (car l) xl x)) nl))
                `(let (tuples) . ,(nreverse nl)))
               (setq vl (unionize xl (goodvars (car l))))
               (setq nl (cons `(setq tuples ,(prgmandexp (car l) xl vl)) nl))
               (setq xl vl)))))

(defun prgmoneor (x p)
  (cond ((null (cdr p)) nil)
        ((null (cddr p)) (prgmoneexp x (cadr p)))
        (t (do ((l (cdr p) (cdr l)) (nl))
               ((null l) (cons 'or (nreverse nl)))
               (setq nl (cons (prgmoneexp x (car l)) nl))))))

(defun prgmonesame (x p)
  (let (al)
    (if (setq al (mgu (cadr p) (caddr p)))
        (quotify (plug x al)))))

(defun prgmonedistinct (x p)
  `(unless (equal ,(makresult (cadr p) nil) ,(makresult (caddr p) nil))
     ,(makresult x nil)))

(defun prgmoneground (x p)
  (if (groundp (cadr p)) (quotify x)))

(defun prgmonenonground (x p)
  (cond ((groundp (cadr p)) nil)
        (t (quotify x))))

(defun prgmoneprimitive (x p)
  (if (primitivep (cadr p)) (quotify x)))

(defun prgmonenonprimitive (x p)
  (cond ((primitivep (cadr p)) nil)
        (t (quotify x))))

(defun prgmonevalue (x p)
  (cond ((atom (cadr p)) (prgmonesame x p))
        (t (prgmonebasicval x (append (cadr p) (cddr p))))))

(defun prgmoneexecute (x p)
  (cond ((null (cddr p))
         `(if (ignore-errors ,(cadr p)) ,(quotify x)))
        ((indvarp (caddr p))
         `(let (dum)
            (if (setq dum (ignore-errors ,(cadr p)))
               ,(makresult x (list (cons (caddr p) 'dum))))))
        (t `(if (equal (ignore-errors ,(cadr p)) ,(caddr p))
                ,(quotify x)))))

(defun prgmoneunprovable (x p)
  `(if (not ,(prgmoneexp t (cadr p))) ,(makresult x nil)))

(defun prgmonebasic (x p)
  `(if (ignore-errors ,(cons (get (car p) 'basic) (cdr p)))
       ,(makresult x nil)))

(defun prgmonebasicval (x p)
  (cond ((indvarp (car (last p)))
         `(let (dum)
            (if (setq dum (ignore-errors ,(cons (car p) (butlast (cdr p)))))
                ,(makresult x (list (cons (car (last p)) 'dum))))))
        (t `(if (equal (ignore-errors ,(cons (car p) (butlast (cdr p))))
                       ,(quotify (car (last p))))
                ,(quotify x)))))

(defun prgmoneth (x p)
  (let* (test index al)
    (setq index (indexable p nil *theory*))
    (do ((l p (cdr l)) (i 0 (1+ i)) (dum))
        ((null l))
        (cond ((eq '?* (car l)))
              ((groundp (car l))
               (setq test (cons `(equal (nth ,i t1) ',(car l)) test)))
              ((setq dum (assoc (car l) al))
               (setq test (cons `(equal (nth ,i t1) ,(cdr dum)) test)))
              (t (setq al (cons (cons (car l) `(nth ,i t1)) al)))))
    `(loop for t1 in (indexees ,index *theory*)
           do (if ,(maksand (nreverse test)) (return ,(makresult x al))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; prgmall
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun prgmall (x p)
  `(lambda (*theory*) ,(prgmallexp x p)))

(defun prgmallexp (x p)
  (cond ((atom p) (prgmallatom x p))
        ((eq 'ask (car p)) (prgmallask x p))
        ((eq 'not (car p)) (prgmallnot x p))
        ((eq 'and (car p)) (prgmalland x p))
        ((eq 'or (car p)) (prgmallor x p))
        ((eq 'oneof (car p)) (prgmalloneof x p))
        ((eq 'same (car p)) (prgmallsame x p))
        ((eq 'distinct (car p)) (prgmalldistinct x p))
        ((eq 'ground (car p)) (prgmallground x p))
        ((eq 'nonground (car p)) (prgmallnonground x p))
        ((eq 'primitive (car p)) (prgmallprimitive x p))
        ((eq 'nonprimitive (car p)) (prgmallnonprimitive x p))
        ((eq '== (car p)) (prgmallvalue x p))
        ((eq 'value (car p)) (prgmallvalue x p))
        ((eq 'execute (car p)) (prgmallexecute x p))
        ((eq 'unprovable (car p)) (prgmallunprovable x p))
        ((get (car p) 'basic) (prgmallbasic x p))
        ((get (car p) 'basicval) (prgmallbasicval x p))
        (t (prgmallth x p))))

(defun prgmallatom (x p)
  (cond ((eq 'true p) `(list ,(quotify x)))
        ((eq 'cut p) `(list ,(quotify x)))
        ((eq 'false p) nil)
        (t `(if (find ',p (indexees ',p *theory*)) (list ,(quotify x))))))

(defun prgmallask (x p)
  `(askall ,(quotify x) ,(quotify (caddr p)) ',(name *receiver*) ',(cadr p)))

(defun prgmalland (x p)
  (cond ((null (cdr p)) `(list ,(quotify x)))
        ((null (cddr p)) (prgmallexp x (cadr p)))
        (t (do ((l (cdr p) (cdr l)) (xl) (vl) (nl))
               ((null (cdr l))
                (setq nl (cons (prgmandexp (car l) xl x) nl))
                `(let (tuples) . ,(nreverse nl)))
               (setq vl (unionize xl (goodvars (car l))))
               (setq nl (cons `(setq tuples ,(prgmandexp (car l) xl vl)) nl))
               (setq xl vl)))))

(defun prgmallor (x p)
  (cond ((null (cdr p)) nil)
        ((null (cddr p)) (prgmallexp x (cadr p)))
        (t (do ((l (cdr p) (cdr l)) (nl))
               ((null l) (cons 'union* (nreverse nl)))
               (setq nl (cons (prgmallexp x (car l)) nl))))))

(defun prgmalloneof (x p)
  (do ((l (cddr p) (cdr l)) (al) (nl))
      ((null l) (quotify (nreverse nl)))
      (if (setq al (mgu (cadr p) (car l)))
          (setq nl (cons (plug x al) nl)))))

(defun prgmallsame (x p)
  (let (al)
    (if (setq al (mgu (cadr p) (caddr p)))
        `(list ,(quotify (plug x al))))))

(defun prgmalldistinct (x p)
  (cond ((mgu (cadr p) (caddr p)) nil)
        (t `(list ,(quotify x)))))

(defun prgmallground (x p)
  (if (groundp (cadr p)) `(list ,(quotify x))))

(defun prgmallnonground (x p)
  (cond ((groundp (cadr p)) nil)
        (t `(list ,(quotify x)))))

(defun prgmallprimitive (x p)
  (if (primitivep (cadr p)) `(list ,(quotify x))))

(defun prgmallnonprimitive (x p)
  (cond ((primitivep (cadr p)) nil)
        (t `(list ,(quotify x)))))

(defun prgmallvalue (x p)
  (cond ((atom (cadr p)) (prgmallsame x p))
        (t (prgmallbasicval x (append (cadr p) (cddr p))))))

(defun prgmallexecute (x p)
  (cond ((null (cddr p))
         `(if (ignore-errors ,(cadr p)) (list ,(quotify x))))
        ((indvarp (caddr p))
         `(let (dum)
            (if (setq dum (ignore-errors ,(cadr p)))
                (list ,(makresult x (list (cons (caddr p) 'dum)))))))
        (t `(if (equal (ignore-errors ,(cadr p)) ,(caddr p))
                (list ,(quotify x))))))

(defun prgmallunprovable (x p)
  `(if (not ,(prgmoneexp t (cadr p))) (list ,(quotify x))))

(defun prgmallbasic (x p)
  `(if (ignore-errors ,(cons (get (car p) 'basic) (cdr p)))
       (list ,(quotify x))))

(defun prgmallbasicval (x p)
  (cond ((indvarp (car (last p)))
         `(let (dum)
            (if (setq dum (ignore-errors ,(cons (car p) (butlast (cdr p)))))
                (list ,(makresult x (list (cons (car (last p)) 'dum)))))))
        (t `(if (equal (ignore-errors ,(cons (car p) (butlast (cdr p))))
                       ,(quotify (car (last p))))
                (list ,(quotify x))))))

(defun prgmallth (x p)
  (let* (test index al)
    (setq index (indexable p nil *theory*))
    (do ((l p (cdr l)) (i 0 (1+ i)) (dum))
        ((null l))
        (cond ((eq '?* (car l)))
              ((groundp (car l))
               (setq test (cons `(equal (nth ,i t1) ',(car l)) test)))
              ((setq dum (assoc (car l) al))
               (setq test (cons `(equal (nth ,i t1) ,(cdr dum)) test)))
              (t (setq al (cons (cons (car l) `(nth ,i t1)) al)))))
    `(loop for t1 in (indexees ,index *theory*)
           with answers
           when ,(maksand (nreverse test))
           do (setq answers (cons ,(makresult x al) answers))
           finally (return (uniquify (nreverse answers))))))


(defun prgmallnot (x p)
  (cond ((atom p) `(findemall ',x '(not ,p)))
        ((eq 'not (car p)) (prgmallexp x (cadr p)))
        ((eq 'and (car p)) (prgmallnotand x p))
        ((eq 'or (car p)) (prgmallnotor x p))
        ((eq 'oneof (car p)) nil)
        ((eq 'same (car p)) nil)
        ((eq 'distinct (car p)) nil)
        ((eq 'ground (car p)) nil)
        ((eq 'nonground (car p)) nil)
        ((eq 'primitive (car p)) nil)
        ((eq 'nonprimitive (car p)) nil)
        ((eq '== (car p)) `(findemall ',x '(not ,p)))
        ((eq 'value (car p)) `(findemall ',x '(not ,p)))
        ((eq 'execute (car p)) `(findemall ',x '(not ,p)))
        ((eq 'unprovable (car p)) (prgmallexp x (cadr p)))
        ((get (car p) 'basic) `(findemall ',x '(not ,p)))
        ((get (car p) 'basicval) `(findemall ',x '(not ,p)))
        (t `(findemall ',x '(not ,p)))))

(defun prgmallnotor (x p)
  (cond ((null (cdr p)) `(list ,(quotify x)))
        ((null (cddr p)) (prgmallnot x (cadr p)))
        (t (prgmalland x (cons 'and (mapcar #'maknot (cdr p)))))))

(defun prgmallnotand (x p)
  (cond ((null (cdr p)) nil)
        ((null (cddr p)) (prgmallnot x (cadr p)))
        (t (do ((l (cdr p) (cdr l)) (nl))
               ((null l) (cons 'union* (nreverse nl)))
               (setq nl (cons (prgmallnot x (car l)) nl))))))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; prgmand
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun prgmandexp (p x y)
  (cond ((groundp x) (prgmallexp y p))
        ((atom p) (prgmandatom p x y))
        ((eq 'ask (car p)) (prgmandask p x y))
        ((eq 'not (car p)) (prgmandnot p x y))
        ((eq 'and (car p)) (prgmandand p x y))
        ((eq 'or (car p)) (prgmandor p x y))
        ((eq 'oneof (car p)) (prgmandcopout p x y))
        ((eq 'same (car p)) (prgmandsame p x y))
        ((eq 'distinct (car p)) (prgmanddistinct p x y))
        ((eq 'ground (car p)) (prgmandground p x y))
        ((eq 'nonground (car p)) (prgmandnonground p x y))
        ((eq 'primitive (car p)) (prgmandprimitive p x y))
        ((eq 'nonprimitive (car p)) (prgmandnonprimitive p x y))
        ((eq '== (car p)) (prgmandcopout p x y))
        ((eq 'value (car p)) (prgmandcopout p x y))
        ((eq 'execute (car p)) (prgmandcopout p x y))
        ((eq 'unprovable (car p))  (prgmandcopout p x y))
        ((get (car p) 'basic) (prgmandbasic p x y))
        ((get (car p) 'basicval) (prgmandcopout p x y))
        (t (prgmandth p x y))))

(defun prgmandatom (p x y)
  (cond ((eq 'true p) (prgmproject x y))
        ((eq 'cut p) (prgmproject x y))
        ((eq 'false p) nil)
        (t `(if (find ',p (indexees ',p *theory*)) ,(prgmproject x y)))))

(defun prgmandask (p x y)
  `(askall ,(quotify y) (list 'and (list* 'oneof ',x tuples) ',(caddr p))
           ',(name *receiver*) ',(cadr p)))

(defun prgmandand (p x y)
  (cond ((null (cdr p)) (prgmproject x y))
        ((null (cddr p)) (prgmandexp (cadr p) x y))
        (t (do ((l (cdr p) (cdr l)) (xl) (vl) (nl))
               ((null (cdr l))
                (setq nl (cons `(setq tuples ,(prgmandexp (car l) x y)) nl))
                (maksprogn (nreverse nl)))
               (setq vl (unionize xl (goodvars (car l))))
               (setq nl (cons `(setq tuples ,(prgmandexp (car l) x vl)) nl))
               (setq xl vl)))))

(defun prgmandor (p x y)
  (cond ((null (cdr p)) nil)
        ((null (cddr p)) (prgmandexp (cadr p) x y))
        (t (do ((l (cdr p) (cdr l)) (nl))
               ((null l) (cons 'union* (nreverse nl)))
               (setq nl (cons (prgmandexp (car l) x y) nl))))))

(defun prgmandsame (p x y)
  (let ((al (destructure x 't1 nil)))
    (cond ((groundedoutp (cadr p) al)
           (cond ((groundedoutp (caddr p) al)
                  `(loop for t1 in tuples
                         with answers
                         when (equal ,(makresult (cadr p) al)
                                     ,(makresult (caddr p) al))
                         do (setq answers (cons ,(makresult y al) answers))
                         finally (return (uniquify (nreverse answers)))))
                 (t (setq al (cons (cons (caddr p) (makresult (cadr p) al)) al))
                    `(loop for t1 in tuples
                           with answers
                           do (setq answers (cons ,(makresult y al) answers))
                           finally (return (uniquify (nreverse answers)))))))
          ((groundedoutp (caddr p) al)
           (setq al (cons (cons (cadr p) (makresult (caddr p) al)) al))
           `(loop for t1 in tuples
                  with answers
                  do (setq answers (cons ,(makresult y al) answers))
                  finally (return (uniquify (nreverse answers)))))
          (t (setq al (cons (cons (caddr p) (quotify (cadr p))) al))
             `(loop for t1 in tuples
                    with answers
                    do (setq answers (cons ,(makresult y al) answers))
                    finally (return (uniquify (nreverse answers))))))))

(defun prgmanddistinct (p x y)
  (let ((al (destructure x 't1 nil)))
    `(loop for t1 in tuples
           with answers
           when (not (equal ,(makresult (cadr p) al) ,(makresult (caddr p) al)))
           do (setq answers (cons ,(makresult y al) answers))
           finally (return (uniquify (nreverse answers))))))

(defun prgmandground (p x y)
  (let ((al (destructure x 't1 nil)))
    `(loop for t1 in tuples
           with answers
           when (groundp ,(makresult (cadr p) al))
           do (setq answers (cons ,(makresult y al) answers))
           finally (return (uniquify (nreverse answers))))))

(defun prgmandnonground (p x y)
  (let ((al (destructure x 't1 nil)))
    `(loop for t1 in tuples
           with answers
           when (not (groundp ,(makresult (cadr p) al)))
           do (setq answers (cons ,(makresult y al) answers))
           finally (return (uniquify (nreverse answers))))))

(defun prgmandprimitive (p x y)
  (let ((al (destructure x 't1 nil)))
    `(loop for t1 in tuples
           with answers
           when (primitivep ,(makresult (cadr p) al))
           do (setq answers (cons ,(makresult y al) answers))
           finally (return (uniquify (nreverse answers))))))

(defun prgmandnonprimitive (p x y)
  (let ((al (destructure x 't1 nil)))
    `(loop for t1 in tuples
           with answers
           when (not (primitivep ,(makresult (cadr p) al)))
           do (setq answers (cons ,(makresult y al) answers))
           finally (return (uniquify (nreverse answers))))))

(defun prgmandvalue (p x y)
  (cond ((atom (cadr p)) (prgmandsame p x y))
        (t (prgmandcopout (append (cadr p) (cddr p)) x y))))

(defun prgmandbasic (p x y)
  (let (al test)
    (setq al (destructure x 'tuple nil))
    (setq test (cons (get (car p) 'basic)
                     (mapcar #'(lambda (x) (makresult x al)) (cdr p))))
    `(loop for t1 in tuples
           with answers
           when ,test
           do (setq answers (cons ,(makresult y al) answers))
           finally (return (uniquify (nreverse answers))))))

(defun prgmandth (p x y)
  (let* (test index al)
    (setq al (destructure x 't1 nil))
    (setq index (indexable p al *theory*))
    (do ((l p (cdr l)) (i 0 (1+ i)) (dum))
        ((null l))
        (cond ((eq '?* (car l)))
              ((groundp (car l))
               (setq test (cons `(equal (nth ,i t2) ',(car l)) test)))
              ((setq dum (assoc (car l) al))
               (setq test (cons `(equal (nth ,i t2) ,(cdr dum)) test)))
              (t (setq al (cons (cons (car l) `(nth ,i t2)) al)))))
    `(loop for t1 in tuples
           with answers
           do (loop for t2 in (indexees ,index *theory*)
                    when ,(maksand (nreverse test))
                    do (setq answers (cons ,(makresult y al) answers)))
           finally (return (uniquify (nreverse answers))))))


(defun prgmandnot (p x y)
  (cond ((atom p) (prgmandcopout `(not ,p) x y))
        ((eq 'not (car p)) (prgmandexp (cadr p) x y))
        ((eq 'and (car p)) (prgmandnotand p x y))
        ((eq 'or (car p)) (prgmandnotor p x y))
        ((eq 'oneof (car p)) nil)
        ((eq 'same (car p)) nil)
        ((eq 'distinct (car p)) nil)
        ((eq 'ground (car p)) nil)
        ((eq 'nonground (car p)) nil)
        ((eq 'primitive (car p)) nil)
        ((eq 'nonprimitive (car p)) nil)
        ((eq '== (car p)) (prgmandcopout `(not ,p) x y))
        ((eq 'value (car p)) (prgmandcopout `(not ,p) x y))
        ((eq 'execute (car p)) (prgmandcopout `(not ,p) x y))
        ((eq 'unprovable (car p)) (prgmandexp (cadr p) x y))
        ((get (car p) 'basic) (prgmandcopout `(not ,p) x y))
        ((get (car p) 'basicval) (prgmandcopout `(not ,p) x y))
        (t (prgmandcopout `(not ,p) x y))))

(defun prgmandcopout (p x y)
  (let* (vars pattern test al)
    (setq vars (goodvars p))
    (setq pattern `(list 'and (list* 'oneof ',x tuples) ',p))
    (setq pattern `(findemall ',vars ,pattern))
    (setq al (destructure x 't1 nil) al (destructure vars 't2 al))
    (setq test (maktest vars 't2 al))
    `(let ((replies ,pattern))
       (loop for t1 in tuples
             with answers
             do (loop for t2 in replies
                      when ,test
                      do (setq answers (cons ,(makresult y al) answers)))
             finally (return (uniquify (nreverse answers)))))))

(defun prgmandnotor (p x y)
  (cond ((null (cdr p)) `(list ,(quotify x)))
        ((null (cddr p)) (prgmandnot (cadr p) x y))
        (t (prgmandand (cons 'and (mapcar #'maknot (cdr p))) x y))))

(defun prgmandnotand (p x y)
  (cond ((null (cdr p)) nil)
        ((null (cddr p)) (prgmandnot (cadr p) x y))
        (t (do ((l (cdr p) (cdr l)) (nl))
               ((null l) (cons 'union* (nreverse nl)))
               (setq nl (cons (prgmandnot (car l) x y) nl))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; miscellaneous
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun prgmproject (x y)
  (cond ((equal x y) 'tuples)
        (t (let (al)
             (setq al (destructure x 't1 nil))
             `(loop for t1 in tuples
                    with answers
                    do (setq answers (cons ,(makresult y al) answers))
                    finally (return (uniquify (nreverse answers))))))))

(defun destructure (x code al)
  (cond ((varp x) (if (assoc x al) al (cons (cons x code) al)))
        ((atom x) al)
        (t (do ((l x (cdr l)) (i 0 (1+ i)))
               ((null l) al)
               (setq al (destructure (car l) `(nth ,i ,code) al))))))

(defun asksole (x p sender receiver)
  (request `(ask-one ,x ,p) sender receiver))

(defun askall (x p sender receiver)
  (request `(ask-all ,x ,p) sender receiver))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun computeupdates (p th nl)
  (cond ((atom p) (adjoin p nl))
        ((eq '==> (car p))
         (dolist (item (finds (caddr p) (cadr p) th))
           (setq nl (contribute item nl)))
         nl)
        ((eq 'and (car p))
         (dolist (item (cdr p)) (setq nl (computechanges item th nl))) nl)
        ((eq 'update (car p))
         (dolist (item (cdr p)) (setq nl (computechanges item th nl))) nl)
        (t (adjoin p nl :test #'equalp))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defmethod process (s (command (eql 'search)) postlines)
  (cond ((null (cdr postlines)) (process-search-start s postlines))
        ((and (setq command (getf-post "Command" postlines)) nil))
        ((equalp command "Expand") (process-search-revision s postlines))
        ((equalp command "Display") (process-search-display s postlines))
        ((equalp command "Textual Searcher") (process-search-textual s postlines))
        ((equalp command "Convert Content") (process-search-content s postlines))
        ((equalp command "Save") (process-search-save s postlines))
        ((equalp command "Drop") (process-search-drop s postlines))
        (t (process-search-revision s postlines))))

(defun process-search-save (s postlines)
  (let (structure class items aspect kif target)
    (multiple-value-setq (structure postlines) (parsestructure postlines))
    (setq class (cadr structure))
    (setq aspect (car structure))
    (setq kif (maksand (reconverter structure)))
    (setq target (read-user-string (getf-post "Target" postlines)))
    (setq items (request `(ask-all ,aspect ,kif) *client* *gui*))
    (dolist (x items)
      (save (makpred x (cadr structure) *gui*) (symbol-value target)))
    (dolist (slot (attributes class))
      (dolist (datum (request `(ask-all (,slot ?x ?y) (and (oneof ?x . ,items) (,slot ?x ?y))) *client* *gui*))
        (save datum (symbol-value target))))
    (when *memory*
      (save `(<= (interested ,target ,aspect ,class) ,kif) *gui*))
    (output-prolog s 200)
    (output-header s "Save Data")
    (format s "<P>Data saved in ~A.</P>" (prettify target))
    (output-footer s)))

(defun process-search-drop (s postlines)
  (let (structure class items aspect kif target)
    (multiple-value-setq (structure postlines) (parsestructure postlines))
    (setq class (cadr structure))
    (setq aspect (car structure))
    (setq kif (maksand (reconverter structure)))
    (setq target (or (read-user-string (getf-post "Target" postlines)) *warehouse*))
    (setq items (request `(ask-all ,aspect ,kif) *client* *gui*))
    (dolist (x items) (drop (makpred x class target) (symbol-value target)))
    (dolist (slot (attributes class))
      (dropall (list slot '?x '?y) (list slot '?x '?y) (symbol-value target)))
    (when *memory*
      (save `(<= (interested ,target ?x ,class) (oneof ?x . ,items)) *gui*))
    (output-prolog s 200)
    (output-header s "Save Data")
    (format s "<P>Data dropped from ~A.</P>" (prettify target))
    (output-footer s)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
