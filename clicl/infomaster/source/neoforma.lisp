;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; (c) Copyright 2000-2006 Michael Genesereth.  All rights reserved.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(eval-when (compile load eval) (proclaim '(special *buttons* *cells*)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; inspector
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defmethod process (s (command (eql 'inspector)) postlines)
  (cond ((null (cdr postlines)) (process-inspector-start s postlines))
        ((getf-post "Change" postlines) (process-inspector-change s postlines))
        ((getf-post "Copy" postlines) (process-inspector-copy s postlines))
        ((getf-post "Delete" postlines) (process-inspectpage-delete s postlines))
        ((getf-post "Copy" postlines) (process-inspector-copy s postlines))
        ((getf-post "Inspect" postlines) (process-inspectpage-revision s postlines))
        ((getf-post "Convert to KIF" postlines) (process-inspector-convert s postlines))
        ((getf-post "Convert to iKIF" postlines) (process-inspector-ikif s postlines))
        ((getf-post "Convert to xKIF" postlines) (process-inspector-xkif s postlines))
        ((getf-post "Save" postlines) (process-inspectpage-save s postlines))
        ((getf-post "Drop" postlines) (process-inspectpage-drop s postlines))
        (t (process-inspector-revision s postlines))))

(defun process-inspector-start (s postlines)
  (let (object class structure (*buttons* 0))
    (setq object (read-value-string (cdr (pop postlines))))
    (setq class (classify object *gui*))
    (setq structure (reviseitem object class))
    (output-inspector-page s object class structure)))

(defun process-inspector-change (s postlines)
  (let (structure object class (*buttons* 0) (*cells* 0))
    (setq structure (read-user-string (cdr (pop postlines))))
    (setq object (car structure))
    (setq class (cadr structure))
    (setq structure (convert-to-update structure))
    (output-changer-page s object class structure)))

(defun process-inspector-copy (s postlines)
  (let (structure object (*buttons* 0) (*cells* 0))
    (setq structure (read-user-string (cdr (pop postlines))))
    (setq structure (convert-to-update structure))
    (setq object (newinstance (cadr structure)))
    (setq structure (cons object (cdr structure)))
    (output-creator-revision s object (cadr structure) structure)))

(defun process-inspector-convert (s postlines)
  (let (structure)
    (setq structure (read-user-string (cdr (pop postlines))))
    (format-html s) (crlf s)
    (output-head s (format nil "Inspector ~A" (prettify (car structure)))) (crlf s)
    (format-body s *bgcolor*) (crlf s)
    (output-header s)
    (format s "<XMP>")
    (dolist (fact (converter structure)) (print-acl s fact) (cr s))
    (format s "</XMP>")
    (output-footer s)
    (finish-body s) (crlf s)
    (finish-html s) (crlf s)))

(defun process-inspector-ikif (s postlines)
  (let (structure)
    (setq structure (read-user-string (cdr (pop postlines))))
    (format-html s) (crlf s)
    (output-head s (format nil "Inspector ~A" (prettify (car structure)))) (crlf s)
    (format-body s *bgcolor*) (crlf s)
    (output-header s)
    (format s "<XMP>")
    (dolist (fact (converter structure)) (format s (grind fact)) (cr s))
    (format s "</XMP>")
    (output-footer s)
    (finish-body s) (crlf s)
    (finish-html s) (crlf s)))

(defun process-inspector-xkif (s postlines)
  (let (structure)
    (setq structure (read-user-string (cdr (pop postlines))))
    (format-html s) (crlf s)
    (output-head s (format nil "Inspector ~A" (prettify (car structure)))) (crlf s)
    (format-body s *bgcolor*) (crlf s)
    (output-header s)
    (format s "<XMP>")
    (format s (cblify structure))
    (format s "</XMP>")
    (output-footer s)
    (finish-body s) (crlf s)
    (finish-html s) (crlf s)))

(defun process-inspector-revision (s postlines)
  (let (structure object class revision (*buttons* 0))
    (setq revision (getrevision postlines))
    (setq postlines (remrevision postlines))
    (setq structure (read-user-string (cdr (pop postlines))))
    (setq object (car structure))
    (setq class (cadr structure))
    (setq structure (revision structure revision))
    (output-inspector-page s object class structure)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Sample Data Structure:
;;; (object class
;;;         (slot1 object)
;;;         (slot1 (object class (slot3 object) ... (slot3 object)))
;;;         ...
;;;         (slot4 object))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun output-inspector-page (s object class structure)
  (format-html s) (crlf s)
  (output-head s (format nil "Inspector ~A" (prettify object))) (crlf s)
  (format-body s *bgcolor*) (crlf s)
  (output-header s)
  (format s "<FORM ACTION=INSPECTOR? METHOD=POST>")
  (format-hidden s "Structure" (htmlify (prin1-to-string structure)))
  (output-inspector-structure s structure)
  (format s "<TABLE WIDTH=100%><TR><TD WIDTH=25% VALIGN=TOP>")
  (format-button s "Change" "Change")
  (format s " this ~A.<BR>" (prettify class))
  (format-button s "Copy" " Copy")
  (format s " this ~A.<BR>" (prettify class))
  (format-button s "Delete" "Delete")
  (format s " this ~A.<BR>" (prettify class))
  (format s "</TD><TD WIDTH=25% VALIGN=TOP>")
  (unless (findp `(nocommand ,*gui* inspect) *interface*)   
    (format-button s "Inspect" "Modal Inspector"))
  (format s "</TD><TD VALIGN=TOP>")
  (format-button s "Convert to KIF" "Convert to KIF")
  (format s "<BR>")
  (format-button s "Convert to iKIF" "Convert to iKIF")
  (format s "<BR>")
  (format-button s "Convert to xKIF" "Convert to xKIF")
  (format s "</TD><TD WIDTH=25% VALIGN=TOP>")
  (unless (findp `(nocommand ,*gui* memory) *interface*)
    (format-button s "Save" "Save")
    (format-button s "Drop" "Drop") (format s "<BR>")
    (format-button s "View" "View")
    (format-button s "Clear" "Clear"))
  
  (format s "</TD></TR></TABLE>")
  (format s "</FORM>")
  (output-footer s)
  (finish-body s) (crlf s)
  (finish-html s) (crlf s))

(defun output-inspector-structure (s x)
  (format s "<B>~A</B> is an object of type <B>" (prettify (car x)))
  (output-classlink s (cadr x))
  (format s "</B>.")
  (force-output s)
  (format s "<P><TABLE CELLSPACING=8>")
  (do ((l (cddr x) (cdr l)) (flag))
      ((null l))
      (format s "<TR><TH ALIGN=LEFT VALIGN=TOP>")
      (unless (eq (caar l) flag) (output-slotlink s (caar l)))
      (setq flag (caar l))
      (format s "</TH><TD VALIGN=TOP>")
      (cond ((null (cdar l)))
            ((atom (cadar l)) (output-plus-button s (incf *buttons*)))
            (t (output-minus-button s (incf *buttons*))))
      (format s "</TD><TD>")
      (cond ((null (cdar l)))
            ((atom (cadar l)) (output-value-in-style s (cadar l) 'typein))
            (t (format s "<TABLE BORDER><TR><TD>")
               (output-square-button s (incf *buttons*))
               (output-inspector-structure s (cadar l))
               (format s "</TD></TR></TABLE>")))
      (format s "</TD></TR>")
      (crlf s))
  (format s "</TABLE>"))


(defparameter *tree* nil)

(defun revision (*tree* n)
  (revisetree *tree* 0 n)
  *tree*)

(defun revisetree (tree m n)
  (cond ((= m n) (setq *tree* tree) (1+ m))
        (t (reviseslots tree (1+ m) n))))

(defun reviseslots (tree m n)
  (do ((l (cddr tree) (cdr l)))
      ((null l) m)
      (cond ((> m n) (return m))
            ((null (cdar l)))
            ((= m n)
             (if (atom (cadar l))
               (rplaca (cdar l) (reviseitem (cadar l) (find-range (caar l))))
               (rplaca (cdar l) (caadar l)))
             (return (1+ m)))
            ((atom (cadar l)) (setq m (1+ m)))
            (t (setq m (revisetree (cadar l) (1+ m) n))))))

(defun output-toggle-button (s x)
  (if (atom x) (output-plus-button s x) (output-minus-button s (car x))))

(defun output-square-button (s x)
  (format s "<INPUT TYPE=IMAGE SRC=\"~Aimages/small.gif\" NAME=~A BORDER=0>" *home* (addressify x)))

(defun output-select-button (s class element)
  (format s "<A HREF=\"javascript:void(0)\" onClick=\"window.open('SELECTOR?Class=~A&Element=~A','Selector','menubar=yes,resizable=yes,width=200,height=600')\"><IMAGE SRC=\"~Aimages/maggie.gif\" BORDER=0></A>"
          (addressify class) (addressify element) *home*))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; updater
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defmethod process (s (command (eql 'updater)) postlines)
  (process-changer s postlines))

(defun process-changer (s postlines)
  (let (command object class)
    (cond ((null (cdr postlines))
           (setq object (read-value-string (cdr (pop postlines))))
           (setq class (classify object *gui*))
           (if class (process-changer-start  s object class)
               (html-message s (format nil "~A is unknown." (prettify object)))))
          ((and (setq command (getf-post "Command" postlines)) nil))
          ((equalp command "Update") (process-changer-change s postlines))
          ((equalp command "Modal Changer") (process-changer-modal s postlines))
          ((equalp command "Convert Content") (process-changer-content s postlines))
          ((equalp command "Convert Difference") (process-changer-difference s postlines))
          ((equalp command "Save") (process-changer-save s postlines))
          ((equalp command "Drop") (process-changer-drop s postlines))
          (t (process-changer-revision s postlines)))))

(defun process-changer-start (s obj class)
  (let (structure (*buttons* 0) (*cells* 0))
    (setq structure (reviseitem obj class))
    (format-html s) (crlf s)
    (output-head s (format nil "Updater ~A" (prettify (car structure)))) (crlf s)
    (format-body s *bgcolor*) (crlf s)
    (output-header s)
    (format s "<FORM ACTION=UPDATER? METHOD=POST NAME=form1>")
    (output-updater-structure s structure)
    (format s "<TABLE WIDTH=100%><TR><TD WIDTH=25% VALIGN=TOP>")
    (format-button s "Command" "Update")
    (format s " this ~A." (prettify class))
    (format s "<BR>")
    (format-button s "Command" "Delete")
    (format s " this ~A." (prettify class))
    (format s "</TD><TD VALIGN=TOP>")
    (unless (findp `(nocommand ,*gui* inspector) *interface*)   
      (format-button s "Command" "Modal Changer"))
    (format s "</TD><TD VALIGN=TOP>")
    (format-button s "Command" "Convert Content")
    (format s "<BR>")
    (format-button s "Command" "Convert Difference")
  (unless (findp `(nocommand ,*gui* memory) *interface*)
    (format s "</TD><TD WIDTH=25% VALIGN=TOP>")
    (format-button s "Command" "Save")
    (format-button s "Command" "Drop") (format s "<BR>")
    (format-button s "Command" "View")
    (format-button s "Command" "Clear"))
    (format s "</TD></TR></TABLE>")
    (format s "</FORM>")
    (output-footer s)
    (finish-body s) (crlf s)
    (finish-html s) (crlf s)))

(defun process-changer-change (s postlines)
  (let (structure object class result (*buttons* 0))
    (multiple-value-setq (structure postlines) (parseobject postlines))
    (setq object (car structure))
    (setq class (cadr structure))
    (prorequest (cons 'update (differentiator structure)))
    (cond ((errorp result) (output-problems s result))
          (t (output-inspector-page s object class (reviseitem object class))))))

(defun process-changer-modal (s postlines)
  (let (structure (*buttons* 0) (*cells* 0))
    (multiple-value-setq (structure postlines) (parseobject postlines))
    (output-change-page s (car structure) (cadr structure) structure)))

(defun process-changer-content (s postlines)
  (let (structure)
    (multiple-value-setq (structure postlines) (parseobject postlines))
    (format-html s) (crlf s)
    (output-head s (format nil "Inspector ~A" (prettify (car structure)))) (crlf s)
    (format-body s *bgcolor*) (crlf s)
    (output-header s)
    (format s "<XMP>")
    (print-acl s (maksand (converter structure)))
    (format s "</XMP>")
    (output-footer s)
    (finish-body s) (crlf s)
    (finish-html s) (crlf s)))

(defun process-changer-difference (s postlines)
  (let (structure)
    (multiple-value-setq (structure postlines) (parseobject postlines))
    (format-html s) (crlf s)
    (output-head s (format nil "Inspector ~A" (prettify (car structure)))) (crlf s)
    (format-body s *bgcolor*) (crlf s)
    (output-header s)
    (format s "<XMP>")
    (print-acl s (maksand (differentiator structure)))
    (format s "</XMP>")
    (output-footer s)
    (finish-body s) (crlf s)
    (finish-html s) (crlf s)))

(defun process-changer-save (s postlines)
  (let (object)
    (setq object (car (parseobject postlines)))
    (format-html s) (crlf s)
    (output-head s "Save") (crlf s)
    (format-body s *bgcolor*) (crlf s)
    (output-header s)
    (save `(isa selection class) *interface*)
    (save `(predicate selection selection.instance) *interface*)
    (save `(specialty warehouse selection.instance) *interface*)
    (save `(interest warehouse selection.instance) *interface*)
    (tellgui `(selection.instance ,object))
    (format s "<P>Object added to class ")
    (output-classlink s 'selection)
    (format s ".<P>")
    (output-footer s)
    (finish-body s) (crlf s)
    (finish-html s) (crlf s)))

(defun process-changer-drop (s postlines)
  (let (object)
    (setq object (car (parseobject postlines)))
    (format-html s) (crlf s)
    (output-head s "Save") (crlf s)
    (format-body s *bgcolor*) (crlf s)
    (output-header s)
    (untellgui `(selection.instance ,object))
    (format s "<P>Object dropped from class ")
    (output-classlink s 'selection)
    (format s ".<P>")
    (output-footer s)
    (finish-body s) (crlf s)
    (finish-html s) (crlf s)))

(defun process-changer-revision (s postlines)
  (let (structure object class revision (*buttons* 0) (*cells* 0))
    (setq revision (getrevision postlines))
    (setq postlines (remrevision postlines))
    (multiple-value-setq (structure postlines) (parseobject postlines))
    (setq object (car structure))
    (setq class (cadr structure))
    (setq structure (revisenew structure revision))
    (output-changer-page s object class structure)))

(defun output-changer-page (s object class structure)
  (format-html s) (crlf s)
  (output-head s (format nil "Updater ~A" (prettify object))) (crlf s)
  (format-body s *bgcolor*) (crlf s)
  (output-header s)
  (format s "<FORM ACTION=UPDATER? METHOD=POST NAME=form1>")
  (output-updater-structure s structure)
  (format s "<TABLE WIDTH=100%><TR><TD WIDTH=25% VALIGN=TOP>")
  (format-button s "Command" "Update")
  (format s " this ~A." (prettify class))
  (format s "<BR>")
  (format-button s "Command" "Delete")
  (format s " this ~A." (prettify class))
  (unless (findp `(nocommand ,*gui* inspector) *interface*)   
    (format s "</TD><TD WIDTH=25% VALIGN=TOP>")
    (format-button s "Command" "Modal Changer"))
  (unless (findp `(nocommand ,*gui* convert) *interface*)   
    (format s "</TD><TD WIDTH=25% VALIGN=TOP>")
    (format-button s "Command" "Convert Content")
    (format s "<BR>")
    (format-button s "Command" "Convert Difference"))
  (unless (findp `(nocommand ,*gui* memory) *interface*)
    (format s "</TD><TD WIDTH=25% VALIGN=TOP>")
    (format-button s "Command" "Save")
    (format-button s "Command" "Drop") (format s "<BR>")
    (format-button s "Command" "View")
    (format-button s "Command" "Clear"))
  (format s "</TD><TD><BR></TD></TR></TABLE>")
  (format s "</TD></TR></TABLE>")
  (format s "</FORM>")
  (format s "</FORM>")
  (output-footer s)
  (finish-body s) (crlf s)
  (finish-html s) (crlf s))

(defun output-updater-structure (s x)
  (format s "<B>~A</B> is an object of type <B>" (prettify (car x)))
  (output-classlink s (cadr x))
  (format s "</B>.")
  (format-hidden s "Start" "")
  (format-hidden s "Object" (stringize (car x)))
  (format-hidden s "Class" (stringize (cadr x)))
  (setq *cells* (+ *cells* 3))
  (format s "<P><TABLE CELLSPACING=3>")
  (do ((l (cddr x) (cdr l)) (range) (flag))
      ((null l))
      (format s "<TR><TH ALIGN=LEFT VALIGN=TOP>")
      (unless (eq (caar l) flag)
        (setq range (find-range (caar l)))
        (output-slotlink s (caar l)))
      (setq flag (caar l))
      (cond ((null (cdar l))
             (format s "</TH><TD VALIGN=TOP>")
             (output-select-button s range (+ *cells* 2))
             (output-snow-button s (incf *buttons*))
             (output-trash-button s (incf *buttons*))
             (output-plus-button s (incf *buttons*))
             (format s "</TD><TD>")
             (format-hidden s "Slot" (stringize (caar l)))
             (format-hidden s "Status" "Closed")
             (format-text s "Value" "" 30)
             (setq *cells* (+ *cells* 3)))
            ((atom (cadar l))
             (format s "</TH><TD VALIGN=TOP>")
             (output-select-button s range (+ *cells* 2))
             (output-snow-button s (incf *buttons*))
             (output-trash-button s (incf *buttons*))
             (output-plus-button s (incf *buttons*))
             (format s "</TD><TD>")
             (format-hidden s "Slot" (stringize (caar l)))
             (format-hidden s "Status" "Closed")
             (format-text s "Value" (stringize (cadar l)) 30)
             (setq *cells* (+ *cells* 3)))
            ((prorequest `(ask-if ,(makpred (caadar l) (cadr (cadar l)) *agent*)))
             (format s "</TH><TD VALIGN=TOP>")
             (output-empty-button s)
             (output-snow-button s (incf *buttons*))
             (output-trash-button s (incf *buttons*))
             (output-minus-button s (incf *buttons*))
             (format s "</TD><TD>")
             (format s "<TABLE BORDER><TR><TD>")
             (format-hidden s "Slot" (stringize (caar l)))
             (format-hidden s "Status" "Open")
             (setq *cells* (+ *cells* 2))
             (output-square-button s (incf *buttons*))
             (output-updater-structure s (cadar l))
             (format s "</TD></TR></TABLE>"))
            (t (format s "</TH><TD VALIGN=TOP>")
               (output-empty-button s)
               (output-snow-button s (incf *buttons*))
               (output-trash-button s (incf *buttons*))
               (output-minus-button s (incf *buttons*))
               (format s "</TD><TD>")
               (format s "<TABLE BORDER><TR><TD>")
               (format-hidden s "Slot" (stringize (caar l)))
               (format-hidden s "Status" "Open")
               (setq *cells* (+ *cells* 2))
               (output-square-button s (incf *buttons*))
               (output-creator-structure s (cadar l))
               (format s "</TD></TR></TABLE>")))
      (format s "</TD></TR>")
      (crlf s))
  (format s "</TABLE>")
  (format-hidden s "End" "")
  (incf *cells*))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; creator
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defmethod process (s (command (eql 'creator)) postlines)
  (let (object class)
    (cond ((null (cdr postlines))
           (setq class (read-value-string (cdr (pop postlines))))
           (setq object (intern (strappend (symbol-name class) "." (princ-to-string (get-universal-time)))))
           (process-creator-start s object class))
          ((getf-post "Create" postlines) (process-creator-create s postlines))
          ((getf-post "Modal Creator" postlines) (process-creator-modal s postlines))
          ((getf-post "Convert Content" postlines) (process-creator-content s postlines))
          ((getf-post "Convert Difference" postlines) (process-creator-difference s postlines))
          (t (process-creator-revision s postlines)))))

(defun process-creator-start (s obj class)
  (let (structure (*buttons* 0) (*cells* 0))
    (setq structure (createitem obj class))
    (format-html s) (crlf s)
    (output-head s (format nil "Inspector ~A" (prettify obj))) (crlf s)
    (format-body s *bgcolor*) (crlf s)
    (output-header s)
    (format s "<FORM ACTION=CREATOR? METHOD=POST>")
    (output-creator-structure s structure)
    (format s "<TABLE WIDTH=100%><TR><TD WIDTH=50% VALIGN=TOP>")
    (format-button s "Create" "Create")
    (format s " this ~A." (prettify class))
    (format s "</TD><TD VALIGN=TOP>")
    (format-button s "Convert Content" "Convert Content")
    (format s "<BR>")
    (format-button s "Convert Difference" "Convert Difference")
    (format s "</TD></TR></TABLE>")
    (format s "</FORM>")
    (output-footer s)
    (finish-body s) (crlf s)
    (finish-html s) (crlf s)))

(defun process-creator-create (s postlines)
  (let (structure object class result (*buttons* 0))
    (multiple-value-setq (structure postlines) (parseobject postlines))
    (setq object (car structure))
    (setq class (cadr structure))
    (setq result (prorequest (cons 'update (differentiator structure))))
    (cond ((errorp result) (output-problems s result))
          (t (setq structure (convert-to-inspect structure))
             (output-inspector-page s object class structure)))))

(defun process-creator-modal (s postlines)
  (let (structure (*buttons* 0) (*cells* 0))
    (multiple-value-setq (structure postlines) (parseobject postlines))
    (output-create-page s structure)))

(defun process-creator-content (s postlines)
  (let (structure)
    (multiple-value-setq (structure postlines) (parseobject postlines))
    (format-html s) (crlf s)
    (output-head s (format nil "Inspector ~A" (prettify (car structure)))) (crlf s)
    (format-body s *bgcolor*) (crlf s)
    (output-header s)
    (format s "<XMP>")
    (print-acl s (maksand (converter structure)))
    (format s "</XMP>")
    (output-footer s)
    (finish-body s) (crlf s)
    (finish-html s) (crlf s)))

(defun process-creator-difference (s postlines)
  (let (structure)
    (multiple-value-setq (structure postlines) (parseobject postlines))
    (format-html s) (crlf s)
    (output-head s (format nil "Inspector ~A" (prettify (car structure)))) (crlf s)
    (format-body s *bgcolor*) (crlf s)
    (output-header s)
    (format s "<XMP>")
    (print-acl s (maksand (differentiator structure)))
    (format s "</XMP>")
    (output-footer s)
    (finish-body s) (crlf s)
    (finish-html s) (crlf s)))

(defun process-creator-revision (s postlines)
  (let (structure object class revision (*buttons* 0) (*cells* 0))
    (setq revision (getrevision postlines))
    (setq postlines (remrevision postlines))
    (multiple-value-setq (structure postlines) (parseobject postlines))
    (setq object (car structure))
    (setq class (cadr structure))
    (setq structure (revisenew structure revision))
    (output-creator-revision s object class structure)))

(defun output-creator-revision (s object class structure)
  (format-html s) (crlf s)
  (output-head s (format nil "Creator ~A" (prettify object))) (crlf s)
  (format-body s *bgcolor*) (crlf s)
  (output-header s)
  (format s "<FORM ACTION=CREATOR? METHOD=POST>")
  (output-creator-structure s structure)
  (format s "<TABLE WIDTH=100%><TR><TD WIDTH=25% VALIGN=TOP>")
  (format-button s "Create" "Create")
  (format s " this ~A." (prettify class))
  (format s "</TD><TD WIDTH=25% VALIGN=TOP>")
  (format-button s "Modal Creator" "Modal Creator")
  (format s "</TD><TD VALIGN=TOP>")
  (format-button s "Convert Content" "Convert Content")
  (format s "<BR>")
  (format-button s "Convert Difference" "Convert Difference")
  (format s "</TD></TR></TABLE>")
  (format s "</FORM>")
  (output-footer s)
  (finish-body s) (crlf s)
  (finish-html s) (crlf s))

(defun output-creator-structure (s x)
  (format-hidden s "Start" "")
  (format-text s "Object" (car x) 30)
  (format s " is an object of type <B>")
  (output-classlink s (cadr x))
  (format s "</B>.")
  (format-hidden s "Class" (stringize (cadr x)))
  (setq *cells* (+ *cells* 3))
  (format s "<P><TABLE CELLSPACING=3>")
  (do ((l (cddr x) (cdr l)) (range) (flag))
      ((null l))
      (format s "<TR><TH ALIGN=LEFT VALIGN=TOP>")
      (unless (eq (caar l) flag)
        (setq range (find-range (caar l)))
        (output-slotlink s (caar l)))
      (setq flag (caar l))
      (cond ((null (cdar l))
             (format s "</TH><TD VALIGN=TOP>")
             (output-select-button s range (+ *cells* 2))
             (output-snow-button s (incf *buttons*))
             (output-trash-button s (incf *buttons*))
             (output-plus-button s (incf *buttons*))
             (format s "</TD><TD>")
             (format-hidden s "Slot" (stringize (caar l)))
             (format-hidden s "Status" "Closed")
             (format-text s "Value" "" 30)
             (setq *cells* (+ *cells* 3)))
            ((atom (cadar l))
             (format s "</TH><TD VALIGN=TOP>")
             (output-select-button s range (+ *cells* 2))
             (output-snow-button s (incf *buttons*))
             (output-trash-button s (incf *buttons*))
             (output-plus-button s (incf *buttons*))
             (format s "</TD><TD>")
             (format-hidden s "Slot" (stringize (caar l)))
             (format-hidden s "Status" "Closed")
             (format-text s "Value" (stringize (cadar l)) 30)
             (setq *cells* (+ *cells* 3)))
            (t (format s "</TH><TD VALIGN=TOP>")
               (output-empty-button s)
               (output-snow-button s (incf *buttons*))
               (output-trash-button s (incf *buttons*))
               (output-minus-button s (incf *buttons*))
               (format s "</TD><TD>")
               (format s "<TABLE BORDER><TR><TD>")
               (format-hidden s "Slot" (stringize (caar l)))
               (format-hidden s "Status" "Open")
               (setq *cells* (+ *cells* 2))
               (output-square-button s (incf *buttons*))
               (output-creator-structure s (cadar l))
               (format s "</TD></TR></TABLE>")))
      (format s "</TD></TR>")
      (crlf s))
  (format s "</TABLE>")
  (format-hidden s "End" "")
  (incf *cells*))


(defun revisenew (*tree* n)
  (revisenewtree *tree* 0 n)
  *tree*)

(defun revisenewtree (tree m n)
  (cond ((= m n) (setq *tree* tree) (1+ m))
        (t (revisenewslots tree (1+ m) n))))

(defun revisenewslots (tree m n)
  (do ((l (cddr tree) (cdr l)) (item) (range))
      ((null l) m)
      (cond ((> m n) (return m))
            ((= m n)
             (rplacd l (cons (list (caar l)) (cdr l)))
             (setq m (+ m 3)))
            ((= (+ m 1) n)
             (rplacd (rdc tree l) (cdr l))
             (setq m (+ m 3)))
            ((= (+ m 2) n)
             (cond ((null (cdar l))
                    (setq range (find-range (caar l)))
                    (setq item (intern (strappend (symbol-name range) "." (princ-to-string (get-universal-time)))))
                    (rplacd (car l) (list (revisenewitem item range))))
                   ((atom (cadar l))
                    (setq range (find-range (caar l)))
                    (rplaca (cdar l) (revisenewitem (cadar l) range)))
                   (t (rplaca (cdar l) (caadar l))))
             (return (+ m 3)))
            ((atom (cadar l)) (setq m (+ m 3)))
            (t (setq m (revisenewtree (cadar l) (+ m 3) n))))))

(defun rdc (foo bar)
  (do ((l foo (cdr l)))
      ((null l) nil)
      (when (eq (cdr l) bar) (return l))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; selector
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defmethod process (s (action (eql 'selector)) postlines)
  (cond ((string= (getf-post "Command" postlines) "Previous")
         (process-selector-previous s postlines))
        ((string= (getf-post "Command" postlines) " More ")
         (process-selector-more s postlines))
        (t (process-selector-start s postlines))))

(defun process-selector-start (s postlines)
  (let (class element)
    (setq class (read-value-string (cdr (pop postlines))))
    (setq element (read-value-string (cdr (pop postlines))))
    (format-body s *bgcolor*)
    (output-class-items s class element 1 20)
    (finish-body s)))

(defun process-selector-more (s postlines)
  (let (class element start end)
    (setq class (read-value-string (cdr (pop postlines))))
    (setq element (read-value-string (cdr (pop postlines))))
    (setq start (read-value-string (cdr (pop postlines))))
    (setq end (read-value-string (cdr (pop postlines))))
    (format-body s *bgcolor*)
    (output-class-items s class element (+ start 20) (+ end 20))
    (finish-body s)))

(defun process-selector-previous (s postlines)
  (let (class element start end)
    (setq class (read-value-string (cdr (pop postlines))))
    (setq element (read-value-string (cdr (pop postlines))))
    (setq start (read-value-string (cdr (pop postlines))))
    (setq end (read-value-string (cdr (pop postlines))))
    (format-body s *bgcolor*)
    (output-class-items s class element (- start 20) (- end 20))
    (finish-body s)))

(defun output-class-items (s class element start end)
  (let (items count)
    (setq items (prorequest `(ask-all ?x ,(makpred '?x class *agent*))))
    (setq count (length items))
    (when (< start 1) (setq start 1))
    (cond ((< end 1) (setq end (min count 20)))
          ((> end count) (setq end count)))
    (when (< end start) (setq end start))
    (cond ((and (= start 1) (= end count)))
          ((> start count) (setq items nil))
          (t (setq items (subseq items (1- start) end))))
    (format s "<P><CENTER><H2>Select ~A</H2></CENTER></P>" (prettify class))
    (when (> start 1)
      (format s "<FORM ACTION=SELECTOR? METHOD=POST>" (addressify class))
      (format-hidden s "Class" (stringize class))
      (format-hidden s "Element" (stringize element))
      (format-hidden s "Start" (stringize start))
      (format-hidden s "Solutions" (stringize end))
      (format s "<P><CENTER>")
      (format-button s "Command" "Previous")
      (format s "</CENTER></P>")
      (format s "</FORM>"))    (do ((l items (cdr l)) (i 1 (1+ i)))
        ((or (null l) (> i 20)))
        (output-class-item s (car l) element)
        (format s "<BR>")
        (crlf s))
    (when (> count 20)
      (format s "<FORM ACTION=SELECTOR? METHOD=POST>" (addressify class))
      (format-hidden s "Class" (stringize class))
      (format-hidden s "Element" (stringize element))
      (format-hidden s "Start" (stringize start))
      (format-hidden s "Solutions" (stringize end))
      (format s "<P><CENTER>")
      (format-button s "Command" " More ")
      (format s "</CENTER></P>")
      (format s "</FORM>"))))

(defun output-class-item (s obj target)
  (format s "<A HREF=\"javascript:void(0)\" onClick=\"window.opener.document.forms[0].elements[~A].value='~A'\">~A</A>"
          (addressify target) (addressify obj) (iconify obj)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; searcher
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defmethod process (s (command (eql 'searcher)) postlines)
  (cond ((null (cdr postlines)) (process-searcher-start s postlines))
        ((and (setq command (getf-post "Command" postlines)) nil))
        ((equalp command "Display") (process-searcher-display s postlines))
        ((equalp command "Modal Searcher") (process-searcher-modal s postlines))
        ((equalp command "Convert Content") (process-searcher-convert s postlines))
        ((equalp command "Save") (process-searcher-save s postlines))
        ((equalp command "Drop") (process-searcher-drop s postlines))
        (t (process-searcher-revision s postlines))))

(defun process-searcher-start (s postlines)
  (let (class structure (*buttons* 0) (*cells* 0))
    (setq class (read-user-string (cdar postlines)))
    (setq structure (maksearchstructure (gentemp "?") class))
    (output-searcher-page s class structure)))

(defun process-searcher-display (s postlines)
  (let (structure class aspect kif slots objects selections start end count)
    (multiple-value-setq (structure postlines) (parseobject postlines))
    (setq class (cadr structure))
    (setq aspect (car structure))
    (setq kif (maksand (converter structure)))
    (setq start 1 end 20)
    (setq objects (request `(ask-all ,aspect ,kif) *client* *agent*))
    (multiple-value-setq (objects count start end) (trim objects start end))
    (setq selections (find-selections *client* objects))
    (setq slots (displayable-slots class))
    (output-display-page s class aspect kif slots objects selections count start end)))

(defun process-searcher-modal (s postlines)
  (let (structure (*buttons* 0) (*cells* 0))
    (multiple-value-setq (structure postlines) (parseobject postlines))
    (output-search-page s (cadr structure) structure)))

(defun process-searcher-convert (s postlines)
  (let (structure)
    (multiple-value-setq (structure postlines) (parseobject postlines))
    (format-html s) (crlf s)
    (output-head s (format nil "Inspector ~A" (prettify (car structure)))) (crlf s)
    (format-body s *bgcolor*) (crlf s)
    (output-header s)
    (format s "<XMP>")
    (print-acl s (maksand (converter structure)))
    (format s "</XMP>")
    (output-footer s)
    (finish-body s) (crlf s)
    (finish-html s) (crlf s)))

(defun process-searcher-save (s postlines)
  (let (structure head body intension)
    (multiple-value-setq (structure postlines) (parseobject postlines))
    (setq intension (find-intension *client* *gui*))
    (setq head (makpred (car structure) intension *gui*))
    (setq body (maksand (reconverter structure)))
    (format-html s) (crlf s)
    (output-head s "Save Rule") (crlf s)
    (format-body s *bgcolor*) (crlf s)
    (output-header s)
    (save `(isa ,intension class) *interface*)
    (dolist (rule (brfs `(<= ,head ,body)))
      (request `(tell ,rule) *client* *gui*))
    (format s "<P>Rule(s) added to class ")
    (output-classlink s intension)
    (format s ".<P>")
    (output-footer s)
    (finish-body s) (crlf s)
    (finish-html s) (crlf s)))

(defun process-searcher-drop (s postlines)
  (let (structure head body intension)
    (multiple-value-setq (structure postlines) (parseobject postlines))
    (setq intension (find-intension *client* *gui*))
    (setq head (makpred (car structure) intension *gui*))
    (setq body (maksand (reconverter structure)))
    (format-html s) (crlf s)
    (output-head s "Drop Rule") (crlf s)
    (format-body s *bgcolor*) (crlf s)
    (output-header s)
    (dolist (rule (brfs `(<= ,head ,body)))
      (request `(untell ,rule) *client* *gui*))
    (format s "<P>Rule(s) dropped from class ")
    (output-classlink s intension)
    (format s ".<P>")
    (output-footer s)
    (finish-body s) (crlf s)
    (finish-html s) (crlf s)))

(defun process-searcher-revision (s postlines)
  (let (structure class revision (*buttons* 0) (*cells* 0))
    (setq revision (getrevision postlines))
    (setq postlines (remrevision postlines))
    (multiple-value-setq (structure postlines) (parseobject postlines))
    (setq class (cadr structure))
    (setq structure (revisesearch structure revision))
    (output-searcher-page s class structure)))


(defun output-searcher-page (s class structure)
  (format-html s) (crlf s)
  (output-head s (format nil "Searcher ~A" (prettify class))) (crlf s)
  (format-body s *bgcolor*) (crlf s)
  (output-header s)
  (format s "<FORM ACTION=SEARCHER? METHOD=POST NAME=form1>")
  (format s "Find every <B>")
  (output-classlink s class)
  (format s "</B> that satisfies the following criteria.")
  (output-searcher-structure s structure)
  (format s "<TABLE WIDTH=100%><TR><TD WIDTH=25% VALIGN=TOP>")
  (format-button s "Command" "Display")
  (format s "</TD><TD WIDTH=25% VALIGN=TOP>")
  (unless (findp `(nocommand ,*gui* inspector) *interface*)   
    (format-button s "Command" "Modal Searcher"))
  (format s "</TD><TD WIDTH=25% VALIGN=TOP>")
  (unless (findp `(nocommand ,*gui* convert) *interface*)
    (format-button s "Command" "Convert Content"))
  (format s "</TD><TD WIDTH=25% VALIGN=TOP>")
  (unless (findp `(nocommand ,*gui* memory) *interface*)
    (format-top-button s "Command" "Save")
    (format-top-button s "Command" "Drop") (format s "<BR/>")
    (format s "<SELECT NAME=\"Target\">")
    (dolist (option (getbaskets))
      (format s "<OPTION>~A~%" (stringize option)))
    (format s "</SELECT>"))
  (format s "</TD></TR></TABLE>")
  (format s "</FORM>")
  (output-footer s)
  (finish-body s) (crlf s)
  (finish-html s) (crlf s))

(defun output-searcher-structure (s x)
  (format-hidden s "Start" "")
  (format-hidden s "Object" (stringize (car x)))
  (format-hidden s "Class" (stringize (cadr x)))
  (setq *cells* (+ *cells* 3))
  (format s "<P><TABLE CELLSPACING=3>")
  (do ((l (cddr x) (cdr l)) (range) (flag))
      ((null l))
      (format s "<TR><TH ALIGN=LEFT VALIGN=TOP>")
      (unless (eq (caar l) flag)
        (setq range (find-range (caar l)))
        (output-slotlink s (caar l)))
      (setq flag (caar l))
      (cond ((null (cdar l))
             (format s "</TH><TD VALIGN=TOP>")
             (output-select-button s range (+ *cells* 2))
             (output-snow-button s (incf *buttons*))
             (output-trash-button s (incf *buttons*))
             (output-plus-button s (incf *buttons*))
             (format s "</TD><TD>")
             (format-hidden s "Slot" (stringize (caar l)))
             (format-hidden s "Status" "Closed")
             (format-text s "Value" "" 30)
             (setq *cells* (+ *cells* 3)))
            ((atom (cadar l))
             (format s "</TH><TD VALIGN=TOP>")
             (output-select-button s range (+ *cells* 2))
             (output-snow-button s (incf *buttons*))
             (output-trash-button s (incf *buttons*))
             (output-plus-button s (incf *buttons*))
             (format s "</TD><TD>")
             (format-hidden s "Slot" (stringize (caar l)))
             (format-hidden s "Status" "Closed")
             (format-text s "Value" (stringize (cadar l)) 30)
             (setq *cells* (+ *cells* 3)))
            (t (format s "</TH><TD VALIGN=TOP>")
               (output-empty-button s)
               (output-snow-button s (incf *buttons*))
               (output-trash-button s (incf *buttons*))
               (output-minus-button s (incf *buttons*))
               (format s "</TD><TD>")
               (format s "<TABLE BORDER><TR><TD>")
               (format-hidden s "Slot" (stringize (caar l)))
               (format-hidden s "Status" "Open")
               (setq *cells* (+ *cells* 2))
               (format s "~A <B>" (article (cadr (cadar l))))
               (output-classlink s (cadr (cadar l)))
               (format s "</B> that satisfies the following criteria<BR>")
               (output-searcher-structure s (cadar l))
               (format s "</TD></TR></TABLE>")))
      (format s "</TD></TR>")
      (crlf s))
  (format s "</TABLE>")
  (format-hidden s "End" "")
  (incf *cells*))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Postlines Sample Data Structure:
;;; (("Start" . "")
;;;  ("Object" . "object1")
;;;  ("Class" . "class1")
;;;  ("Slot" . "slot1")
;;;  ("Status" . "Closed")
;;;  ("Value" . "object2")
;;;  ("Slot" . "Slot2")
;;;  ("Status" . "Open")
;;;  ("Start" . "")
;;;  ("Object" . "object3")
;;;  ("Class" . "class2")
;;;  ("Slot" . "Slot3")
;;;  ("Status" . "Closed")
;;;  ("Value" . "object4")
;;;  ("Slot" . "Slot3")
;;;  ("Value" . "object5")
;;;  ("End" . "")
;;;  ("Slot" . "Slot4")
;;;  ("Status" . "Closed")
;;;  ("Value" . "unknown")
;;;  ("Slot" . "Slot5")
;;;  ("Status" . "Closed")
;;;  ("Value" . "object6")
;;;  ("End" . "")))
;;;
;;; (object1 class1
;;;          (slot1 object2)
;;;          (slot2 (object3 class2 (slot3 object4) (slot3 object5)))
;;;          (slot4 unknown)
;;;          (slot5 object6))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun parseobject (postlines)
  (let (object class slots)
    (pop postlines)
    (setq object (read-user-string (cdr (pop postlines))))
    (setq class (read-user-string (cdr (pop postlines))))
    (do ((slot) (value) (nl))
        ((or (null postlines) (string= (caar postlines) "End"))
         (pop postlines)
         (setq slots (nreverse nl)))
        (setq slot (read-user-string (cdr (pop postlines))))
        (cond ((string= (cdr (pop postlines)) "Closed")
               (setq value (read-user-string (cdr (pop postlines)))))
              (t (multiple-value-setq (value postlines) (parseobject postlines))))
        (setq nl (cons (if value (list slot value) (list slot)) nl)))
    (values (list* object class slots) postlines)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; interconversion
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun convert-to-update (x)
  (cond ((atom x) x)
        (t (do ((l (slots-of-class (cadr x)) (cdr l)) (m (cddr x)) (new) (nl))
               ((null l) (cons (car x) (cons (cadr x) (nreverse nl))))
               (cond ((findp `(changestyle ,(car l) noshow) *interface*)
                      (do () ((null m))
                        (cond ((eq (car l) (caar m)) (setq m (cdr m)))
                              (t (return nil)))))
                     ((eq (car l) (caar m))
                      (do () ((null m))
                        (cond ((not (eq (car l) (caar m))) (return nil))
                              ((null (cdar m)) (setq nl (cons (car m) nl) m (cdr m)))
                              (t (setq nl (cons (list (caar m) (convert-to-update (cadar m))) nl)
                                       m (cdr m))))))
                     ((setq new (prorequest `(ask-all (,(car l) ?x) (,(car l) ,(car x) ?x))))
                      (setq nl (nreconc new nl)))
                     (t (setq nl (cons (list (car l)) nl))))))))

(defun convert-to-inspect (x)
  (cond ((atom x) x)
        ((eq (car x) 'taxonomy) x)
        (t (do ((l (slots-of-class (cadr x)) (cdr l)) (m (cddr x)) (new) (nl))
               ((null l) (cons (car x) (cons (cadr x) (nreverse nl))))
               (cond ((findp `(inspectstyle ,(car l) noshow) *interface*)
                      (do () ((null m))
                        (cond ((eq (car l) (caar m)) (setq m (cdr m)))
                              (t (return nil)))))
                     ((eq (car l) (caar m))
                      (do () ((null m))
                        (cond ((not (eq (car l) (caar m))) (return nil))
                              ((null (cdar m)) (setq nl (cons (car m) nl) m (cdr m)))
                              (t (setq nl (cons (list (caar m) (convert-to-inspect (cadar m))) nl)
                                       m (cdr m))))))
                     ((setq new (prorequest `(ask-all (,(car l) ?x) (,(car l) ,(car x) ?x))))
                      (setq nl (nreconc new nl)))
                     (t (setq nl (cons (list (car l)) nl))))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; converter
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun converter (x)
  (nreverse (converttree x nil)))

(defun converttree (x nl)
  (cond ((atom x) nl)
        (t (setq nl (convertslots x nl))
           (adjoiner (makpred (car x) (cadr x) *gui*) nl))))

(defun convertslots (x nl)
  (do ((l (cddr x) (cdr l)))
      ((null l) nl)
      (cond ((null (cdar l)))
            ((atom (cadar l))
             (setq nl (adjoiner (list (caar l) (car x) (cadar l)) nl)))
            ((eq (caadar l) 'taxonomy)
             (setq nl (adjoiner (list (caar l) (car x) (car (last (cadar l)))) nl)))
            (t (setq nl (adjoiner (list (caar l) (car x) (caadar l)) nl))
               (setq nl (converttree (cadar l) nl))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; cblify
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun cblify (x)
  (with-output-to-string (s) (cblifytree s x 0)))

(defun cblifytree (s x n)
  (formatn s " " n)
  (format s "<~A OID=\"~A\">" (cadr x) (car x)) (cr s)
  (cblifyslots s x (+ n 2))
  (formatn s " " n)
  (format s "</~A>" (cadr x)) (cr s))

(defun cblifyslots (s x n)
  (do ((l (cddr x) (cdr l)))
      ((null l))
      (cond ((null (cdar l)))
            ((atom (cadar l))
             (formatn s " " n)
             (format s "<~A>" (caar l))
             (format s "<~A OID=\"~A\"/>" (classify (cadar l) *gui*) (cadar l))
             (format s "</~A>" (caar l))
             (cr s))
            (t (formatn s " " n)
               (format s "<~A>" (caar l)) (cr s)
               (cblifytree s (cadar l) (+ n 2))
               (formatn s " " n)
               (format s "</~A>" (caar l)) (cr s)))))

(defun cr (s)
  (write-char #\return s))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Example
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
#|
(definemore *manager*
  '((isa schema sort)
    (isa schema thing)
    (superclass schema thing)
    (attribute  schema schema.sort)
    (attribute  schema schema.table)

    (arity schema.sort 2)
    (range schema.sort sort)

    (arity schema.table 2)
    (range schema.table relation)

    (isa sort sort)
    (isa sort thing)
    (superclass sort thing)
    (attribute  sort sort.supersort)
    (attribute  sort sort.predicate)
    (attribute  sort sort.attribute)

    (arity sort.supersort 2)
    (range sort.supersort sort)

    (arity sort.predicate 2)
    (range sort.predicate naryrelation)

    (arity sort.attribute 2)
    (range sort.attribute slot)

    (isa slot sort)
    (isa slot thing)
    (superclass slot relation)
    (attribute  slot slot.domain)
    (attribute  slot slot.range)
    (attribute  slot slot.unique)
    (attribute  slot slot.total)
    (attribute  slot slot.style)

    (arity slot.domain 2)
    (range slot.domain sort)

    (arity slot.range 2)
    (range slot.range sort)

    (arity slot.unique 2)
    (range slot.unique boolean)

    (arity slot.total 2)
    (range slot.total boolean)

    (arity slot.style 2)
    (range slot.style modality)

    (isa            myworld schema)
    (schema.sort    myworld product.521518)
    (schema.sort    myworld product.521519)
    (schema.sort    myworld product.521520)

    (isa            product.521518 sort)
    (sort.supersort product.521518 product.5215)
    (sort.predicate product.521518 product.521518.instance)
    (sort.attribute product.521518 product.521518.type)
    (sort.attribute product.521518 product.521518.material)
    (sort.attribute product.521518 product.521518.interior)
    (sort.attribute product.521518 product.521518.exterior)
    (sort.attribute product.521518 product.521518.color)
    (sort.attribute product.521518 product.521518.capacity)
    (sort.attribute product.521518 product.521518.diameter)
    (sort.attribute product.521518 product.521518.msrp)
    (sort.attribute product.521518 product.521518.manufacturer)
    (sort.attribute product.521518 product.521518.upc)
    (sort.attribute product.521518 product.521518.image)

    (isa            product.521518.instance naryrelation)
    (isa            product.521518.instance relation)
    (isa            product.521518.instance thing)
    (superrelation  product.521518.instance true)
    (arity          product.521518.instance 1)
    (selection      product.521518.instance selection.521518.instance)

    (isa            product.521518.type slot)
    (isa            product.521518.type attributerelation)
    (slot.domain    product.521518.type product.521518)
    (slot.range     product.521518.type type)
    (slot.unique    product.521518.type yes)
    (slot.total     product.521518.type yes)
    (slot.option    product.521518.type accessory)
    (slot.option    product.521518.type baking-dish)
    (slot.option    product.521518.type bowl)
    (slot.option    product.521518.type cup)
    (slot.option    product.521518.type dish)
    (slot.option    product.521518.type double-boiler)
    (slot.option    product.521518.type dutch-oven)
    (slot.option    product.521518.type griddle)
    (slot.option    product.521518.type roaster)
    (slot.option    product.521518.type sauce-pan)
    (slot.option    product.521518.type skillet)
    (slot.option    product.521518.type stock-pot)
    (slot.option    product.521518.type tea-kettle)

    (isa            product.521518.material slot)
    (slot.domain    product.521518.material product.521518)
    (slot.range     product.521518.material material)
    (slot.unique    product.521518.material no)
    (slot.total     product.521518.material yes)
    (slot.option    product.521518.material aluminum)
    (slot.option    product.521518.material ceramic)
    (slot.option    product.521518.material glass)
    (slot.option    product.521518.material iron)
    (slot.option    product.521518.material stainless)

    (isa            product.521518.interior slot)
    (slot.domain    product.521518.interior product.521518)
    (slot.range     product.521518.interior material)
    (slot.unique    product.521518.interior no)
    (slot.total     product.521518.interior yes)
    (slot.option    product.521518.interior ceramic)
    (slot.option    product.521518.interior enamel)
    (slot.option    product.521518.interior glass)
    (slot.option    product.521518.interior metal)
    (slot.option    product.521518.interior porcelain)
    (slot.option    product.521518.interior teflon)

    (isa            product.521518.exterior slot)
    (slot.domain    product.521518.exterior product.521518)
    (slot.range     product.521518.exterior material)
    (slot.unique    product.521518.exterior no)
    (slot.total     product.521518.exterior yes)
    (slot.option    product.521518.exterior ceramic)
    (slot.option    product.521518.exterior enamel)
    (slot.option    product.521518.exterior glass)
    (slot.option    product.521518.exterior metal)
    (slot.option    product.521518.exterior porcelain)
    (slot.option    product.521518.exterior teflon)

    (isa            product.521518.color slot)
    (isa            product.521518.color attributerelation)
    (slot.domain    product.521518.color product.521518)
    (slot.range     product.521518.color color)
    (slot.unique    product.521518.color no)
    (slot.total     product.521518.color yes)
    (slot.option    product.521518.color black)
    (slot.option    product.521518.color grey)
    (slot.option    product.521518.color silver)
    (slot.option    product.521518.color clear)
    (slot.option    product.521518.color white)
    (slot.option    product.521518.color beige)
    (slot.option    product.521518.color brown)
    (slot.option    product.521518.color red)
    (slot.option    product.521518.color green)
    (slot.option    product.521518.color blue)
    (slot.option    product.521518.color purple)

    (isa            product.521518.capacity slot)
    (isa            product.521518.capacity attributerelation)
    (slot.domain    product.521518.capacity product.521518)
    (slot.range     product.521518.capacity number)
    (slot.unique    product.521518.capacity yes)
    (slot.total     product.521518.capacity yes)

    (isa            product.521518.diameter slot)
    (isa            product.521518.diameter attributerelation)
    (slot.domain    product.521518.diameter product.521518)
    (slot.range     product.521518.diameter number)
    (slot.unique    product.521518.diameter yes)
    (slot.total     product.521518.diameter yes)

    (isa            product.521518.msrp slot)
    (isa            product.521518.msrp attributerelation)
    (slot.domain    product.521518.msrp product.521518)
    (slot.range     product.521518.msrp number)
    (slot.unique    product.521518.msrp yes)
    (slot.total     product.521518.msrp yes)

    (isa            product.521518.manufacturer slot)
    (isa            product.521518.manufacturer attributerelation)
    (slot.domain    product.521518.manufacturer product.521518)
    (slot.range     product.521518.manufacturer company)
    (slot.unique    product.521518.manufacturer yes)
    (slot.total     product.521518.manufacturer yes)

    (isa            product.521518.upc slot)
    (isa            product.521518.upc relation)
    (slot.domain    product.521518.upc product.521518)
    (slot.range     product.521518.upc string)
    (slot.unique    product.521518.upc yes)
    (slot.total     product.521518.upc no)

    (isa            product.521518.image slot)
    (isa            product.521518.image attributerelation)
    (slot.domain    product.521518.image product.521518)
    (slot.range     product.521518.image string)
    (slot.unique    product.521518.image no)
    (slot.total     product.521518.image no)

    (isa            product.521518.feature slot)
    (isa            product.521518.feature attributerelation)
    (slot.domain    product.521518.feature product.521518)
    (slot.range     product.521518.feature thing)
    (slot.unique    product.521518.feature no)
    (slot.total     product.521518.feature no)

    (isa yes boolean)
    (isa no boolean)))
|#
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

