(in-package :imerge);;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Functionality tests;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(defvar *test-dir*     (make-pathname :name nil :type nil      :defaults  #+EXCL			excl:*source-pathname*		#+Harlequin-Common-Lisp dspec:*source-pathname*		#+MCL 			ccl::*loading-file-source-file*		#+CMU 			(truename *load-pathname*)		#+CLisp 		*load-pathname*		#+LCL 			lcl:*source-pathname*		;;; include trailing '/' to be safe		#-(or LCL Allegro MCL Harlequin-Common-Lisp CLisp CMU)		(error "Fix me: ~S" '*iMerge-root*)))(defparameter *tests*  '("epilog.test"    "database.test"    "sequel.test"    "kif.test"    "xml.test"    "cdt.test"    "proforma.test"    "integrator.test"    "preprocessor.test"    "metalibrary.test"    "manager.test"    "library.test"    "warehouse.test"    "album.test"    "autohouse.test"    ;"colleges.test"    "housewares.test"    "university.test"    "endtoend.test"))(defun test-path (string)  (merge-pathnames string *test-dir*))(defun finderrors (&optional (verbose nil) (catch-errors-p t))  (do ((l *tests* (cdr l)) (dum) (errors 0))      ((null l) errors)    (when verbose (format t "~&;; Starting test: ~A" (first l)))    (setq dum (testfile (car l) verbose catch-errors-p) errors (+ dum errors))    (fresh-line t)    (format t "~A errors in ~A" dum (car l))    (terpri t)))(defun testfile (fn &optional (verbose nil) (catch-errors-p t))  (with-open-file (f (test-path fn) :direction :input)    (do ((test) (expect) (n 0) (count 0))        (nil)        (cond ((eq 'stop (setq test (read f nil 'stop))) (return n))              ((eq 'stop (setq expect (read f nil 'stop)))               (princ "Early end of file for ") (princ fn)               (terpri) (return n))              (t (setq n (+ n (testitem test expect count verbose 					catch-errors-p)))))      (incf count))))(defun testitem (test expect count verbose catch-errors-p)  (let (actual	(cookie "*** Error: "))    (when verbose (format t "~%Test ~D: ~S" count test))    (if catch-errors-p	(handler-case (setq actual (eval test))	  (error (condition) 	    (setq actual 	      (strappend cookie (princ-to-string condition)))))      (setq actual (eval test)))    (cond ((and (not (and (stringp actual) (startstringp cookie actual)))		(listp test)                (find (car test)                      '(testtypes testdata checkdata checkrules checkviews)))           (or actual 1))          ((and (eq expect '*) 		(not (and (stringp actual) (startstringp cookie actual))))	   0)          ((equalp actual expect) 0)          (t (when (not verbose) (format t "~%Test ~D: ~S" count test))             (terpri) (princ "Expect: ") (prin1 expect)             (terpri) (princ "Actual: ") (prin1 actual)	     (when (and (listp expect) (listp actual))	       (terpri) (princ "Difference: ") 	       (prin1 (set-exclusive-or actual expect :test #'equalp)))             (terpri) 1))))(defun testdata (var th)  (do ((l (eval var) (cdr l)) (errors 0))      ((null l) errors)      (unless (testp (car l) th)        (fresh-line) (princ "Missing: ") (princ (car l))        (setq errors (1+ errors)))))(defun testp (p th)  (cond ((atom p) (truep p th))        ((eq (car p) 'frontpage))        ((find (car p) '(changestyle searchstyle documentation))         (truep (list (car p) (cadr p) '?y) th))        (t (truep p th))))(defun testtypes ()  (do ((l (words *manager*) (cdr l)) (errors 0))      ((null l) errors)      (cond ((numberp (car l)))            ((characterp (car l)))            ((stringp (car l)))            ((eq (car l) 'unknown))            (t (dolist (class (classes (car l)))                 (unless (findp `(isa ,(car l) ,class) *manager*)                   (fresh-line) (princ "Missing class info: ")                   (princ (list 'isa (car l) class))                   (setq errors (1+ errors))))))))(defun classes (x)  (do ((l (finds '?c `(isa ,x ?c) *manager*) (cdr l)) (nl))      ((null l) (nreverse (adjoin 'thing nl)))      (setq nl (superclasses (car l) nl))))(defun superclasses (x nl)  (cond ((find x nl) nl)        (t (setq nl (cons x nl))           (dolist (class (finds '?c `(superclass ,x ?c) *manager*))             (setq nl (superclasses class nl)))           nl)));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Performance tests;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(defparameter *table*  (make-instance 'infoserver :name 'table :kind 'tableserver))(defun testload (f target)  (initialize target)  (time (loadrelation 'foo f target 'tdt)));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;