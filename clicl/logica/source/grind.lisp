;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; (c) Copyright 1991 Michael R. Genesereth;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Needs;;;  parentheses;;;  -, /;;;  quote, comma;;;;;; Help for parser;;;  different all and exists;;;  V;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(defmacro strappend (&rest l)  `(concatenate 'string . ,l))(defun grind (p)  (grindexp p 'paren 'paren))(defun grindexp (p lop rop)  (cond ((varp p) (grind-variable p))        ((atom p) (string-downcase (princ-to-string p)))        ((eq '\^ (car p)) (grind-\^ p lop rop))        ((eq '* (car p)) (grind-* p lop rop))        ((eq '+ (car p)) (grind-+ p lop rop))        ((eq '> (car p)) (grind-> p lop rop))        ((eq '>= (car p)) (grind->= p lop rop))        ((eq '= (car p)) (grind-= p lop rop))        ((eq '\# (car p)) (grind-\# p lop rop))        ((eq '=< (car p)) (grind-=< p lop rop))        ((eq '< (car p)) (grind-< p lop rop))        ((eq 'listof (car p)) (grind-listof p lop rop))        ((eq 'setof (car p)) (grind-setof p lop rop))        ((eq 'not (car p)) (grind-not p lop rop))        ((eq 'and (car p)) (grind-and p lop rop))        ((eq 'or (car p)) (grind-or p lop rop))        ((eq '=> (car p)) (grind-=> p lop rop))        ((eq '<= (car p)) (grind-<= p lop rop))        ((eq '<=> (car p)) (grind-<=> p lop rop))        ((eq 'forall (car p)) (grind-forall p lop rop))        ((eq 'exists (car p)) (grind-exists p lop rop))        ((null (cdr p)) (strappend (grind (car p)) "()"))        (t (do ((l (cddr p) (cdr l))                (str (strappend (grind (car p)) "(" (grind (cadr p)))))               ((null l) (strappend str ")"))               (setq str (strappend str "," (grind (car l))))))))(defun grind-\^ (p lop rop)  (strappend (grindexp (cadr p) lop '\^) "^" (grindexp (caddr p) '\^ rop)))(defun grind-* (p lop rop)  (cond ((null (cdr p)) (grind 0))        ((null (cddr p)) (grindexp (cadr p) lop rop))        (t (do ((l (cddr p) (cdr l)) (str (grindexp (cadr p) lop '*)))               ((null (cdr l)) (strappend str "*" (grindexp (car l) '* rop)))               (setq str (strappend str "*" (grindexp (car l) '* '*)))))))(defun grind-+ (p lop rop)  (cond ((null (cdr p)) (grind 0))        ((null (cddr p)) (grindexp (cadr p) lop rop))        (t (do ((l (cddr p) (cdr l)) (str (grindexp (cadr p) lop '+)))               ((null (cdr l)) (strappend str "+" (grindexp (car l) '+ rop)))               (setq str (strappend str "+" (grindexp (car l) '+ '+)))))))(defun grind-> (p lop rop)  (strappend (grindexp (cadr p) lop '>) ">" (grindexp (caddr p) '> rop)))(defun grind->= (p lop rop)  (strappend (grindexp (cadr p) lop '>=) ">=" (grindexp (caddr p) '>= rop)))(defun grind-= (p lop rop)  (strappend (grindexp (cadr p) lop '=) "=" (grindexp (caddr p) '= rop)))(defun grind-\# (p lop rop)  (strappend (grindexp (cadr p) lop '\#) "#" (grindexp (caddr p) '\# rop)))(defun grind-=< (p lop rop)  (strappend (grindexp (cadr p) lop '=<) "=<" (grindexp (caddr p) '=< rop)))(defun grind-< (p lop rop)  (strappend (grindexp (cadr p) lop '<) "<" (grindexp (caddr p) '< rop)))(defun grind-listof (p lop rop)  (cond ((null (cdr p)) "[]")        (t (do ((l (cddr p) (cdr l)) (str (strappend "[" (grind (cadr p)))))               ((null (cdr l)) (strappend str "," (grind (car l)) "]"))               (setq str (strappend str "," (grind (car l))))))))(defun grind-setof (p lop rop)  (cond ((null (cdr p)) "{}")        (t (do ((l (cddr p) (cdr l)) (str (strappend "{" (grind (cadr p)))))               ((null (cdr l)) (strappend str "," (grind (car l)) "}"))               (setq str (strappend str "," (grind (car l))))))))(defun grind-not (p lop rop)  (strappend "~" (grind (cadr p))))(defun grind-and (p lop rop)  (cond ((null (cdr p)) (grind 'true))        ((null (cddr p)) (grindexp (cadr p) lop rop))        (t (do ((l (cddr p) (cdr l)) (str (grindexp (cadr p) lop 'and)))               ((null (cdr l)) (strappend str " & " (grindexp (car l) 'and rop)))               (setq str (strappend str " & " (grindexp (car l) 'and 'and)))))))(defun grind-or (p lop rop)  (cond ((null (cdr p)) (grind 'false))        ((null (cddr p)) (grindexp (cadr p) lop rop))        (t (do ((l (cddr p) (cdr l)) (str (grindexp (cadr p) lop 'or)))               ((null (cdr l)) (strappend str " V " (grindexp (car l) 'or rop)))               (setq str (strappend str " V " (grindexp (car l) 'or 'or)))))))(defun grind-=> (p lop rop)  (strappend (grind-and (butlast p) lop '=>) " => "             (grindexp (car (last p)) '=> rop)))(defun grind-<= (p lop rop)  (strappend (grindexp (cadr p) lop '<=) " <= " (grind-and (cdr p) '<= rop)))(defun grind-<=> (p lop rop)  (strappend (grindexp (cadr p) lop '<=>) " <=> " (grindexp (caddr p) '<=> rop)))(defun grind-forall (p lop rop)  (declare (ignore lop))  (strappend "A" (grind (cadr p)) "." (grindexp (caddr p) 'paren rop)))(defun grind-exists (p lop rop)  (declare (ignore lop))  (strappend "E" (grind (cadr p)) "." (grindexp (caddr p) 'paren rop)))(defun grind-variable (p)  (string-left-trim "?" (symbol-name p)))(defun grind-parens (p)  (strappend "(" (grind p) ")"))(defun bpgeqp (f g)  (cond ((eq f '\^))        ((eq f '*) (not (eq '\^ g)))));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;