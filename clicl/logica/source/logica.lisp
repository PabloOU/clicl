;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; (c) 1996-2002 Michael Genesereth;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Logica;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(eval-when (compile load eval)  (proclaim '(special *occurcheck* *theory* *termination* *inferences* *limit*)));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Truthtable;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(defmethod process (s (file (eql 'truthtable)) postlines)  (let (command)    (setq command (getf-post "Command" postlines))    (cond ((null command) (process-truthtable-start s))          ((string-equal command "Check Truth Table")           (process-truthtable-check s postlines))          ((string-equal command "Show Truth Table")           (process-truthtable-show s postlines)))))(defun process-truthtable-start (s)  (format s "<HTML><BODY BGCOLOR=WHITE><BR><CENTER><H1>Logica Truth Table</H1></CENTER><HR>&nbsp;&nbsp;<A HREF=>Home</A>&nbsp;&nbsp;<A HREF=Truthtable?>Truth Table</A>&nbsp;&nbsp;<A HREF=Converter?>Converter</A>&nbsp;&nbsp;<A HREF=Unifier?>Unifier</A>&nbsp;&nbsp;<A HREF=LOGICA?>Resolution</A>&nbsp;&nbsp;<A HREF=EPILOG?>Epilog</A>&nbsp;&nbsp;<A HREF=EDITOR?>Editor</A>&nbsp;&nbsp;<HR><FORM ACTION=Truthtable? METHOD=POST><CENTER><TABLE><TR><TH VALIGN=TOP>Propositional Sentences</TH></TR><TR><TD><TEXTAREA NAME=Sentences ROWS=15 COLS=80 WRAP=SOFT></TEXTAREA></TD></TR></TABLE></CENTER><BR><CENTER><INPUT TYPE=SUBMIT NAME=Command VALUE=\"Check Truth Table\"><INPUT TYPE=SUBMIT NAME=Command VALUE=\"Show Truth Table\"></CENTER></FORM>")  (format-end s))(defun process-truthtable-check (s postlines)  (let (sentences constants result)    (setq sentences (read-sentences (cdr (pop postlines))))    (setq constants (get-constants sentences))    (setq result (checktruthtable (maksand sentences) constants))    (output-prolog s 200)    (format-truthtable-start s)    (format s "<P>The following sentence(s) are ")    (cond ((eq result 'valid) (format s "<B>Valid</B>.</P>"))          ((eq result 'unsatisfiable) (format s "<B>Unsatisfiable</B>.</P>"))          (t (format s "<B>Satisfiable and Falsifiable</B>.</P>")))    (dolist (p sentences) (output-kif s p))    (format-end s)))(defun process-truthtable-show (s postlines)  (let (sentences constants result)    (setq sentences (read-sentences (cdr (pop postlines))))    (setq constants (get-constants sentences))    (setq result (checktruthtable (maksand sentences) constants))    (output-prolog s 200)    (format-truthtable-start s)    (format s "<P>The following sentence(s) are ")    (cond ((eq result 'valid) (format s "<B>Valid</B>.</P>"))          ((eq result 'unsatisfiable) (format s "<B>Unsatisfiable</B>.</P>"))          (t (format s "<B>Satisfiable and Falsifiable</B>.</P>")))    (dolist (p sentences) (output-kif s p))    (format s "<P>Here is the truth table:</P>")    (format-truthtable s constants (gettruthtable (maksand sentences) constants))    (format-end s)))(defun checktruthtable (p constants)  (do ((l (get-interpretations constants) (cdr l)) (flag))      ((null l) flag)      (cond ((checktruth p (car l))             (cond ((eq flag 'valid))                   ((eq flag 'satisfiable))                   ((eq flag 'unsatisfiable) (setq flag 'satisfiable))                   (t (setq flag 'valid))))            ((eq flag 'valid) (setq flag 'satisfiable))            ((eq flag 'satisfiable))            ((eq flag 'unsatisfiable))            (t (setq flag 'unsatisfiable)))))(defun gettruthtable (p constants)  (do ((l (get-interpretations constants) (cdr l)) (answer) (table) (flag))      ((null l) (nreverse table))      (setq answer (checktruth p (car l)))      (setq table (cons (nconc (nreverse (mapcar #'cdr (car l)))                               (list answer)) table))      (cond (answer             (cond ((eq flag 'valid))                   ((eq flag 'satisfiable))                   ((eq flag 'unsatisfiable) (setq flag 'satisfiable))                   (t (setq flag 'valid))))            ((eq flag 'valid) (setq flag 'satisfiable))            ((eq flag 'satisfiable))            ((eq flag 'unsatisfiable))            (t (setq flag 'unsatisfiable)))))(defun format-truthtable (s constants table)  (format s "<P><CENTER><TABLE BORDER>")  (format s "<TR>")  (dolist (x constants)    (format s "<TH>")    (format s "~A" x)    (format s "</TH>"))  (format s "<TH>")  (format s "Sentences")  (format s "</TH>")  (format s "</TR>")  (dolist (row table)    (format s "<TR>")    (dolist (col row)      (format s "<TD ALIGN=CENTER>")      (format s (if col "T" "F"))      (format s "</TD>"))    (format s "</TR>"))  (format s "</TABLE></CENTER><P>"))(defun get-constants (p)  (nreverse (getconstants p nil)))(defun getconstants (p nl)   (cond ((atom p)         (if (find p '(not and or <= => <=>)) nl (adjoin p nl)))        (t (dolist (x p) (setq nl (getconstants x nl))) nl)))(defun get-interpretations (cl)  (nreverse (getinterpretations cl nil nil)))(defun getinterpretations (cl al nl)  (cond ((null cl) (cons al nl))        (t (setq nl (getinterpretations (cdr cl) (acons (car cl) t al) nl))           (getinterpretations (cdr cl) (acons (car cl) nil al) nl))))(defun checktruth (p al)  (cond ((atom p) (cdr (assoc p al)))        ((eq 'not (car p)) (not (checktruth (cadr p) al)))        ((eq 'and (car p)) (every #'(lambda (x) (checktruth x al)) (cdr p)))        ((eq 'or (car p)) (some #'(lambda (x) (checktruth x al)) (cdr p)))        ((eq '=> (car p))         (do ((l (cdr p) (cdr l)))             ((null (cdr l)) (checktruth (car l) al))             (unless (checktruth (car l) al) (return t))))        ((eq '<= (car p))         (if (every #'(lambda (x) (checktruth x al)) (cddr p))             (checktruth (cadr p) al)             t))        ((eq '<=> (car p)) (eq (checktruth (cadr p) al) (checktruth (caddr p) al)))))(defun format-truthtable-start (s)  (format s "<HTML><HEAD></HEAD><BODY BGCOLOR=WHITE><BR><CENTER><H1>Logica Truth Table</H1></CENTER><HR>&nbsp;&nbsp;<A HREF=>Home</A>&nbsp;&nbsp;<A HREF=Truthtable?>Truth Table</A>&nbsp;&nbsp;<A HREF=Converter?>Converter</A>&nbsp;&nbsp;<A HREF=UNIFIER?>Unifier</A>&nbsp;&nbsp;<A HREF=LOGICA?>Resolution</A>&nbsp;&nbsp;<A HREF=EPILOG?>Epilog</A>&nbsp;&nbsp;<A HREF=EDITOR?>Editor</A>&nbsp;&nbsp;<HR>"));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Converter;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(defmethod process (s (file (eql 'converter)) postlines)  (let (command)    (setq command (getf-post "Command" postlines))    (cond ((null command) (output-converter-page s nil))          ((string-equal command "Skolemize")           (process-converter-skolemize s postlines))          ((string-equal command "Herbrandize")           (process-converter-herbrandize s postlines))          ((string-equal command "Conjunctive Normal Form")           (process-converter-cnf s postlines))          ((string-equal command "Disjunctive Normal Form")           (process-converter-dnf s postlines))          ((string-equal command "Forward Rule Form")           (process-converter-frf s postlines))          ((string-equal command "Backward Rule Form")           (process-converter-brf s postlines))          ((string-equal command "Contrapositives")           (process-converter-contrapositives s postlines))          ((string-equal command "Reverse Rules")           (process-converter-reverserules s postlines)))))(defun process-converter-skolemize (s postlines)  (let (sentences result)    (setq sentences (read-sentences (cdr (pop postlines))))    (setq result (mapcar #'skolemize sentences))    (output-converter-page s result)))(defun process-converter-herbrandize (s postlines)  (let (sentences result)    (setq sentences (read-sentences (cdr (pop postlines))))    (setq result (mapcar #'herbrandize sentences))    (output-converter-page s result)))(defun process-converter-cnf (s postlines)  (let (sentences result)    (setq sentences (read-sentences (cdr (pop postlines))))    (setq result (cnf (maksand sentences)))    (output-converter-page s (list result))))(defun process-converter-dnf (s postlines)  (let (sentences result)    (setq sentences (read-sentences (cdr (pop postlines))))    (setq result (dnf (maksand sentences)))    (output-converter-page s (list result))))(defun process-converter-frf (s postlines)  (let (sentences result)    (setq sentences (read-sentences (cdr (pop postlines))))    (setq result (frfs (maksand sentences)))    (output-converter-page s result)))(defun process-converter-brf (s postlines)  (let (sentences result)    (setq sentences (read-sentences (cdr (pop postlines))))    (setq result (brfs (maksand sentences)))    (output-converter-page s result)))(defun process-converter-contrapositives (s postlines)  (let (sentences result)    (setq sentences (read-sentences (cdr (pop postlines))))    (setq result (contrapositives (maksand sentences)))    (output-converter-page s result)))(defun process-converter-reverserules (s postlines)  (let (sentences result)    (setq sentences (read-sentences (cdr (pop postlines))))    (setq result (mapcar #'reverse-rule sentences))    (output-converter-page s result)))(defun output-converter-page (s sentences)  (format s "<HTML><BODY BGCOLOR=WHITE><BR><CENTER><H1>Logica Truth Table</H1></CENTER><HR>&nbsp;&nbsp;<A HREF=>Home</A>&nbsp;&nbsp;<A HREF=Truthtable?>Truth Table</A>&nbsp;&nbsp;<A HREF=Converter?>Converter</A>&nbsp;&nbsp;<A HREF=Unifier?>Unifier</A>&nbsp;&nbsp;<A HREF=LOGICA?>Resolution</A>&nbsp;&nbsp;<A HREF=EPILOG?>Epilog</A>&nbsp;&nbsp;<A HREF=EDITOR?>Editor</A>&nbsp;&nbsp;<HR><FORM ACTION=Converter? METHOD=POST><CENTER><TABLE><TR><TH VALIGN=TOP>Sentences</TH></TR><TR><TD><TEXTAREA NAME=Sentences ROWS=15 COLS=80 WRAP=SOFT>")  (dolist (p sentences) (format s (kif-to-html-string p)) (crlf s))  (format s "</TEXTAREA></TD></TR></TABLE></CENTER><BR><CENTER><TABLE><TR VALIGN=TOP><TD><INPUT TYPE=SUBMIT NAME=Command VALUE=\"Skolemize\"><BR><INPUT TYPE=SUBMIT NAME=Command VALUE=\"Herbrandize\"></TD><TD><INPUT TYPE=SUBMIT NAME=Command VALUE=\"Conjunctive Normal Form\"><BR><INPUT TYPE=SUBMIT NAME=Command VALUE=\"Forward Rule Form\"><BR><INPUT TYPE=SUBMIT NAME=Command VALUE=\"Backward Rule Form\"><BR></TD><TD><INPUT TYPE=SUBMIT NAME=Command VALUE=\"Contrapositives\"><BR><INPUT TYPE=SUBMIT NAME=Command VALUE=\"Reverse Rules\"></TD></TR></TABLE></CENTER></FORM>")  (format-end s));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Unifier;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(defmethod process (s (file (eql 'unifier)) postlines)  (let (command)    (setq command (getf-post "Command" postlines))    (cond ((null command) (process-unifier-start s))          ((string-equal command "Unify")           (process-unifier-unify s postlines)))))(defun process-unifier-start (s)  (output-prolog s 200)  (format-start s)  (format s "<FORM ACTION=UNIFIER? METHOD=POST><BR><CENTER><TABLE><TR><TH VALIGN=TOP>First Expression</TH><TD><TEXTAREA NAME=Premises ROWS=3 COLS=80 WRAP=SOFT></TEXTAREA></TD></TR><TR><TH VALIGN=TOP>Second Expression</TH><TD><TEXTAREA NAME=Question ROWS=3 COLS=80 WRAP=SOFT></TEXTAREA></TD></TR></TABLE></CENTER><BR><CENTER><INPUT TYPE=SUBMIT NAME=Command VALUE=\"Unify\"></CENTER>")  (format s "</FORM>")  (format-end s))(defun process-unifier-unify (s postlines)  (let (x y al)    (setq x (read-user-string (cdr (pop postlines))))    (setq y (read-user-string (cdr (pop postlines))))    (setq al (mgu x y))    (output-prolog s 200)    (format-start s)    (if al (format-unifier s x y al) (format-nonunifiable s x y))    (format-end s)))(defun format-start (s)  (format s "<HTML><HEAD></HEAD><BODY BGCOLOR=WHITE><BR><CENTER><H1>Logica Unifier</H1></CENTER><HR>&nbsp;&nbsp;<A HREF=>Home</A>&nbsp;&nbsp;<A HREF=Truthtable?>Truth Table</A>&nbsp;&nbsp;<A HREF=Converter?>Converter</A>&nbsp;&nbsp;<A HREF=UNIFIER?>Unifier</A>&nbsp;&nbsp;<A HREF=LOGICA?>Resolution</A>&nbsp;&nbsp;<A HREF=EPILOG?>Epilog</A>&nbsp;&nbsp;<A HREF=EDITOR?>Editor</A>&nbsp;&nbsp;<HR>"))(defun format-unifier (s x y al)  (format s "<BR>The substitution:<BR><BR><PRE>")  (dolist (pair (cdr (reverse al)))    (format s "~A = ~A<BR>" (car pair) (plug (cdr pair) al)))  (format s "</PRE>")  (format s "is a most general unifier for the expressions:<BR>")  (output-kif s x)  (output-kif s y))(defun format-nonunifiable (s x y)  (format s "<BR>The following expressions are not unifiable:<BR>")  (output-kif s x)  (output-kif s y))(defun format-end (s)  (format s "<BR><HR>")  (format s "<ADDRESS>Comments to <A HREF=\"mailto:genesereth@stanford.edu\">Michael Genesereth</A>.</ADDRESS>")  (format s "</BODY>")  (format s "</HTML>"));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Resolution;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(defparameter *subsumption* nil)(defparameter *tautology* nil)(defparameter *unit* nil)(defparameter *input* nil)(defparameter *support* nil)(defparameter *ordered* nil)(defmethod process (s (file (eql 'logica)) postlines)  (let (command)    (setq command (getf-post "Command" postlines))    (cond ((null command) (process-logica-start s))          ((string-equal command "Show Search")           (process-logica-search s postlines))          ((string-equal command "Show Proof")           (process-logica-proof s postlines))          ((string-equal command "Show Result")           (process-logica-result s postlines)))))(defun process-logica-start (s)  (format s "<HTML><BODY BGCOLOR=WHITE><BR><CENTER><H1>Logica Resolution</H1></CENTER><HR>&nbsp;&nbsp;<A HREF=>Home</A>&nbsp;&nbsp;<A HREF=Truthtable?>Truth Table</A>&nbsp;&nbsp;<A HREF=Converter?>Converter</A>&nbsp;&nbsp;<A HREF=Unifier?>Unifier</A>&nbsp;&nbsp;<A HREF=LOGICA?>Resolution</A>&nbsp;&nbsp;<A HREF=EPILOG?>Epilog</A>&nbsp;&nbsp;<A HREF=EDITOR?>Editor</A>&nbsp;&nbsp;<HR><FORM ACTION=LOGICA? METHOD=POST><CENTER><TABLE><TR><TH VALIGN=TOP>Premises</TH><TD><TEXTAREA NAME=Premises ROWS=15 COLS=80 WRAP=SOFT></TEXTAREA></TD></TR><TR><TH VALIGN=TOP>Conclusion</TH><TD><TEXTAREA NAME=Question ROWS=5 COLS=80 WRAP=SOFT></TEXTAREA></TD></TR><TR><TH VALIGN=TOP>Strategy</TH><TD><INPUT TYPE=CHECKBOX NAME=Subsumption> Forward Subsumption<BR><INPUT TYPE=CHECKBOX NAME=Tautology> Tautology Elimination<BR><INPUT TYPE=CHECKBOX NAME=Unit> Unit Restriction<BR><INPUT TYPE=CHECKBOX NAME=Input> Input Restriction<BR><INPUT TYPE=CHECKBOX NAME=Support> Set of Support Restriction<BR><INPUT TYPE=CHECKBOX NAME=Ordered> Ordered Resolution<BR></TD></TR><TR><TH VALIGN=TOP>Limit</TH><TD><INPUT TYPE=TEXT NAME=End VALUE=20 SIZE=5> steps (Max 10000)</TD></TR></TABLE></CENTER><BR><CENTER><INPUT TYPE=SUBMIT NAME=Command VALUE=\"Show Result\"><INPUT TYPE=SUBMIT NAME=Command VALUE=\"Show Proof\"><INPUT TYPE=SUBMIT NAME=Command VALUE=\"Show Search\"></CENTER></FORM>")  (format-end s))(defun process-logica-search (s postlines)  (let (premises conclusion proof end *inferences*        *subsumption* *tautology* *unit* *input* *support* *ordered*)    (setq premises (read-sentences (cdr (pop postlines))))    (setq conclusion (or (read-user-string (cdr (pop postlines))) 'false))    (setq *subsumption* (if (read-value-string (getf-post "Subsumption" postlines)) t))    (setq *tautology* (if (read-value-string (getf-post "Tautology" postlines)) t))    (setq *unit* (if (read-value-string (getf-post "Unit" postlines)) t))    (setq *input* (if (read-value-string (getf-post "Input" postlines)) t))    (setq *support* (if (read-value-string (getf-post "Support" postlines)) t))    (setq *ordered* (if (read-value-string (getf-post "Ordered" postlines)) t))    (setq end (read-value-string (getf-post "End" postlines)))    (output-prolog s 200)    (format s "<HTML>")    (format s "<BODY BGCOLOR=WHITE>")    (format s "<HR><CENTER><H1>Result</H1></CENTER><HR><BR>")    (setq premises (mapcan #'makclauses premises))    (setq conclusion (makclauses (maknot conclusion)))    (setq end (if (numberp end) (min end 10000) 20))    (setq proof (logica premises conclusion end))    (setq *inferences* (length proof))    (output-proof s proof)    (format s "<BR><HR>")    (format s "<ADDRESS>Comments to <A HREF=\"mailto:genesereth@stanford.edu\">Michael Genesereth</A>.</ADDRESS>")    (format s "</BODY>")    (format s "</HTML>")))(defun process-logica-proof (s postlines)  (let (premises conclusion proof end *inferences*        *subsumption* *tautology* *unit* *input* *support* *ordered*)    (setq premises (read-sentences (cdr (pop postlines))))    (setq conclusion (or (read-user-string (cdr (pop postlines))) 'false))    (setq *subsumption* (if (read-value-string (getf-post "Subsumption" postlines)) t))    (setq *tautology* (if (read-value-string (getf-post "Tautology" postlines)) t))    (setq *unit* (if (read-value-string (getf-post "Unit" postlines)) t))    (setq *input* (if (read-value-string (getf-post "Input" postlines)) t))    (setq *support* (if (read-value-string (getf-post "Support" postlines)) t))    (setq *ordered* (if (read-value-string (getf-post "Ordered" postlines)) t))    (setq end (read-value-string (getf-post "End" postlines)))    (output-prolog s 200)    (format s "<HTML>")    (format s "<BODY BGCOLOR=WHITE>")    (format s "<HR><CENTER><H1>Result</H1></CENTER><HR><BR>")    (setq premises (mapcan #'makclauses premises))    (setq conclusion (makclauses (maknot conclusion)))    (setq end (if (numberp end) (min end 10000) 20))    (setq proof (logica premises conclusion end))    (setq *inferences* (length proof))    (if (find '(or) proof :key #'sentence :test #'equal)        (output-proof s (pruneproof proof))        (format s "<P>Failure after ~A steps.</P>" *inferences*))    (format s "<BR><HR>")    (format s "<ADDRESS>Comments to <A HREF=\"mailto:genesereth@stanford.edu\">Michael Genesereth</A>.</ADDRESS>")    (format s "</BODY>")    (format s "</HTML>")))(defun process-logica-result (s postlines)  (let (premises conclusion proof end         *subsumption* *tautology* *unit* *input* *support* *ordered*)    (setq premises (read-sentences (cdr (pop postlines))))    (setq conclusion (or (read-user-string (cdr (pop postlines))) 'false))    (setq *subsumption* (if (read-value-string (getf-post "Subsumption" postlines)) t))    (setq *tautology* (if (read-value-string (getf-post "Tautology" postlines)) t))    (setq *unit* (if (read-value-string (getf-post "Unit" postlines)) t))    (setq *input* (if (read-value-string (getf-post "Input" postlines)) t))    (setq *support* (if (read-value-string (getf-post "Support" postlines)) t))    (setq *ordered* (if (read-value-string (getf-post "Ordered" postlines)) t))    (setq end (read-value-string (getf-post "End" postlines)))    (output-prolog s 200)    (format s "<HTML>")    (format s "<BODY BGCOLOR=WHITE>")    (format s "<HR><CENTER><H1>Result</H1></CENTER><HR><BR>")    (setq premises (mapcan #'makclauses premises))    (setq conclusion (makclauses (maknot conclusion)))    (setq end (if (numberp end) (min end 10000) 20))    (setq proof (logica premises conclusion end))    (if (find '(or) proof :key #'sentence :test #'equal)        (format s "<P>Success after ~A steps.</P>" (length proof))        (format s "<P>Failure after ~A steps.</P>" (length proof)))    (format s "<BR><HR>")    (format s "<ADDRESS>Comments to <A HREF=\"mailto:genesereth@stanford.edu\">Michael Genesereth</A>.</ADDRESS>")    (format s "</BODY>")    (format s "</HTML>")))(defclass conclusion ()  ((sequence :accessor sequence :initarg :sequence :initform 1)   (sentence :accessor sentence :initarg :sentence :initform 'false)   (positive :accessor positive :initarg :positive :initform nil)   (negative :accessor negative :initarg :negative :initform nil)))(defun makeconclusion (s p n)  (make-instance 'conclusion :sentence s :positive p :negative n))(defun makclauses (p)  (mapcar #'(lambda (x) (cons 'or x)) (clausesets p)))(defun output-proof (s proof)  (format-proof s (convertproof proof)))(defun convertproof (proof)  (do ((l proof (cdr l)) (step 1 (1+ step)) (dum) (nl))      ((null l) (nreverse nl))      (setf (sequence (car l)) step)      (cond ((symbolp (positive (car l)))             (setq dum (list step (sentence (car l)) (positive (car l)))))            (t (setq dum (list step (sentence (car l))                               (sequence (positive (car l)))                               (sequence (negative (car l)))))))      (setq nl (cons dum nl))))(defun pruneproof (proof)  (markproof (car (last proof)))  (do ((l proof (cdr l)) (nl))      ((null l) (nreverse nl))      (when (equal (sequence (car l)) 0) (setq nl (cons (car l) nl)))))(defun markproof (node)  (cond ((equal (sequence node) 0))        (t (setf (sequence node) 0)           (when (typep (positive node) 'conclusion)             (markproof (positive node))             (markproof (negative node))))))(defun logica (premises conclusions end)  (do ((l premises (cdr l)) (nl))      ((null l) (setq premises (nreverse nl)))      (setq nl (cons (makeconclusion (car l) 'premise nil) nl)))  (do ((l conclusions (cdr l)) (nl))      ((null l) (setq conclusions (nreverse nl)))      (setq nl (cons (makeconclusion (car l) 'goal nil) nl)))  (cond (*input* (runinput premises conclusions end))        (t (runregular premises conclusions end))))(defun runinput (premises conclusions end)  (setq premises (nconc premises conclusions))  (unless *support* (setq conclusions premises))  (do ((l premises (cdr l)) (copy (copy-list premises))       (flag) (step (length premises)))      ((null l) premises)      (when (or flag (>= step end)) (return premises))      (do ((m copy (cdr m)))          ((null m))          (when (or flag (>= step end)) (return t))          (dolist (result (newresolve (car l) (car m)))            (unless (find (sentence result) premises :key #'sentence :test #'similarp)              (setq premises (nconc premises (list result)))              (setq step (1+ step)))            (cond ((equal (sentence result) '(or)) (setq flag t) (return t))                  ((>= step end) (return t)))))))(defun runregular (premises conclusions end)  (setq premises (nconc premises conclusions))  (unless *support* (setq conclusions premises))  (do ((l conclusions (cdr l)) (flag) (step (length premises)))      ((null l) premises)      (when (or flag (>= step end)) (return premises))      (do ((m premises (cdr m)))          ((eq m (cdr l)))          (when (or flag (>= step end)) (return t))          (dolist (result (newresolve (car l) (car m)))            (unless (find (sentence result) premises :key #'sentence :test #'similarp)              (setq premises (nconc premises (list result)))              (setq step (1+ step)))            (cond ((equal (sentence result) '(or)) (setq flag t) (return t))                  ((>= step end) (return t)))))))(defun newresolve (p q)  (let (results)    (cond ((and *unit* (not (or (unitp (sentence p)) (unitp (sentence q)))))           (setq results nil))          (*ordered* (setq results (newordered (sentence p) (sentence q))))          (t (setq results (newresolution (sentence p) (sentence q)))))    (do ((l results (cdr l)) (nl))        ((null l) (nreverse nl))        (setq nl (cons (makeconclusion (car l) q p) nl)))))(defun newresolution (p q)  (do ((l (cdr p) (cdr l)) (al (environment)) (bl (environment)) (result) (nl))      ((null l) (nreverse nl))      (do ((m (cdr q) (cdr m)))          ((null m))          (when (unify (maknot (car m)) bl (car l) al)            (setq result (newresolvent (remove (car m) (cdr q) :test #'eq) bl                                       (remove (car l) (cdr p) :test #'eq) al))            (setf (alist al) nil)            (setf (alist bl) nil)            (cond ((and *tautology* (tautologyp result)))                  (t (setq nl (adjoin result nl :test #'equal))))))))(defun newresolvent (x alist y bl)  (setq x (newplugstdexp x alist) y (newplugstdexp y bl))  (cons 'or (unionize x y)))(defun newordered (p q)  (let ((al (environment)) (bl (environment)) result)    (cond ((null (cdr p)) nil)          ((null (cdr q)) nil)          ((unify (maknot (cadr q)) bl (cadr p) al)           (setq result (newresolvent (remove (cadr q) (cdr q) :test #'eq) bl                                      (remove (cadr p) (cdr p) :test #'eq) al))           (setf (alist al) nil)           (setf (alist bl) nil)           (cond ((and *tautology* (tautologyp result)) nil)                 (t (list result)))))))(defun enderton (p q)  (do ((l (cdr p) (cdr l)) (result) (nl))      ((null l) (nreverse nl))      (do ((m (cdr q) (cdr m)))          ((null m))          (when (equal (car l) (maknot (car m)))            (setq result (maksor (unionize (remove (car l) (cdr p) :test #'eq)                                           (remove (car m) (cdr q) :test #'eq))))            (cond ((and *tautology* (tautologyp result)))                  (t (setq nl (adjoin result nl :test #'equal))))))))(defun newplugstdexp (x al)  (cond ((indvarp x) (newplugstdexpindvar x al))	((atom x) x)	((eq 'quote (car x)) x)	(t (newplugstdexpcdr x al))))(defun newplugstdexpcdr (x al)  (do ((l x (cdr l)) (nl))      ((null l) (nreverse nl))      (if (seqvarp (car l))          (return (nreconc nl (newplugstdexpseqvar (car l) al)))          (setq nl (cons (newplugstdexp (car l) al) nl)))))(defun newplugstdexpindvar (x al)  (let (dum)    (cond ((eq '?* x) '?*)          ((setq dum (getbdg x al))           (cond ((cddr dum) (newplugstdexp (cadr dum) (cddr dum)))                 ((eq alist al) x)                 ((cdr dum) (cadr dum))                 (t (setoldbdg dum (gentemp "?") alist))))          ((eq alist al) x)	  (t (setnewbdg x al (gentemp "?") alist)))))(defun newplugstdexpseqvar (x al)  (let (dum)    (cond ((eq '@* x) (list x))          ((setq dum (getbdg x al))           (cond ((cddr dum) (newplugstdexpcdr (cadr dum) (cddr dum)))                 ((eq alist al) (list x))                 ((cdr dum) (cadr dum))                 (t (setoldbdg dum (list (gentemp "@")) nil))))          ((eq alist al) (list x))          (t (setnewbdg x al (list (gentemp "@")) nil)))))(defun runit (premises step end)  (do ((l premises (cdr l)) (i 1 (1+ i)))      ((or (null l) (>= step end)))      (do ((m premises (cdr m)) (j 1 (1+ j)))          ((or (eq m (cdr l)) (>= step end)))          (dolist (result (resolve (car l) (car m)))            (cond ((>= step end))                  ((find result premises :test #'equalp))                  (t (setq premises (nconc premises (list result)))                     (format-step *stream* (incf step) result (format nil "~A, ~A" j i))))))))(defun format-step (s num step just)  (let ((*print-case* :downcase))    (format s "<TR><TH HALIGN=RIGHT>~A.</TH>" num)    (format s "<TD><TT>~A</TT></TD>" step)    (format s "<TD>~A</TD></TR>" just)))(defun resolve (p q)  (unless (and (listp p) (eq 'or (car p))) (setq p (list 'or p)))  (unless (and (listp q) (eq 'or (car q))) (setq q (list 'or q)))  (cond ((and *unit* (not (or (unitp p) (unitp q)))) nil)        (*ordered* (ordered p q))        (t (resolution p q))))(defun resolution (p q)  (setq q (stdize q))  (do ((l (cdr p) (cdr l)) (al) (result) (nl))      ((null l) (nreverse nl))      (do ((m (cdr q) (cdr m)))          ((null m))          (when (setq al (mgu (car l) (maknot (car m))))            (setq result (maksor (unionize (remove (car l) (cdr p) :test #'equal)                                           (remove (car m) (cdr q) :test #'equal))))            (setq result (decolonize (plug result al)))            (cond ((and *tautology* (tautologyp result)))                  (t (setq nl (adjoin result nl :test #'equalp))))))))(defun ordered (p q)  (let (al result)    (unless (and (listp p) (eq 'or (car p))) (setq p (list 'or p)))    (unless (and (listp q) (eq 'or (car q))) (setq q (list 'or q)))    (setq q (stdize q))    (cond ((null (cdr p)) nil)          ((null (cdr q)) nil)          ((setq al (mgu (cadr p) (maknot (cadr q))))           (setq result (maksor (unionize (cddr p) (cddr q))))           (setq result (decolonize (plug result al)))           (cond ((and *tautology* (tautologyp result)) nil)                 (t (list result)))))))(defun tautologyp (x)  (cond ((atom x) nil)        ((eq 'not (car x)) nil)        ((eq 'or (car x))         (do ((l (cdr x) (cdr l)))             ((null l) nil)             (when (find (maknot (car l)) (cdr l) :test #'equalp)               (return t))))))(defun unitp (x)  (cond ((atom x))        ((eq 'not (car x)))        ((eq 'or (car x)) (null (cddr x)))));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Epilog;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(defparameter *contrapositives* nil)(setq *limit* 10000)(defmethod process (s (file (eql 'epilog)) postlines)  (let (command)    (setq command (getf-post "Command" postlines))    (cond ((null command) (process-epilog-start s))          ((string-equal command "Show Proof")           (process-epilog-proof s postlines))          ((string-equal command "Show Result")           (process-epilog-result s postlines))          ((string-equal command "Show Search")           (process-epilog-search s postlines)))))(defun process-epilog-start (s)  (format s "<HTML><BODY BGCOLOR=WHITE><BR><CENTER><H1>Logica Epilog</H1></CENTER><HR>&nbsp;&nbsp;<A HREF=>Home</A>&nbsp;&nbsp;<A HREF=Truthtable?>Truth Table</A>&nbsp;&nbsp;<A HREF=Converter?>Converter</A>&nbsp;&nbsp;<A HREF=Unifier?>Unifier</A>&nbsp;&nbsp;<A HREF=LOGICA?>Resolution</A>&nbsp;&nbsp;<A HREF=EPILOG?>Epilog</A>&nbsp;&nbsp;<A HREF=EDITOR?>Editor</A>&nbsp;&nbsp;<HR><FORM ACTION=EPILOG? METHOD=POST><CENTER><TABLE><TR><TH VALIGN=TOP>Premises</TH><TD><TEXTAREA NAME=Premises ROWS=15 COLS=80 WRAP=SOFT></TEXTAREA></TD></TR><TR><TH VALIGN=TOP>Conclusion</TH><TD><TEXTAREA NAME=Question ROWS=5 COLS=80 WRAP=SOFT></TEXTAREA></TD></TR><TR><TH VALIGN=TOP>Strategy</TH><TD><INPUT TYPE=CHECKBOX NAME=Contrapositives> Contrapositives<BR><INPUT TYPE=CHECKBOX NAME=Ancestry> Ancestry Filtering</TD></TR><TR><TH VALIGN=TOP>Depth</TH><TD><INPUT TYPE=TEXT NAME=Depth VALUE=5 SIZE=5></TD></TR></TABLE><BR><INPUT TYPE=SUBMIT NAME=Command VALUE=\"Show Result\"><INPUT TYPE=SUBMIT NAME=Command VALUE=\"Show Proof\"><INPUT TYPE=SUBMIT NAME=Command VALUE=\"Show Search\"></CENTER></FORM>")  (format-end s))(defun process-epilog-proof (s postlines)  (let (premises conclusion proof        *termination* *inferences* *ancestry* *contrapositives* *depth*)    (setq premises (read-sentences (cdr (pop postlines))))    (setq conclusion (or (read-user-string (cdr (pop postlines))) 'false))    (setq *ancestry* (if (read-value-string (getf-post "Ancestry" postlines)) t))    (setq *contrapositives* (if (read-value-string (getf-post "Contrapositives" postlines)) t))    (setq *depth* (or (read-value-string (getf-post "Depth" postlines)) 5))    (output-prolog s 200)    (format s "<HTML>")    (format s "<BODY BGCOLOR=WHITE>")    (format s "<HR><CENTER><H1>Result</H1></CENTER><HR><BR>")    (if (setq proof (epilog premises conclusion))        (format-epilog s proof)        (format s "<P>Failure after ~A step(s).</P>" *inferences*))    (format s "<BR><HR>")    (format s "<ADDRESS>Comments to <A HREF=\"mailto:genesereth@stanford.edu\">Michael Genesereth</A>.</ADDRESS>")    (format s "</BODY>")    (format s "</HTML>")))(defun process-epilog-result (s postlines)  (let (premises conclusion        *termination* *inferences* *ancestry* *contrapositives* *depth*)    (setq premises (read-sentences (cdr (pop postlines))))    (setq conclusion (or (read-user-string (cdr (pop postlines))) 'false))    (setq *ancestry* (if (read-value-string (getf-post "Ancestry" postlines)) t))    (setq *contrapositives* (if (read-value-string (getf-post "Contrapositives" postlines)) t))    (setq *depth* (or (read-value-string (getf-post "Depth" postlines)) 5))    (output-prolog s 200)    (format s "<HTML>")    (format s "<BODY BGCOLOR=WHITE>")    (format s "<HR><CENTER><H1>Result</H1></CENTER><HR><BR>")    (if (epilog premises conclusion)        (format s "<P>Success after ~A step(s).</P>" *inferences*)        (format s "<P>Failure after ~A step(s).</P>" *inferences*))    (format s "<BR><HR>")    (format s "<ADDRESS>Comments to <A HREF=\"mailto:genesereth@stanford.edu\">Michael Genesereth</A>.</ADDRESS>")    (format s "</BODY>")    (format s "</HTML>")))(defun process-epilog-search (s postlines)  (let (premises conclusion proof        *termination* *inferences* *ancestry* *contrapositives* *depth*)    (setq premises (read-sentences (cdr (pop postlines))))    (setq conclusion (or (read-user-string (cdr (pop postlines))) 'false))    (setq *ancestry* (if (read-value-string (getf-post "Ancestry" postlines)) t))    (setq *contrapositives* (if (read-value-string (getf-post "Contrapositives" postlines)) t))    (setq *depth* (or (read-value-string (getf-post "Depth" postlines)) 5))    (output-prolog s 200)    (format s "<HTML>")    (format s "<BODY BGCOLOR=WHITE>")    (format s "<HR><CENTER><H1>Result</H1></CENTER><HR><BR>")    (setq proof (episearch premises conclusion))    (format-trace s proof)    (format s "<BR><HR>")    (format s "<ADDRESS>Comments to <A HREF=\"mailto:genesereth@stanford.edu\">Michael Genesereth</A>.</ADDRESS>")    (format s "</BODY>")    (format s "</HTML>")))(defun epilog (premises conclusion)  (let (proof *theory*)    (setq *theory* (make-instance 'theory))    (when *contrapositives*      (setq premises (nconc premises (list (maknot conclusion))))      (setq premises (contrapositives (maksand premises))))    (dolist (x premises) (save x *theory*))    (setq proof (ignore-errors       (cond ((atom conclusion) (newerfindp conclusion *theory*))            ((eq (car conclusion) 'or) (neweror conclusion *theory*))            (t (newerfindp conclusion *theory*)))))    (empty *theory*)    proof))(defun neweror (p th)  (do ((l (cdr p) (cdr l)) (dum))      ((null l) nil)      (when (setq dum (newerfindp (car l) th)) (return dum))))(defun newerfindp (p th) (let (proof)    (when (setq proof (newerstart p th))      (newerconvert (cons (list `(query ,p) 'goal) (butlast proof))))))(defun newerstart (p *theory*)  (let ((alist (environment)))    (setq *unifications* 0)    (setq *inferences* (length (contents *theory*)))    (setq *termination* nil)    (cond ((atom p) (newerfind p (list p) alist 0 nil))          ((eq (car p) 'and) (newerexit p alist 0 nil))          (t (newerfind p (list p) alist 0 nil)))))(defun newerfind (p pl al depth cont)  (setq *inferences* (1+ *inferences*))  (cond ((>= *inferences* *limit*) (setq *termination* t) nil)        ((> depth *depth*) nil)        ((and *ancestry* (newerancestor p al cont)) nil)        ((newerreduce p pl al depth cont))        (*termination* nil)        (t (newerfindth p pl al depth cont))))(defun newerreduce (p pl al depth cont)  (do ((l cont (cdr l)) (new (cons (list pl al depth) cont))       (ol) (dum) (red) (goal) (proof))      ((null l))      (when (setq ol (unify (maknot (caaar l)) (cadar l) p al))        (cond ((setq proof (newerexit pl al depth cont))               (setq dum (newersubgoal new))               (backup ol)               (setq red (newerclause l))               (setq goal (newerclause new))               (return (cons (list dum goal red) proof)))              (*termination* (backup ol) (return nil))              (t (backup ol))))))(defun newerfindth (p pl al depth cont)  (do ((l (envindexps p al *theory*) (cdr l)) (bl (environment)) (ol)       (new (cons (list pl al depth) cont)) (goal) (dum) (proof))      ((null l))      (cond ((setq ol (unify (car l) bl p al))             (cond ((setq proof (newerexit pl al depth cont))                    (setq dum (newersubgoal new))                    (backup ol)                    (setq goal (newerclause new))                    (return (cons (list dum goal (car l)) proof)))                   (*termination* (backup ol) (return nil))                   (t (backup ol))))            ((and (listp (car l)) (eq '<= (caar l))                  (setq ol (unify (cadar l) bl p al)))             (cond ((setq proof (newerexit (cdar l) bl (1+ depth) new))                    (setq dum (newersubgoal (cons (list (cdar l) bl) new)))                    (backup ol)                    (setq goal (newerclause new))                    (return (cons (list dum goal (car l)) proof)))                   (*termination* (backup ol) (return nil))                   (t (backup ol)))))))(defun newerancestor (p al cont)  (do ((l cont (cdr l)))      ((null l) nil)      (if (identify (caaar l) (cadar l) p al) (return t))))(defun newerexit (pl al depth cont)  (cond ((cdr pl) (newerfind (cadr pl) (cdr pl) al depth cont))        ((null cont) (setq *inferences* (1+ *inferences*)) (list 'proof))        (t (newerexit (caar cont) (cadar cont) (caddar cont) (cdr cont)))))(defun newersubgoal (cont)  (do ((l cont (cdr l)) (nl))      ((null l) `(query ,(maksand (nreverse nl))))      (do ((m (cdaar l) (cdr m)) (al (cadar l)))          ((null m))          (setq nl (cons (plugstdexp (car m) al) nl)))))(defun newerclause (cont)  (do ((l cont (cdr l)) (nl (list (plugstdexp (caaar cont) (cadar cont)))))      ((null l) `(query ,(maksand (nreverse nl))))      (do ((m (cdaar l) (cdr m)) (al (cadar l)))          ((null m))          (setq nl (cons (plugstdexp (car m) al) nl)))))(defun newerconvert (proof)  (do* ((l proof (cdr l)) (nl (newerpremises proof))        (step (1+ (length nl)) (1+ step)))       ((null l) (nreverse nl))       (cond ((eq (cadar l) 'goal)              (setq nl (cons (list step (caar l) 'goal) nl)))             (t (do ((m (cdar l) (cdr m)) (dum) (nm))                    ((null m)                     (setq nl (cons (cons step (cons (caar l) (nreverse nm))) nl)))                    (cond ((setq dum (find (car m) nl :key #'cadr :test #'samep))                           (setq nm (cons (car dum) nm)))                          (t (setq nm (cons '? nm)))))))))(defun newerconvert (proof)  (do* ((l proof (cdr l)) (nl (newerpremises proof)) (dum)        (step (1+ (length nl)) (1+ step)))       ((null l) (nreverse nl))       (cond ((eq (cadar l) 'goal) (setq dum (list step (caar l) 'goal)))             ((eq (cadar l) 'premise) (setq dum (list step (caar l) 'premise)))             ((setq dum (find (caddar l) nl :key #'cadr :test #'equal))              (setq dum (list step (caar l) (1- step) (car dum))))             (t (setq dum (list step (caar l) (1- step) '?))))       (setq nl (cons dum nl))))(defun newerpremises (proof)  (do ((l proof (cdr l)) (step 1) (nl))      ((null l) nl)      (cond ((eq (cadar l) 'goal))            ((and (listp (caddar l)) (eq (caaddar l) 'query)))            ((find (caddar l) nl :key #'cadr :test #'equal))            (t (setq nl (cons (list step (caddar l) 'premise) nl))               (setq step (1+ step))))))(defun prproof (proof s)  (dolist (x proof)    (when (listp x)      (fresh-line s) (princ x s))))(defparameter *proof* nil)(defun episearch (premises conclusion)  (let (proof *theory*)    (setq *theory* (make-instance 'theory))    (when *contrapositives*      (setq premises (nconc premises (list (maknot conclusion))))      (setq premises (contrapositives (maksand premises))))    (dolist (x premises) (save x *theory*))    (setq proof (ignore-errors       (cond ((atom conclusion) (newestfindp conclusion *theory*))            ((eq (car conclusion) 'or) (newestor conclusion *theory*))            (t (newestfindp conclusion *theory*)))))    (empty *theory*)    proof))(defun newestor (p th)  (do ((l (cdr p) (cdr l)) (dum))      ((null l) nil)      (when (setq dum (newestfindp (car l) th)) (return dum))))(defun newestfindp (p th) (let (*proof*)    (neweststart p th)    (newestconvert (cons (list `(query ,p) 'goal) (nreverse *proof*)))))(defun neweststart (p *theory*)  (let ((alist (environment)))    (setq *unifications* 0)    (setq *inferences* (length (contents *theory*)))    (setq *termination* nil)    (cond ((atom p) (newestfind p (list p) alist 0 nil))          ((eq (car p) 'and) (newestexit p alist 0 nil))          (t (newestfind p (list p) alist 0 nil)))))(defun newestfind (p pl al depth cont)  (setq *inferences* (1+ *inferences*))  (cond ((>= *inferences* *limit*) (setq *termination* t) nil)        ((> depth *depth*) nil)        ((and *ancestry* (newerancestor p al cont)) nil)        ((newestreduce p pl al depth cont))        (*termination* nil)        (t (newestfindth p pl al depth cont))))(defun newestreduce (p pl al depth cont)  (do ((l cont (cdr l)) (new (cons (list pl al depth) cont))       (ol) (dum) (red) (goal))      ((null l))      (setq goal (newerclause new))      (when (setq ol (unify (maknot (caaar l)) (cadar l) p al))        (setq dum (newersubgoal new))        (setq red (newerclause l))        (setq *proof* (cons (list dum goal red) *proof*))        (cond ((newestexit pl al depth cont)               (backup ol)               (return t))              (*termination* (backup ol) (return nil))              (t (backup ol))))))(defun newestfindth (p pl al depth cont)  (do ((l (envindexps p al *theory*) (cdr l)) (bl (environment)) (ol)       (new (cons (list pl al depth) cont)) (goal) (dum))      ((null l))      (setq goal (newerclause new))      (cond ((setq ol (unify (car l) bl p al))             (setq dum (newersubgoal new))             (setq *proof* (cons (list dum goal (car l)) *proof*))             (cond ((newestexit pl al depth cont)                    (backup ol)                    (return t))                   (*termination* (backup ol) (return nil))                   (t (backup ol))))            ((and (listp (car l)) (eq '<= (caar l))                  (setq ol (unify (cadar l) bl p al)))             (setq dum (newersubgoal (cons (list (cdar l) bl) new)))             (setq *proof* (cons (list dum goal (car l)) *proof*))             (cond ((newestexit (cdar l) bl (1+ depth) new)                    (backup ol)                    (return t))                   (*termination* (backup ol) (return nil))                   (t (backup ol)))))))(defun newestexit (pl al depth cont)  (cond ((cdr pl) (newestfind (cadr pl) (cdr pl) al depth cont))        ((null cont) (setq *inferences* (1+ *inferences*)) (list 'proof))        (t (newestexit (caar cont) (cadar cont) (caddar cont) (cdr cont)))))(defun newestconvert (proof)  (do* ((l proof (cdr l)) (nl (newestpremises *theory*)) (left) (right)        (step (1+ (length nl)) (1+ step)))       ((null l) (nreverse nl))       (cond ((eq (cadar l) 'goal) (setq left 'goal))             ((eq (cadar l) 'premise) (setq left 'premise))             ((setq left (find (cadar l) nl :key #'cadr :test #'equal))              (setq left (car left)))             (t (setq left '?)))       (cond ((setq right (find (caddar l) nl :key #'cadr :test #'equal))              (setq right (car right)))             (t (setq right '?)))       (setq nl (cons (list step (caar l) left right) nl))))(defun newestpremises (th)  (do ((l (contents th) (cdr l)) (step 1 (1+ step)) (nl))      ((null l) nl)      (setq nl (cons (list step (car l) 'premise) nl))))(defun oldfindp (p *theory*)  (oldfind p 0 nil))(defun oldfind (p depth stack)  (cond ((> depth *depth*) (setq *termination* t) nil)        ((atom p) (oldfindth p nil depth stack))        ((eq 'and (car p))         (if (null (cdr p)) (list 'proof)             (oldfindth (cadr p) (cddr p) depth stack)))        (t (oldfindth p nil depth stack))))(defun oldfindth (p pl depth stack)  (do ((l (indexps p *theory*) (cdr l)) (al (environment)) (bl (environment)) (dum))      ((null l))      (cond ((unify (car l) bl p al)             (cond ((setq dum (oldfind (plug (cons 'and pl) al) depth stack))                    (return (cons (list (plug p al) (car l)) dum)))                   (t (setf (alist al) nil) (setf (alist bl) nil))))            ((and (listp (car l)) (eq '<= (caar l)) (unify (cadar l) bl p al))             (setq dum (newgoals (cddar l) bl pl al))             (cond ((setq dum (oldfind dum (1+ depth) stack))                    (return (cons (list (plug p al) (car l)) dum)))                   (t (setf (alist al) nil) (setf (alist bl) nil)))))))(defun newgoals (x alist y bl)  (setq x (newplugstdexp x alist) y (newplugstdexp y bl))  (cons 'and (append x y)));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Editor;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(defmethod process (s (file (eql 'editor)) postlines)  (let (command)    (setq command (getf-post "Command" postlines))    (format t "~A" postlines)    (cond ((null command) (process-editor-start s))          ((string-equal command "Add Row")           (process-editor-add s postlines))          ((string-equal command "Delete Row")           (process-editor-delete s postlines))          ((string-equal command "Check Proof")           (process-editor-check s postlines))          ((string-equal command "Clean Proof")           (process-editor-clean s postlines)))))(defun process-editor-start (s)  (output-prolog s 200)  (format-open s)  (format-sketch s nil)  (format-close s))(defun process-editor-add (s postlines)  (let (selection proof before after)    (setq selection (read-user-string (getf-post "Selection" postlines)))    (setq proof (readsketch postlines))    (setq before (subseq proof 0 selection))    (setq after (nthcdr selection proof))    (dolist (step after)      (rplaca step (1+ (car step)))      (when (and (numberp (caddr step)) (> (caddr step) selection))        (rplaca (cddr step) (1+ (caddr step))))      (when (and (numberp (cadddr step)) (> (cadddr step) selection))        (rplaca (cdddr step) (1+ (cadddr step)))))    (setq proof (nconc before (cons (list (1+ selection) nil) after)))    (output-prolog s 200)    (format-open s)    (format-sketch s proof)    (format-close s)))(defun process-editor-delete (s postlines)  (let (selection proof before after)    (setq selection (1- (read-user-string (getf-post "Selection" postlines))))    (setq proof (readsketch postlines))    (when (>= selection 0)      (setq before (subseq proof 0 selection))      (setq after (nthcdr selection proof))      (dolist (step after)        (rplaca step (1- (car step)))        (when (and (numberp (caddr step)) (> (caddr step) selection))          (rplaca (cddr step) (1- (caddr step))))        (when (and (numberp (cadddr step)) (> (cadddr step) selection))          (rplaca (cdddr step) (1- (cadddr step)))))      (setq proof (nconc before (cdr after))))    (output-prolog s 200)    (format-open s)    (format-sketch s proof)    (format-close s)))(defun process-editor-check (s postlines)  (let (proof answer)    (setq proof (readproof postlines))    (format t "~A" proof)    (output-prolog s 200)    (format-open s)    (cond ((eq (setq answer (checkproof proof)) t)           (format-sketch s proof)           (format-close s))          (t (format s "<BR>~A<BR>" answer)             (format s "</BODY></HTML>")))))(defun process-editor-clean (s postlines)  (let (proof)    (setq proof (readproof postlines))    (output-prolog s 200)    (format-open s)    (format-proof s proof)    (format s "</BODY></HTML>")))(defun checkproof (proof)  (do ((l proof (cdr l)) (i 1 (1+ i)) (left) (right) (results))      ((null l) t)      (setq left (caddar l) right (cadddar l))      (cond ((or (eq left 'premise) (eq left 'goal)))            ((or (eq right 'premise) (eq right 'goal)))            ((or (null left) (null right))             (return (format nil "Missing justification in line ~A." i)))            ((null (cadar l))             (setq results (newresolution (clause proof left) (clause proof right)))             (cond ((null results)                    (return (format nil "Bad inference in line ~A." i)))                   (t (rplaca (cdar l) (car results))                      (dolist (x (cdr results))                        (addrow proof i)                        (setq l (cdr l))                        (rplaca (cdar l) x)                        (rplacd (cdar l) (list left right))))))            ((find (cons 'or (car (clausesets (cadar l))))                   (newresolution (clause proof left) (clause proof right))                   :test #'samesetp))            (t (return (format nil "No inference in line ~A." i))))))(defun addrow (proof n)  (cond ((= n 0) (setq proof (cons (list 1 nil) proof)))        (t (do ((l proof (cdr l)) (i 1 (1+ i)))               ((null l))               (when (= i n)                 (rplacd l (cons (list (1+ i) nil) (cdr l)))                 (return t)))))  (dolist (step (nthcdr (1+ n) proof))    (rplaca step (1+ (car step)))    (when (and (numberp (caddr step)) (> (caddr step) n))      (rplaca (cddr step) (1+ (caddr step))))    (when (and (numberp (cadddr step)) (> (cadddr step) n))      (rplaca (cdddr step) (1+ (cadddr step)))))  proof)(defun clause (proof n)  (cons 'or (car (clausesets (cadar (nthcdr (1- n) proof))))))(defun readproof (postlines)  (do ((l postlines (cdddr l)) (i 1 (1+ i)) (clause) (left) (right) (nl))      ((or (null l) (string= (caar l) "Command")) (nreverse nl))      (when (string= (caar l) "Selection") (pop l))      (setq clause (read-user-string (cdar l)))      (setq left (read-user-string (cdadr l)))      (setq right (read-user-string (cdaddr l)))      (cond ((and (null clause) (null left) (null right)))            ((and left right)             (setq nl (cons (list i clause left right) nl)))            ((not (null left))             (setq nl (cons (list i clause left) nl)))            ((not (null right))             (setq nl (cons (list i clause right) nl)))            (t (setq nl (cons (list i clause) nl))))))(defun readsketch (postlines)  (do ((l postlines (cdddr l)) (i 1 (1+ i)) (clause) (left) (right) (nl))      ((or (null l) (string= (caar l) "Command")) (nreverse nl))      (when (string= (caar l) "Selection") (pop l))      (setq clause (read-user-string (cdar l)))      (setq left (read-user-string (cdadr l)))      (setq right (read-user-string (cdaddr l)))      (setq nl (cons (list i clause left right) nl))))(defun format-open (s)  (format s "<HTML><HEAD></HEAD><BODY BGCOLOR=WHITE><BR><CENTER><H1>Logica Editor</H1></CENTER><HR>&nbsp;&nbsp;<A HREF=>Home</A>&nbsp;&nbsp;<A HREF=Truthtable?>Truth Table</A>&nbsp;&nbsp;<A HREF=Converter?>Converter</A>&nbsp;&nbsp;<A HREF=UNIFIER?>Unifier</A>&nbsp;&nbsp;<A HREF=LOGICA?>Resolution</A>&nbsp;&nbsp;<A HREF=EPILOG?>Epilog</A><A HREF=EDITOR?>Editor</A>&nbsp;&nbsp;<HR><FORM ACTION=EDITOR? METHOD=POST>"))(defun format-sketch (s proof)  (format s "<CENTER><TABLE BORDER>")  (format s "<TR><TD>")  (format-radio s "Selection" "0" t)  (format s "</TD><TH>Step</TH><TH>Proof</TH><TH>Justification</TH></TR>")  (dolist (step proof)    (format s "<TR><TD>")    (format-radio s "Selection" (princ-to-string (car step)) nil)    (format s "</TD><TH ALIGN=RIGHT>~A.</TH>" (makhtml (car step)))    (format s "<TD>")    (format-text s "Item" (makhtml (cadr step)) 60)    (format s "</TD><TD>")    (format-text s "Item" (makhtml (caddr step)) 7)    (format-text s "Item" (makhtml (cadddr step)) 7))  (do ((i (1+ (length proof)) (1+ i))       (n (* (ceiling (1+ (prooflength proof)) 10) 10)))      ((> i n))      (format s "<TR><TD>")      (format-radio s "Selection" (makhtml i) nil)      (format s "</TD><TH ALIGN=RIGHT>~A.</TH>" i)      (format s "<TD>")      (format-text s "Item" "" 60)      (format s "</TD><TD>")      (format-text s "Left" "" 7)      (format-text s "Right" "" 7)      (format s "</TD></TR>"))  (format s "</TABLE></CENTER>"))(defun format-proof (s proof)  (let ((*print-case* :downcase))    (format s "<CENTER><TABLE><TR><TD><TABLE BORDER>")    (format s "<TR><TH>Step</TH><TH>Proof</TH><TH>Justification</TH></TR>")    (dolist (step proof)      (format s "<TR><TH ALIGN=RIGHT>~A.</TH>" (car step))      (format s "<TD><TT>~A</TT></TD>" (cadr step))      (cond ((eq (caddr step) 'premise) (format s "<TD>Premise</TD></TR>"))            ((eq (caddr step) 'goal) (format s "<TD>Goal</TD></TR>"))            (t (format s "<TD>~A" (caddr step))               (dolist (x (cdddr step)) (format s ", ~A" x))               (format s "</TD></TR>"))))    (format s "</TABLE></TD></TR>")    (format s "<TR><TD ALIGN=CENTER>~A steps of search</TD></TR>" *inferences*)    (format s "</TABLE></CENTER>")))(defun format-epilog (s proof)  (let ((*print-case* :downcase))    (format s "<CENTER><TABLE><TR><TD><TABLE BORDER>")    (format s "<TR><TH>Step</TH><TH>Proof</TH><TH>Justification</TH></TR>")    (dolist (step proof)      (format s "<TR><TH ALIGN=RIGHT>~A.</TH>" (car step))      (format s "<TD><TT>")      (format-sentence s (cadr step))      (format s "</TT></TD>")      (cond ((eq (caddr step) 'premise) (format s "<TD>Premise</TD></TR>"))            ((eq (caddr step) 'goal) (format s "<TD>Goal</TD></TR>"))            (t (format s "<TD>~A" (caddr step))               (dolist (x (cdddr step)) (format s ", ~A" x))               (format s "</TD></TR>"))))    (format s "</TABLE></TD></TR>")    (format s "<TR><TD ALIGN=CENTER>~A steps of search</TD></TR>" *inferences*)    (format s "</TABLE></CENTER><BR>")))(defun format-trace (s proof)  (let ((*print-case* :downcase))    (format s "<CENTER><TABLE BORDER>")    (format s "<TR><TH>Step</TH><TH>Proof</TH><TH>Justification</TH></TR>")    (dolist (step proof)      (format s "<TR><TH ALIGN=RIGHT>~A.</TH>" (car step))      (format s "<TD><TT>")      (format-sentence s (cadr step))      (format s "</TT></TD>")      (cond ((eq (caddr step) 'premise) (format s "<TD>Premise</TD></TR>"))            ((eq (caddr step) 'goal) (format s "<TD>Goal</TD></TR>"))            (t (format s "<TD>~A" (caddr step))               (dolist (x (cdddr step)) (format s ", ~A" x))               (format s "</TD></TR>"))))    (format s "</TABLE></CENTER>")))(defun format-sentence (s x)  (cond ((atom x) (format s "~A" x))        ((eq (car x) 'query) (format s "~A?" (cadr x)))        (t (format s "~A" x))))(defun format-radio (s name value checked)  (if checked      (format s "<INPUT TYPE=RADIO NAME=\"~A\" VALUE=\"~A\" CHECKED>"              name value)      (format s "<INPUT TYPE=RADIO NAME=\"~A\" VALUE=\"~A\">"              name value)))(defun format-close (s)    (format s "<BR><CENTER><INPUT TYPE=SUBMIT NAME=Command VALUE=\"Add Row\"><INPUT TYPE=SUBMIT NAME=Command VALUE=\"Delete Row\"><INPUT TYPE=SUBMIT NAME=Command VALUE=\"Check Proof\"><INPUT TYPE=SUBMIT NAME=Command VALUE=\"Clean Proof\"></CENTER</FORM><BR>")    (format-end s))(defun prooflength (proof)  (do ((l proof (cdr l)) (i 1 (1+ i)) (end 0))      ((null l) end)      (when (or (cadar l) (caddar l) (cadddar l))        (setq end i))))(defun makhtml (kif)  (let ((*print-case* :downcase))    (cond ((null kif) "")          (t (htmlify (prin1-to-string kif))))));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Miscellaneous;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(defun similarp (x y)  (cond (*subsumption* (subsumptionp y x))        (t (samep x y))))(defun samesetp (x y)  (and (samesubsetp (cdr x) (cdr y) truth) (samesubsetp (cdr y) (cdr x) truth)))(defun samesubsetp (x y al)  (cond ((null x) al)        (t (do ((m y (cdr m)) (bl))               ((null m) nil)               (when (and (setq bl (samepexp (car x) (car m) al))                          (samesubsetp (cdr x) y bl))                 (return bl))))))(defun subsumptionp (p q)  (subsumptionps (cdr p) (cdr q) truth))(defun subsumptionps (pl ql al)  (cond ((null pl) al)        (t (do ((m ql (cdr m)) (bl))               ((null m))               (if (and (setq bl (matchpexp (car pl) (car m) al))                        (setq bl (subsumptionps (cdr pl) ql bl)))                   (return bl))))));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Manager;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(defparameter *manager*  (make-instance 'dataserver    :name 'manager    :indexing 'fullindexing    :inference 'fastserver))(setq *interface* *manager*)(definemore *manager*  '((isa        standard interface)    (isa        standard agent)    (isa        standard thing)    (nameisglobal standard no)    (recipient  standard manager)    (nocommand  standard sort)    (nocommand  standard rulify)    (nocommand  standard save)    (frontpage standard "source/logica_new.html"#|"<HTML><BODY BGCOLOR=WHITE><BR><CENTER><H1>Logica</H1></CENTER><HR>&nbsp;&nbsp;<A HREF=>Home</A>&nbsp;&nbsp;<A HREF=Truthtable?>Truth Table</A>&nbsp;&nbsp;<A HREF=Converter?>Converter</A>&nbsp;&nbsp;<A HREF=Unifier?>Unifier</A>&nbsp;&nbsp;<A HREF=LOGICA?>Resolution</A>&nbsp;&nbsp;<A HREF=EPILOG?>Epilog</A>&nbsp;&nbsp;<A HREF=EDITOR?>Editor</A>&nbsp;&nbsp;<HR><H3>Overview</H3><B>Logica</B> is a simple proof system for propositional and relational logic.It includes a truth-table-based satisfiability checker for Propositional Logic;it includes a unifier for checking unifiability of Relational Logic expressions;it incudes automatic proof methods based on Resolution and Epilog; andit includes an editor for manually creating proofs.  Click on the desired linkabove to access one of these capabilities.</P><H3>Language</H3><P>The language used by <B>Logica</B> is a prefix version of the language usedin class.  Every expression takes the form of a logical operator or a relationconstant followed by its arguments and enclosed in parentheses.</P><P>The following examples illustrate the relationship between the infixnotation used in class and this prefix notation.  Note: Most of the capabilitiesassume a subset of this notation, e.g. Epilog accepts literals and reductionsonly.  In fact, only Resolution allows the full syntax.  See descriptions belowfor details.</P><P><CENTER><TABLE BORDER><TR><TH>Infix</TH><TH>Prefix</TH></TR><TR><TD><TT>r(a,b,c)</TT></TD><TD><TT>(r a b c)</TT></TD></TR><TR><TD><TT>~~p</TT></TD><TD><TT>(not p)</TT></TD></TR><TR><TD><TT>p&amp;q</TT></TD><TD><TT>(and p q)</TT></TD></TR><TR><TD><TT>p|q</TT></TD><TD><TT>(or p q)</TT></TD></TR><TR><TD><TT>p=>q</TT></TD><TD><TT>(=> p q)</TT></TD></TR><TR><TD><TT>p<=q</TT></TD><TD><TT>(<= p q)</TT></TD></TR><TR></TR><TR></TR><TR><TD><TT>Ax.Ey.p(x,y)</TT></TD><TD><TT>(forall (?x) (exists (?y) (p ?x ?y)))</TT></TD></TR></TABLE></CENTER></P><P>Case does not matter in this notation.  Upper and lower case versions of acharacter are treated as the same character.   Variables are denoted byprefixing with the <TT>?</TT> character.  In other words, to enter the variable<TT>X</TT>, type <TT>?x</TT> or <TT>?X</TT>.</P><P><CENTER><TABLE BORDER><TR><TH>Infix</TH><TH>Prefix</TH></TR><TR><TD><TT>p(X,b)=>q(X)</TT></TD><TD><TT>(=> (p ?x b) (q ?x))</TT></TD></TR></TABLE></CENTER></P><H3>Truth Table</H3><P>Type any number of Propositional Logic sentences into the expression box.  PressCheck Truth Table to determine joint validity, satisfiability, or unsatisfiabilityof the specified sentences.  Press Show Truth Table if you also want to see the truthtable.  Note that the truth tables grow exponentially in the number of propositionalconstants.  Specifying too many constants will stress the system.</P><H3>Unifier</H3><P>Type a single atomic sentence into each of the expression boxes and press Unify tocompute a most general unifier (if any).</P><H3>Resolution</H3><P>Type your premises into the Premise box and your desired conclusion, if any,into the Conclusion box.  Remember to use Prefix notation.If you enter no premises, it will assume you havenone.  If you have no conclusion, it will assume <TT>false</TT>.  If the systemdetects a syntax error in either field, it will treat that field as empty.  So,if    you enter premises or conclusions and do not see any in the resultingproof, it means there is a syntax error.</P><P>Once you have entered your premises and conclusions, select from among thestrategy choices.  The system ALWAYS applies Identical Clause Removal, i.e. itwill not produce the same conclusion twice.</P><P>Finally, select a maximum number of steps for the system to take beforequitting.  Beware of specifying too high a number.  This will waste systemresources and tax your patience.</P><H3>Epilog</H3><P>Type your premises into the Premise box and your desired conclusion, if any,into the Conclusion box.  Premises should all be literals (e.g. <TT>(p a b)</TT>and <TT>(q b)</TT>) or reductions (e.g. <TT>(<= (r ?x) (p ?x ?y) (q ?y))</TT>). Conclusions should be boolean expressions (e.g. <TT>(and (p a b) (r a))</TT>).If you enter no premises, it will assumeyou have none.  If you have no conclusion, it will assume <TT>false</TT>.  If thesystem detects a syntax error in either field, it will treat that field as empty. So, if you enter premises or conclusions and do not see any in the resulting proof,it means there is a syntax error.</P><P>Once you have entered your premises and conclusions, select a maximum depth.Do not specify too high a number.  You may also check the Contrapositives boxif yuo want the system to compute contrapositives before starting inference.</P><H3>Editor</H3><P>Pretty straightforward after a little experimentation.  Expressions should allbe literals  (e.g. <TT>(p a b)</TT> and <TT>(q b)</TT>) or clauses (e.g.<TT>(or (r ?x) (not (p ?x ?y)) (not (q ?y)))</TT>).For premises, type \"Premise\" into one of the justification boxes. For goals,type \"Goal\" into one of the justification boxes.  For resolutions, enter the linenumbers of the parents into the justification boxes.  Otherwise, the proof checkerwill complain.  To get more lines, select the place where you want to insert a newline and press Add Row at any time.  Press Check Proof after you get to thelast line to check your proof.  Press Clean proof to eliminate redundant lines.</P><H3>Future Plans</H3><P>This is a quickie implementation, just to see what is needed here. Constructive comments welcome.  Snide remarks less welcome (unlesshumorous).</P>If people think this system has any pedagogical value, we will develop itfurther in the future.  For example, we will switch to infix format.  We willadd additional elimination and restriction strategies and search controlcapabilities.  In order to facilitate navigation, we will offer hyperlinkedproofs as well as linear proofs.  We may add capabilties for using truth tablesand Herbrand tables.  We may add unification checkers.  And so forth.  If youhave comments, please let us know.<P><HR><ADDRESS>Comments to <A HREF=\"mailto:genesereth@stanford.edu\">Michael Genesereth</A>.</ADDRESS></HTML>"|#)))(defmethod insert (p (receiver (eql *manager*)))  (when (meta receiver) (fancyinsert p receiver))  (prog1 (dbinsert p receiver)         (metainsert p)))(defmethod uninsert (p (receiver (eql *manager*)))  (prog1 (call-next-method p receiver)         (metauninsert p)         (when (meta receiver) (fancyuninsert p receiver))));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Metaservers;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(defun metainsert (p)  (unless (atom p) (setvalue (car p) (cadr p) (caddr p))))(defmethod setvalue (slot obj val)  (cond ((eq 'isa slot) (create obj val))        ((eq 'basetime slot) (reset-chore obj))        ((eq 'period slot) (reset-chore obj))        ((eq 'runday slot) (reset-chore obj))        ((eq 'operation slot) (reset-chore obj))        ((eq 'includee slot) (setincludee obj val))        ((eq 'host slot) (sethost obj val))        ((eq 'port slot) (setport obj val))))(defun metauninsert (p)  (unless (atom p) (remvalue (car p) (cadr p) (caddr p))))(defmethod remvalue (slot obj val)  (cond ((eq 'isa slot) (destroy obj val))        ((eq 'basetime slot) (reset-chore obj))        ((eq 'period slot) (reset-chore obj))        ((eq 'runday slot) (reset-chore obj))        ((eq 'operation slot) (reset-chore obj))        ((eq 'includee slot) (unsetincludee obj val))        ((eq 'host slot) (sethost obj ""))        ((eq 'port slot) (setport obj 0))))(defmethod create (obj type)  (cond ((not (symbolp obj)) nil)        ((eq type 'chore) (make-chore obj))        ((eq type 'remote)         (unless (and (boundp obj) (remotep (symbol-value obj)))           (let ((host (or (find-host obj) "")) (port (or (find-port obj) 0)))             (set obj (make-remote obj host port)))))        ((and (boundp obj) (eq (type-of (symbol-value obj)) type)))        ((find type '(interface counter basket aclserver sqlpublisher                      transformer translator facilitator broker authorizer))         (set obj (make-instance type :name obj)))))(defmethod destroy (obj type)  (cond ((not (symbolp obj)) nil)        ((eq type 'chore) (kill-chore obj))        ((and (boundp obj) (eq (type-of (symbol-value obj)) type)              (find type '(interface counter basket aclserver sqlpublisher                           transformer translator facilitator broker authorizer)))         (makunbound obj))))(defun setincludee (t1 t2)  (if (and (symbolp t1) (boundp t1) (setq t1 (symbol-value t1))           (symbolp t2) (boundp t2) (setq t2 (symbol-value t2))           (typep t2 'dataserver))      (includes t1 t2)))(defun unsetincludee (t1 t2)  (if (and (symbolp t1) (boundp t1) (setq t1 (symbol-value t1))           (symbolp t2) (boundp t2) (setq t2 (symbol-value t2))           (typep t2 'dataserver))      (unincludes t1 t2)))(defun sethost (x h)  (if (and (symbolp x) (boundp x) (remotep (setq x (symbol-value x)))           (or (not (equal h *host*)) (not (equal (port x) *port*))))    (setf (host x) h)))(defun setport (x p)  (if (and (symbolp x) (boundp x)  (remotep (setq x (symbol-value x)))           (or (not (equal (host x) *host*)) (not (equal p *port*))))    (setf (port x) p)))(defun find-host (x)  (findx '?x `(host ,x ?x) *manager*))(defun find-port (x)  (findx '?x `(port ,x ?x) *manager*));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;