(POS (EXAMPLE.INSTANCE DRESDENQUEENS))(POS (EXAMPLE.DATEENTERED DRESDENQUEENS 3355255579))(POS (EXAMPLE.DATEMODIFIED DRESDENQUEENS 3355255579))(POS (EXAMPLE.TECHNIQUE DRESDENQUEENS DATAEXTRACTION))(POS (EXAMPLE.TECHNIQUE DRESDENQUEENS GENERATEOVERGUESS))(POS (EXAMPLE.DESCRIPTION DRESDENQUEENS "We extracted the data out of the rules and relied on generation instead of guess and check."))(POS (EXAMPLE.SOURCE DRESDENQUEENS "  (<= (goal player ?s)
      (attacks ?n)
      (mapnum2val ?n ?s))
  (mapnum2val s0 100)
  (mapnum2val s2 90)
  (mapnum2val s3 80)
  (mapnum2val s4 70)
  (mapnum2val s5 60)
  (mapnum2val s6 50)
  (mapnum2val s7 40)
  (mapnum2val s8 0)
  (mapnum2val s9 0)
  (mapnum2val s10 0)
"))(POS (EXAMPLE.TARGET DRESDENQUEENS "  (<= (goal player 100)
      (attacks s0))
  (<= (goal player 90)
      (attacks s2))
  (<= (goal player 80)
      (attacks s3))
  (<= (goal player 70)
      (attacks s4))
  (<= (goal player 60)
      (attacks s5))
  (<= (goal player 50)
      (attacks s6))
  (<= (goal player 40)
      (attacks s7))
  (<= (goal player 0)
      (attacks s8))
  (<= (goal player 0)
      (attacks s9))
  (<= (goal player 0)
      (attacks s10))
"))(POS (EXAMPLE.INSTANCE TOETICTAC))(POS (EXAMPLE.DATEENTERED TOETICTAC 3355255669))(POS (EXAMPLE.DATEMODIFIED TOETICTAC 3355255669))(POS (EXAMPLE.TECHNIQUE TOETICTAC RELATIONALIZING))(POS (EXAMPLE.DESCRIPTION TOETICTAC "The old: each of the 9 cells is labelled with an x, an o, or a b: cell(x,y,label).  The new: each of the 9 cells (a,b,c,d,e,f,g,h,i) is either true of ecks or ohs or blank, each of which is a unary relation. "))(POS (EXAMPLE.EFFICIENCYGAINS TOETICTAC "Notes: tictactoe is the original theory and toetictac is the new one.
? (time (brute-force-playable tictactoe))
(BRUTE-FORCE-PLAYABLE TICTACTOE) took 56,488 milliseconds (56.488 seconds) to run.
Of that, 2,602 milliseconds (2.602 seconds) were spent in The Cooperative Multitasking Experience.
 88,240,736 bytes of memory allocated.
T
? (time (brute-force-playable toetictac))
;Compiler warnings :
;   Undeclared free variable TOETICTAC, in an anonymous lambda form.
(BRUTE-FORCE-PLAYABLE TOETICTAC) took 38,920 milliseconds (38.920 seconds) to run.
Of that, 1,514 milliseconds (1.514 seconds) were spent in The Cooperative Multitasking Experience.
 48,237,344 bytes of memory allocated.
T
"))(POS (EXAMPLE.SOURCE TOETICTAC "    (role white)
    (role black)
    (init (cell 1 1 b))
    (init (cell 1 2 b))
    (init (cell 1 3 b))
    (init (cell 2 1 b))
    (init (cell 2 2 b))
    (init (cell 2 3 b))
    (init (cell 3 1 b))
    (init (cell 3 2 b))
    (init (cell 3 3 b))
    (init (control white))
    (<= (next (cell ?m ?n x))
        (does white (mark ?m ?n))
        (true (cell ?m ?n b)))
    (<= (next (cell ?m ?n o))
        (does black (mark ?m ?n))
        (true (cell ?m ?n b)))
    (<= (next (cell ?m ?n ?w))
        (true (cell ?m ?n ?w))
        (distinct ?w b))
    (<= (next (cell ?m ?n b))
        (does ?w (mark ?j ?k))
        (true (cell ?m ?n b))
        (or (distinct ?m ?j) (distinct ?n ?k)))
    (<= (next (control white))
        (true (control black)))
    (<= (next (control black))
        (true (control white)))
    (<= (row ?m ?x)
        (true (cell ?m 1 ?x))
        (true (cell ?m 2 ?x))
        (true (cell ?m 3 ?x)))
    (<= (column ?n ?x)
        (true (cell 1 ?n ?x))
        (true (cell 2 ?n ?x))
        (true (cell 3 ?n ?x)))
    (<= (diagonal ?x)
        (true (cell 1 1 ?x))
        (true (cell 2 2 ?x))
        (true (cell 3 3 ?x)))
    (<= (diagonal ?x)
        (true (cell 1 3 ?x))
        (true (cell 2 2 ?x))
        (true (cell 3 1 ?x)))
    (<= (line ?x)
        (row ?m ?x))
    (<= (line ?x)
        (column ?m ?x))
    (<= (line ?x)
        (diagonal ?x))
    (<= open
        (true (cell ?m ?n b)))
    (<= (legal ?w (mark ?x ?y))
        (true (cell ?x ?y b))
        (true (control ?w)))
    (<= (legal white noop)
        (true (cell ?x ?y b))
        (true (control black)))
    (<= (legal black noop)
        (true (cell ?x ?y b))
        (true (control white)))
    (<= (goal white 100)
        (line x))
    (<= (goal white 50)
        (not (line x))
        (not (line o))
        (not open))
    (<= (goal white 0)
        (line o))
    (<= (goal black 100)
        (line o))
    (<= (goal black 50)
        (not (line x))
        (not (line o))
        (not open))
    (<= (goal black 0)
        (line x))
    (<= terminal
        (line x))
    (<= terminal
        (line o))
    (<= terminal
        (not open))
"))(POS (EXAMPLE.TARGET TOETICTAC "    (role xplayer)
    (role oplayer)
    (init (blank a))
    (init (blank b))
    (init (blank c))
    (init (blank d))
    (init (blank e))
    (init (blank f))
    (init (blank g))
    (init (blank h))
    (init (blank i))
    (init (control xplayer))
    (<= (next (ecks ?m))
        (does xplayer (mark ?m))
        (true (blank ?m)))
    (<= (next (oh ?m))
        (does oplayer (mark ?m))
        (true (blank ?m)))
    (<= (next (ecks ?m))
        (true (ecks ?m)))
    (<= (next (oh ?m))
        (true (oh ?m)))
    (<= (next (blank ?m))
        (does ?w (mark ?n))
        (true (blank ?m))
        (distinct ?m ?n))
    (<= (next (control xplayer))
        (true (control oplayer)))
    (<= (next (control oplayer))
        (true (control xplayer)))
    (line a b c)
    (line a d g)
    (line d e f)
    (line b e h)
    (line g h i)
    (line c f i)
    (line a e i)
    (line c e g)
    (<= xline
        (line ?a ?b ?c)
        (true (ecks ?a))
        (true (ecks ?b))
        (true (ecks ?c)))
    (<= oline
        (line ?a ?b ?c)
        (true (oh ?a))
        (true (oh ?b))
        (true (oh ?c)))
    (<= open
        (true (blank ?m)))
    (<= (legal ?player (mark ?y))
        (true (blank ?y))
        (true (control ?player)))
    (<= (legal oplayer noop)
        (true (control xplayer)))
    (<= (legal xplayer noop)
        (true (control oplayer)))
    (<= (goal xplayer 100)
        xline)
    (<= (goal xplayer 50)
        (not xline)
        (not oline)
        (not open))
    (<= (goal xplayer 0)
        oline)
    (<= (goal oplayer 100)
        oline)
    (<= (goal oplayer 50)
        (not xline)
        (not oline)
        (not open))
    (<= (goal oplayer 0)
        xline)
    (<= terminal
        xline)
    (<= terminal
        oline)
    (<= terminal
        (not open))
"))(POS (EXAMPLE.INSTANCE MAZEWORLD))(POS (EXAMPLE.DATEENTERED MAZEWORLD 3355255765))(POS (EXAMPLE.DATEMODIFIED MAZEWORLD 3355255765))(POS (EXAMPLE.TECHNIQUE MAZEWORLD CONSISTENCY2DEDUCTION))(POS (EXAMPLE.TECHNIQUE MAZEWORLD UNNAMED))(POS (EXAMPLE.DESCRIPTION MAZEWORLD "Original maze world is an incomplete information game.  The new maze world is a complete information game, where all the uncertainty has been built into the role world.  When building the game tree for a 2-player incomplete game, the branching factor for your opponent is all possible moves since we don't necessarily know what moves that player can legally make.  Sometimes, some of those moves are inconsistent with the current state of the world.  By compiling the incompleteness into the world player, we can enumerate just the legal moves that are consistent with the state of the game."))(POS (EXAMPLE.SOURCE MAZEWORLD "  (role robot)

    (initial 1)
    (successor 1 2)
    (successor 2 3)
    (successor 3 4)
    (successor 4 5)
    (successor 5 6)
    (successor 6 7)
    (successor 7 8)
    (successor 8 9)
    (successor 9 10)

    (adjacent a b)
    (adjacent b c)
    (adjacent c d)
    (adjacent d a)

    (percept robot bright)

    ;;;;

    (<= (legal robot move ?n))
    (<= (legal robot noop ?n))

    (<= (goal robot 100 ?n)
        (true (cell ?x) ?n)
        (true (gold ?x) ?n))
    
    (<= (goal robot 0 ?n)
        (true (cell ?x) ?n)
	(true (gold ?y) ?n)
        (distinct ?x ?y))
        
    (terminal 7)

    ;;;;
    
    ; state
    (true (cell a) 1)
    (not (true (gold a) 1))

    ; effector
    (<= (true (cell ?y) ?n)
        (successor ?m ?n)
        (does robot move ?m)
        (true (cell ?x) ?m)
        (adjacent ?x ?y))

    (<= (true (cell ?y) ?n)
        (successor ?m ?n)
        (does robot noop ?m)
        (true (cell ?y) ?n))
		
    
    ; state
    (<= (true (gold d) ?n)
        (not (true (gold a) ?n))
        (not (true (gold b) ?n))
        (not (true (gold c) ?n))
        (not (true (gold i) ?n)))

    
    ; gold sensor
    (<= (true (gold ?x) ?n)
        (sees robot bright ?n)
        (true (cell ?x) ?n))

    (<= (not (true (gold ?x) ?n))
        (not (sees robot bright ?n)) 
        (true (cell ?x) ?n))
    

    ; frame: monotonicity of gold
    (<= (true (gold ?x) ?n)
        (successor ?m ?n)
        (true (gold ?x) ?m))

    (<= (not (true (gold ?x) ?n))
        (successor ?m ?n)
        (not (true (gold ?x) ?m)))
"))(POS (EXAMPLE.TARGET MAZEWORLD "  (role robot)
  (role world)
  
  (successor 1 2)
  (successor 2 3)
  (successor 3 4)
  (successor 4 5)
  (successor 5 6)
  (successor 6 7)
  (successor 7 8)
  (successor 8 9)
  (successor 9 10)
  
  (adjacent a b)
  (adjacent b c)
  (adjacent c d)
  (adjacent d a)
  
  (percept robot bright)

  ;;;;

  (init (step 1))
  (init (listof * * *))
  (init (cell a))
  
  ;;;;
  
  (<= (legal robot move))
  (<= (legal robot noop))
  
  (<= (legal world (listof ?x ?u ?v))
      (true (listof * ?u ?v))
      (bit3 ?x ?u ?v))
  (<= (legal world (listof ?x ?u ?v))
      (true (listof ?x * ?v))
      (bit3 ?x ?u ?v))
  (<= (legal world (listof ?x ?u ?v))
      (true (listof ?x ?u *))
      (bit3 ?x ?u ?v))
  (<= (legal world (listof ?x ?u ?v))
      (true (listof * * ?v))
      (bit3 ?x ?u ?v))
  (<= (legal world (listof ?x ?u ?v))
      (true (listof * ?u *))
      (bit3 ?x ?u ?v))
  (<= (legal world (listof ?x ?u ?v))
      (true (listof ?x * *))
      (bit3 ?x ?u ?v))
  (<= (legal world (listof ?x ?u ?v))
      (true (listof * * *))
      (bit3 ?x ?u ?v))
  
  
  (<= (bit3 ?x ?y ?z) (bit ?x) (bit ?y) (bit ?z))
  (bit 1) 
  (bit 0)
  
  (<= (goal robot 100)
      (true (cell ?x))
      (true (real (gold ?x))))
  
  (<= (goal robot 0)
      (true (cell ?x))
      (true (real ?y))
      (distinct ?x ?y))
  
  ;;;;
  
  ; counter
  (<= (next (step ?x))
      (true (step ?y))
      (successor ?y ?x))
  
  ; effector: world
  (<= (next (real ?x))
      (does world ?y)
      (item-true ?x ?y))
  
  (<= (item-true (gold b) (listof 1 ?y ?z)))
  (<= (item-true (gold c) (listof ?x 1 ?z)))
  (<= (item-true (gold d) (listof ?x ?y 1)))
  (<= (item-false (gold b) (listof 0 ?y ?z)))
  (<= (item-false (gold c) (listof ?x 0 ?z)))
  (<= (item-false (gold d) (listof ?x ?y 0)))
  
  ; effector: robot
  (<= (next (cell ?y))
      (does robot move)
      (true (cell ?x))
      (adjacent ?x ?y))
  
  (<= (next (cell ?y))
      (does robot noop)
      (true (cell ?y)))
  
  
  ; frame and sensor: skolem
  (<= (next (listof ?x ?y ?z))
      (val (gold b) ?x)
      (val (gold c) ?y)
      (val (gold d) ?z))
  
  (<= (val ?x 1)
      (tru ?x))
  (<= (val ?x 1)
      (true (listof @y))
      (item-true ?x (listof @y)))

  (<= (val ?x 0)
      (nottru ?x))
  (<= (val ?x 0)
      (true (listof @y))
      (item-false ?x (listof @y)))

  (<= (val ?x *)
      (true (listof @y))
      (not (item-true ?x (listof @y)))
      (not (item-false ?x (listof @y)))
      (not  (tru ?x))
      (not (nottru ?x)))

  
  (<= (nottru (gold ?y))
      (does robot move)
      (true (cell ?x))
      (adjacent ?x ?y)
      (does world ?wm)
      (item-false (gold ?y) ?wm)) 
  
  (<= (tru (gold ?y))
      (does robot move)
      (true (cell ?x))
      (adjacent ?x ?y)
      (does world ?wm)
      (item-true (gold ?y) ?wm)) 
"))(POS (EXAMPLE.INSTANCE MAPCOLORING))(POS (EXAMPLE.DATEENTERED MAPCOLORING 3355255875))(POS (EXAMPLE.DATEMODIFIED MAPCOLORING 3355255875))(POS (EXAMPLE.TECHNIQUE MAPCOLORING CONSISTENCY2DEDUCTION))(POS (EXAMPLE.TECHNIQUE MAPCOLORING CHIRKOVAREFORMULATION))(POS (EXAMPLE.SOURCE MAPCOLORING "  (<= (not (color ?r ?c))
      (not (region ?r)))

  (<= (not (color ?r ?c))
      (not (hue ?c)))

  (<= (not (color ?r1 ?c))
      (adjacent ?r1 ?r2)
      (color ?r2 ?c))

  (region r1)
  (region r2)
  (region r3)

  (hue red)
  (hue blue)

  (adjacent r1 r2)
  (adjacent r2 r1)
  (adjacent r2 r3)
  (adjacent r3 r2)
"))(POS (EXAMPLE.SOURCEQUERY MAPCOLORING "(and (color r1 ?x) (color r2 ?y) (color r3 ?z))
"))(POS (EXAMPLE.TARGET MAPCOLORING "(next red blue)
(next blue red)"))(POS (EXAMPLE.TARGETQUERY MAPCOLORING "(and (next ?x ?y) (next ?y ?z))"))(POS (EXAMPLE.DESCRIPTION MAPCOLORING "The first version is not deductive; in fact, it entails which colorings are invalid.  The second version is deductive.  The first can be separated from region, hue, adjacent, but the second version builds all 3 into the formulation.  The first is more natural, but the second seems to be more efficient. Instead of building an arbitrary model for the axioms, we can use CSP/LP techniques to find an answer.  Actually, it is unclear to what extent the second formulation is faster than the first."))(POS (EXAMPLE.INSTANCE EXAMPLE.3355256133))(POS (EXAMPLE.DATEENTERED EXAMPLE.3355256133 3355256133))(POS (EXAMPLE.DATEMODIFIED EXAMPLE.3355256133 3355256133))(POS (EXAMPLE.DESCRIPTION EXAMPLE.3355256133 "test description"))(NEG (EXAMPLE.DESCRIPTION EXAMPLE.3355256133 "test description"))(POS (EXAMPLE.DESCRIPTION EXAMPLE.3355256133 "test description 2"))(NEG (EXAMPLE.EFFICIENCYGAINS TOETICTAC "Notes: tictactoe is the original theory and toetictac is the new one.
? (time (brute-force-playable tictactoe))
(BRUTE-FORCE-PLAYABLE TICTACTOE) took 56,488 milliseconds (56.488 seconds) to run.
Of that, 2,602 milliseconds (2.602 seconds) were spent in The Cooperative Multitasking Experience.
 88,240,736 bytes of memory allocated.
T
? (time (brute-force-playable toetictac))
;Compiler warnings :
;   Undeclared free variable TOETICTAC, in an anonymous lambda form.
(BRUTE-FORCE-PLAYABLE TOETICTAC) took 38,920 milliseconds (38.920 seconds) to run.
Of that, 1,514 milliseconds (1.514 seconds) were spent in The Cooperative Multitasking Experience.
 48,237,344 bytes of memory allocated.
T
"))(POS (EXAMPLE.EFFICIENCYGAINS TOETICTAC "(brute-force-playable source) takes 56.5 seconds.
(brute-force-playable target) takes 39 seconds."))(NEG (EXAMPLE.DATEENTERED EXAMPLE.3355256133 3355256133))(NEG (EXAMPLE.DATEMODIFIED EXAMPLE.3355256133 3355256133))(NEG (EXAMPLE.DESCRIPTION EXAMPLE.3355256133 "test description 2"))(NEG (EXAMPLE.INSTANCE EXAMPLE.3355256133))(POS (EXAMPLE.EFFICIENCYGAINS DRESDENQUEENS "(reward player ?x)
Source: 425 seconds, Target: 3 seconds"))(POS (PRETTYNAME DRESDENQUEENS "Dresden Queens"))(POS (PRETTYNAME MAPCOLORING "Map Coloring"))(POS (PRETTYNAME MAZEWORLD "Maze World"))(POS (PRETTYNAME TOETICTAC "Toetictac"))(POS (PRETTYNAME CHIRKOVAREFORMULATION "Chirkova"))(POS (PRETTYNAME CONSISTENCY2DEDUCTION "Consistency2Deduction"))(NEG (PRETTYNAME CHIRKOVAREFORMULATION "Chirkova"))(POS (PRETTYNAME CHIRKOVAREFORMULATION "Chirkova Reformulation"))(POS (PRETTYNAME DATAEXTRACTION "Data Extraction"))(POS (PRETTYNAME DATAINFUSION "Data Infusion"))(POS (PRETTYNAME GENERATEOVERGUESS "Generate Over Guess"))(POS (PRETTYNAME OBJECTIFYING "Objectifying"))(POS (PRETTYNAME REIFICATION "Reification"))(POS (PRETTYNAME RELATIONALIZING "Relationalizing"))(POS (PRETTYNAME UNNAMED "Unnamed"))(POS (SHORTNAME CHIRKOVAREFORMULATION "Chirkova"))(POS (SHORTNAME CONSISTENCY2DEDUCTION "C2D"))(POS (SHORTNAME DATAEXTRACTION "Extraction"))(POS (SHORTNAME DATAINFUSION "Infusion"))(POS (SHORTNAME GENERATEOVERGUESS "GOG"))(POS (SHORTNAME OBJECTIFYING "2Obj"))(POS (SHORTNAME REIFICATION "Reification"))(POS (SHORTNAME RELATIONALIZING "2Reln"))(POS (SHORTNAME UNNAMED "?"))(POS (COMPLETENESS.INSTANCE COMPLETE))(POS (COMPLETENESS.INSTANCE INCOMPLETE))(POS (EXAMPLE.COMPLETE DRESDENQUEENS COMPLETE))(POS (EXAMPLE.COMPLETE TOETICTAC COMPLETE))(POS (EXAMPLE.COMPLETE MAZEWORLD INCOMPLETE))(POS (EXAMPLE.COMPLETE MAPCOLORING INCOMPLETE))(POS (EXAMPLE.TECHNIQUE TOETICTAC UNNAMED))(NEG (EXAMPLE.DESCRIPTION DRESDENQUEENS "We extracted the data out of the rules and relied on generation instead of guess and check."))(POS (EXAMPLE.DESCRIPTION DRESDENQUEENS "When a GGP class was taught in Dresden, the 8-queens puzzle was used at some point.  The original axioms they wrote ran slowly when asking the query for the reward a player earned after having placed the 8 queens on the board.  The formulation was propositional: check if there are 8 queens that are attacked by some other queen; if so, award 0 points.  Then check if there are 7 queens that are attacked, and award 40 points.  And so on.  Nat changed the axioms so that first they compute how many queens are attacked and then use a lookup table to compute the points awarded."))(NEG (EXAMPLE.DESCRIPTION TOETICTAC "The old: each of the 9 cells is labelled with an x, an o, or a b: cell(x,y,label).  The new: each of the 9 cells (a,b,c,d,e,f,g,h,i) is either true of ecks or ohs or blank, each of which is a unary relation. "))(POS (EXAMPLE.DESCRIPTION TOETICTAC "Toetictac is a reconceptualization of the original axioms for tictactoe.  In the original version each of the 9 cells is labelled with an x, an o, or a b: cell(x,y,label).  In the new version each of the 9 cells (a,b,c,d,e,f,g,h,i) is either true of ecks or ohs or blank, each of which is a unary relation."))(POS (TECHNIQUE.INSTANCE NAF))(POS (TECHNIQUE.DESCRIPTION NAF "Negation as failure is a meta-inference rule: if the closed sentence p is not entailed (cannot be proven) then infer -p.  We've found it useful for performing iteration, and it is also useful in complete theories when failing to prove p in the positive space is easier than proving -p directly.  "))(POS (PRETTYNAME NAF "Negation as Failure"))(POS (SHORTNAME NAF "NAF"))(POS (BOOLEAN.INSTANCE TRUE))(POS (PRETTYNAME TRUE "True"))(POS (SHORTNAME TRUE "T"))(POS (BOOLEAN.INSTANCE FALSE))(POS (PRETTYNAME FALSE "False"))(POS (SHORTNAME FALSE "F"))(POS (MATRIXSHOW CONSISTENCY2DEDUCTION TRUE))(POS (MATRIXSHOW DRESDENQUEENS TRUE))(POS (MATRIXSHOW REIFICATION TRUE))(POS (MATRIXSHOW UNNAMED TRUE))(POS (MATRIXSHOW RELATIONALIZING FALSE))(POS (MATRIXSHOW OBJECTIFYING FALSE))(POS (MATRIXSHOW GENERATEOVERGUESS TRUE))(POS (MATRIXSHOW DATAEXTRACTION TRUE))(POS (MATRIXSHOW DATAINFUSION TRUE))(POS (MATRIXSHOW CHIRKOVAREFORMULATION TRUE))(POS (MATRIXSHOW NAF TRUE))(POS (MATRIXSHOW TOETICTAC TRUE))(POS (MATRIXSHOW MAZEWORLD TRUE))(POS (MATRIXSHOW MAPCOLORING TRUE))(POS (EXAMPLE.INSTANCE EXAMPLE.3355774383))(POS (PRETTYNAME EXAMPLE.3355774383 "Exponential negation"))(POS (SHORTNAME EXAMPLE.3355774383 "ExpNeg"))(POS (EXAMPLE.COMPLETE EXAMPLE.3355774383 COMPLETE))(POS (EXAMPLE.TECHNIQUE EXAMPLE.3355774383 NAF))(POS (EXAMPLE.DESCRIPTION EXAMPLE.3355774383 "An iff can be used to compactly define a complete relation; however, when converting an iff to clausal form, negating the body can produce a large number of rules.  This example shows that an exponential number of rules can be produced.  In general, if this example is generalized to include n disjuncts of conjunctions of length m, there are m^n rules of length m for defining the negative space.  There would be n rules of length m for defining the positive space."))(POS (EXAMPLE.EFFICIENCYGAINS EXAMPLE.3355774383 "6/4 unis/infs to explore positive space versus 54/28 unis/infs to explore negative space"))(POS (MATRIXSHOW EXAMPLE.3355774383 TRUE))(POS (EXAMPLE.SOURCEQUERY EXAMPLE.3355774383 "(not illegal)"))(POS (EXAMPLE.SOURCE EXAMPLE.3355774383 "(<=> illegal (or (and p1 p2 p3) (and q1 q2 q3) (and r1 r2 r3)))
"))(POS (EXAMPLE.TARGETQUERY EXAMPLE.3355774383 "(not illegal)"))(POS (EXAMPLE.TARGET EXAMPLE.3355774383 "(<= illegal (or (and p1 p2 p3) (and q1 q2 q3) (and r1 r2 r3)))
"))(POS (EXAMPLE.INSTANCE EXPONENTIALNEGATION))(POS (PRETTYNAME EXPONENTIALNEGATION "Exponential negation"))(POS (SHORTNAME EXPONENTIALNEGATION "ExpNeg"))(POS (EXAMPLE.COMPLETE EXPONENTIALNEGATION COMPLETE))(POS (EXAMPLE.TECHNIQUE EXPONENTIALNEGATION NAF))(POS (EXAMPLE.DESCRIPTION EXPONENTIALNEGATION "An iff can be used to compactly define a complete relation; however, when converting an iff to clausal form, negating the body can produce a large number of rules.  This example shows that an exponential number of rules can be produced.  In general, if this example is generalized to include n disjuncts of conjunctions of length m, there are m^n rules of length m for defining the negative space.  There would be n rules of length m for defining the positive space."))(POS (EXAMPLE.EFFICIENCYGAINS EXPONENTIALNEGATION "6/4 unis/infs to explore positive space versus 54/28 unis/infs to explore negative space"))(POS (MATRIXSHOW EXPONENTIALNEGATION TRUE))(POS (EXAMPLE.SOURCEQUERY EXPONENTIALNEGATION "(not illegal)"))(POS (EXAMPLE.SOURCE EXPONENTIALNEGATION "(<=> illegal (or (and p1 p2 p3) (and q1 q2 q3) (and r1 r2 r3)))
"))(POS (EXAMPLE.TARGETQUERY EXPONENTIALNEGATION "(not illegal)"))(POS (EXAMPLE.TARGET EXPONENTIALNEGATION "(<= illegal (or (and p1 p2 p3) (and q1 q2 q3) (and r1 r2 r3)))
"))(NEG (EXAMPLE.INSTANCE EXAMPLE.3355774383))(POS (EXAMPLE.INSTANCE JIGSAW))(POS (PRETTYNAME JIGSAW "Jigsaw"))(POS (SHORTNAME JIGSAW "Jigsaw"))(POS (EXAMPLE.COMPLETE JIGSAW INCOMPLETE))(POS (EXAMPLE.TECHNIQUE JIGSAW UNNAMED))(POS (EXAMPLE.DESCRIPTION JIGSAW "This is a 4-piece jigsaw puzzle.  The original jigsaw axioms are complicated, and converting them into clausal form is expensive.  Moreover, finding an answer after conversion takes a very, very long time.  Lastly, the relations included have modular definitions--they could be picked up and moved to other theories without (much) modification.  The new axioms include less information, but they include sufficient information to answer the query goal.  The new axioms find all answers in less than a second."))(POS (EXAMPLE.EFFICIENCYGAINS JIGSAW "13000x speedup"))(POS (MATRIXSHOW JIGSAW TRUE))(POS (EXAMPLE.SOURCEQUERY JIGSAW "(goal ?x ?y ?z ?w)"))(POS (EXAMPLE.SOURCE JIGSAW "  (<=> (cardinal ?x) (or (= ?x north) (= ?x south) (= ?x west) (= ?x east)))
  (<=> (piece ?x) (or (= ?x p1) (= ?x p2) (= ?x p3) (= ?x p4) (= ?x p0)))
  (<=> (orientation ?x) (or (= ?x 0) (= ?x 90) (= ?x 180) (= ?x 270)))

  ;(or (piece ?x) (orientation ?x) (cardinal ?x))

  (<=> (edge ?x ?y) 
       (or (and (= ?x p1) (or (= ?y east) (= ?y north)))
           (and (= ?x p2) (or (= ?y west) (= ?y north)))
           (and (= ?x p3) (or (= ?y west) (= ?y south)))
           (and (= ?x p4) (or (= ?y north) (= ?y east)))) )

  (<=> (rotate ?x ?amt ?y) 
       (or (and (= ?x north) (= ?amt 0) (= ?y north)) 
           (and (= ?x north) (= ?amt 90) (= ?y east))
           (and (= ?x north) (= ?amt 180) (= ?y south))
           (and (= ?x north) (= ?amt 270) (= ?y west))
           
           (and (= ?x south) (= ?amt 0) (= ?y south)) 
           (and (= ?x south) (= ?amt 90) (= ?y west))
           (and (= ?x south) (= ?amt 180) (= ?y north))
           (and (= ?x south) (= ?amt 270) (= ?y east))

           (and (= ?x east) (= ?amt 0) (= ?y east)) 
           (and (= ?x east) (= ?amt 90) (= ?y south))
           (and (= ?x east) (= ?amt 180) (= ?y west))
           (and (= ?x east) (= ?amt 270) (= ?y north))

           (and (= ?x west) (= ?amt 0) (= ?y west)) 
           (and (= ?x west) (= ?amt 90) (= ?y north))
           (and (= ?x west) (= ?amt 180) (= ?y east))
           (and (= ?x west) (= ?amt 270) (= ?y south))
           ))

  (<=> (orientededge ?x ?o ?e)
       (and (piece ?x) 
            (orientation ?o)
            (cardinal ?e)
            (or (and (edge ?x north)
                     (rotate north ?o ?e))
                (and (edge ?x south)
                     (rotate south ?o ?e))
                (and (edge ?x east)
                     (rotate east ?o ?e))
                (and (edge ?x west)
                     (rotate west ?o ?e)) )))

  (<=> (connectedh ?x ?xo ?y ?yo)
       (and (piece ?x)
            (orientation ?xo)
            (piece ?y)
            (orientation ?yo)
            (or (and (orientededge ?x ?xo east)
                     (orientededge ?y ?yo west))
                (and (not (orientededge ?x ?xo east))
                     (not (orientededge ?y ?yo west))) )))
 
  (<=> (connectedv ?x ?xo ?y ?yo)
       (and (piece ?x)
            (orientation ?xo)
            (piece ?y)
            (orientation ?yo)
            (or (and (orientededge ?x ?xo south)
                     (orientededge ?y ?yo north))
                (and (not (orientededge ?x ?xo south))
                     (not (orientededge ?y ?yo north))) )))

  ; border uses p0, a piece with no edges
  (<=> (border ?o1 ?o2 ?o3 ?o4)
       (and (connectedh p0 0 p1 ?o1)
            (connectedv p0 0 p1 ?o1)
            (connectedv p0 0 p2 ?o2)
            (connectedh p2 ?o2 p0 0)
            (connectedh p4 ?o4 p0 0)
            (connectedv p4 ?o4 p0 0)
            (connectedv p3 ?o3 p0 0)
            (connectedh p0 0 p3 ?o3)))

  (<=> (connected ?o1 ?o2 ?o3 ?o4)
       (and (connectedh p1 ?o1 p2 ?o2)
            (connectedh p3 ?o3 p4 ?o4)
            (connectedv p1 ?o1 p3 ?o3)
            (connectedv p2 ?o2 p4 ?o4)
            (border ?o1 ?o2 ?o3 ?o4)))

  (<= (goal ?o1 ?o2 ?o3 ?o4)
      (connected ?o1 ?o2 ?o3 ?o4))
 
"))(POS (EXAMPLE.TARGETQUERY JIGSAW "(goal ?x ?y ?z ?w)"))(POS (EXAMPLE.TARGET JIGSAW "  (piece p1) 
  (piece p2) 
  (piece p3) 
  (piece p4) 
   
  (rotation 0) 
  (rotation 90) 
  (rotation 180) 
  (rotation 270) 
   
  (cardinal north) 
  (cardinal south) 
  (cardinal east) 
  (cardinal west) 
   
  (edge p1 north) 
  (edge p1 east) 
  (edge p2 north) 
  (edge p2 west) 
  (edge p3 south) 
  (edge p3 west) 
  (edge p4 north) 
  (edge p4 east) 
   
  (<= (east ?p ?rot) 
      (or (and (edge ?p east) (same ?rot 0)) 
          (and (edge ?p north) (same ?rot 90)) 
          (and (edge ?p west) (same ?rot 180)) 
          (and (edge ?p south) (same ?rot 270)))) 
   
  (<= (west ?p ?rot) 
      (or (and (edge ?p west) (same ?rot 0)) 
          (and (edge ?p south) (same ?rot 90)) 
          (and (edge ?p east) (same ?rot 180)) 
          (and (edge ?p north) (same ?rot 270)))) 
   
  (<= (north ?p ?rot) 
      (or (and (edge ?p north) (same ?rot 0)) 
          (and (edge ?p west) (same ?rot 90)) 
          (and (edge ?p south) (same ?rot 180)) 
          (and (edge ?p east) (same ?rot 270)))) 
   
  (<= (south ?p ?rot) 
      (or (and (edge ?p south) (same ?rot 0)) 
          (and (edge ?p east) (same ?rot 90)) 
          (and (edge ?p north) (same ?rot 180)) 
          (and (edge ?p west) (same ?rot 270)))) 
   
   
  (<= (goal ?nw ?ne ?sw ?se) 
      (rotation ?nw) 
      (rotation ?ne) 
      (rotation ?sw) 
      (rotation ?se) 
      (east p1 ?nw) 
      (west p2 ?ne) 
      (east p3 ?sw) 
      (west p4 ?se) 
      (south p1 ?nw) 
      (north p3 ?sw) 
      (south p2 ?ne) 
      (north p4 ?se))
"))(POS (TECHNIQUE.INSTANCE RESIDUESREWRITE))(POS (PRETTYNAME RESIDUESREWRITE "Rewrite with Residues"))(POS (SHORTNAME RESIDUESREWRITE "Residue"))(POS (MATRIXSHOW RESIDUESREWRITE TRUE))(POS (TECHNIQUE.DESCRIPTION RESIDUESREWRITE "Given a query phi, a set of sentences Delta, and a set of relations R, find all residues for phi in Delta wrt R.  Turn the result into a disjunction and simplify it."))(NEG (EXAMPLE.TECHNIQUE JIGSAW UNNAMED))(POS (EXAMPLE.TECHNIQUE JIGSAW RESIDUESREWRITE))(POS (EXAMPLE.TECHNIQUE JIGSAW UNNAMED))(NEG (EXAMPLE.TARGET JIGSAW "  (piece p1) 
  (piece p2) 
  (piece p3) 
  (piece p4) 
   
  (rotation 0) 
  (rotation 90) 
  (rotation 180) 
  (rotation 270) 
   
  (cardinal north) 
  (cardinal south) 
  (cardinal east) 
  (cardinal west) 
   
  (edge p1 north) 
  (edge p1 east) 
  (edge p2 north) 
  (edge p2 west) 
  (edge p3 south) 
  (edge p3 west) 
  (edge p4 north) 
  (edge p4 east) 
   
  (<= (east ?p ?rot) 
      (or (and (edge ?p east) (same ?rot 0)) 
          (and (edge ?p north) (same ?rot 90)) 
          (and (edge ?p west) (same ?rot 180)) 
          (and (edge ?p south) (same ?rot 270)))) 
   
  (<= (west ?p ?rot) 
      (or (and (edge ?p west) (same ?rot 0)) 
          (and (edge ?p south) (same ?rot 90)) 
          (and (edge ?p east) (same ?rot 180)) 
          (and (edge ?p north) (same ?rot 270)))) 
   
  (<= (north ?p ?rot) 
      (or (and (edge ?p north) (same ?rot 0)) 
          (and (edge ?p west) (same ?rot 90)) 
          (and (edge ?p south) (same ?rot 180)) 
          (and (edge ?p east) (same ?rot 270)))) 
   
  (<= (south ?p ?rot) 
      (or (and (edge ?p south) (same ?rot 0)) 
          (and (edge ?p east) (same ?rot 90)) 
          (and (edge ?p north) (same ?rot 180)) 
          (and (edge ?p west) (same ?rot 270)))) 
   
   
  (<= (goal ?nw ?ne ?sw ?se) 
      (rotation ?nw) 
      (rotation ?ne) 
      (rotation ?sw) 
      (rotation ?se) 
      (east p1 ?nw) 
      (west p2 ?ne) 
      (east p3 ?sw) 
      (west p4 ?se) 
      (south p1 ?nw) 
      (north p3 ?sw) 
      (south p2 ?ne) 
      (north p4 ?se))
"))(POS (EXAMPLE.TARGET JIGSAW "  (piece p1) 
  (piece p2) 
  (piece p3) 
  (piece p4) 
   
  (rotation 0) 
  (rotation 90) 
  (rotation 180) 
  (rotation 270) 
   
  (cardinal north) 
  (cardinal south) 
  (cardinal east) 
  (cardinal west) 
   
  (edge p1 north) 
  (edge p1 east) 
  (edge p2 north) 
  (edge p2 west) 
  (edge p3 south) 
  (edge p3 west) 
  (edge p4 north) 
  (edge p4 east) 
   
  (<= (rotate ?p ?rot east) 
      (or (and (edge ?p east) (same ?rot 0)) 
          (and (edge ?p north) (same ?rot 90)) 
          (and (edge ?p west) (same ?rot 180)) 
          (and (edge ?p south) (same ?rot 270)))) 
   
  (<= (rotate ?p ?rot west) 
      (or (and (edge ?p west) (same ?rot 0)) 
          (and (edge ?p south) (same ?rot 90)) 
          (and (edge ?p east) (same ?rot 180)) 
          (and (edge ?p north) (same ?rot 270)))) 
   
  (<= (rotate ?p ?rot north) 
      (or (and (edge ?p north) (same ?rot 0)) 
          (and (edge ?p west) (same ?rot 90)) 
          (and (edge ?p south) (same ?rot 180)) 
          (and (edge ?p east) (same ?rot 270)))) 
   
  (<= (rotate ?p ?rot south) 
      (or (and (edge ?p south) (same ?rot 0)) 
          (and (edge ?p east) (same ?rot 90)) 
          (and (edge ?p north) (same ?rot 180)) 
          (and (edge ?p west) (same ?rot 270)))) 
   
   
  (<= (goal ?nw ?ne ?sw ?se) 
      (rotation ?nw) 
      (rotation ?ne) 
      (rotation ?sw) 
      (rotation ?se) 
      (rotate p1 ?nw east) 
      (rotate p2 ?ne west) 
      (rotate p3 ?sw east) 
      (rotate p4 ?se west) 
      (rotate p1 ?nw south) 
      (rotate p3 ?sw north) 
      (rotate p2 ?ne south) 
      (rotate p4 ?se north))
"))(NEG (EXAMPLE.TECHNIQUE JIGSAW UNNAMED))(POS (EXAMPLE.TECHNIQUE JIGSAW NAF))(POS (EXAMPLE.TECHNIQUE JIGSAW UNNAMED))(POS (TECHNIQUE.INSTANCE STATICCONJORDERING))(POS (PRETTYNAME STATICCONJORDERING "Static Conjunct Ordering"))(POS (SHORTNAME STATICCONJORDERING "statconjorder"))(POS (MATRIXSHOW STATICCONJORDERING TRUE))(POS (TECHNIQUE.DESCRIPTION STATICCONJORDERING "For model elimination, ordering conjuncts statically requires simply changing the sequence of literals in the body of the rules."))(POS (EXAMPLE.INSTANCE GUESS))(POS (PRETTYNAME GUESS "Guess"))(POS (SHORTNAME GUESS "Guess"))(POS (EXAMPLE.COMPLETE GUESS COMPLETE))(POS (EXAMPLE.TECHNIQUE GUESS STATICCONJORDERING))(POS (EXAMPLE.DESCRIPTION GUESS "Example where a bad conjunct ordering requires non-zero work to find legal moves because the ground conjuncts are not moved all the way to the front."))(POS (EXAMPLE.EFFICIENCYGAINS GUESS "In this game, search space shrinks from 64^2 to 1 per rule."))(POS (MATRIXSHOW GUESS TRUE))(POS (EXAMPLE.COMMENTS GUESS "There may be a bug in the game -- something about greater than."))(POS (EXAMPLE.SOURCEQUERY GUESS "(legal chooser ?x)"))(POS (EXAMPLE.SOURCE GUESS "  (role guesser)
  (role chooser)
  (<= (legal guesser ?g)
      (true (possible ?g))
      (true (control guesser))
  (<= (legal guesser wait)
      (true (control chooser))
  (<= (next (control guesser))
      (true (control chooser))
  (<= (next (control chooser))
      (true (control guesser))
  (<= (next (guess ?x))
      (does guesser ?x)
      (true (possible ?x))
  (<= (legal chooser higher)
      (true (possible ?n))
      (greater ?n ?x)
      (true (guess ?x))
      (true (control chooser))
  (<= (legal chooser lower)
      (true (possible ?n))
      (greater ?x ?n)
      (true (guess ?x))
      (true (control chooser))
  (<= (legal chooser wait)
      (true (control guesser))
  (<= (next (possible ?x))
      (true (possible ?x))
      (true (control guesser))
  (<= (next (possible ?x))
      (true (possible ?x))
      (greater ?x ?y)
      (true (guess ?y))
      (does chooser higher)
  (<= (next (possible ?x))
      (true (possible ?x))
      (greater ?y ?x)
      (true (guess ?y))
      (does chooser lower)
  (<= (next (step ?x))
      (true (step ?y))
      (succ ?y ?x)
  (<= (goal guesser 100)
      (not unfinished)
  (<= (goal guesser 0)
      unfinished
  (<= (goal chooser 100)
      unfinished
  (<= (goal chooser 0)
      (not unfinished)
  (<= terminal
      (not unfinished)
  (<= terminal
      (true (step 12))
  (<= unfinished
      (true (possible ?x))
      (true (possible ?y))
      (distinct ?x ?y)
  (<= (greater ?x ?y)
      (succ ?y ?x)
  (<= (greater ?x ?y)
      (succ ?x ?z)
      (greater ?z ?y)
  (init (step 1))
  (init (control guesser))
  (init (possible 1))
  (init (possible 2))
  (init (possible 3))
  (init (possible 4))
  (init (possible 5))
  (init (possible 6))
  (init (possible 7))
  (init (possible 8))
  (init (possible 9))
  (init (possible 10))
  (init (possible 11))
  (init (possible 12))
  (init (possible 13))
  (init (possible 14))
  (init (possible 15))
  (init (possible 16))
  (init (possible 17))
  (init (possible 18))
  (init (possible 19))
  (init (possible 20))
  (init (possible 21))
  (init (possible 22))
  (init (possible 23))
  (init (possible 24))
  (init (possible 25))
  (init (possible 26))
  (init (possible 27))
  (init (possible 28))
  (init (possible 29))
  (init (possible 30))
  (init (possible 31))
  (init (possible 32))
  (init (possible 33))
  (init (possible 34))
  (init (possible 35))
  (init (possible 36))
  (init (possible 37))
  (init (possible 38))
  (init (possible 39))
  (init (possible 40))
  (init (possible 41))
  (init (possible 42))
  (init (possible 43))
  (init (possible 44))
  (init (possible 45))
  (init (possible 46))
  (init (possible 47))
  (init (possible 48))
  (init (possible 49))
  (init (possible 50))
  (init (possible 51))
  (init (possible 52))
  (init (possible 53))
  (init (possible 54))
  (init (possible 55))
  (init (possible 56))
  (init (possible 57))
  (init (possible 58))
  (init (possible 59))
  (init (possible 60))
  (init (possible 61))
  (init (possible 62))
  (init (possible 63))
  (succ 1 2)
  (succ 2 3)
  (succ 3 4)
  (succ 4 5)
  (succ 5 6)
  (succ 6 7)
  (succ 7 8)
  (succ 8 9)
  (succ 9 10)
  (succ 10 11)
  (succ 11 12)
  (succ 12 13)
  (succ 13 14)
  (succ 14 15)
  (succ 15 16)
  (succ 16 17)
  (succ 17 18)
  (succ 18 19)
  (succ 19 20)
  (succ 20 21)
  (succ 21 22)
  (succ 22 23)
  (succ 23 24)
  (succ 24 25)
  (succ 25 26)
  (succ 26 27)
  (succ 27 28)
  (succ 28 29)
  (succ 29 30)
  (succ 30 31)
  (succ 31 32)
  (succ 32 33)
  (succ 33 34)
  (succ 34 35)
  (succ 35 36)
  (succ 36 37)
  (succ 37 38)
  (succ 38 39)
  (succ 39 40)
  (succ 40 41)
  (succ 41 42)
  (succ 42 43)
  (succ 43 44)
  (succ 44 45)
  (succ 45 46)
  (succ 46 47)
  (succ 47 48)
  (succ 48 49)
  (succ 49 50)
  (succ 50 51)
  (succ 51 52)
  (succ 52 53)
  (succ 53 54)
  (succ 54 55)
  (succ 55 56)
  (succ 56 57)
  (succ 57 58)
  (succ 58 59)
  (succ 59 60)
  (succ 60 61)
  (succ 61 62)
  (succ 62 63)"))(POS (EXAMPLE.TARGETQUERY GUESS "(legal chooser ?x)"))(POS (EXAMPLE.TARGET GUESS "  (role guesser)
  (role chooser)

  (<= (legal guesser ?g)
      (true (control guesser))
      (true (possible ?g)))

  (<= (legal guesser wait)
      (true (control chooser)))

  (<= (next (control guesser))
      (true (control chooser)))

  (<= (next (control chooser))
      (true (control guesser)))

  (<= (next (guess ?x))
      (does guesser ?x)
      (true (possible ?x)))

  (<= (legal chooser higher)
      (true (control chooser))
      (true (possible ?n))
      (greater ?n ?x)
      (true (guess ?x)))

  (<= (legal chooser lower)
      (true (control chooser))
      (true (possible ?n))
      (greater ?x ?n)
      (true (guess ?x)))

  (<= (legal chooser wait)
      (true (control guesser)))

  (<= (next (possible ?x))
      (true (control guesser))
      (true (possible ?x)))

  (<= (next (possible ?x))
      (does chooser higher)
      (true (possible ?x))
      (greater ?x ?y)
      (true (guess ?y)))

  (<= (next (possible ?x))
      (does chooser lower)
      (true (possible ?x))
      (greater ?y ?x)
      (true (guess ?y)))

  (<= (next (step ?x))
      (true (step ?y))
      (succ ?y ?x))

  (<= (goal guesser 100)
      (not unfinished))
  (<= (goal guesser 0)
      unfinished)
  (<= (goal chooser 100)
      unfinished)
  (<= (goal chooser 0)
      (not unfinished))
  (<= terminal
      (not unfinished))
  (<= terminal
      (true (step 12)))
  (<= unfinished
      (true (possible ?x))
      (true (possible ?y))
      (distinct ?x ?y))
  (<= (greater ?x ?y)
      (succ ?y ?x))
  (<= (greater ?x ?y)
      (succ ?x ?z)
      (greater ?z ?y))
  (init (step 1))
  (init (control guesser))
  (init (possible 1))
  (init (possible 2))
  (init (possible 3))
  (init (possible 4))
  (init (possible 5))
  (init (possible 6))
  (init (possible 7))
  (init (possible 8))
  (init (possible 9))
  (init (possible 10))
  (init (possible 11))
  (init (possible 12))
  (init (possible 13))
  (init (possible 14))
  (init (possible 15))
  (init (possible 16))
  (init (possible 17))
  (init (possible 18))
  (init (possible 19))
  (init (possible 20))
  (init (possible 21))
  (init (possible 22))
  (init (possible 23))
  (init (possible 24))
  (init (possible 25))
  (init (possible 26))
  (init (possible 27))
  (init (possible 28))
  (init (possible 29))
  (init (possible 30))
  (init (possible 31))
  (init (possible 32))
  (init (possible 33))
  (init (possible 34))
  (init (possible 35))
  (init (possible 36))
  (init (possible 37))
  (init (possible 38))
  (init (possible 39))
  (init (possible 40))
  (init (possible 41))
  (init (possible 42))
  (init (possible 43))
  (init (possible 44))
  (init (possible 45))
  (init (possible 46))
  (init (possible 47))
  (init (possible 48))
  (init (possible 49))
  (init (possible 50))
  (init (possible 51))
  (init (possible 52))
  (init (possible 53))
  (init (possible 54))
  (init (possible 55))
  (init (possible 56))
  (init (possible 57))
  (init (possible 58))
  (init (possible 59))
  (init (possible 60))
  (init (possible 61))
  (init (possible 62))
  (init (possible 63))
  (succ 1 2)
  (succ 2 3)
  (succ 3 4)
  (succ 4 5)
  (succ 5 6)
  (succ 6 7)
  (succ 7 8)
  (succ 8 9)
  (succ 9 10)
  (succ 10 11)
  (succ 11 12)
  (succ 12 13)
  (succ 13 14)
  (succ 14 15)
  (succ 15 16)
  (succ 16 17)
  (succ 17 18)
  (succ 18 19)
  (succ 19 20)
  (succ 20 21)
  (succ 21 22)
  (succ 22 23)
  (succ 23 24)
  (succ 24 25)
  (succ 25 26)
  (succ 26 27)
  (succ 27 28)
  (succ 28 29)
  (succ 29 30)
  (succ 30 31)
  (succ 31 32)
  (succ 32 33)
  (succ 33 34)
  (succ 34 35)
  (succ 35 36)
  (succ 36 37)
  (succ 37 38)
  (succ 38 39)
  (succ 39 40)
  (succ 40 41)
  (succ 41 42)
  (succ 42 43)
  (succ 43 44)
  (succ 44 45)
  (succ 45 46)
  (succ 46 47)
  (succ 47 48)
  (succ 48 49)
  (succ 49 50)
  (succ 50 51)
  (succ 51 52)
  (succ 52 53)
  (succ 53 54)
  (succ 54 55)
  (succ 55 56)
  (succ 56 57)
  (succ 57 58)
  (succ 58 59)
  (succ 59 60)
  (succ 60 61)
  (succ 61 62)
  (succ 62 63)"))(NEG (SHORTNAME STATICCONJORDERING "statconjorder"))(POS (SHORTNAME STATICCONJORDERING "StatCO"))(NEG (EXAMPLE.COMPLETE JIGSAW INCOMPLETE))(POS (EXAMPLE.COMPLETE JIGSAW COMPLETE))(POS (TECHNIQUE.INSTANCE BILEVEL))(POS (PRETTYNAME BILEVEL "Bilevel Reasoning"))(POS (SHORTNAME BILEVEL "Bi"))(POS (MATRIXSHOW BILEVEL TRUE))(POS (TECHNIQUE.DESCRIPTION BILEVEL "Split the problem into two pieces: the data and the axioms."))(POS (EXAMPLE.INSTANCE 4QUEENS))(POS (PRETTYNAME 4QUEENS "4-Queens"))(POS (SHORTNAME 4QUEENS "4queens"))(POS (EXAMPLE.COMPLETE 4QUEENS INCOMPLETE))(POS (EXAMPLE.TECHNIQUE 4QUEENS CONSISTENCY2DEDUCTION))(POS (EXAMPLE.TECHNIQUE 4QUEENS BILEVEL))(POS (EXAMPLE.TECHNIQUE 4QUEENS NAF))(POS (EXAMPLE.DESCRIPTION 4QUEENS "The traditional 8-queens puzzle, shrunken to a 4x4 board with 4 queens.  Two solutions exist to what is usually a CSP.  But in this example, we are asking an entailment query about those solutions: is the upper left square always blank?"))(POS (MATRIXSHOW 4QUEENS TRUE))(POS (EXAMPLE.COMMENTS 4QUEENS "Add in UNA and DCA for all object constants, i.e. this is finite Herbrand logic."))(POS (EXAMPLE.SOURCEQUERY 4QUEENS "      (forall (?x1 ?y1 ?x2 ?y2 ?x3 ?y3 ?x4 ?y4) 
              (=> (ans ?x1 ?y1 ?x2 ?y2 ?x3 ?y3 ?x4 ?y4)
                  (and (not (= ?x1 1))
                       (not (= ?y1 1))
                       (not (= ?x2 1))
                       (not (= ?y2 1))
                       (not (= ?x3 1))
                       (not (= ?y3 1))
                       (not (= ?x4 1))
                       (not (= ?y4 1))))"))(POS (EXAMPLE.SOURCE 4QUEENS "  (<= (ans ?x1 ?y1 ?x2 ?y2 ?x3 ?y3 ?x4 ?y4)
      (and (row q1 ?x1) (col q1 ?y1) (row q2 ?x2) (col q2 ?y2) (row q3 ?x3) (col q3 ?y3) (row q4 ?x4) (col q4 ?y4)))

  ; all the queens have different rows
  (<= (not (row ?x ?c))
      (row ?y ?c)
      (not (= ?x ?y)))

  ; all the queens have different columns
  (<= (not (col ?x ?c))
      (col ?y ?c)
      (not (= ?x ?y)))

  ; given a row and column, we can compute the two diagonals it is on.
  (<= (d ?q pos ?z) (row ?q ?x) (col ?q ?y) (sub ?y ?x ?z))
  (<= (d ?q neg ?z) (row ?q ?x) (col ?q ?y) (add ?y ?x ?z))

  ; all the queens have different diagonals
  (<= (not (d ?q1 ?sign ?z))
      (d ?q2 ?sign ?z)
      (not (= ?q1 ?q2)))

  ; add and subtract
  (add 1 1 2)
  (add 1 2 3)
  (add 1 3 4)
  (add 1 4 5)
  (add 2 1 3)
  (add 2 2 4)
  (add 2 3 5)
  (add 2 4 6)
  (add 3 1 4)
  (add 3 2 5)
  (add 3 3 6)
  (add 3 4 7)
  (add 4 1 5)
  (add 4 2 6)
  (add 4 3 7)
  (add 4 4 8)

  (sub 1 1 0)
  (sub 1 2 -1)
  (sub 1 3 -2)
  (sub 1 4 -3)
  (sub 2 1 1)
  (sub 2 2 0)
  (sub 2 3 -1)
  (sub 2 4 -2)
  (sub 3 1 2)
  (sub 3 2 1)
  (sub 3 3 0)
  (sub 3 4 -1)
  (sub 4 1 3)
  (sub 4 2 2)
  (sub 4 3 1)
  (sub 4 4 0)
"))(POS (EXAMPLE.TARGETQUERY 4QUEENS "ent"))(POS (EXAMPLE.TARGET 4QUEENS "  (<= ent
      (not notent))
  (<= notent
      (goal17 ?X1 ?Y1 ?X2 ?Y2 ?X3 ?Y3 ?X4 ?Y4)
      (not (phi ?X1 ?Y1 ?X2 ?Y2 ?X3 ?Y3 ?X4 ?Y4)))
 
  (<= (phi ?X1 ?Y1 ?X2 ?Y2 ?X3 ?Y3 ?X4 ?Y4)
      (or (distinct ?x1 1)
          (distinct ?y1 1))
      (or (distinct ?x2 1)
          (distinct ?y2 1))
      (or (distinct ?x3 1)
          (distinct ?y3 1))
      (or (distinct ?x4 1)
          (distinct ?y4 1)))
      
  ; below ne is the not equal table
  (<= (goal17 ?X1 ?Y1 ?X2 ?Y2 ?X3 ?Y3 ?X4 ?Y4)
      
      (sub ?y1 ?x1 ?neg1)
      (add ?y1 ?x1 ?pos1)
      (sub ?y2 ?x2 ?neg2)
      (distinct ?X1 ?X2)
      (distinct ?Y1 ?Y2)
      (distinct ?neg2 ?neg1)
      (add ?y2 ?x2 ?pos2)
      (distinct ?pos2 ?pos1)
      
      
      (sub ?y3 ?x3 ?neg3)
      (distinct ?X1 ?X3) 
      (distinct ?Y1 ?Y3)
      (distinct ?X2 ?X3)
      (distinct ?Y2 ?Y3)
      (distinct ?neg3 ?neg2)
      (distinct ?neg3 ?neg1)
      (add ?y3 ?x3 ?pos3)
      (distinct ?pos3 ?pos2)
      (distinct ?pos3 ?pos1)
      
      (sub ?y4 ?x4 ?neg4)
      (distinct ?X1 ?X4)
      (distinct ?X2 ?X4)
      (distinct ?X3 ?X4)
      (distinct ?Y1 ?Y4)
      (distinct ?Y2 ?Y4)
      (distinct ?Y3 ?Y4)
      (distinct ?neg4 ?neg3)
      (distinct ?neg4 ?neg2)
      (distinct ?neg4 ?neg1)
      (add ?y4 ?x4 ?pos4)
      (distinct ?pos4 ?pos3)
      (distinct ?pos4 ?pos2)
      (distinct ?pos4 ?pos1))
  
  (add 1 1 2)
  (add 1 2 3)
  (add 1 3 4)
  (add 1 4 5)
  (add 2 1 3)
  (add 2 2 4)
  (add 2 3 5)
  (add 2 4 6)
  (add 3 1 4)
  (add 3 2 5)
  (add 3 3 6)
  (add 3 4 7)
  (add 4 1 5)
  (add 4 2 6)
  (add 4 3 7)
  (add 4 4 8)

  (sub 1 1 0)
  (sub 1 2 -1)
  (sub 1 3 -2)
  (sub 1 4 -3)
  (sub 2 1 1)
  (sub 2 2 0)
  (sub 2 3 -1)
  (sub 2 4 -2)
  (sub 3 1 2)
  (sub 3 2 1)
  (sub 3 3 0)
  (sub 3 4 -1)
  (sub 4 1 3)
  (sub 4 2 2)
  (sub 4 3 1)
  (sub 4 4 0)"))(NEG (EXAMPLE.DESCRIPTION 4QUEENS "The traditional 8-queens puzzle, shrunken to a 4x4 board with 4 queens.  Two solutions exist to what is usually a CSP.  But in this example, we are asking an entailment query about those solutions: is the upper left square always blank?"))(POS (EXAMPLE.DESCRIPTION 4QUEENS "The traditional 8-queens puzzle, shrunken to a 4x4 board with 4 queens.  Two solutions exist to what is usually a CSP.  But in this example, we are asking an entailment query about those solutions: is the upper left square always blank?  This translation turns an entailment query stated in FHL into a datalog query."))(POS (EXAMPLE.TECHNIQUE 4QUEENS UNNAMED))(NEG (EXAMPLE.SOURCEQUERY 4QUEENS "      (forall (?x1 ?y1 ?x2 ?y2 ?x3 ?y3 ?x4 ?y4) 
              (=> (ans ?x1 ?y1 ?x2 ?y2 ?x3 ?y3 ?x4 ?y4)
                  (and (not (= ?x1 1))
                       (not (= ?y1 1))
                       (not (= ?x2 1))
                       (not (= ?y2 1))
                       (not (= ?x3 1))
                       (not (= ?y3 1))
                       (not (= ?x4 1))
                       (not (= ?y4 1))))"))(POS (EXAMPLE.SOURCEQUERY 4QUEENS "goal"))(NEG (EXAMPLE.SOURCE 4QUEENS "  (<= (ans ?x1 ?y1 ?x2 ?y2 ?x3 ?y3 ?x4 ?y4)
      (and (row q1 ?x1) (col q1 ?y1) (row q2 ?x2) (col q2 ?y2) (row q3 ?x3) (col q3 ?y3) (row q4 ?x4) (col q4 ?y4)))

  ; all the queens have different rows
  (<= (not (row ?x ?c))
      (row ?y ?c)
      (not (= ?x ?y)))

  ; all the queens have different columns
  (<= (not (col ?x ?c))
      (col ?y ?c)
      (not (= ?x ?y)))

  ; given a row and column, we can compute the two diagonals it is on.
  (<= (d ?q pos ?z) (row ?q ?x) (col ?q ?y) (sub ?y ?x ?z))
  (<= (d ?q neg ?z) (row ?q ?x) (col ?q ?y) (add ?y ?x ?z))

  ; all the queens have different diagonals
  (<= (not (d ?q1 ?sign ?z))
      (d ?q2 ?sign ?z)
      (not (= ?q1 ?q2)))

  ; add and subtract
  (add 1 1 2)
  (add 1 2 3)
  (add 1 3 4)
  (add 1 4 5)
  (add 2 1 3)
  (add 2 2 4)
  (add 2 3 5)
  (add 2 4 6)
  (add 3 1 4)
  (add 3 2 5)
  (add 3 3 6)
  (add 3 4 7)
  (add 4 1 5)
  (add 4 2 6)
  (add 4 3 7)
  (add 4 4 8)

  (sub 1 1 0)
  (sub 1 2 -1)
  (sub 1 3 -2)
  (sub 1 4 -3)
  (sub 2 1 1)
  (sub 2 2 0)
  (sub 2 3 -1)
  (sub 2 4 -2)
  (sub 3 1 2)
  (sub 3 2 1)
  (sub 3 3 0)
  (sub 3 4 -1)
  (sub 4 1 3)
  (sub 4 2 2)
  (sub 4 3 1)
  (sub 4 4 0)
"))(POS (EXAMPLE.SOURCE 4QUEENS "  (<= goal 
      (forall (?x1 ?y1 ?x2 ?y2 ?x3 ?y3 ?x4 ?y4) 
              (=> (and (row q1 ?x1) (col q1 ?y1) (row q2 ?x2) (col q2 ?y2) (row q3 ?x3) (col q3 ?y3) (row q4 ?x4) (col q4 ?y4))
                  (not (or (and (= ?x1 1) (= ?y1 1))
                           (and (= ?x2 1) (= ?y2 1))
                           (and (= ?x3 1) (= ?y3 1))
                           (and (= ?x4 1) (= ?y4 1)))))))

  ; all the queens have different rows
  (<= (not (row ?x ?c))
      (row ?y ?c)
      (not (= ?x ?y)))

  ; all the queens have different columns
  (<= (not (col ?x ?c))
      (col ?y ?c)
      (not (= ?x ?y)))

  ; given a row and column, we can compute the two diagonals it is on.
  (<= (d ?q pos ?z) (row ?q ?x) (col ?q ?y) (sub ?y ?x ?z))
  (<= (d ?q neg ?z) (row ?q ?x) (col ?q ?y) (add ?y ?x ?z))

  ; all the queens have different diagonals
  (<= (not (d ?q1 ?sign ?z))
      (d ?q2 ?sign ?z)
      (not (= ?q1 ?q2)))

  ; add and subtract
  (add 1 1 2)
  (add 1 2 3)
  (add 1 3 4)
  (add 1 4 5)
  (add 2 1 3)
  (add 2 2 4)
  (add 2 3 5)
  (add 2 4 6)
  (add 3 1 4)
  (add 3 2 5)
  (add 3 3 6)
  (add 3 4 7)
  (add 4 1 5)
  (add 4 2 6)
  (add 4 3 7)
  (add 4 4 8)

  (sub 1 1 0)
  (sub 1 2 -1)
  (sub 1 3 -2)
  (sub 1 4 -3)
  (sub 2 1 1)
  (sub 2 2 0)
  (sub 2 3 -1)
  (sub 2 4 -2)
  (sub 3 1 2)
  (sub 3 2 1)
  (sub 3 3 0)
  (sub 3 4 -1)
  (sub 4 1 3)
  (sub 4 2 2)
  (sub 4 3 1)
  (sub 4 4 0)
"))(NEG (EXAMPLE.SOURCEQUERY 4QUEENS "goal"))(POS (EXAMPLE.SOURCEQUERY 4QUEENS "(forall (?x1 ?y1 ?x2 ?y2 ?x3 ?y3 ?x4 ?y4) 
              (=> (and (row q1 ?x1) (col q1 ?y1) (row q2 ?x2) (col q2 ?y2) (row q3 ?x3) (col q3 ?y3) (row q4 ?x4) (col q4 ?y4))
                  (not (or (and (= ?x1 1) (= ?y1 1))
                           (and (= ?x2 1) (= ?y2 1))
                           (and (= ?x3 1) (= ?y3 1))
                           (and (= ?x4 1) (= ?y4 1))))))"))(NEG (EXAMPLE.SOURCE 4QUEENS "  (<= goal 
      (forall (?x1 ?y1 ?x2 ?y2 ?x3 ?y3 ?x4 ?y4) 
              (=> (and (row q1 ?x1) (col q1 ?y1) (row q2 ?x2) (col q2 ?y2) (row q3 ?x3) (col q3 ?y3) (row q4 ?x4) (col q4 ?y4))
                  (not (or (and (= ?x1 1) (= ?y1 1))
                           (and (= ?x2 1) (= ?y2 1))
                           (and (= ?x3 1) (= ?y3 1))
                           (and (= ?x4 1) (= ?y4 1)))))))

  ; all the queens have different rows
  (<= (not (row ?x ?c))
      (row ?y ?c)
      (not (= ?x ?y)))

  ; all the queens have different columns
  (<= (not (col ?x ?c))
      (col ?y ?c)
      (not (= ?x ?y)))

  ; given a row and column, we can compute the two diagonals it is on.
  (<= (d ?q pos ?z) (row ?q ?x) (col ?q ?y) (sub ?y ?x ?z))
  (<= (d ?q neg ?z) (row ?q ?x) (col ?q ?y) (add ?y ?x ?z))

  ; all the queens have different diagonals
  (<= (not (d ?q1 ?sign ?z))
      (d ?q2 ?sign ?z)
      (not (= ?q1 ?q2)))

  ; add and subtract
  (add 1 1 2)
  (add 1 2 3)
  (add 1 3 4)
  (add 1 4 5)
  (add 2 1 3)
  (add 2 2 4)
  (add 2 3 5)
  (add 2 4 6)
  (add 3 1 4)
  (add 3 2 5)
  (add 3 3 6)
  (add 3 4 7)
  (add 4 1 5)
  (add 4 2 6)
  (add 4 3 7)
  (add 4 4 8)

  (sub 1 1 0)
  (sub 1 2 -1)
  (sub 1 3 -2)
  (sub 1 4 -3)
  (sub 2 1 1)
  (sub 2 2 0)
  (sub 2 3 -1)
  (sub 2 4 -2)
  (sub 3 1 2)
  (sub 3 2 1)
  (sub 3 3 0)
  (sub 3 4 -1)
  (sub 4 1 3)
  (sub 4 2 2)
  (sub 4 3 1)
  (sub 4 4 0)
"))(POS (EXAMPLE.SOURCE 4QUEENS "
  ; all the queens have different rows
  (<= (not (row ?x ?c))
      (row ?y ?c)
      (not (= ?x ?y)))

  ; all the queens have different columns
  (<= (not (col ?x ?c))
      (col ?y ?c)
      (not (= ?x ?y)))

  ; given a row and column, we can compute the two diagonals it is on.
  (<= (d ?q pos ?z) (row ?q ?x) (col ?q ?y) (sub ?y ?x ?z))
  (<= (d ?q neg ?z) (row ?q ?x) (col ?q ?y) (add ?y ?x ?z))

  ; all the queens have different diagonals
  (<= (not (d ?q1 ?sign ?z))
      (d ?q2 ?sign ?z)
      (not (= ?q1 ?q2)))

  ; add and subtract
  (add 1 1 2)
  (add 1 2 3)
  (add 1 3 4)
  (add 1 4 5)
  (add 2 1 3)
  (add 2 2 4)
  (add 2 3 5)
  (add 2 4 6)
  (add 3 1 4)
  (add 3 2 5)
  (add 3 3 6)
  (add 3 4 7)
  (add 4 1 5)
  (add 4 2 6)
  (add 4 3 7)
  (add 4 4 8)

  (sub 1 1 0)
  (sub 1 2 -1)
  (sub 1 3 -2)
  (sub 1 4 -3)
  (sub 2 1 1)
  (sub 2 2 0)
  (sub 2 3 -1)
  (sub 2 4 -2)
  (sub 3 1 2)
  (sub 3 2 1)
  (sub 3 3 0)
  (sub 3 4 -1)
  (sub 4 1 3)
  (sub 4 2 2)
  (sub 4 3 1)
  (sub 4 4 0)
"))(POS (TECHNIQUE.INSTANCE SYMMETRYANALYSIS))(POS (PRETTYNAME SYMMETRYANALYSIS "Symmetry Analysis"))(POS (SHORTNAME SYMMETRYANALYSIS "Sym"))(POS (MATRIXSHOW SYMMETRYANALYSIS TRUE))(POS (TECHNIQUE.DESCRIPTION SYMMETRYANALYSIS "Take advantage of symmetry in the problem to reduce the search space."))(POS (EXAMPLE.INSTANCE 4QSDATALOG))(POS (PRETTYNAME 4QSDATALOG "4-Queens Datalog"))(POS (SHORTNAME 4QSDATALOG "4qsdatalog"))(POS (EXAMPLE.COMPLETE 4QSDATALOG COMPLETE))(POS (EXAMPLE.TECHNIQUE 4QSDATALOG SYMMETRYANALYSIS))(POS (EXAMPLE.DESCRIPTION 4QSDATALOG "Take advantage of the fact that we can order the queens so that the first one is always placed left of the second, the second left of the third, and so on.  To do this, we use less-than instead of just distinct."))(POS (EXAMPLE.EFFICIENCYGAINS 4QSDATALOG "5x"))(POS (MATRIXSHOW 4QSDATALOG TRUE))(POS (EXAMPLE.COMMENTS 4QSDATALOG "We should be able to detect the fact that the query doesn't care about what order the queens are in; determining that less-than can be used and how to do that should then be possible."))(POS (EXAMPLE.SOURCEQUERY 4QSDATALOG "ent"))(POS (EXAMPLE.SOURCE 4QSDATALOG "  (<= ent
      (not notent))
  (<= notent
      (goal17 ?X1 ?Y1 ?X2 ?Y2 ?X3 ?Y3 ?X4 ?Y4)
      (not (phi ?X1 ?Y1 ?X2 ?Y2 ?X3 ?Y3 ?X4 ?Y4)))
 
  (<= (phi ?X1 ?Y1 ?X2 ?Y2 ?X3 ?Y3 ?X4 ?Y4)
      (or (distinct ?x1 1)
          (distinct ?y1 1))
      (or (distinct ?x2 1)
          (distinct ?y2 1))
      (or (distinct ?x3 1)
          (distinct ?y3 1))
      (or (distinct ?x4 1)
          (distinct ?y4 1)))
      
  ; below ne is the not equal table
  (<= (goal17 ?X1 ?Y1 ?X2 ?Y2 ?X3 ?Y3 ?X4 ?Y4)
      
      (sub ?y1 ?x1 ?neg1)
      (add ?y1 ?x1 ?pos1)
      (sub ?y2 ?x2 ?neg2)
      (distinct ?X1 ?X2)
      (distinct ?Y1 ?Y2)
      (distinct ?neg2 ?neg1)
      (add ?y2 ?x2 ?pos2)
      (distinct ?pos2 ?pos1)
      
      
      (sub ?y3 ?x3 ?neg3)
      (distinct ?X1 ?X3) 
      (distinct ?Y1 ?Y3)
      (distinct ?X2 ?X3)
      (distinct ?Y2 ?Y3)
      (distinct ?neg3 ?neg2)
      (distinct ?neg3 ?neg1)
      (add ?y3 ?x3 ?pos3)
      (distinct ?pos3 ?pos2)
      (distinct ?pos3 ?pos1)
      
      (sub ?y4 ?x4 ?neg4)
      (distinct ?X1 ?X4)
      (distinct ?X2 ?X4)
      (distinct ?X3 ?X4)
      (distinct ?Y1 ?Y4)
      (distinct ?Y2 ?Y4)
      (distinct ?Y3 ?Y4)
      (distinct ?neg4 ?neg3)
      (distinct ?neg4 ?neg2)
      (distinct ?neg4 ?neg1)
      (add ?y4 ?x4 ?pos4)
      (distinct ?pos4 ?pos3)
      (distinct ?pos4 ?pos2)
      (distinct ?pos4 ?pos1))
  
  (add 1 1 2)
  (add 1 2 3)
  (add 1 3 4)
  (add 1 4 5)
  (add 2 1 3)
  (add 2 2 4)
  (add 2 3 5)
  (add 2 4 6)
  (add 3 1 4)
  (add 3 2 5)
  (add 3 3 6)
  (add 3 4 7)
  (add 4 1 5)
  (add 4 2 6)
  (add 4 3 7)
  (add 4 4 8)

  (sub 1 1 0)
  (sub 1 2 -1)
  (sub 1 3 -2)
  (sub 1 4 -3)
  (sub 2 1 1)
  (sub 2 2 0)
  (sub 2 3 -1)
  (sub 2 4 -2)
  (sub 3 1 2)
  (sub 3 2 1)
  (sub 3 3 0)
  (sub 3 4 -1)
  (sub 4 1 3)
  (sub 4 2 2)
  (sub 4 3 1)
  (sub 4 4 0)"))(POS (EXAMPLE.TARGETQUERY 4QSDATALOG "ent"))(POS (EXAMPLE.TARGET 4QSDATALOG "  (<= ent
      (not notent))
  (<= notent
      (goal17 ?X1 ?Y1 ?X2 ?Y2 ?X3 ?Y3 ?X4 ?Y4)
      (not (phi ?X1 ?Y1 ?X2 ?Y2 ?X3 ?Y3 ?X4 ?Y4)))
 
  (<= (phi ?X1 ?Y1 ?X2 ?Y2 ?X3 ?Y3 ?X4 ?Y4)
      (or (distinct ?x1 1)
          (distinct ?y1 1))
      (or (distinct ?x2 1)
          (distinct ?y2 1))
      (or (distinct ?x3 1)
          (distinct ?y3 1))
      (or (distinct ?x4 1)
          (distinct ?y4 1)))
      
  ; below ne is the not equal table
  (<= (goal17 ?X1 ?Y1 ?X2 ?Y2 ?X3 ?Y3 ?X4 ?Y4)
      
      (sub ?y1 ?x1 ?neg1)
      (add ?y1 ?x1 ?pos1)
      (sub ?y2 ?x2 ?neg2)
      (< ?x1 ?x2)
      (distinct ?y1 ?y2)
      (distinct ?neg2 ?neg1)
      (add ?y2 ?x2 ?pos2)
      (distinct ?pos2 ?pos1)
      
      
      (sub ?y3 ?x3 ?neg3)
      (< ?x2 ?x3)
      (distinct ?y3 ?y1)
      (distinct ?y3 ?y2)
      (distinct ?neg3 ?neg2)
      (distinct ?neg3 ?neg1)
      (add ?y3 ?x3 ?pos3)
      (distinct ?pos3 ?pos2)
      (distinct ?pos3 ?pos1)
      
      (sub ?y4 ?x4 ?neg4)
      (< ?x3 ?x4)
      (distinct ?y4 ?y1)
      (distinct ?y4 ?y2)
      (distinct ?y4 ?y3)
      (distinct ?neg4 ?neg3)
      (distinct ?neg4 ?neg2)
      (distinct ?neg4 ?neg1)
      (add ?y4 ?x4 ?pos4)
      (distinct ?pos4 ?pos3)
      (distinct ?pos4 ?pos2)
      (distinct ?pos4 ?pos1))
  
  (add 1 1 2)
  (add 1 2 3)
  (add 1 3 4)
  (add 1 4 5)
  (add 2 1 3)
  (add 2 2 4)
  (add 2 3 5)
  (add 2 4 6)
  (add 3 1 4)
  (add 3 2 5)
  (add 3 3 6)
  (add 3 4 7)
  (add 4 1 5)
  (add 4 2 6)
  (add 4 3 7)
  (add 4 4 8)

  (sub 1 1 0)
  (sub 1 2 -1)
  (sub 1 3 -2)
  (sub 1 4 -3)
  (sub 2 1 1)
  (sub 2 2 0)
  (sub 2 3 -1)
  (sub 2 4 -2)
  (sub 3 1 2)
  (sub 3 2 1)
  (sub 3 3 0)
  (sub 3 4 -1)
  (sub 4 1 3)
  (sub 4 2 2)
  (sub 4 3 1)
  (sub 4 4 0)"))(NEG (EXAMPLE.COMMENTS 4QUEENS "Add in UNA and DCA for all object constants, i.e. this is finite Herbrand logic."))(POS (EXAMPLE.COMMENTS 4QUEENS "In the source, add in UNA and DCA for all object constants, i.e. this is finite Herbrand logic."))(NEG (EXAMPLE.SOURCE 4QUEENS "
  ; all the queens have different rows
  (<= (not (row ?x ?c))
      (row ?y ?c)
      (not (= ?x ?y)))

  ; all the queens have different columns
  (<= (not (col ?x ?c))
      (col ?y ?c)
      (not (= ?x ?y)))

  ; given a row and column, we can compute the two diagonals it is on.
  (<= (d ?q pos ?z) (row ?q ?x) (col ?q ?y) (sub ?y ?x ?z))
  (<= (d ?q neg ?z) (row ?q ?x) (col ?q ?y) (add ?y ?x ?z))

  ; all the queens have different diagonals
  (<= (not (d ?q1 ?sign ?z))
      (d ?q2 ?sign ?z)
      (not (= ?q1 ?q2)))

  ; add and subtract
  (add 1 1 2)
  (add 1 2 3)
  (add 1 3 4)
  (add 1 4 5)
  (add 2 1 3)
  (add 2 2 4)
  (add 2 3 5)
  (add 2 4 6)
  (add 3 1 4)
  (add 3 2 5)
  (add 3 3 6)
  (add 3 4 7)
  (add 4 1 5)
  (add 4 2 6)
  (add 4 3 7)
  (add 4 4 8)

  (sub 1 1 0)
  (sub 1 2 -1)
  (sub 1 3 -2)
  (sub 1 4 -3)
  (sub 2 1 1)
  (sub 2 2 0)
  (sub 2 3 -1)
  (sub 2 4 -2)
  (sub 3 1 2)
  (sub 3 2 1)
  (sub 3 3 0)
  (sub 3 4 -1)
  (sub 4 1 3)
  (sub 4 2 2)
  (sub 4 3 1)
  (sub 4 4 0)
"))(POS (EXAMPLE.SOURCE 4QUEENS "  ; all the queens have different rows
  (<= (not (row ?x ?c))
      (row ?y ?c)
      (not (= ?x ?y)))

  ; all the queens have different columns
  (<= (not (col ?x ?c))
      (col ?y ?c)
      (not (= ?x ?y)))

  ; given a row and column, we can compute the two diagonals it is on.
  (<= (d ?q pos ?z) (row ?q ?x) (col ?q ?y) (sub ?y ?x ?z))
  (<= (d ?q neg ?z) (row ?q ?x) (col ?q ?y) (add ?y ?x ?z))

  ; all the queens have different diagonals
  (<= (not (d ?q1 ?sign ?z))
      (d ?q2 ?sign ?z)
      (not (= ?q1 ?q2)))

  ; add and subtract
  (add 1 1 2)
  (add 1 2 3)
  (add 1 3 4)
  (add 1 4 5)
  (add 2 1 3)
  (add 2 2 4)
  (add 2 3 5)
  (add 2 4 6)
  (add 3 1 4)
  (add 3 2 5)
  (add 3 3 6)
  (add 3 4 7)
  (add 4 1 5)
  (add 4 2 6)
  (add 4 3 7)
  (add 4 4 8)

  (sub 1 1 0)
  (sub 1 2 -1)
  (sub 1 3 -2)
  (sub 1 4 -3)
  (sub 2 1 1)
  (sub 2 2 0)
  (sub 2 3 -1)
  (sub 2 4 -2)
  (sub 3 1 2)
  (sub 3 2 1)
  (sub 3 3 0)
  (sub 3 4 -1)
  (sub 4 1 3)
  (sub 4 2 2)
  (sub 4 3 1)
  (sub 4 4 0)
"))(POS (EXAMPLE.INSTANCE NQUEENS))(POS (PRETTYNAME NQUEENS "N-Queens"))(POS (SHORTNAME NQUEENS "nqueens"))(POS (EXAMPLE.COMPLETE NQUEENS INCOMPLETE))(POS (EXAMPLE.TECHNIQUE NQUEENS BILEVEL))(POS (EXAMPLE.TECHNIQUE NQUEENS NAF))(POS (EXAMPLE.TECHNIQUE NQUEENS CONSISTENCY2DEDUCTION))(POS (EXAMPLE.TECHNIQUE NQUEENS UNNAMED))(POS (EXAMPLE.DESCRIPTION NQUEENS "Here we use (a minimal-model semantic version of) metalevel logic to describe the class of all X-queens queries, where the constraints are written as usual in FHL.  The recursive query definition is guarded by a single table that says how many queens are available (which I believe may play a crucial role in doing the translation).  The datalog version uses recursion and functions, again bounded by the single table with the number of queens.  "))(POS (MATRIXSHOW NQUEENS TRUE))(POS (EXAMPLE.COMMENTS NQUEENS "Here we can do the reformulation once and apply it to any n-queens problem by simply changing the value in that NumQueens table and the add/sub facts.  We pay a little more in interpreting the Datalog because of the added recursion.

This example illustrates just C2D: we just want to enumerate all the solutiions.  (query ?x) is true in the Datalog version if ?x is a list of queen locations, ?x satisfies the constraints of n-queens, and ?x has n locations, where n is the value in the table querylength.
"))(POS (EXAMPLE.SOURCEQUERY NQUEENS "  (query ?x)"))(POS (EXAMPLE.SOURCE NQUEENS "
 ;;;;;;;;;; metalevel query definition ;;;;;;;;;;;;
(<= (query ?x)
      (queens ?x)
      (query-length ?n)
      (length ?x ?n))

  (<= (queen \"(and (row <?q> <?x>) (col <?q> <?y>))\")
      (queen ?q)
      (var ?x)
      (var ?y)
      (not (= ?x ?y)))

  (<= (queens \"(and ?x ?y)\")
      (queen ?x)
      (queens ?y))

  (<= (length \"(?x ?y ?z)\" (s 0))
      (not (= ?x \"and\")))
  (<= (length \"(and <?x> <?y>)\" (s ?z))
      (length ?y ?z))

  ;;;;;;; then we have the normal constraints ;;;;;;;;
  ; all the queens have different rows
  (<= (not (row ?x ?c))
      (row ?y ?c)
      (not (= ?x ?y)))

  ; all the queens have different columns
  (<= (not (col ?x ?c))
      (col ?y ?c)
      (not (= ?x ?y)))

  ; given a row and column, we can compute the two diagonals it is on.
  (<= (d ?q pos ?z) (row ?q ?x) (col ?q ?y) (sub ?y ?x ?z))
  (<= (d ?q neg ?z) (row ?q ?x) (col ?q ?y) (add ?y ?x ?z))

  ; all the queens have different diagonals
  (<= (not (d ?q1 ?sign ?z))
      (d ?q2 ?sign ?z)
      (not (= ?q1 ?q2)))

  ; add and subtract
  (add 1 1 2)
  (add 1 2 3)
  (add 1 3 4)
  (add 1 4 5)
  (add 2 1 3)
  (add 2 2 4)
  (add 2 3 5)
  (add 2 4 6)
  (add 3 1 4)
  (add 3 2 5)
  (add 3 3 6)
  (add 3 4 7)
  (add 4 1 5)
  (add 4 2 6)
  (add 4 3 7)
  (add 4 4 8)

  (sub 1 1 0)
  (sub 1 2 -1)
  (sub 1 3 -2)
  (sub 1 4 -3)
  (sub 2 1 1)
  (sub 2 2 0)
  (sub 2 3 -1)
  (sub 2 4 -2)
  (sub 3 1 2)
  (sub 3 2 1)
  (sub 3 3 0)
  (sub 3 4 -1)
  (sub 4 1 3)
  (sub 4 2 2)
  (sub 4 3 1)
  (sub 4 4 0)
"))(POS (EXAMPLE.TARGETQUERY NQUEENS "(query ?x)"))(POS (EXAMPLE.TARGET NQUEENS "  (<= (query ?x)
      (querylength ?n)
      (ans ?x ?n))

  (<= (ans nil 0))
  (<= (ans (f ?x ?y) (s ?z))
      (ans ?y ?z)
      (augmentans ?x ?y))

  (<= (augmentans ?x ?y)
      (place-queen ?x)
      (not (some-queen-attacks ?x ?y)))

  (<= (place-queen (loc ?x ?y ?neg ?pos))
      (sub ?y ?x ?neg)
      (add ?y ?x ?pos))
      
  (<= (some-queen-attacks (loc ?x ?y ?neg ?pos) (f (loc ?x2 ?y2 ?neg2 ?pos2) ?rest))
      (or (= ?x ?x2)
          (= ?y ?y2)
          (= ?neg ?neg2)
          (= ?pos ?pos2)
          (some-queen-attacks (loc ?x ?y ?neg ?pos) ?rest)))
  (= ?x ?x)

  (querylength (s (s (s (s 0)))))
  (add 1 1 2)
  (add 1 2 3)
  (add 1 3 4)
  (add 1 4 5)
  (add 2 1 3)
  (add 2 2 4)
  (add 2 3 5)
  (add 2 4 6)
  (add 3 1 4)
  (add 3 2 5)
  (add 3 3 6)
  (add 3 4 7)
  (add 4 1 5)
  (add 4 2 6)
  (add 4 3 7)
  (add 4 4 8)

  (sub 1 1 0)
  (sub 1 2 -1)
  (sub 1 3 -2)
  (sub 1 4 -3)
  (sub 2 1 1)
  (sub 2 2 0)
  (sub 2 3 -1)
  (sub 2 4 -2)
  (sub 3 1 2)
  (sub 3 2 1)
  (sub 3 3 0)
  (sub 3 4 -1)
  (sub 4 1 3)
  (sub 4 2 2)
  (sub 4 3 1)
  (sub 4 4 0)
"))(POS (EXAMPLE.INSTANCE WUMPUSPERCEPTS))(POS (PRETTYNAME WUMPUSPERCEPTS "Wumpus World with Percepts"))(POS (SHORTNAME WUMPUSPERCEPTS "wumpus.per"))(POS (EXAMPLE.COMPLETE WUMPUSPERCEPTS INCOMPLETE))(POS (EXAMPLE.TECHNIQUE WUMPUSPERCEPTS BILEVEL))(POS (EXAMPLE.TECHNIQUE WUMPUSPERCEPTS CONSISTENCY2DEDUCTION))(POS (EXAMPLE.TECHNIQUE WUMPUSPERCEPTS NAF))(POS (EXAMPLE.TECHNIQUE WUMPUSPERCEPTS UNNAMED))(POS (EXAMPLE.DESCRIPTION WUMPUSPERCEPTS "A snapshot of wumpus world, after sensing a stench at one location and a shine at another.  Is the gold to the west of the wumpus in all cases?  Translate this problem stated in logic, where the data is the set of percepts, into a datalog program (with a single function for representing the structure of a grid location) that checks the entailment by cases."))(POS (MATRIXSHOW WUMPUSPERCEPTS TRUE))(POS (EXAMPLE.COMMENTS WUMPUSPERCEPTS "There is nothing mystical about introducing (cell x y) instead of sticking to opaque names for cells.  It was partly laziness and partly I believe we may be able to automatically produce this translation by analyzing the constraints on the data (which we might include as integrity constraints)."))(POS (EXAMPLE.SOURCEQUERY WUMPUSPERCEPTS "      (=> (gold ?x) (wumpus ?y) (westof ?x ?y)))
"))(POS (EXAMPLE.SOURCE WUMPUSPERCEPTS "  (north a e)
  (north e i)
  (north i m)
  (north b f)
  (north f j)
  (north j n)
  (north c g)
  (north g k)
  (north k o)
  (north d h)
  (north h l)
  (north l p)

  (east a b)
  (east b c)
  (east c d)
  (east e f)
  (east f g)
  (east g h)
  (east i j)
  (east j k)
  (east k l)
  (east m n)
  (east n o)
  (east o p)


  (<=> (west ?x ?y) (east ?y ?x))
  (<=> (south ?x ?y) (north ?y ?x))

  (<=> (westof ?x ?y)
       (or (west ?x ?y)
           (exists ?z (and (west ?x ?z) (west ?z ?y)))
           (exists (?z ?w) (and (west ?x ?z) (west ?z ?w) (west ?w ?y)))))

  (westborder e)
  (westborder i)
  (eastborder h)
  (eastborder l)
  (northborder b)
  (northborder c)
  (southborder n)
  (southborder o)

  (nwcorner a)
  (necorner d)
  (swcorner m)
  (secorner p)
  
  (notborder f)
  (notborder g)
  (notborder j)
  (notborder k)


  ; center
  (=> (stench ?cell)
      (notborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?celle)
          (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (notborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))
           (not (wumpus ?cellw))
           (not (wumpus ?cells))))

  ;;; borders

  ;west
  (=> (stench ?cell)
      (westborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (or (wumpus ?celln)
          (wumpus ?celle)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (westborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))
           (not (wumpus ?cells))))


  ; north
  (=> (stench ?cell)
      (northborder ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (or (wumpus ?celle)
          (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (northborder ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (and (not (wumpus ?celle))
           (not (wumpus ?cellw))
           (not (wumpus ?cells))))

      
  ; south
  (=> (stench ?cell)
      (southborder ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?celle)
          (wumpus ?cellw)))

  (=> (not (stench ?cell))
      (southborder ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))
           (not (wumpus ?cellw))))

  ; east
  (=> (stench ?cell)
      (eastborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (eastborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?cellw))
           (not (wumpus ?cells))))

  ;;; corners

  ; nw
  (=> (stench ?cell)
      (nwcorner ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (or (wumpus ?celle)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (nwcorner ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (and (not (wumpus ?celle))
           (not (wumpus ?cells))))

  ; ne
  (=> (stench ?cell)
      (necorner ?cell)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (or (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (necorner ?cell)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (and (not (wumpus ?cellw))
           (not (wumpus ?cells))))

  ; sw
  (=> (stench ?cell)
      (wwcorner ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (or (wumpus ?celln)
          (wumpus ?celle)))

  (=> (not (stench ?cell))
      (wwcorner ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))))

  ; se
  (=> (stench ?cell)
      (secorner ?cell)
      (north ?cell ?celln)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?cellw)))

  (=> (not (stench ?cell))
      (secorner ?cell)
      (north ?cell ?celln)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?cellw))))

  ;(or (wumpus a) (wumpus b) (wumpus c) (wumpus d) (wumpus e) (wumpus f) (wumpus g) (wumpus h) (wumpus i))

  (shiney e)
  (not (stench e))
  (stench l)
  (not (shiney l))
"))(POS (EXAMPLE.TARGETQUERY WUMPUSPERCEPTS "ent"))(POS (EXAMPLE.TARGET WUMPUSPERCEPTS "(deftheory datalog-wumpusworld2

  (<= ent
      (not notent))
  (<= notent
      (possworld ?x ?y)
      (not (westof ?x ?y)))

  (<= (westof ?x ?y)
      (or (west ?x ?y)
          (and (west ?x ?z) (west ?z ?y))
          (and (west ?x ?z) (west ?z ?w) (west ?w ?y))))

  (<= (possworld ?x ?y)
      (possgold ?x)
      (posswumpus ?y))

  ; poss gold
  (<= (possgold ?x)
      (adjacentshiney ?x)
      (not (some-adjacentnonshiney ?x))
      (not (some-nonadjacentshiney ?x)))

  (<= (adjacentshiney ?x)
      (shiney ?s)
      (adjacent ?s ?x))

  (<= (some-nonadjacentshiney ?x)
      (shiney ?s)
      (not (adjacent ?s ?x)))

  (<= (some-adjacentnonshiney ?x)
      (adjacent ?x ?y)
      (nshiney ?y))

  ; poss wumpus
  (<= (posswumpus ?x)
      (adjacentstench ?x)
      (not (some-adjacentnonstench ?x))
      (not (some-nonadjacentstench ?x)))

  (<= (adjacentstench ?x)
      (stench ?s)
      (adjacent ?s ?x))

  (<= (some-nonadjacentstench ?x)
      (stench ?s)
      (not (adjacent ?s ?x)))

  (<= (some-adjacentnonstench ?x)
      (adjacent ?x ?y)
      (nstench ?y))
      

  (adj 1 2)
  (adj 2 3)
  (adj 3 4)
  (<= (next ?x ?y)
      (or (adj ?x ?y) (adj ?y ?x)))
  
  (<= (adjacent (cell ?x ?y) (cell ?z ?y))
      (next ?x ?z))

  (<= (adjacent (cell ?x ?y) (cell ?x ?w))
      (next ?y ?w))

  (<= (adjacent (cell ?x ?y) (cell ?z ?w))
      (next ?x ?z)
      (next ?y ?w))

  (<= (west (cell ?x ?y) (cell ?x2 ?w))
      (adj ?x ?x2))

  (shiney (cell 1 3))
  (nstench (cell 1 3))
  (stench (cell 4 2))
  (nshiney (cell 4 2))
)"))(NEG (EXAMPLE.TARGET WUMPUSPERCEPTS "(deftheory datalog-wumpusworld2

  (<= ent
      (not notent))
  (<= notent
      (possworld ?x ?y)
      (not (westof ?x ?y)))

  (<= (westof ?x ?y)
      (or (west ?x ?y)
          (and (west ?x ?z) (west ?z ?y))
          (and (west ?x ?z) (west ?z ?w) (west ?w ?y))))

  (<= (possworld ?x ?y)
      (possgold ?x)
      (posswumpus ?y))

  ; poss gold
  (<= (possgold ?x)
      (adjacentshiney ?x)
      (not (some-adjacentnonshiney ?x))
      (not (some-nonadjacentshiney ?x)))

  (<= (adjacentshiney ?x)
      (shiney ?s)
      (adjacent ?s ?x))

  (<= (some-nonadjacentshiney ?x)
      (shiney ?s)
      (not (adjacent ?s ?x)))

  (<= (some-adjacentnonshiney ?x)
      (adjacent ?x ?y)
      (nshiney ?y))

  ; poss wumpus
  (<= (posswumpus ?x)
      (adjacentstench ?x)
      (not (some-adjacentnonstench ?x))
      (not (some-nonadjacentstench ?x)))

  (<= (adjacentstench ?x)
      (stench ?s)
      (adjacent ?s ?x))

  (<= (some-nonadjacentstench ?x)
      (stench ?s)
      (not (adjacent ?s ?x)))

  (<= (some-adjacentnonstench ?x)
      (adjacent ?x ?y)
      (nstench ?y))
      

  (adj 1 2)
  (adj 2 3)
  (adj 3 4)
  (<= (next ?x ?y)
      (or (adj ?x ?y) (adj ?y ?x)))
  
  (<= (adjacent (cell ?x ?y) (cell ?z ?y))
      (next ?x ?z))

  (<= (adjacent (cell ?x ?y) (cell ?x ?w))
      (next ?y ?w))

  (<= (adjacent (cell ?x ?y) (cell ?z ?w))
      (next ?x ?z)
      (next ?y ?w))

  (<= (west (cell ?x ?y) (cell ?x2 ?w))
      (adj ?x ?x2))

  (shiney (cell 1 3))
  (nstench (cell 1 3))
  (stench (cell 4 2))
  (nshiney (cell 4 2))
)"))(POS (EXAMPLE.TARGET WUMPUSPERCEPTS "  (<= ent
      (not notent))
  (<= notent
      (possworld ?x ?y)
      (not (westof ?x ?y)))

  (<= (westof ?x ?y)
      (or (west ?x ?y)
          (and (west ?x ?z) (west ?z ?y))
          (and (west ?x ?z) (west ?z ?w) (west ?w ?y))))

  (<= (possworld ?x ?y)
      (possgold ?x)
      (posswumpus ?y))

  ; poss gold
  (<= (possgold ?x)
      (adjacentshiney ?x)
      (not (some-adjacentnonshiney ?x))
      (not (some-nonadjacentshiney ?x)))

  (<= (adjacentshiney ?x)
      (shiney ?s)
      (adjacent ?s ?x))

  (<= (some-nonadjacentshiney ?x)
      (shiney ?s)
      (not (adjacent ?s ?x)))

  (<= (some-adjacentnonshiney ?x)
      (adjacent ?x ?y)
      (nshiney ?y))

  ; poss wumpus
  (<= (posswumpus ?x)
      (adjacentstench ?x)
      (not (some-adjacentnonstench ?x))
      (not (some-nonadjacentstench ?x)))

  (<= (adjacentstench ?x)
      (stench ?s)
      (adjacent ?s ?x))

  (<= (some-nonadjacentstench ?x)
      (stench ?s)
      (not (adjacent ?s ?x)))

  (<= (some-adjacentnonstench ?x)
      (adjacent ?x ?y)
      (nstench ?y))
      

  (adj 1 2)
  (adj 2 3)
  (adj 3 4)
  (<= (next ?x ?y)
      (or (adj ?x ?y) (adj ?y ?x)))
  
  (<= (adjacent (cell ?x ?y) (cell ?z ?y))
      (next ?x ?z))

  (<= (adjacent (cell ?x ?y) (cell ?x ?w))
      (next ?y ?w))

  (<= (adjacent (cell ?x ?y) (cell ?z ?w))
      (next ?x ?z)
      (next ?y ?w))

  (<= (west (cell ?x ?y) (cell ?x2 ?w))
      (adj ?x ?x2))

  (shiney (cell 1 3))
  (nstench (cell 1 3))
  (stench (cell 4 2))
  (nshiney (cell 4 2))"))(NEG (EXAMPLE.DESCRIPTION WUMPUSPERCEPTS "A snapshot of wumpus world, after sensing a stench at one location and a shine at another.  Is the gold to the west of the wumpus in all cases?  Translate this problem stated in logic, where the data is the set of percepts, into a datalog program (with a single function for representing the structure of a grid location) that checks the entailment by cases."))(POS (EXAMPLE.DESCRIPTION WUMPUSPERCEPTS "A snapshot of wumpus world, after sensing a stench at one location and a shine at another.  Is the gold to the west of the wumpus in all cases?  Translate this problem stated in logic, where the data is the set of percepts, into a datalog program that checks the entailment by cases.  The tricky part here is that the percept tables (the ones that are supposed to be left out of the transformation) are incomplete; thus, we cannot import them directly into datalog. Because the tables are incomplete but not disjunctive, we create a complete table for stench, another complete table for notstench; likewise for shine.  The stench table includes all those cells where we observed a stench; the notstench table contains all those cells without a stench.  These can both be complete, and we know the environment maintains consistency. "))(NEG (EXAMPLE.COMMENTS WUMPUSPERCEPTS "There is nothing mystical about introducing (cell x y) instead of sticking to opaque names for cells.  It was partly laziness and partly I believe we may be able to automatically produce this translation by analyzing the constraints on the data (which we might include as integrity constraints)."))(POS (EXAMPLE.COMMENTS WUMPUSPERCEPTS "Here I'm using some functions in the source, simply because the problem was easier to write down this way.  It may also be a case that demonstrates that sometimes we can deal with functions.  I'm conflating this with completing the tables stench and shine, but I couldn't bring myself to write it without functions."))(NEG (EXAMPLE.SOURCE WUMPUSPERCEPTS "  (north a e)
  (north e i)
  (north i m)
  (north b f)
  (north f j)
  (north j n)
  (north c g)
  (north g k)
  (north k o)
  (north d h)
  (north h l)
  (north l p)

  (east a b)
  (east b c)
  (east c d)
  (east e f)
  (east f g)
  (east g h)
  (east i j)
  (east j k)
  (east k l)
  (east m n)
  (east n o)
  (east o p)


  (<=> (west ?x ?y) (east ?y ?x))
  (<=> (south ?x ?y) (north ?y ?x))

  (<=> (westof ?x ?y)
       (or (west ?x ?y)
           (exists ?z (and (west ?x ?z) (west ?z ?y)))
           (exists (?z ?w) (and (west ?x ?z) (west ?z ?w) (west ?w ?y)))))

  (westborder e)
  (westborder i)
  (eastborder h)
  (eastborder l)
  (northborder b)
  (northborder c)
  (southborder n)
  (southborder o)

  (nwcorner a)
  (necorner d)
  (swcorner m)
  (secorner p)
  
  (notborder f)
  (notborder g)
  (notborder j)
  (notborder k)


  ; center
  (=> (stench ?cell)
      (notborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?celle)
          (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (notborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))
           (not (wumpus ?cellw))
           (not (wumpus ?cells))))

  ;;; borders

  ;west
  (=> (stench ?cell)
      (westborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (or (wumpus ?celln)
          (wumpus ?celle)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (westborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))
           (not (wumpus ?cells))))


  ; north
  (=> (stench ?cell)
      (northborder ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (or (wumpus ?celle)
          (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (northborder ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (and (not (wumpus ?celle))
           (not (wumpus ?cellw))
           (not (wumpus ?cells))))

      
  ; south
  (=> (stench ?cell)
      (southborder ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?celle)
          (wumpus ?cellw)))

  (=> (not (stench ?cell))
      (southborder ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))
           (not (wumpus ?cellw))))

  ; east
  (=> (stench ?cell)
      (eastborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (eastborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?cellw))
           (not (wumpus ?cells))))

  ;;; corners

  ; nw
  (=> (stench ?cell)
      (nwcorner ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (or (wumpus ?celle)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (nwcorner ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (and (not (wumpus ?celle))
           (not (wumpus ?cells))))

  ; ne
  (=> (stench ?cell)
      (necorner ?cell)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (or (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (necorner ?cell)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (and (not (wumpus ?cellw))
           (not (wumpus ?cells))))

  ; sw
  (=> (stench ?cell)
      (wwcorner ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (or (wumpus ?celln)
          (wumpus ?celle)))

  (=> (not (stench ?cell))
      (wwcorner ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))))

  ; se
  (=> (stench ?cell)
      (secorner ?cell)
      (north ?cell ?celln)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?cellw)))

  (=> (not (stench ?cell))
      (secorner ?cell)
      (north ?cell ?celln)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?cellw))))

  ;(or (wumpus a) (wumpus b) (wumpus c) (wumpus d) (wumpus e) (wumpus f) (wumpus g) (wumpus h) (wumpus i))

  (shiney e)
  (not (stench e))
  (stench l)
  (not (shiney l))
"))(POS (EXAMPLE.SOURCE WUMPUSPERCEPTS "
  (succ 1 2)
  (succ 2 3)
  (succ 3 4)

  (<=> (next ?x ?y)
       (or (succ ?x ?y)
           (succ ?y ?x)))

  (<=> (west (cell ?x ?y) (cell ?x2 ?y))
       (succ ?x2 ?x))
  (<=> (north (cell ?x ?y) (cell ?x ?y2))
       (succ ?y2 ?y))
  
  (<=> (east ?x ?y) (west ?y ?x))
  (<=> (south ?x ?y) (north ?y ?x))

  (<=> (westof (cell ?x ?y) (cell ?x2 ?y2))
       (or (adj ?x ?x2)
           (exists ?z (and (adj ?x ?z) (adj ?z ?x2)))
           (exists (?z ?w) (and (adj ?x ?z) (adj ?z ?w) (adj ?w ?x2)))))

  (<=> (westborder (cell 1 ?x))
       (not (= ?x 1))
       (not (= ?x 4)))

  (<=> (eastborder (cell 4 ?x))
       (not (= ?x 1))
       (not (= ?x 4)))

  (<=> (southborder (cell ?x 1))
       (not (= ?x 1))
       (not (= ?x 4)))

  (<=> (northborder (cell ?x 4))
       (not (= ?x 1))
       (not (= ?x 4)))

  (nwcorner (cell 1 4))
  (necorner (cell 4 4))
  (swcorner (cell 1 1))
  (secorner (cell 4 1))
  
  (<=> (notborder (cell ?x ?y))
       (and (not (= ?x 1))
            (not (= ?x 4))
            (not (= ?y 1))
            (not (= ?y 4))))

  ; center
  (=> (stench ?cell)
      (notborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?celle)
          (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (notborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))
           (not (wumpus ?cellw))
           (not (wumpus ?cells))))

  ;;; borders

  ;west
  (=> (stench ?cell)
      (westborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (or (wumpus ?celln)
          (wumpus ?celle)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (westborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))
           (not (wumpus ?cells))))


  ; north
  (=> (stench ?cell)
      (northborder ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (or (wumpus ?celle)
          (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (northborder ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (and (not (wumpus ?celle))
           (not (wumpus ?cellw))
           (not (wumpus ?cells))))

      
  ; south
  (=> (stench ?cell)
      (southborder ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?celle)
          (wumpus ?cellw)))

  (=> (not (stench ?cell))
      (southborder ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))
           (not (wumpus ?cellw))))

  ; east
  (=> (stench ?cell)
      (eastborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (eastborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?cellw))
           (not (wumpus ?cells))))

  ;;; corners

  ; nw
  (=> (stench ?cell)
      (nwcorner ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (or (wumpus ?celle)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (nwcorner ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (and (not (wumpus ?celle))
           (not (wumpus ?cells))))

  ; ne
  (=> (stench ?cell)
      (necorner ?cell)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (or (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (necorner ?cell)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (and (not (wumpus ?cellw))
           (not (wumpus ?cells))))

  ; sw
  (=> (stench ?cell)
      (wwcorner ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (or (wumpus ?celln)
          (wumpus ?celle)))

  (=> (not (stench ?cell))
      (wwcorner ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))))

  ; se
  (=> (stench ?cell)
      (secorner ?cell)
      (north ?cell ?celln)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?cellw)))

  (=> (not (stench ?cell))
      (secorner ?cell)
      (north ?cell ?celln)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?cellw))))

  (exists (?x ?y) (wumpus (cell ?x ?y)))

  (shiney (cell 1 3))
  (not (stench (cell 1 3)))
  (stench (cell 4 2))
  (not (shiney (cell 4 2)))
"))(NEG (EXAMPLE.SOURCEQUERY WUMPUSPERCEPTS "      (=> (gold ?x) (wumpus ?y) (westof ?x ?y)))
"))(POS (EXAMPLE.SOURCEQUERY WUMPUSPERCEPTS "      (=> (gold ?x) (wumpus ?y) (westof ?x ?y))
"))(NEG (EXAMPLE.SOURCE WUMPUSPERCEPTS "
  (succ 1 2)
  (succ 2 3)
  (succ 3 4)

  (<=> (next ?x ?y)
       (or (succ ?x ?y)
           (succ ?y ?x)))

  (<=> (west (cell ?x ?y) (cell ?x2 ?y))
       (succ ?x2 ?x))
  (<=> (north (cell ?x ?y) (cell ?x ?y2))
       (succ ?y2 ?y))
  
  (<=> (east ?x ?y) (west ?y ?x))
  (<=> (south ?x ?y) (north ?y ?x))

  (<=> (westof (cell ?x ?y) (cell ?x2 ?y2))
       (or (adj ?x ?x2)
           (exists ?z (and (adj ?x ?z) (adj ?z ?x2)))
           (exists (?z ?w) (and (adj ?x ?z) (adj ?z ?w) (adj ?w ?x2)))))

  (<=> (westborder (cell 1 ?x))
       (not (= ?x 1))
       (not (= ?x 4)))

  (<=> (eastborder (cell 4 ?x))
       (not (= ?x 1))
       (not (= ?x 4)))

  (<=> (southborder (cell ?x 1))
       (not (= ?x 1))
       (not (= ?x 4)))

  (<=> (northborder (cell ?x 4))
       (not (= ?x 1))
       (not (= ?x 4)))

  (nwcorner (cell 1 4))
  (necorner (cell 4 4))
  (swcorner (cell 1 1))
  (secorner (cell 4 1))
  
  (<=> (notborder (cell ?x ?y))
       (and (not (= ?x 1))
            (not (= ?x 4))
            (not (= ?y 1))
            (not (= ?y 4))))

  ; center
  (=> (stench ?cell)
      (notborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?celle)
          (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (notborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))
           (not (wumpus ?cellw))
           (not (wumpus ?cells))))

  ;;; borders

  ;west
  (=> (stench ?cell)
      (westborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (or (wumpus ?celln)
          (wumpus ?celle)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (westborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))
           (not (wumpus ?cells))))


  ; north
  (=> (stench ?cell)
      (northborder ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (or (wumpus ?celle)
          (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (northborder ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (and (not (wumpus ?celle))
           (not (wumpus ?cellw))
           (not (wumpus ?cells))))

      
  ; south
  (=> (stench ?cell)
      (southborder ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?celle)
          (wumpus ?cellw)))

  (=> (not (stench ?cell))
      (southborder ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))
           (not (wumpus ?cellw))))

  ; east
  (=> (stench ?cell)
      (eastborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (eastborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?cellw))
           (not (wumpus ?cells))))

  ;;; corners

  ; nw
  (=> (stench ?cell)
      (nwcorner ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (or (wumpus ?celle)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (nwcorner ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (and (not (wumpus ?celle))
           (not (wumpus ?cells))))

  ; ne
  (=> (stench ?cell)
      (necorner ?cell)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (or (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (necorner ?cell)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (and (not (wumpus ?cellw))
           (not (wumpus ?cells))))

  ; sw
  (=> (stench ?cell)
      (wwcorner ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (or (wumpus ?celln)
          (wumpus ?celle)))

  (=> (not (stench ?cell))
      (wwcorner ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))))

  ; se
  (=> (stench ?cell)
      (secorner ?cell)
      (north ?cell ?celln)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?cellw)))

  (=> (not (stench ?cell))
      (secorner ?cell)
      (north ?cell ?celln)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?cellw))))

  (exists (?x ?y) (wumpus (cell ?x ?y)))

  (shiney (cell 1 3))
  (not (stench (cell 1 3)))
  (stench (cell 4 2))
  (not (shiney (cell 4 2)))
"))(POS (EXAMPLE.SOURCE WUMPUSPERCEPTS "  (succ 1 2)
  (succ 2 3)
  (succ 3 4)

  (<=> (next ?x ?y)
       (or (succ ?x ?y)
           (succ ?y ?x)))

  (<=> (west (cell ?x ?y) (cell ?x2 ?y))
       (succ ?x2 ?x))
  (<=> (north (cell ?x ?y) (cell ?x ?y2))
       (succ ?y2 ?y))
  
  (<=> (east ?x ?y) (west ?y ?x))
  (<=> (south ?x ?y) (north ?y ?x))

  (<=> (westof (cell ?x ?y) (cell ?x2 ?y2))
       (or (adj ?x ?x2)
           (exists ?z (and (adj ?x ?z) (adj ?z ?x2)))
           (exists (?z ?w) (and (adj ?x ?z) (adj ?z ?w) (adj ?w ?x2)))))

  (<=> (westborder (cell 1 ?x))
       (not (= ?x 1))
       (not (= ?x 4)))

  (<=> (eastborder (cell 4 ?x))
       (not (= ?x 1))
       (not (= ?x 4)))

  (<=> (southborder (cell ?x 1))
       (not (= ?x 1))
       (not (= ?x 4)))

  (<=> (northborder (cell ?x 4))
       (not (= ?x 1))
       (not (= ?x 4)))

  (nwcorner (cell 1 4))
  (necorner (cell 4 4))
  (swcorner (cell 1 1))
  (secorner (cell 4 1))
  
  (<=> (notborder (cell ?x ?y))
       (and (not (= ?x 1))
            (not (= ?x 4))
            (not (= ?y 1))
            (not (= ?y 4))))

  ; center
  (=> (stench ?cell)
      (notborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?celle)
          (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (notborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))
           (not (wumpus ?cellw))
           (not (wumpus ?cells))))

  ;;; borders

  ;west
  (=> (stench ?cell)
      (westborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (or (wumpus ?celln)
          (wumpus ?celle)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (westborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))
           (not (wumpus ?cells))))


  ; north
  (=> (stench ?cell)
      (northborder ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (or (wumpus ?celle)
          (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (northborder ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (and (not (wumpus ?celle))
           (not (wumpus ?cellw))
           (not (wumpus ?cells))))

      
  ; south
  (=> (stench ?cell)
      (southborder ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?celle)
          (wumpus ?cellw)))

  (=> (not (stench ?cell))
      (southborder ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))
           (not (wumpus ?cellw))))

  ; east
  (=> (stench ?cell)
      (eastborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (eastborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?cellw))
           (not (wumpus ?cells))))

  ;;; corners

  ; nw
  (=> (stench ?cell)
      (nwcorner ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (or (wumpus ?celle)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (nwcorner ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (and (not (wumpus ?celle))
           (not (wumpus ?cells))))

  ; ne
  (=> (stench ?cell)
      (necorner ?cell)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (or (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (necorner ?cell)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (and (not (wumpus ?cellw))
           (not (wumpus ?cells))))

  ; sw
  (=> (stench ?cell)
      (wwcorner ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (or (wumpus ?celln)
          (wumpus ?celle)))

  (=> (not (stench ?cell))
      (wwcorner ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))))

  ; se
  (=> (stench ?cell)
      (secorner ?cell)
      (north ?cell ?celln)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?cellw)))

  (=> (not (stench ?cell))
      (secorner ?cell)
      (north ?cell ?celln)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?cellw))))

  (exists (?x ?y) (wumpus (cell ?x ?y)))

  (shiney (cell 1 3))
  (not (stench (cell 1 3)))
  (stench (cell 4 2))
  (not (shiney (cell 4 2)))
"))(NEG (EXAMPLE.SOURCE WUMPUSPERCEPTS "  (succ 1 2)
  (succ 2 3)
  (succ 3 4)

  (<=> (next ?x ?y)
       (or (succ ?x ?y)
           (succ ?y ?x)))

  (<=> (west (cell ?x ?y) (cell ?x2 ?y))
       (succ ?x2 ?x))
  (<=> (north (cell ?x ?y) (cell ?x ?y2))
       (succ ?y2 ?y))
  
  (<=> (east ?x ?y) (west ?y ?x))
  (<=> (south ?x ?y) (north ?y ?x))

  (<=> (westof (cell ?x ?y) (cell ?x2 ?y2))
       (or (adj ?x ?x2)
           (exists ?z (and (adj ?x ?z) (adj ?z ?x2)))
           (exists (?z ?w) (and (adj ?x ?z) (adj ?z ?w) (adj ?w ?x2)))))

  (<=> (westborder (cell 1 ?x))
       (not (= ?x 1))
       (not (= ?x 4)))

  (<=> (eastborder (cell 4 ?x))
       (not (= ?x 1))
       (not (= ?x 4)))

  (<=> (southborder (cell ?x 1))
       (not (= ?x 1))
       (not (= ?x 4)))

  (<=> (northborder (cell ?x 4))
       (not (= ?x 1))
       (not (= ?x 4)))

  (nwcorner (cell 1 4))
  (necorner (cell 4 4))
  (swcorner (cell 1 1))
  (secorner (cell 4 1))
  
  (<=> (notborder (cell ?x ?y))
       (and (not (= ?x 1))
            (not (= ?x 4))
            (not (= ?y 1))
            (not (= ?y 4))))

  ; center
  (=> (stench ?cell)
      (notborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?celle)
          (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (notborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))
           (not (wumpus ?cellw))
           (not (wumpus ?cells))))

  ;;; borders

  ;west
  (=> (stench ?cell)
      (westborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (or (wumpus ?celln)
          (wumpus ?celle)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (westborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))
           (not (wumpus ?cells))))


  ; north
  (=> (stench ?cell)
      (northborder ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (or (wumpus ?celle)
          (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (northborder ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (and (not (wumpus ?celle))
           (not (wumpus ?cellw))
           (not (wumpus ?cells))))

      
  ; south
  (=> (stench ?cell)
      (southborder ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?celle)
          (wumpus ?cellw)))

  (=> (not (stench ?cell))
      (southborder ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))
           (not (wumpus ?cellw))))

  ; east
  (=> (stench ?cell)
      (eastborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (eastborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?cellw))
           (not (wumpus ?cells))))

  ;;; corners

  ; nw
  (=> (stench ?cell)
      (nwcorner ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (or (wumpus ?celle)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (nwcorner ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (and (not (wumpus ?celle))
           (not (wumpus ?cells))))

  ; ne
  (=> (stench ?cell)
      (necorner ?cell)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (or (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (necorner ?cell)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (and (not (wumpus ?cellw))
           (not (wumpus ?cells))))

  ; sw
  (=> (stench ?cell)
      (wwcorner ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (or (wumpus ?celln)
          (wumpus ?celle)))

  (=> (not (stench ?cell))
      (wwcorner ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))))

  ; se
  (=> (stench ?cell)
      (secorner ?cell)
      (north ?cell ?celln)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?cellw)))

  (=> (not (stench ?cell))
      (secorner ?cell)
      (north ?cell ?celln)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?cellw))))

  (exists (?x ?y) (wumpus (cell ?x ?y)))

  (shiney (cell 1 3))
  (not (stench (cell 1 3)))
  (stench (cell 4 2))
  (not (shiney (cell 4 2)))
"))(POS (EXAMPLE.SOURCE WUMPUSPERCEPTS "
  (succ 1 2)
  (succ 2 3)
  (succ 3 4)

  (<=> (next ?x ?y)
       (or (succ ?x ?y)
           (succ ?y ?x)))

  (<=> (west (cell ?x ?y) (cell ?x2 ?y))
       (succ ?x2 ?x))
  (<=> (north (cell ?x ?y) (cell ?x ?y2))
       (succ ?y2 ?y))
  
  (<=> (east ?x ?y) (west ?y ?x))
  (<=> (south ?x ?y) (north ?y ?x))

  (<=> (westof (cell ?x ?y) (cell ?x2 ?y2))
       (or (succ ?x ?x2)
           (exists ?z (and (succ ?x ?z) (succ ?z ?x2)))
           (exists (?z ?w) (and (succ ?x ?z) (succ ?z ?w) (succ ?w ?x2)))))

  (<=> (westborder (cell 1 ?x))
       (not (= ?x 1))
       (not (= ?x 4)))

  (<=> (eastborder (cell 4 ?x))
       (not (= ?x 1))
       (not (= ?x 4)))

  (<=> (southborder (cell ?x 1))
       (not (= ?x 1))
       (not (= ?x 4)))

  (<=> (northborder (cell ?x 4))
       (not (= ?x 1))
       (not (= ?x 4)))

  (nwcorner (cell 1 4))
  (necorner (cell 4 4))
  (swcorner (cell 1 1))
  (secorner (cell 4 1))
  
  (<=> (notborder (cell ?x ?y))
       (and (not (= ?x 1))
            (not (= ?x 4))
            (not (= ?y 1))
            (not (= ?y 4))))

  ; center
  (=> (stench ?cell)
      (notborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?celle)
          (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (notborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))
           (not (wumpus ?cellw))
           (not (wumpus ?cells))))

  ;;; borders

  ;west
  (=> (stench ?cell)
      (westborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (or (wumpus ?celln)
          (wumpus ?celle)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (westborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))
           (not (wumpus ?cells))))


  ; north
  (=> (stench ?cell)
      (northborder ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (or (wumpus ?celle)
          (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (northborder ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (and (not (wumpus ?celle))
           (not (wumpus ?cellw))
           (not (wumpus ?cells))))

      
  ; south
  (=> (stench ?cell)
      (southborder ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?celle)
          (wumpus ?cellw)))

  (=> (not (stench ?cell))
      (southborder ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))
           (not (wumpus ?cellw))))

  ; east
  (=> (stench ?cell)
      (eastborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (eastborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?cellw))
           (not (wumpus ?cells))))

  ;;; corners

  ; nw
  (=> (stench ?cell)
      (nwcorner ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (or (wumpus ?celle)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (nwcorner ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (and (not (wumpus ?celle))
           (not (wumpus ?cells))))

  ; ne
  (=> (stench ?cell)
      (necorner ?cell)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (or (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (necorner ?cell)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (and (not (wumpus ?cellw))
           (not (wumpus ?cells))))

  ; sw
  (=> (stench ?cell)
      (wwcorner ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (or (wumpus ?celln)
          (wumpus ?celle)))

  (=> (not (stench ?cell))
      (wwcorner ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))))

  ; se
  (=> (stench ?cell)
      (secorner ?cell)
      (north ?cell ?celln)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?cellw)))

  (=> (not (stench ?cell))
      (secorner ?cell)
      (north ?cell ?celln)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?cellw))))

  (exists (?x ?y) (wumpus (cell ?x ?y)))

  (shiney (cell 1 3))
  (not (stench (cell 1 3)))
  (stench (cell 4 2))
  (not (shiney (cell 4 2)))
"))(POS (EXAMPLE.INSTANCE WUMPUSDISJUNCTIVE))(POS (PRETTYNAME WUMPUSDISJUNCTIVE "Disjunctive Wumpus World"))(POS (SHORTNAME WUMPUSDISJUNCTIVE "wumpus.disj"))(POS (EXAMPLE.COMPLETE WUMPUSDISJUNCTIVE INCOMPLETE))(POS (EXAMPLE.TECHNIQUE WUMPUSDISJUNCTIVE BILEVEL))(POS (EXAMPLE.TECHNIQUE WUMPUSDISJUNCTIVE CONSISTENCY2DEDUCTION))(POS (EXAMPLE.TECHNIQUE WUMPUSDISJUNCTIVE NAF))(POS (EXAMPLE.TECHNIQUE WUMPUSDISJUNCTIVE UNNAMED))(POS (EXAMPLE.DESCRIPTION WUMPUSDISJUNCTIVE "In this snapshot version of wumpus world, at each step of the game, we write down what the percepts we have received mean.  For example, if we sense a stench then we write down that the wumpus is in one of the surrounding squares.  This incomplete theory is built on top of incomplete and, more to the point, disjunctive base tables.  The reformulation must then take into account that those base tables must be completed each time new info is added.  The way we complete the tables is to introduce new object constants into the language, that is at least what we would have done had we used object constants to name each cell instead of functional terms.  This example illustrates the need to change the universe of discourse."))(POS (MATRIXSHOW WUMPUSDISJUNCTIVE TRUE))(POS (EXAMPLE.COMMENTS WUMPUSDISJUNCTIVE "This example definitely illustrates the issues of starting with DISJUNCTIVE base tables can produce.  One way to deal with that is to increase the size of the universe, as indicated in the description.  Another way is to add functional terms, as is done in the actual example below.

The only reason this example might be problematic for Otter/Vampire is that the query is a universal statement, and we have a DCA to worry about."))(POS (EXAMPLE.SOURCEQUERY WUMPUSDISJUNCTIVE "(=> (gold ?x) (wumpus ?y) (westof ?x ?y))"))(POS (EXAMPLE.SOURCE WUMPUSDISJUNCTIVE "  (succ 1 2)
  (succ 2 3)
  (succ 3 4)

  (<=> (westof (cell ?x ?y) (cell ?x2 ?y2))
       (or (succ ?x ?x2)
           (exists ?z (and (succ ?x ?z) (succ ?z ?x2)))
           (exists (?z ?w) (and (succ ?x ?z) (succ ?z ?w) (succ ?w ?x2)))))


  (or (gold (cell 1 4)) (gold (cell 1 2)) (gold (cell 2 2)) (gold (cell 2 3)) (gold (cell 2 4)))
  (not (wumpus (cell 1 4)))
  (not (wumpus (cell 1 2)))
  (not (wumpus (cell 2 2)))
  (not (wumpus (cell 2 3)))
  (not (wumpus (cell 2 4)))

  (or (wumpus (cell 3 1)) (wumpus (cell 3 2)) (wumpus (cell 3 3)) (wumpus (cell 4 1)) (wumpus (cell 4 3)))
  (not (gold (cell 3 1)))
  (not (gold (cell 3 2)))
  (not (gold (cell 3 3)))
  (not (gold (cell 4 1)))
  (not (gold (cell 4 3)))
"))(POS (EXAMPLE.TARGETQUERY WUMPUSDISJUNCTIVE "ent"))(POS (EXAMPLE.TARGET WUMPUSDISJUNCTIVE " (<= ent
      (not notent))
  (<= notent
      (possgold ?x)
      (posswumpus ?y)
      (not (westof ?x ?y)))
      
  (<= (possgold ?x)
      (gold ?y)
      (part ?y ?x)
      (not (ngold ?x))
      (not (some-goldnotin ?x)))

  (<= (some-goldnotin ?x)
      (gold ?y)
      (not (part ?y ?x)))

  (<= (posswumpus ?x)
      (wumpus ?y)
      (part ?y ?x)
      (not (nwumpus ?x))
      (not (some-wumpusnotin ?x)))
  
  (<= (some-wumpusnotin ?x)
      (wumpus ?y)
      (not (part ?y ?x)))

  (<= (part (listof ?x @y) ?x))
  (<= (part (listof ?z @y) ?x)
      (part (listof @y) ?x))

  (adj 1 2)
  (adj 2 3)
  (adj 3 4)

  (<= (west (cell ?x ?y) (cell ?x2 ?w))
      (adj ?x ?x2))

  (<= (westof ?x ?y)
      (or (west ?x ?y)
          (and (west ?x ?z) (west ?z ?y))
          (and (west ?x ?z) (west ?z ?w) (west ?w ?y))))

  (gold (listof (cell 1 4) (cell 1 2) (cell 2 2) (cell 2 3) (cell 2 4)))
  (ngold (cell 3 1))
  (ngold (cell 3 2))
  (ngold (cell 3 3))
  (ngold (cell 4 1))
  (ngold (cell 4 3))

  (wumpus (listof (cell 3 1) (cell 3 2) (cell 3 3) (cell 4 1) (cell 4 3)))
  (nwumpus (cell 1 4))
  (nwumpus (cell 1 2))
  (nwumpus (cell 2 2))
  (nwumpus (cell 2 3))
  (nwumpus (cell 2 4))
"))(NEG (EXAMPLE.DESCRIPTION WUMPUSDISJUNCTIVE "In this snapshot version of wumpus world, at each step of the game, we write down what the percepts we have received mean.  For example, if we sense a stench then we write down that the wumpus is in one of the surrounding squares.  This incomplete theory is built on top of incomplete and, more to the point, disjunctive base tables.  The reformulation must then take into account that those base tables must be completed each time new info is added.  The way we complete the tables is to introduce new object constants into the language, that is at least what we would have done had we used object constants to name each cell instead of functional terms.  This example illustrates the need to change the universe of discourse."))(POS (EXAMPLE.DESCRIPTION WUMPUSDISJUNCTIVE "In this snapshot version of wumpus world, at each step of the game, we write down what the percepts we have received mean.  For example, if we sense a stench then we write down that the wumpus is in one of the surrounding squares.  This incomplete theory is built on top of incomplete and, more to the point, disjunctive base tables.  The reformulation must then take into account that those base tables must be completed each time new info is added.  The way we complete the tables is to introduce new object constants into the language.  This example illustrates the problem of disjunctive base tables and a solution: the introduction of new object constants."))(NEG (EXAMPLE.COMMENTS WUMPUSDISJUNCTIVE "This example definitely illustrates the issues of starting with DISJUNCTIVE base tables can produce.  One way to deal with that is to increase the size of the universe, as indicated in the description.  Another way is to add functional terms, as is done in the actual example below.

The only reason this example might be problematic for Otter/Vampire is that the query is a universal statement, and we have a DCA to worry about."))(POS (EXAMPLE.COMMENTS WUMPUSDISJUNCTIVE "The only reason this example might be problematic for Otter/Vampire is that the query is a universal statement, and we have a DCA to worry about.

Add UNA/DCA to the source."))(NEG (EXAMPLE.SOURCEQUERY WUMPUSDISJUNCTIVE "(=> (gold ?x) (wumpus ?y) (westof ?x ?y))"))(POS (EXAMPLE.SOURCEQUERY WUMPUSDISJUNCTIVE "(forall (?x ?y) (=> (gold ?x) (wumpus ?y) (westof ?x ?y)))"))(NEG (EXAMPLE.SOURCE WUMPUSDISJUNCTIVE "  (succ 1 2)
  (succ 2 3)
  (succ 3 4)

  (<=> (westof (cell ?x ?y) (cell ?x2 ?y2))
       (or (succ ?x ?x2)
           (exists ?z (and (succ ?x ?z) (succ ?z ?x2)))
           (exists (?z ?w) (and (succ ?x ?z) (succ ?z ?w) (succ ?w ?x2)))))


  (or (gold (cell 1 4)) (gold (cell 1 2)) (gold (cell 2 2)) (gold (cell 2 3)) (gold (cell 2 4)))
  (not (wumpus (cell 1 4)))
  (not (wumpus (cell 1 2)))
  (not (wumpus (cell 2 2)))
  (not (wumpus (cell 2 3)))
  (not (wumpus (cell 2 4)))

  (or (wumpus (cell 3 1)) (wumpus (cell 3 2)) (wumpus (cell 3 3)) (wumpus (cell 4 1)) (wumpus (cell 4 3)))
  (not (gold (cell 3 1)))
  (not (gold (cell 3 2)))
  (not (gold (cell 3 3)))
  (not (gold (cell 4 1)))
  (not (gold (cell 4 3)))
"))(POS (EXAMPLE.SOURCE WUMPUSDISJUNCTIVE "  (or (gold a) (gold i) (gold b) (gold f) (gold j))
  (not (wumpus a))
  (not (wumpus i))
  (not (wumpus b))
  (not (wumpus f))
  (not (wumpus j))

  (or (wumpus g) (wumpus k) (wumpus o) (wumpus h) (wumpus p))
  (not (gold g))
  (not (gold k))
  (not (gold o))
  (not (gold h))
  (not (gold p))

(westof A B)
(westof A F)
(westof A J)
(westof A N)
(westof A C)
(westof A G)
(westof A K)
(westof A O)
(westof A D)
(westof A H)
(westof A L)
(westof A P)
(westof E B)
(westof E F)
(westof E J)
(westof E N)
(westof E C)
(westof E G)
(westof E K)
(westof E O)
(westof E D)
(westof E H)
(westof E L)
(westof E P)
(westof I B)
(westof I F)
(westof I J)
(westof I N)
(westof I C)
(westof I G)
(westof I K)
(westof I O)
(westof I D)
(westof I H)
(westof I L)
(westof I P)
(westof M B)
(westof M F)
(westof M J)
(westof M N)
(westof M C)
(westof M G)
(westof M K)
(westof M O)
(westof M D)
(westof M H)
(westof M L)
(westof M P)
(westof B C)
(westof B G)
(westof B K)
(westof B O)
(westof B D)
(westof B H)
(westof B L)
(westof B P)
(westof F C)
(westof F G)
(westof F K)
(westof F O)
(westof F D)
(westof F H)
(westof F L)
(westof F P)
(westof J C)
(westof J G)
(westof J K)
(westof J O)
(westof J D)
(westof J H)
(westof J L)
(westof J P)
(westof N C)
(westof N G)
(westof N K)
(westof N O)
(westof N D)
(westof N H)
(westof N L)
(westof N P)
(westof C D)
(westof C H)
(westof C L)
(westof C P)
(westof G D)
(westof G H)
(westof G L)
(westof G P)
(westof K D)
(westof K H)
(westof K L)
(westof K P)
(westof O D)
(westof O H)
(westof O L)
(westof O P)"))(NEG (EXAMPLE.TARGET WUMPUSDISJUNCTIVE " (<= ent
      (not notent))
  (<= notent
      (possgold ?x)
      (posswumpus ?y)
      (not (westof ?x ?y)))
      
  (<= (possgold ?x)
      (gold ?y)
      (part ?y ?x)
      (not (ngold ?x))
      (not (some-goldnotin ?x)))

  (<= (some-goldnotin ?x)
      (gold ?y)
      (not (part ?y ?x)))

  (<= (posswumpus ?x)
      (wumpus ?y)
      (part ?y ?x)
      (not (nwumpus ?x))
      (not (some-wumpusnotin ?x)))
  
  (<= (some-wumpusnotin ?x)
      (wumpus ?y)
      (not (part ?y ?x)))

  (<= (part (listof ?x @y) ?x))
  (<= (part (listof ?z @y) ?x)
      (part (listof @y) ?x))

  (adj 1 2)
  (adj 2 3)
  (adj 3 4)

  (<= (west (cell ?x ?y) (cell ?x2 ?w))
      (adj ?x ?x2))

  (<= (westof ?x ?y)
      (or (west ?x ?y)
          (and (west ?x ?z) (west ?z ?y))
          (and (west ?x ?z) (west ?z ?w) (west ?w ?y))))

  (gold (listof (cell 1 4) (cell 1 2) (cell 2 2) (cell 2 3) (cell 2 4)))
  (ngold (cell 3 1))
  (ngold (cell 3 2))
  (ngold (cell 3 3))
  (ngold (cell 4 1))
  (ngold (cell 4 3))

  (wumpus (listof (cell 3 1) (cell 3 2) (cell 3 3) (cell 4 1) (cell 4 3)))
  (nwumpus (cell 1 4))
  (nwumpus (cell 1 2))
  (nwumpus (cell 2 2))
  (nwumpus (cell 2 3))
  (nwumpus (cell 2 4))
"))(POS (EXAMPLE.TARGET WUMPUSDISJUNCTIVE "  (<= ent
      (not notent))
  (<= notent
      (possgold ?x)
      (posswumpus ?y)
      (not (westof ?x ?y)))
      
  (<= (possgold ?x)
      (gold ?y)
      (part ?y ?x)
      (not (ngold ?x))
      (not (some-goldnotin ?x)))

  (<= (some-goldnotin ?x)
      (gold ?y)
      (not (part ?y ?x)))

  (<= (posswumpus ?x)
      (wumpus ?y)
      (part ?y ?x)
      (not (nwumpus ?x))
      (not (some-wumpusnotin ?x)))
  
  (<= (some-wumpusnotin ?x)
      (wumpus ?y)
      (not (part ?y ?x)))

  (gold aibfj)
  (ngold g)
  (ngold k)
  (ngold o)
  (ngold h)
  (ngold p)

  (wumpus gkohp)
  (nwumpus a)
  (nwumpus i)
  (nwumpus b)
  (nwumpus f)
  (nwumpus j)

  (part aibfj a)
  (part aibfj i)
  (part aibfj b)
  (part aibfj f)
  (part aibfj j)

  (part gkohp g)
  (part gkohp k)
  (part gkohp o)
  (part gkohp h)
  (part gkohp p)

(westof A B)
(westof A F)
(westof A J)
(westof A N)
(westof A C)
(westof A G)
(westof A K)
(westof A O)
(westof A D)
(westof A H)
(westof A L)
(westof A P)
(westof E B)
(westof E F)
(westof E J)
(westof E N)
(westof E C)
(westof E G)
(westof E K)
(westof E O)
(westof E D)
(westof E H)
(westof E L)
(westof E P)
(westof I B)
(westof I F)
(westof I J)
(westof I N)
(westof I C)
(westof I G)
(westof I K)
(westof I O)
(westof I D)
(westof I H)
(westof I L)
(westof I P)
(westof M B)
(westof M F)
(westof M J)
(westof M N)
(westof M C)
(westof M G)
(westof M K)
(westof M O)
(westof M D)
(westof M H)
(westof M L)
(westof M P)
(westof B C)
(westof B G)
(westof B K)
(westof B O)
(westof B D)
(westof B H)
(westof B L)
(westof B P)
(westof F C)
(westof F G)
(westof F K)
(westof F O)
(westof F D)
(westof F H)
(westof F L)
(westof F P)
(westof J C)
(westof J G)
(westof J K)
(westof J O)
(westof J D)
(westof J H)
(westof J L)
(westof J P)
(westof N C)
(westof N G)
(westof N K)
(westof N O)
(westof N D)
(westof N H)
(westof N L)
(westof N P)
(westof C D)
(westof C H)
(westof C L)
(westof C P)
(westof G D)
(westof G H)
(westof G L)
(westof G P)
(westof K D)
(westof K H)
(westof K L)
(westof K P)
(westof O D)
(westof O H)
(westof O L)
(westof O P)
"))(NEG (EXAMPLE.COMMENTS WUMPUSPERCEPTS "Here I'm using some functions in the source, simply because the problem was easier to write down this way.  It may also be a case that demonstrates that sometimes we can deal with functions.  I'm conflating this with completing the tables stench and shine, but I couldn't bring myself to write it without functions."))(POS (EXAMPLE.COMMENTS WUMPUSPERCEPTS "There is a version using functions to name cells.  Add UNA and DCA to the source."))(NEG (EXAMPLE.SOURCEQUERY WUMPUSPERCEPTS "      (=> (gold ?x) (wumpus ?y) (westof ?x ?y))
"))(POS (EXAMPLE.SOURCEQUERY WUMPUSPERCEPTS "     (forall (?x ?y) (=> (gold ?x) (wumpus ?y) (westof ?x ?y)))
"))(NEG (EXAMPLE.SOURCE WUMPUSPERCEPTS "
  (succ 1 2)
  (succ 2 3)
  (succ 3 4)

  (<=> (next ?x ?y)
       (or (succ ?x ?y)
           (succ ?y ?x)))

  (<=> (west (cell ?x ?y) (cell ?x2 ?y))
       (succ ?x2 ?x))
  (<=> (north (cell ?x ?y) (cell ?x ?y2))
       (succ ?y2 ?y))
  
  (<=> (east ?x ?y) (west ?y ?x))
  (<=> (south ?x ?y) (north ?y ?x))

  (<=> (westof (cell ?x ?y) (cell ?x2 ?y2))
       (or (succ ?x ?x2)
           (exists ?z (and (succ ?x ?z) (succ ?z ?x2)))
           (exists (?z ?w) (and (succ ?x ?z) (succ ?z ?w) (succ ?w ?x2)))))

  (<=> (westborder (cell 1 ?x))
       (not (= ?x 1))
       (not (= ?x 4)))

  (<=> (eastborder (cell 4 ?x))
       (not (= ?x 1))
       (not (= ?x 4)))

  (<=> (southborder (cell ?x 1))
       (not (= ?x 1))
       (not (= ?x 4)))

  (<=> (northborder (cell ?x 4))
       (not (= ?x 1))
       (not (= ?x 4)))

  (nwcorner (cell 1 4))
  (necorner (cell 4 4))
  (swcorner (cell 1 1))
  (secorner (cell 4 1))
  
  (<=> (notborder (cell ?x ?y))
       (and (not (= ?x 1))
            (not (= ?x 4))
            (not (= ?y 1))
            (not (= ?y 4))))

  ; center
  (=> (stench ?cell)
      (notborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?celle)
          (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (notborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))
           (not (wumpus ?cellw))
           (not (wumpus ?cells))))

  ;;; borders

  ;west
  (=> (stench ?cell)
      (westborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (or (wumpus ?celln)
          (wumpus ?celle)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (westborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))
           (not (wumpus ?cells))))


  ; north
  (=> (stench ?cell)
      (northborder ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (or (wumpus ?celle)
          (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (northborder ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (and (not (wumpus ?celle))
           (not (wumpus ?cellw))
           (not (wumpus ?cells))))

      
  ; south
  (=> (stench ?cell)
      (southborder ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?celle)
          (wumpus ?cellw)))

  (=> (not (stench ?cell))
      (southborder ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))
           (not (wumpus ?cellw))))

  ; east
  (=> (stench ?cell)
      (eastborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (eastborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?cellw))
           (not (wumpus ?cells))))

  ;;; corners

  ; nw
  (=> (stench ?cell)
      (nwcorner ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (or (wumpus ?celle)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (nwcorner ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (and (not (wumpus ?celle))
           (not (wumpus ?cells))))

  ; ne
  (=> (stench ?cell)
      (necorner ?cell)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (or (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (necorner ?cell)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (and (not (wumpus ?cellw))
           (not (wumpus ?cells))))

  ; sw
  (=> (stench ?cell)
      (wwcorner ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (or (wumpus ?celln)
          (wumpus ?celle)))

  (=> (not (stench ?cell))
      (wwcorner ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))))

  ; se
  (=> (stench ?cell)
      (secorner ?cell)
      (north ?cell ?celln)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?cellw)))

  (=> (not (stench ?cell))
      (secorner ?cell)
      (north ?cell ?celln)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?cellw))))

  (exists (?x ?y) (wumpus (cell ?x ?y)))

  (shiney (cell 1 3))
  (not (stench (cell 1 3)))
  (stench (cell 4 2))
  (not (shiney (cell 4 2)))
"))(POS (EXAMPLE.SOURCE WUMPUSPERCEPTS "  ; complete tables
  (north a e)
  (north e i)
  (north i m)
  (north b f)
  (north f j)
  (north j n)
  (north c g)
  (north g k)
  (north k o)
  (north d h)
  (north h l)
  (north l p)

  (west a b)
  (west b c)
  (west c d)
  (west e f)
  (west f g)
  (west g h)
  (west i j)
  (west j k)
  (west k l)
  (west m n)
  (west n o)
  (west o p)
  
  (<=> (east ?x ?y) (west ?y ?x))
  (<=> (south ?x ?y) (north ?y ?x))

  ; more complete tables
  (westborder e)
  (westborder i)
  (northborder b)
  (northborder c)
  (eastborder h)
  (eastborder l)
  (southborder n)
  (southborder o)

  (nwcorner a)
  (necorner d)
  (swcorner m)
  (swcorner p)

  (notborder f)
  (notborder g)
  (notborder j)
  (notborder k)
  
  ; center
  (=> (stench ?cell)
      (notborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?celle)
          (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (notborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))
           (not (wumpus ?cellw))
           (not (wumpus ?cells))))

  ;;; borders

  ;west
  (=> (stench ?cell)
      (westborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (or (wumpus ?celln)
          (wumpus ?celle)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (westborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))
           (not (wumpus ?cells))))


  ; north
  (=> (stench ?cell)
      (northborder ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (or (wumpus ?celle)
          (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (northborder ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (and (not (wumpus ?celle))
           (not (wumpus ?cellw))
           (not (wumpus ?cells))))

      
  ; south
  (=> (stench ?cell)
      (southborder ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?celle)
          (wumpus ?cellw)))

  (=> (not (stench ?cell))
      (southborder ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))
           (not (wumpus ?cellw))))

  ; east
  (=> (stench ?cell)
      (eastborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (eastborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?cellw))
           (not (wumpus ?cells))))

  ;;; corners

  ; nw
  (=> (stench ?cell)
      (nwcorner ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (or (wumpus ?celle)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (nwcorner ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (and (not (wumpus ?celle))
           (not (wumpus ?cells))))

  ; ne
  (=> (stench ?cell)
      (necorner ?cell)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (or (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (necorner ?cell)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (and (not (wumpus ?cellw))
           (not (wumpus ?cells))))

  ; sw
  (=> (stench ?cell)
      (wwcorner ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (or (wumpus ?celln)
          (wumpus ?celle)))

  (=> (not (stench ?cell))
      (wwcorner ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))))

  ; se
  (=> (stench ?cell)
      (secorner ?cell)
      (north ?cell ?celln)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?cellw)))

  (=> (not (stench ?cell))
      (secorner ?cell)
      (north ?cell ?celln)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?cellw))))


  (exists ?x (wumpus ?x))
  (exists ?x (gold ?x))

  (shiney e)
  (not (stench e))
  (stench l)
  (not (shiney l))



; a complete table
(westof A B)
(westof A F)
(westof A J)
(westof A N)
(westof A C)
(westof A G)
(westof A K)
(westof A O)
(westof A D)
(westof A H)
(westof A L)
(westof A P)
(westof E B)
(westof E F)
(westof E J)
(westof E N)
(westof E C)
(westof E G)
(westof E K)
(westof E O)
(westof E D)
(westof E H)
(westof E L)
(westof E P)
(westof I B)
(westof I F)
(westof I J)
(westof I N)
(westof I C)
(westof I G)
(westof I K)
(westof I O)
(westof I D)
(westof I H)
(westof I L)
(westof I P)
(westof M B)
(westof M F)
(westof M J)
(westof M N)
(westof M C)
(westof M G)
(westof M K)
(westof M O)
(westof M D)
(westof M H)
(westof M L)
(westof M P)
(westof B C)
(westof B G)
(westof B K)
(westof B O)
(westof B D)
(westof B H)
(westof B L)
(westof B P)
(westof F C)
(westof F G)
(westof F K)
(westof F O)
(westof F D)
(westof F H)
(westof F L)
(westof F P)
(westof J C)
(westof J G)
(westof J K)
(westof J O)
(westof J D)
(westof J H)
(westof J L)
(westof J P)
(westof N C)
(westof N G)
(westof N K)
(westof N O)
(westof N D)
(westof N H)
(westof N L)
(westof N P)
(westof C D)
(westof C H)
(westof C L)
(westof C P)
(westof G D)
(westof G H)
(westof G L)
(westof G P)
(westof K D)
(westof K H)
(westof K L)
(westof K P)
(westof O D)
(westof O H)
(westof O L)
(westof O P)
"))(NEG (EXAMPLE.TARGET WUMPUSPERCEPTS "  (<= ent
      (not notent))
  (<= notent
      (possworld ?x ?y)
      (not (westof ?x ?y)))

  (<= (westof ?x ?y)
      (or (west ?x ?y)
          (and (west ?x ?z) (west ?z ?y))
          (and (west ?x ?z) (west ?z ?w) (west ?w ?y))))

  (<= (possworld ?x ?y)
      (possgold ?x)
      (posswumpus ?y))

  ; poss gold
  (<= (possgold ?x)
      (adjacentshiney ?x)
      (not (some-adjacentnonshiney ?x))
      (not (some-nonadjacentshiney ?x)))

  (<= (adjacentshiney ?x)
      (shiney ?s)
      (adjacent ?s ?x))

  (<= (some-nonadjacentshiney ?x)
      (shiney ?s)
      (not (adjacent ?s ?x)))

  (<= (some-adjacentnonshiney ?x)
      (adjacent ?x ?y)
      (nshiney ?y))

  ; poss wumpus
  (<= (posswumpus ?x)
      (adjacentstench ?x)
      (not (some-adjacentnonstench ?x))
      (not (some-nonadjacentstench ?x)))

  (<= (adjacentstench ?x)
      (stench ?s)
      (adjacent ?s ?x))

  (<= (some-nonadjacentstench ?x)
      (stench ?s)
      (not (adjacent ?s ?x)))

  (<= (some-adjacentnonstench ?x)
      (adjacent ?x ?y)
      (nstench ?y))
      

  (adj 1 2)
  (adj 2 3)
  (adj 3 4)
  (<= (next ?x ?y)
      (or (adj ?x ?y) (adj ?y ?x)))
  
  (<= (adjacent (cell ?x ?y) (cell ?z ?y))
      (next ?x ?z))

  (<= (adjacent (cell ?x ?y) (cell ?x ?w))
      (next ?y ?w))

  (<= (adjacent (cell ?x ?y) (cell ?z ?w))
      (next ?x ?z)
      (next ?y ?w))

  (<= (west (cell ?x ?y) (cell ?x2 ?w))
      (adj ?x ?x2))

  (shiney (cell 1 3))
  (nstench (cell 1 3))
  (stench (cell 4 2))
  (nshiney (cell 4 2))"))(POS (EXAMPLE.TARGET WUMPUSPERCEPTS "  (<= ent
      (not notent))
  (<= notent
      (possworld ?x ?y)
      (not (westof ?x ?y)))


  (<= (possworld ?x ?y)
      (possgold ?x)
      (posswumpus ?y))

  ; poss gold
  (<= (possgold ?x)
      (adjacentshiney ?x)
      (not (some-adjacentnonshiney ?x))
      (not (some-nonadjacentshiney ?x)))

  (<= (adjacentshiney ?x)
      (shiney ?s)
      (adjacent ?s ?x))

  (<= (some-nonadjacentshiney ?x)
      (shiney ?s)
      (not (adjacent ?s ?x)))

  (<= (some-adjacentnonshiney ?x)
      (adjacent ?x ?y)
      (nshiney ?y))

  ; poss wumpus
  (<= (posswumpus ?x)
      (adjacentstench ?x)
      (not (some-adjacentnonstench ?x))
      (not (some-nonadjacentstench ?x)))

  (<= (adjacentstench ?x)
      (stench ?s)
      (adjacent ?s ?x))

  (<= (some-nonadjacentstench ?x)
      (stench ?s)
      (not (adjacent ?s ?x)))

  (<= (some-adjacentnonstench ?x)
      (adjacent ?x ?y)
      (nstench ?y))
      
#|
 --- --- --- ---
| a | b | c | d |
 --- --- --- ---
| e | f | g | h |
 --- --- --- ---
| i | j | k | l |
 --- --- --- ---
| m | n | o | p |
 --- --- --- ---
Shine: e
Stench: l

|#

  (<= (adjacent ?x ?y)
      (or (north ?x ?y)
          (north ?y ?x)
          (west ?x ?y)
          (west ?y ?x)
          (and (west ?z ?x) (north ?y ?z))
          (and (west ?z ?x) (north ?z ?y))
          (and (west ?x ?z) (north ?y ?z))
          (and (west ?x ?z) (north ?z ?y))))

  (north a e)
  (north e i)
  (north i m)
  (north b f)
  (north f j)
  (north j n)
  (north c g)
  (north g k)
  (north k o)
  (north d h)
  (north h l)
  (north l p)

  (west a b)
  (west b c)
  (west c d)
  (west e f)
  (west f g)
  (west g h)
  (west i j)
  (west j k)
  (west k l)
  (west m n)
  (west n o)
  (west o p)
  
  (<= (east ?x ?y) (west ?y ?x))
  (<= (south ?x ?y) (north ?y ?x))


  (shiney e)
  (nstench e)
  (stench l)
  (nshiney l)

(westof A B)
(westof A F)
(westof A J)
(westof A N)
(westof A C)
(westof A G)
(westof A K)
(westof A O)
(westof A D)
(westof A H)
(westof A L)
(westof A P)
(westof E B)
(westof E F)
(westof E J)
(westof E N)
(westof E C)
(westof E G)
(westof E K)
(westof E O)
(westof E D)
(westof E H)
(westof E L)
(westof E P)
(westof I B)
(westof I F)
(westof I J)
(westof I N)
(westof I C)
(westof I G)
(westof I K)
(westof I O)
(westof I D)
(westof I H)
(westof I L)
(westof I P)
(westof M B)
(westof M F)
(westof M J)
(westof M N)
(westof M C)
(westof M G)
(westof M K)
(westof M O)
(westof M D)
(westof M H)
(westof M L)
(westof M P)
(westof B C)
(westof B G)
(westof B K)
(westof B O)
(westof B D)
(westof B H)
(westof B L)
(westof B P)
(westof F C)
(westof F G)
(westof F K)
(westof F O)
(westof F D)
(westof F H)
(westof F L)
(westof F P)
(westof J C)
(westof J G)
(westof J K)
(westof J O)
(westof J D)
(westof J H)
(westof J L)
(westof J P)
(westof N C)
(westof N G)
(westof N K)
(westof N O)
(westof N D)
(westof N H)
(westof N L)
(westof N P)
(westof C D)
(westof C H)
(westof C L)
(westof C P)
(westof G D)
(westof G H)
(westof G L)
(westof G P)
(westof K D)
(westof K H)
(westof K L)
(westof K P)
(westof O D)
(westof O H)
(westof O L)
(westof O P)"))(POS (LANGUAGE.INSTANCE IKIF))(POS (LANGUAGE.INSTANCE KIF))(POS (LANGUAGE.INSTANCE XML))(POS (TECHNIQUE.INSTANCE CONSISTENCY2DEDUCTION))(POS (TECHNIQUE.DESCRIPTION CONSISTENCY2DEDUCTION "Consistency2Deduction[Delta,phi(xbar)] computes an expression that represents for all the query instances tbar such that Delta U {phi(tbar)} is consistent."))(POS (TECHNIQUE.INSTANCE REIFICATION))(POS (TECHNIQUE.DESCRIPTION REIFICATION "Reification is an umbrella technique that encompasses all kinds of vocabulary and conceptualization shifts."))(POS (TECHNIQUE.INSTANCE UNNAMED))(POS (TECHNIQUE.DESCRIPTION UNNAMED "Encompasses all unnamed techniques."))(POS (TECHNIQUE.INSTANCE RELATIONALIZING))(POS (TECHNIQUE.DESCRIPTION RELATIONALIZING "Form of reification where object/function constants are turned into relation constants."))(POS (TECHNIQUE.INSTANCE OBJECTIFYING))(POS (TECHNIQUE.DESCRIPTION OBJECTIFYING "Form of reification where relation constants become function or object constants."))(POS (TECHNIQUE.INSTANCE GENERATEOVERGUESS))(POS (TECHNIQUE.DESCRIPTION GENERATEOVERGUESS "Technique that changes a guess-and-check problem formulation reformulation into a formulation that generates the answer constructively."))(POS (TECHNIQUE.INSTANCE DATAEXTRACTION))(POS (TECHNIQUE.DESCRIPTION DATAEXTRACTION "Pulls data out of a rule or set of rules, places that data into tables, and appropriately adjusts the rule so that semantically the original and the new versions are identical.  Inverse of dataInfusion."))(POS (TECHNIQUE.INSTANCE DATAINFUSION))(POS (TECHNIQUE.DESCRIPTION DATAINFUSION "Pushes data from a table into rules, a special form of partial deduction from the logic programming literature.  Inverse of dataExtraction."))(POS (TECHNIQUE.INSTANCE CHIRKOVAREFORMULATION))(POS (TECHNIQUE.DESCRIPTION CHIRKOVAREFORMULATION "Computes the optimal viewset for transforming an unknown (but fixed-size) database into a new database that more efficiently answers a given query set."))(POS (PERSON.INSTANCE NATLOVE))(POS (PERSON.FIRSTNAME NATLOVE "Nat"))(POS (PERSON.LASTNAME NATLOVE "Love"))(POS (PERSON.TEAM NATLOVE NATLOVE))(POS (PERSON.EMAIL NATLOVE "natlove@stanford.edu"))(POS (PERSON.INSTANCE JDUCHI))(POS (PERSON.FIRSTNAME JDUCHI "John"))(POS (PERSON.LASTNAME JDUCHI "Duchi"))(POS (PERSON.TEAM JDUCHI JDUCHI))(POS (PERSON.EMAIL JDUCHI "jduchi@stanford.edu"))(POS (PERSON.INSTANCE DTARLOW))(POS (PERSON.FIRSTNAME DTARLOW "Danny"))(POS (PERSON.LASTNAME DTARLOW "Tarlow"))(POS (PERSON.TEAM DTARLOW DTARLOW))(POS (PERSON.EMAIL DTARLOW "dtarlow@stanford.edu"))(POS (PERSON.INSTANCE THINRICH))(POS (PERSON.FIRSTNAME THINRICH "Tim"))(POS (PERSON.LASTNAME THINRICH "Hinrichs"))(POS (PERSON.TEAM THINRICH THINRICH))(POS (PERSON.EMAIL THINRICH "thinrich@stanford.edu"))(POS (PAPER.INSTANCE ABITEBOUL))(POS (PAPER.BIBTEX ABITEBOUL BOOK))(POS (PAPER.AUTHOR ABITEBOUL "Serge Abiteboul and Richard Hull and Victor Vianu"))(POS (PAPER.TITLE ABITEBOUL "Foundations of Databases"))(POS (PAPER.PUBLISHER ABITEBOUL "Addison-Wesley Publishing Company"))(POS (PAPER.LINK ABITEBOUL "http://www.amazon.com/Foundations-Databases-Logical-Serge-Abiteboul/dp/0201537710"))(POS (PAPER.YEAR ABITEBOUL 1995))(POS (PAPER.DESCRIPTION ABITEBOUL "
The definitive guide for comparing various database query languages.
"))(POS (PAPER.TOPIC ABITEBOUL ""))(POS (PAPER.INSTANCE AGRAWAL2000))(POS (PAPER.BIBTEX AGRAWAL2000 INPROCEEDINGS))(POS (PAPER.AUTHOR AGRAWAL2000 "Agrawal and Chaudrhuri and Narasavya"))(POS (PAPER.TITLE AGRAWAL2000 "Automatic selection of materialized views and indexes in Microsoft SQL Server"))(POS (PAPER.PUBLICATION AGRAWAL2000 "In proceedings of Very Large Databases (VLDB)"))(POS (PAPER.STARTPAGE AGRAWAL2000 496))(POS (PAPER.ENDPAGE AGRAWAL2000 505))(POS (PAPER.YEAR AGRAWAL2000 2000))(POS (PAPER.DESCRIPTION AGRAWAL2000 "
Another paper on view selection problem in databases.
"))(POS (PAPER.TOPIC AGRAWAL2000 "Databases"))(POS (PAPER.INSTANCE AIELLO80))(POS (PAPER.BIBTEX AIELLO80 INPROCEEDINGS))(POS (PAPER.AUTHOR AIELLO80 "Luigia Aiello"))(POS (PAPER.TITLE AIELLO80 "Automatic Generation of Semantic Attachments in FOL"))(POS (PAPER.PUBLICATION AIELLO80 "AAAI"))(POS (PAPER.YEAR AIELLO80 1980))(POS (PAPER.RANK AIELLO80 "[**]"))(POS (PAPER.DESCRIPTION AIELLO80 "
Aiello describes a process of generating new semantic attachments from old
ones by compiling FOL into Lisp.
"))(POS (PAPER.TOPIC AIELLO80 "Theorem Proving with Attachments"))(POS (PAPER.INSTANCE ALFERES94))(POS (PAPER.AUTHOR ALFERES94 "J.J. Alferes, R. Li and L.M. Pereira"))(POS (PAPER.TITLE ALFERES94 "Concurrent Actions and Changes in the Situation Calculus"))(POS (PAPER.PUBLICATION ALFERES94 "Proceedings of IBERAMIA 94"))(POS (PAPER.STARTPAGE ALFERES94 93))(POS (PAPER.ENDPAGE ALFERES94 104))(POS (PAPER.LINK ALFERES94 "http://centria.fct.unl.pt/~lmp/publications/Biblio.html"))(POS (PAPER.YEAR ALFERES94 1994))(POS (PAPER.DESCRIPTION ALFERES94 "
Alferes shows that Situation Calculus extended with concurrent actions (e.g. buytoothpaste||buyshampoo) is no more expressive than standard Situation Calculus.  Intuitively, give names to every subset of actions since there are only 2^n such subsets of n actions.  Use those names as the actions in situation calculus.  The trouble here is how do we produce the effect axioms of a concurrent action set given the effect axioms of the individual actions?  Some of these axioms simply must be given by the user, e.g. buying toothpaste and shampoo at the same time might result in a free bar of soap, though neither effect axiom for buying toothpaste or shampoo would mention soap.  For those actions whose composition (in Alferes terms) can be determined automatically, the authors offer a solution using nonmonotonic logic: if Holds(p, Result(a, Result(b,s))) and Holds(p, Result(b, Result(a,s))) and there is no definition for Holds(p, Result(a||b),s), then conclude Holds(p, Result(a||b,s)).  Alferes elaborates the rule to include preconditions and subsets of size other than 2 (though some technical details arise in doing the latter).
"))(POS (PAPER.TOPIC ALFERES94 "Fundamentals"))(POS (PAPER.INSTANCE ALLEN90))(POS (PAPER.AUTHOR ALLEN90 "J. Allen, J. Hendler and A. Tate"))(POS (PAPER.TITLE ALLEN90 "Readings in Planning"))(POS (PAPER.LINK ALLEN90 "http://www.amazon.com/exec/obidos/ASIN/1558601309/qid%3D954347291/sr%3D1-13/002-1714614-2412067"))(POS (PAPER.YEAR ALLEN90 1990))(POS (PAPER.DESCRIPTION ALLEN90 "
Survey book on planning through 1990.
"))(POS (PAPER.TOPIC ALLEN90 "Historical"))(POS (PAPER.INSTANCE ALLWEIN96))(POS (PAPER.BIBTEX ALLWEIN96 BOOK))(POS (PAPER.AUTHOR ALLWEIN96 "Gerard Allwein and Jon Barwise"))(POS (PAPER.TITLE ALLWEIN96 "Logical Reasoning with Diagrams"))(POS (PAPER.PUBLISHER ALLWEIN96 "Oxford University Press"))(POS (PAPER.LINK ALLWEIN96 "http://www.amazon.com/exec/obidos/tg/detail/-/0195104277/104-6992918-7685512?vi=glance"))(POS (PAPER.YEAR ALLWEIN96 1996))(POS (PAPER.RANK ALLWEIN96 "[***]"))(POS (PAPER.DESCRIPTION ALLWEIN96 "
This book advocates the appropriate use of diagrams in formal, rigorous
proofs.  It formalizes the notions of entailment from a diagram and 
adjustments to a diagram.  The formalization is pretty complex, but
it is not obvious how to simplify it.  The book also looks at various
logics that can incorporate diagramatic methods.  The last two sections
are non-theoretical: a series of case studies and a series of heterogeneous
systems.  The bibiliography looks helpful.
"))(POS (PAPER.TOPIC ALLWEIN96 "Graphical Reasoning Techniques"))(POS (PAPER.INSTANCE ALSAC2002))(POS (PAPER.AUTHOR ALSAC2002 "Guray Alsac and Chitta Baral "))(POS (PAPER.TITLE ALSAC2002 "Reasoning in description logics using declarative logic programming"))(POS (PAPER.LINK ALSAC2002 "http://citeseer.ist.psu.edu/context/2398354/0"))(POS (PAPER.YEAR ALSAC2002 2002))(POS (PAPER.DESCRIPTION ALSAC2002 "
The authors discuss a nontrivial translation of a particular 
description logic into logic programming.
"))(POS (PAPER.TOPIC ALSAC2002 "Logic Programming"))(POS (PAPER.INSTANCE AMIR2001))(POS (PAPER.BIBTEX AMIR2001 PHDTHESIS))(POS (PAPER.AUTHOR AMIR2001 "Eyal Amir"))(POS (PAPER.TITLE AMIR2001 "Dividing and Conquering Logic"))(POS (PAPER.PUBLISHER AMIR2001 "Stanford University"))(POS (PAPER.LINK AMIR2001 ""))(POS (PAPER.YEAR AMIR2001 2001))(POS (PAPER.DESCRIPTION AMIR2001 "
Amir's thesis considers several problems related to the construction and
reasoning about large knowledge bases.  First he discusses object-oriented
first-order logic, a synthesis of the object oriented paradigm and
FOL.  Second he applies this logic to theories of action, most notably
situation calculus.  Third he shows how to parallelize automated
theorem proving where a theory has been partitioned into pieces.  Fourth
he gives algorithms for automatically decomposing theories, based on
the syntactic character of the axioms.  Last he describes a logic-based
subsumption architecture for automated robot control, similar in spirit
to Golog.  An appendix on logic, one on reactive control systems, and
30 pages of references round out the thesis.  It should be noted
that while he does augment various resolution procedures to work
in this parallel setting, the rest of the results are independent of
a particular calculus.
"))(POS (PAPER.TOPIC AMIR2001 "Logical Knowledge Representation"))(POS (PAPER.INSTANCE ARENAS98))(POS (PAPER.AUTHOR ARENAS98 "Marcello Arenas and Leopoldo Bertossi"))(POS (PAPER.TITLE ARENAS98 "Hypothetical Temporal Reasoning with History Encoding"))(POS (PAPER.PUBLICATION ARENAS98 "Knowledge Representation Meets Database"))(POS (PAPER.VOLUME ARENAS98 "4.1-4.8"))(POS (PAPER.LINK ARENAS98 "http://citeseer.ist.psu.edu/529093.html"))(POS (PAPER.YEAR ARENAS98 1998))(POS (PAPER.RANK ARENAS98 "[***]"))(POS (PAPER.DESCRIPTION ARENAS98 "
Arenas and Bertossi build on J. Chomicki's work of progressing a history of a database transaction's effects through the execution of a transaction to save on the costs of doing temporal constraint checking.  They also use Reiter's work on evaluating a query in the state that results after executing a sequence of actions.  The authors meld these two approaches to answer queries about the evolution of a database that contain quantification over states (for two specific types of queries).  This work also leads to a process for transforming dynamic integrity constraints into static ones and transforming history dependent action preconditions into local preconditions. 
"))(POS (PAPER.TOPIC ARENAS98 "Hypothetical Temporal DB Queries"))(POS (PAPER.RELATED ARENAS98 CHOMICKI95))(POS (PAPER.INSTANCE ARENAS98B))(POS (PAPER.AUTHOR ARENAS98B "Marcelo Arenas, Leopoldo Bertossi and Javier Pinto"))(POS (PAPER.TITLE ARENAS98B "Representation of Temporal Knowledge in the Situation Calculus"))(POS (PAPER.LINK ARENAS98B "http://citeseer.ist.psu.edu/527517.html"))(POS (PAPER.YEAR ARENAS98B 1998))(POS (PAPER.RANK ARENAS98B "[***]"))(POS (PAPER.DESCRIPTION ARENAS98B "
This incomplete paper describes translating a first-order modal temporal logic, Metric Time Temporal Logic, into situation calculus in the context of database updates.  The key insight is the creation of new relations that summarize information about the past.  Doing this gives us the power to write non-Markovian axioms (those that depend on a history of states instead of a just the last state).  
"))(POS (PAPER.TOPIC ARENAS98B "Hypothetical Temporal DB Queries"))(POS (PAPER.INSTANCE ARMANDO93))(POS (PAPER.BIBTEX ARMANDO93 ARTICLE))(POS (PAPER.AUTHOR ARMANDO93 "A. Armando and E. Giunchiglia"))(POS (PAPER.TITLE ARMANDO93 "Embedding complex decision procedures inside an interative theorem prover"))(POS (PAPER.PUBLICATION ARMANDO93 "Annals of Mathematics and Artificial Intelligence"))(POS (PAPER.VOLUME ARMANDO93 "8(3-4)"))(POS (PAPER.STARTPAGE ARMANDO93 475))(POS (PAPER.ENDPAGE ARMANDO93 502))(POS (PAPER.LINK ARMANDO93 "http://citeseer.ist.psu.edu/context/552111/0"))(POS (PAPER.YEAR ARMANDO93 1993))(POS (PAPER.DESCRIPTION ARMANDO93 "
Building a Non-CNF SAT solver out of a CNF SAT-solver.  
"))(POS (PAPER.TOPIC ARMANDO93 "SAT Solving"))(POS (PAPER.INSTANCE ARMANDO97))(POS (PAPER.BIBTEX ARMANDO97 TECHREPORT))(POS (PAPER.AUTHOR ARMANDO97 "A. Armando and S. Ranise"))(POS (PAPER.TITLE ARMANDO97 "From Integrated Reasoning Specialists to Plug-and-Play Reasoning Components"))(POS (PAPER.PUBLICATION ARMANDO97 "Technical Report
           "))(POS (PAPER.LINK ARMANDO97 "http://citeseer.ist.psu.edu/armando98from.html"))(POS (PAPER.YEAR ARMANDO97 1997))(POS (PAPER.RANK ARMANDO97 "[***]"))(POS (PAPER.DESCRIPTION ARMANDO97 "
Armando and Ranise investigate breaking apart a reasoner into its
constituent pieces.  This investigation aims at learning how to
describe reasoners in an effort to promote the heterogeneous integration
of reasoners.  Their case study is NQTHM, Boyer and Moore's linear
arithmetic decision procedure.
"))(POS (PAPER.TOPIC ARMANDO97 "Architectures"))(POS (PAPER.INSTANCE ASTRACHAN92))(POS (PAPER.BIBTEX ASTRACHAN92 INPROCEEDINGS))(POS (PAPER.AUTHOR ASTRACHAN92 "Owen Astrachan and Mark Stickel"))(POS (PAPER.TITLE ASTRACHAN92 "Caching and Lemmaizing in Model Elimination Theorem Provers"))(POS (PAPER.PUBLICATION ASTRACHAN92 "Proceedings of CADE"))(POS (PAPER.LINK ASTRACHAN92 "http://citeseer.ist.psu.edu/astrachan92caching.html"))(POS (PAPER.YEAR ASTRACHAN92 1992))(POS (PAPER.RANK ASTRACHAN92 "[***]"))(POS (PAPER.DESCRIPTION ASTRACHAN92 "
Caching essentially saves intermediate results of a proof in a lookup table and
checks that table to avoid repeating the search for a result already computed.
It keeps track of the depth at which solutions are found to ensure
the same solutions are found given the appropriate depth cutoff using
iterative deepening.  Lemmaizing adds a derived result to the set of input 
clauses, which hopefully will decrease the depth of the proof by more 
than it increases the branching factor. This seminal paper deals with the 
Horn case.
"))(POS (PAPER.TOPIC ASTRACHAN92 "Theorem Proving with Attachments"))(POS (PAPER.INSTANCE AUDEMARD2000))(POS (PAPER.BIBTEX AUDEMARD2000 INPROCEEDINGS))(POS (PAPER.AUTHOR AUDEMARD2000 "Gilles Audemard and Belaid Benhamou and Laurent Henocque"))(POS (PAPER.TITLE AUDEMARD2000 "Two techniques to improve Finite Model Search"))(POS (PAPER.PUBLICATION AUDEMARD2000 "Proceedings of the 17th International Conference on Automated Deduction"))(POS (PAPER.LINK AUDEMARD2000 "http://citeseer.ist.psu.edu/386981.html"))(POS (PAPER.YEAR AUDEMARD2000 2000))(POS (PAPER.DESCRIPTION AUDEMARD2000 "
Two techniques are introduced to speed up SEM-style model finding.
"))(POS (PAPER.TOPIC AUDEMARD2000 "Model Building"))(POS (PAPER.INSTANCE BACHMAIR97))(POS (PAPER.AUTHOR BACHMAIR97 "Leo Bachmair and Harald Ganzinger and Andrei Voronkov"))(POS (PAPER.TITLE BACHMAIR97 "Elimination of Equality via Transformation with Ordering Constraints"))(POS (PAPER.PUBLICATION BACHMAIR97 "CADE"))(POS (PAPER.LINK BACHMAIR97 "http://portal.acm.org/citation.cfm?id=648234.753446"))(POS (PAPER.YEAR BACHMAIR97 1997))(POS (PAPER.DESCRIPTION BACHMAIR97 "
This paper  builds on Brand's method for eliminating the substitution,
reflexivity, symmetry, and transitivity axioms of equality by rewriting
the rules.  It adds ordering constraints in the process of transformation,
which seems to be one of the big benefits.
"))(POS (PAPER.TOPIC BACHMAIR97 "Transformations"))(POS (PAPER.INSTANCE BARALIS97))(POS (PAPER.BIBTEX BARALIS97 INPROCEEDINGS))(POS (PAPER.AUTHOR BARALIS97 "Baralis and Paraboschi and Teniente"))(POS (PAPER.TITLE BARALIS97 "Materialized view selection in a multidimensional database"))(POS (PAPER.PUBLICATION BARALIS97 "In proceedings of Very Large Databases (VLDB)"))(POS (PAPER.STARTPAGE BARALIS97 155))(POS (PAPER.ENDPAGE BARALIS97 165))(POS (PAPER.YEAR BARALIS97 1997))(POS (PAPER.DESCRIPTION BARALIS97 "
Paper on view selection problem in databases
"))(POS (PAPER.TOPIC BARALIS97 "Databases"))(POS (PAPER.INSTANCE BARRETT2000))(POS (PAPER.BIBTEX BARRETT2000 INPROCEEDINGS))(POS (PAPER.AUTHOR BARRETT2000 "Clark Barrett and David Dill and Aaron Stump"))(POS (PAPER.TITLE BARRETT2000 "A Framework for Cooperating Decision Procedures"))(POS (PAPER.PUBLICATION BARRETT2000 "17th International Conference on Automated Deduction
           "))(POS (PAPER.LINK BARRETT2000 "http://citeseer.ist.psu.edu/barrett00framework.html"))(POS (PAPER.YEAR BARRETT2000 2000))(POS (PAPER.RANK BARRETT2000 "[**]"))(POS (PAPER.DESCRIPTION BARRETT2000 "
Barrett et. al. describe a framework approach for building reasoners
that combine decision procedures.  This work is a precurser to janicic2002.
They introduce half a dozen operations that can be used to interrelate
these decision procedures; they further show how Nelson Oppen and
Shostak procedures can be built in their framework.
"))(POS (PAPER.TOPIC BARRETT2000 "Architectures"))(POS (PAPER.RELATED BARRETT2000 JANICIC2002))(POS (PAPER.INSTANCE BAUMGARTNER2003))(POS (PAPER.BIBTEX BAUMGARTNER2003 ARTICLE))(POS (PAPER.AUTHOR BAUMGARTNER2003 "Peter Baumgartner and Cesare Tinelli"))(POS (PAPER.TITLE BAUMGARTNER2003 "The Model Evolution Calculus"))(POS (PAPER.PUBLICATION BAUMGARTNER2003 "19th International Conference on Automated
    Deduction"))(POS (PAPER.STARTPAGE BAUMGARTNER2003 350))(POS (PAPER.ENDPAGE BAUMGARTNER2003 364))(POS (PAPER.LINK BAUMGARTNER2003 "http://sherry.ifi.unizh.ch/577584.html"))(POS (PAPER.YEAR BAUMGARTNER2003 2003))(POS (PAPER.RANK BAUMGARTNER2003 "[****]"))(POS (PAPER.DESCRIPTION BAUMGARTNER2003 "
Baumgartner and Tinelli describe a first-order version of the DPLL 
(Davis-Putnam-Logemann-Loveland) SAT solver.  In the case of
propositional logic, ME reduces to DPLL.  It differs in the first-order
case because of additional inference rules and skolemization.  The procedure
works by exaustively trying to build a first-order model.  If the search 
fails, the sentences are unsatisfiable.  But if the sentences are satisfiable,
the procedure may run forever trying to construct one.  (Obviously if there
are only infinite models this technique may have issues.) 
"))(POS (PAPER.TOPIC BAUMGARTNER2003 "The Model Evolution Calculus"))(POS (PAPER.INSTANCE BAUMGARTNER2007))(POS (PAPER.BIBTEX BAUMGARTNER2007 ARTICLE))(POS (PAPER.AUTHOR BAUMGARTNER2007 "Peter Baumgartner and Alexander Fuchs and Hans Nivelle and Cesare Tinelli"))(POS (PAPER.TITLE BAUMGARTNER2007 "Computing Finite Models by Reduction to Function-Free Clause Logic"))(POS (PAPER.PUBLICATION BAUMGARTNER2007 "Journal of Applied Logic"))(POS (PAPER.LINK BAUMGARTNER2007 "http://goedel.cs.uiowa.edu/Darwin/"))(POS (PAPER.YEAR BAUMGARTNER2007 2007))(POS (PAPER.DESCRIPTION BAUMGARTNER2007 "
Paper on FMDarwin for building finite models of clause sets.  Unlike
techniques for finding a model directly and techniques that ground out
sentences and invoke a SAT solver, FMDarwin reduces a set of clauses
to function-free clause logic in a way that preserves satisfiability
for a particular size domain.  Then it uses Darwin, an implementation
of the model evolution calculus, to check the satisfiability of
the function-free clauses, iterating through domain sizes.  
"))(POS (PAPER.TOPIC BAUMGARTNER2007 "Model Building"))(POS (PAPER.INSTANCE BAUMGARTNER94))(POS (PAPER.AUTHOR BAUMGARTNER94 "Peter Baumgartner and Ulrich Furbach"))(POS (PAPER.TITLE BAUMGARTNER94 "Model Elimination Without Contrapositives"))(POS (PAPER.PUBLICATION BAUMGARTNER94 "Proceedings of Conference on Automated Deduction"))(POS (PAPER.VOLUME BAUMGARTNER94 "814"))(POS (PAPER.STARTPAGE BAUMGARTNER94 87))(POS (PAPER.ENDPAGE BAUMGARTNER94 101))(POS (PAPER.LINK BAUMGARTNER94 "http://portal.acm.org/citation.cfm?id=752966"))(POS (PAPER.YEAR BAUMGARTNER94 1994))(POS (PAPER.DESCRIPTION BAUMGARTNER94 "
Baumgartner and Furbach introduce Restart Model Elimination and a couple of refinements.
RME obviates the need for contrapositives; all the rules are written in the form
A1 | ... | An <= B1 ^ ... ^ Bm, i.e. the only extension steps that can be performed
are on one of the Ai.  The price we pay is that whenever the literal on the top of the 
stack is positive, we put the goal literal onto the top of the stack (forcibly in
strict RME), hence the name Restart ME.  Also, this means that ancestry pruning cannot
be used with RME if completeness is to be preserved.  Soundness and refutational 
completeness results.  Some experimental results and fairly lengthy comparison
to other calculi.
"))(POS (PAPER.TOPIC BAUMGARTNER94 "Calculi"))(POS (PAPER.INSTANCE BAUMGARTNER95))(POS (PAPER.BIBTEX BAUMGARTNER95 ARTICLE))(POS (PAPER.AUTHOR BAUMGARTNER95 "Peter Baumgartner and Ulrich Furbach and Frieder Stolzenburg"))(POS (PAPER.TITLE BAUMGARTNER95 "Model Elimination, Logic Programming and Computing Answers"))(POS (PAPER.PUBLICATION BAUMGARTNER95 "Technical Report"))(POS (PAPER.LINK BAUMGARTNER95 "http://citeseer.ist.psu.edu/144755.html"))(POS (PAPER.YEAR BAUMGARTNER95 1995))(POS (PAPER.DESCRIPTION BAUMGARTNER95 "
The authors demonstrate that restart model elimination can be used as a complete
interpreter for positive disjunctive logic programming.  That is, they show how
to adjust RME so that it is complete for (definite) answer extraction.  With proofs.
Also, they introduce a limited form of ancestry pruning.  More experiments.
"))(POS (PAPER.TOPIC BAUMGARTNER95 "Calculi"))(POS (PAPER.INSTANCE BELL95))(POS (PAPER.BIBTEX BELL95 ARTICLE))(POS (PAPER.AUTHOR BELL95 "John Bell"))(POS (PAPER.TITLE BELL95 "Pragmatic Reasoning: A model-based theory"))(POS (PAPER.PUBLISHER BELL95 "Kluwer Academic Publishers"))(POS (PAPER.PUBLICATION BELL95 "Applied Logic: How, What and Why"))(POS (PAPER.LINK BELL95 "http://citeseer.ist.psu.edu/bell92pragmatic.html"))(POS (PAPER.YEAR BELL95 1995))(POS (PAPER.RANK BELL95 "[****]"))(POS (PAPER.DESCRIPTION BELL95 "
Bell defines pragmatic reasoning as context-dependent reasoning, in
contrast to deduction which is context-free.  He mathematizes
the two model-theoretically and discusses different versions
of pragmatic entailment.  He compares it to mental models, and
looks at different techniques that have been developed for
expressing pragmatic reasoning tasks.
"))(POS (PAPER.TOPIC BELL95 "Logical Knowledge Representation"))(POS (PAPER.INSTANCE BEREZIN2002))(POS (PAPER.BIBTEX BEREZIN2002 PHDTHESIS))(POS (PAPER.AUTHOR BEREZIN2002 "Sergey Berezin"))(POS (PAPER.TITLE BEREZIN2002 "Model Checking and Theorem Proving: A Unified Framework"))(POS (PAPER.PUBLICATION BEREZIN2002 "CMU Ph.D. Thesis"))(POS (PAPER.LINK BEREZIN2002 "http://chicory.stanford.edu/~berezin/thesis/"))(POS (PAPER.YEAR BEREZIN2002 2002))(POS (PAPER.RANK BEREZIN2002 "[**]"))(POS (PAPER.DESCRIPTION BEREZIN2002 "
This thesis builds a framework for integrating model checking and 
theorem proving, focusing on formal verification applications.  
The basic framework proves first-order branching time mu-calculus
properties of Kripke models, but the inference rules can be easily
changed to facilitate the fast development of new proof systems
(called model provers).  Related work is not so thorough. 
"))(POS (PAPER.TOPIC BEREZIN2002 "Model Checking"))(POS (PAPER.INSTANCE BLACKBURN))(POS (PAPER.BIBTEX BLACKBURN BOOK))(POS (PAPER.AUTHOR BLACKBURN "Patrick Blackburn and Johan van Benthem and Frank Wolter"))(POS (PAPER.TITLE BLACKBURN "Handbook of Modal Logic"))(POS (PAPER.PUBLISHER BLACKBURN "Elsevier Science"))(POS (PAPER.LINK BLACKBURN "http://www.elsevier.com/wps/find/bookdescription.cws_home/708884/description#description"))(POS (PAPER.YEAR BLACKBURN 2006))(POS (PAPER.RANK BLACKBURN "[*****]"))(POS (PAPER.DESCRIPTION BLACKBURN "
A handbook for modal logic, covering basic and advanced theory, variations and extensions, and applications.
"))(POS (PAPER.TOPIC BLACKBURN ""))(POS (PAPER.INSTANCE BODIRSKY2004))(POS (PAPER.BIBTEX BODIRSKY2004 PHDTHESIS))(POS (PAPER.AUTHOR BODIRSKY2004 "Manuel Bodirsky"))(POS (PAPER.TITLE BODIRSKY2004 "Constraint Satisfaction with Infinite Domains"))(POS (PAPER.LINK BODIRSKY2004 "http://www.informatik.hu-berlin.de/~bodirsky/publications/diss.html"))(POS (PAPER.YEAR BODIRSKY2004 2004))(POS (PAPER.DESCRIPTION BODIRSKY2004 "
Bodirsky examines the problem of the homomorphic CSP: given one structure,
is it homomorphic to the target structure?  He for the first time
considers target structures that are countably large; more precisely,
those that are countably large but are omega categorical, i.e. 
all countable models of the first-order theory of that model are isomorphic.
In this work, he produces an algorithm for constructing a tree that
satisfies a given set of constraints, where those constraints require
the existence of nodes that meet certain conditions.  Three possible conditions:
x is an ancestor of y, x and y are equal, and x occurs in a subtree to
the left of the subtree that includes y.  While these constraints force
nodes to exist that satisfy particular relationships, OOCSPs force 
particular nodes to have a particular relationship.
"))(POS (PAPER.TOPIC BODIRSKY2004 "Miscellaneous"))(POS (PAPER.INSTANCE BONACINA97))(POS (PAPER.BIBTEX BONACINA97 INPROCEEDINGS))(POS (PAPER.AUTHOR BONACINA97 "Maria Bonacina"))(POS (PAPER.TITLE BONACINA97 "Machine-independent evaluation of theorem-proving strategies"))(POS (PAPER.PUBLICATION BONACINA97 "Workshop on Theorem Proving Strategies"))(POS (PAPER.STARTPAGE BONACINA97 37))(POS (PAPER.ENDPAGE BONACINA97 39))(POS (PAPER.LINK BONACINA97 "http://citeseer.ist.psu.edu/bonacina97machineindependent.html"))(POS (PAPER.YEAR BONACINA97 1997))(POS (PAPER.RANK BONACINA97 "[***]"))(POS (PAPER.DESCRIPTION BONACINA97 "
Bonacina's position piece explains the need for 'strategy analysis' of
theorem proving techniques.  'Strategy analysis' focuses on theorem-proving
complexity as in plaisted94, but also incorporates indexing, data-structures,
unification complexity, etc.   Bonacina gives a summary of another paper 
that confronts the problem representing deletion strategies in a search
space.  Cites kowalski69 as handling the case where results are never
deleted.  She also explains how a sizable body of related work 
concentrates on the complexity of a logical formalism without reference
to any automated proof-finding system, e.g. goubault94.  
"))(POS (PAPER.TOPIC BONACINA97 "Comparative Analysis"))(POS (PAPER.RELATED BONACINA97 KOWALSKI69))(POS (PAPER.RELATED BONACINA97 GOUBAULT94))(POS (PAPER.INSTANCE BONACINA98))(POS (PAPER.BIBTEX BONACINA98 MISC))(POS (PAPER.AUTHOR BONACINA98 "Maria Bonacina"))(POS (PAPER.TITLE BONACINA98 "Strategy analysis: from Sequential to parallel strategies"))(POS (PAPER.STARTPAGE BONACINA98 21))(POS (PAPER.ENDPAGE BONACINA98 23))(POS (PAPER.LINK BONACINA98 "http://citeseer.ist.psu.edu/36838.html"))(POS (PAPER.YEAR BONACINA98 1998))(POS (PAPER.RANK BONACINA98 "[*]"))(POS (PAPER.DESCRIPTION BONACINA98 "
Bonacina's position paper describes the formalization of the
search space for parallelized theorem proving with contraction
operations.  This paper covers the main ideas, but the meat looks
to be cited in two technical reports.
"))(POS (PAPER.TOPIC BONACINA98 "Comparative Analysis"))(POS (PAPER.INSTANCE BORGER))(POS (PAPER.BIBTEX BORGER BOOK))(POS (PAPER.AUTHOR BORGER "Egon Borger and Erich Gradel and Yuri Gurevich"))(POS (PAPER.TITLE BORGER "The Classical Decision Problem"))(POS (PAPER.PUBLISHER BORGER "Springer-Verlag"))(POS (PAPER.LINK BORGER "http://books.google.com/books?id=3po2Tv_UVcMC&dq=&pg=PP1&ots=FMOqyLGt4N&sig=7pB4XtFUSbGbiUuF4XlKGattRts&prev=http://www.google.com/search%3Fclient%3Dsafari%26rls%3Den%26q%3Dthe%2Bclassical%2Bdecision%2Bproblem%26ie%3DUTF-8%26oe%3DUTF-8&sa=X&oi=print&ct=title#PPP1,M1"))(POS (PAPER.YEAR BORGER 1997))(POS (PAPER.DESCRIPTION BORGER "
The book detailing decidability results for entailment in various prefix
classes of first-order logic, along with complexity results for the 
decidable classes.
"))(POS (PAPER.TOPIC BORGER ""))(POS (PAPER.INSTANCE BORNING92))(POS (PAPER.BIBTEX BORNING92 ARTICLE))(POS (PAPER.AUTHOR BORNING92 "A. Borning and B.N. Freeman-Benson and M. Wilson"))(POS (PAPER.TITLE BORNING92 "Constraint hierarchies"))(POS (PAPER.PUBLICATION BORNING92 "Lisp and Symbolic Computation"))(POS (PAPER.VOLUME BORNING92 "5"))(POS (PAPER.STARTPAGE BORNING92 223))(POS (PAPER.ENDPAGE BORNING92 270))(POS (PAPER.LINK BORNING92 "http://citeseer.ist.psu.edu/borning92constraint.html"))(POS (PAPER.YEAR BORNING92 1992))(POS (PAPER.RANK BORNING92 "[*]"))(POS (PAPER.DESCRIPTION BORNING92 "
Constraint hierarchies, aka Hierarchical Constraint Satisfaction Problems,
impose a precedence hierarchy on constraints.  Only the highest 
precedence constraints must be satisfied; the others constraints
form an ordered set of preferences on the solutions.
"))(POS (PAPER.TOPIC BORNING92 "Object Oriented Constraint Satisfaction"))(POS (PAPER.INSTANCE BORRETT2001))(POS (PAPER.AUTHOR BORRETT2001 "James Borrett and Edward Tsang"))(POS (PAPER.TITLE BORRETT2001 "A Context for Constraint Satisfaction Problem Formulation Selection"))(POS (PAPER.PUBLICATION BORRETT2001 "Constraints"))(POS (PAPER.VOLUME BORRETT2001 "6"))(POS (PAPER.STARTPAGE BORRETT2001 299))(POS (PAPER.ENDPAGE BORRETT2001 327))(POS (PAPER.LINK BORRETT2001 "http://citeseer.ist.psu.edu/borret99context.html"))(POS (PAPER.YEAR BORRETT2001 2001))(POS (PAPER.RANK BORRETT2001 "[***]"))(POS (PAPER.DESCRIPTION BORRETT2001 "
Borrett and Tsang construct a framework for searching through various constraint satisfaction problem formulations and selecting one.  They only consider
formulations of the form <V,D,C>, i.e. typical CSP formulations.  They break the problem into 4 parts: generating an initial formulation, constructing operators to change that formulation, constructing heuristics for choosing which operator to apply, and constructing an evaluation function to that determines the cost of a given formulation.  They go on to demonstrate a particular type of operator: the introduction of redundant constraints and show how searching through CSP formulations with this type of operator works in their framework.
"))(POS (PAPER.TOPIC BORRETT2001 "Reformulation"))(POS (PAPER.INSTANCE BOWEN91))(POS (PAPER.BIBTEX BOWEN91 ARTICLE))(POS (PAPER.AUTHOR BOWEN91 "J. Bowen and D. Bahler"))(POS (PAPER.TITLE BOWEN91 "Conditional Existence of Variables in Generalized Constraint Networks
"))(POS (PAPER.PUBLICATION BOWEN91 "AAAI "))(POS (PAPER.LINK BOWEN91 "http://www.csc.ncsu.edu/faculty/bahler/aaai91/aaai91.pdf"))(POS (PAPER.YEAR BOWEN91 1991))(POS (PAPER.DESCRIPTION BOWEN91 "
Bowen and Bahler employ Free Logic to construct a constraint network
where not all variables must be assigned values.  A constraint network
is defined as a set of logical sentences with a DCA; 
a solution is an interpretation
of the vocabulary in a model so that the sentences are satisfied.  
Free logic differs from FOL in that not every element in the vocabulary
needs to be mapped into the model.
"))(POS (PAPER.TOPIC BOWEN91 "Miscellaneous"))(POS (PAPER.INSTANCE BRY2007))(POS (PAPER.BIBTEX BRY2007 ARTICLE))(POS (PAPER.AUTHOR BRY2007 "Francois Bry and Norbert Eisinger and Thomas Eiter and Tim Furche and Georg Gottlob and Clemens Ley and Benedikt Linse and Reinhard Pichler and Fang Wei"))(POS (PAPER.TITLE BRY2007 "Foundations of Rule-Based Query Answering"))(POS (PAPER.PUBLICATION BRY2007 "Reasoning Web, Third International Summer School 2007, Grigoris Antoniou, Uwe Assmann, Cristina Baroglio, Stefan Decker, Nicola Henze, Paula-Lavinia Patranjan, Robert Tolksdorf (editors)"))(POS (PAPER.VOLUME BRY2007 "LNCS 4636"))(POS (PAPER.LINK BRY2007 "http://www.pms.ifi.lmu.de/publikationen/index.html#PMS-FB-2007-7"))(POS (PAPER.YEAR BRY2007 2007))(POS (PAPER.DESCRIPTION BRY2007 "
The mathematical foundations of logical query languages.
"))(POS (PAPER.TOPIC BRY2007 "Logical Knowledge Representation"))(POS (PAPER.INSTANCE BUNDY73))(POS (PAPER.BIBTEX BUNDY73 INPROCEEDINGS))(POS (PAPER.AUTHOR BUNDY73 "Alan Bundy"))(POS (PAPER.TITLE BUNDY73 "Doing Arithmetic With Diagrams"))(POS (PAPER.PUBLICATION BUNDY73 "IJCAI"))(POS (PAPER.YEAR BUNDY73 1973))(POS (PAPER.RANK BUNDY73 "[**]"))(POS (PAPER.DESCRIPTION BUNDY73 "
Bundy describes SUMS (System which Understands Mathematical
Symbols), a theorem prover for theorems over natural numbers.
The SUMS proof process represents the natural numbers in
a diagram, and by manipulating the diagram, determines the
truth of a conjecture.  Bundy makes an interesting point at the 
end of the paper: mathematicians do not usually manipulate
logic to prove theorems.  Rather, they convince themselves
of the correctness of a conjecture through diagrams or other
semantic insights and then use logic as a language for
communicating to others the proof of the theorem.  SUMS
is an attempt at building a machine that simply 
convinces itself of the truth of a conjecture.
"))(POS (PAPER.TOPIC BUNDY73 "Graphical Reasoning Techniques"))(POS (PAPER.INSTANCE BUNDY99))(POS (PAPER.AUTHOR BUNDY99 "Alan Bundy"))(POS (PAPER.TITLE BUNDY99 "A Survey of Automated Deduction"))(POS (PAPER.LINK BUNDY99 "http://citeseer.ist.psu.edu/bundy99survey.html"))(POS (PAPER.YEAR BUNDY99 1999))(POS (PAPER.RANK BUNDY99 ""))(POS (PAPER.DESCRIPTION BUNDY99 "
Bundy surveys research in automated deduction.  He focuses on resolution,
term rewriting, built-in unification, higher-order logics and type-theory,
induction, interactive theorem-proving, meta-reasoning, common sense
reasoning, and logic programming.
"))(POS (PAPER.TOPIC BUNDY99 "Theorem Proving"))(POS (PAPER.INSTANCE BYLANDER94))(POS (PAPER.AUTHOR BYLANDER94 "Tom Bylander"))(POS (PAPER.TITLE BYLANDER94 "The Computational Complexity of Propositional STRIPS Planning"))(POS (PAPER.PUBLICATION BYLANDER94 "Artificial Intelligence"))(POS (PAPER.VOLUME BYLANDER94 "69(1-2)"))(POS (PAPER.STARTPAGE BYLANDER94 165))(POS (PAPER.ENDPAGE BYLANDER94 204))(POS (PAPER.LINK BYLANDER94 "http://citeseer.ist.psu.edu/bylander94computational.html"))(POS (PAPER.YEAR BYLANDER94 1994))(POS (PAPER.DESCRIPTION BYLANDER94 "
Bylander discusses complexity results for propositional STRIPS; he also mentions that a class of first-order STRIPS can be reduced in polynomial time to propositional STRIPS, making these results widely applicable.  PLANSAT (decision problem for determining whether an instance of prop STRIPS planning is satisfiable) is PSPACE-complete.  PLANSAT[2+,2] (PLANSAT where all operators have at least 2 positive preconditions and 2 postconditions) is also PSPACE-complete.  Results are shown for a variety of restrictions, concluding that without severe restrictions, PLANSAT is NP-complete or PSPACE-complete.
These results carry over to PLANMIN (the decision problem of determining whether an instance has a solution of k or fewer operators.  The new results here show a variety of PLANMIN are NP-complete, and a couple, very restricted versions are polynomial.  He also shows results for Propositional Strips with formulas (Extended Propositional STRIPS).  EPLANSAT, EPLANSAT[0,1+] restricted to define Horn clauses are PSPACE-complete.  More results are shown for EPLANSAT and EPLANSATMIN.  See paper for details.
"))(POS (PAPER.TOPIC BYLANDER94 "Historical"))(POS (PAPER.INSTANCE BYRNE2000))(POS (PAPER.BIBTEX BYRNE2000 MISC))(POS (PAPER.AUTHOR BYRNE2000 "Ruth Byrne and Lisa Gilroy"))(POS (PAPER.TITLE BYRNE2000 "Mental Models Website"))(POS (PAPER.LINK BYRNE2000 "http://www.tcd.ie/Psychology/Ruth_Byrne/mental_models/index.html"))(POS (PAPER.YEAR BYRNE2000 2000))(POS (PAPER.DESCRIPTION BYRNE2000 "
Mental Models website--the Psychology version of model-based reasoning.
"))(POS (PAPER.TOPIC BYRNE2000 "Model-Based Reasoning"))(POS (PAPER.INSTANCE CADOLI2000))(POS (PAPER.BIBTEX CADOLI2000 MISC))(POS (PAPER.AUTHOR CADOLI2000 "Marco Cadoli and Francesco M. Donini and Paolo Liberatore and Marco Schaerf"))(POS (PAPER.TITLE CADOLI2000 "Preprocessing of Intractable Problems"))(POS (PAPER.PUBLICATION CADOLI2000 "Information and Computation"))(POS (PAPER.VOLUME CADOLI2000 "176(2)"))(POS (PAPER.STARTPAGE CADOLI2000 89))(POS (PAPER.ENDPAGE CADOLI2000 120))(POS (PAPER.LINK CADOLI2000 "http://citeseer.ist.psu.edu/cadoli00preprocessing.html"))(POS (PAPER.YEAR CADOLI2000 2000))(POS (PAPER.RANK CADOLI2000 "[**]"))(POS (PAPER.DESCRIPTION CADOLI2000 "
This paper describes complexity classes for algorithms after they
have been preprocessed, or compiled.  The problems targeted have two
parts, one that is fixed, and one that changes frequently.  For
example, determining whether Delta entails a sentence phi has a
fixed part (Delta) and a changing part (phi).  If we could compile
Delta into a more vivid representation, computing entailment might
be easier.  This paper formalizes that idea, gives a complexity class
hierarchy, and a method for reductions.  Cool ideas, but very
theoretical (and only with propositional KB examples).
"))(POS (PAPER.TOPIC CADOLI2000 "Knowledge Base Compilation"))(POS (PAPER.INSTANCE CADOLI2000B))(POS (PAPER.BIBTEX CADOLI2000B MISC))(POS (PAPER.AUTHOR CADOLI2000B "Marco Cadoli and Francesco Donini and Paolo Liberatore and Marco Schaerf"))(POS (PAPER.TITLE CADOLI2000B "Space Efficiency of Propositional Knowledge Representation Formalisms"))(POS (PAPER.PUBLICATION CADOLI2000B "Journal of Artificial Intelligence Research"))(POS (PAPER.VOLUME CADOLI2000B "13"))(POS (PAPER.STARTPAGE CADOLI2000B 1))(POS (PAPER.ENDPAGE CADOLI2000B 31))(POS (PAPER.LINK CADOLI2000B "http://citeseer.ist.psu.edu/cadoli00space.html"))(POS (PAPER.YEAR CADOLI2000B 2000))(POS (PAPER.RANK CADOLI2000B "[*****]"))(POS (PAPER.DESCRIPTION CADOLI2000B "
The authors leverage previous work on compilation complexity classes to compare
various propositional knowledge formalisms.  They introduce two axes for comparing
such formalisms under translation: theorem-preservation and model-preservation.
That is, given a set of sentences in one formalism, translate those sentences
into another formalism so that (1) the theorems are preserved across the translation
after a translation of their own or (2) the models are preserved across the
translation after a translation of their own.  The translation of premise sets
is assumed to be polynomial in size; the requirement on the translation of
theorems/models is that the representation of the translation process itself
must be polynomial in size.  

The authors then introduce the notion of 
model-C and thm-C classes.  A formalism belongs to the model-C class iff 
model checking in that formalism is in the compilability class C, where the KB is 
the fixed part and the model is the varying part.  A formalism belongs to
the thm-C class iff inference in that formalism is in the compilability class C,
where the KB is the fixed part and the query is the varying part.

Next the authors prove that two formalisms in the same model-C/thm-C class then
there must be a poly-size reduction between the two formalisms that 
preserves models/theorems.  They also show that if two problems are in different
classes there is no polynomial size reduction satisfying models/theorems.

Finally, the propositional formalisms stable model semantics, circumscription, 
generalized closed world, skeptical default logic, credulous default logic, 
WIDTIO belief revision, and skeptical belief revision are analyzed in this 
framework, giving fairly complete coverage of inference/model space complexity.
"))(POS (PAPER.TOPIC CADOLI2000B "Knowledge Base Compilation"))(POS (PAPER.INSTANCE CADOLI2001))(POS (PAPER.AUTHOR CADOLI2001 "Marco Cadoli and Andrea Schaerf"))(POS (PAPER.TITLE CADOLI2001 "Compiling Problem Specifications into SAT"))(POS (PAPER.PUBLICATION CADOLI2001 "Lecture Notes in Computer Science"))(POS (PAPER.VOLUME CADOLI2001 "2028"))(POS (PAPER.LINK CADOLI2001 "http://citeseer.ist.psu.edu/cadoli01compiling.html"))(POS (PAPER.RANK CADOLI2001 "[***]"))(POS (PAPER.DESCRIPTION CADOLI2001 "
Cadoli and Schaerf describe a language, NP-Spec, for specifying problems
in NP, and a technique for translating that language into SAT.  They
mention a previous translation into Prolog.  With SAT, results were
far better than with Prolog; that is, they could solve what they called
medium-sized problems instead of just small problems.  NP-Spec is based
on Prolog without negation (except on some predefined predicates) with
a fixed database. It includes a mix of metalevel constraints and object-level
constraints.
"))(POS (PAPER.TOPIC CADOLI2001 "Knowledge Base Compilation"))(POS (PAPER.INSTANCE CADOLI2002))(POS (PAPER.AUTHOR CADOLI2002 "Marco Cadoli and Toni Mancini"))(POS (PAPER.TITLE CADOLI2002 "Knowledge compilation = Query rewriting + View synthesis"))(POS (PAPER.PUBLICATION CADOLI2002 "Symposium on Principles of Database Systems"))(POS (PAPER.STARTPAGE CADOLI2002 199))(POS (PAPER.ENDPAGE CADOLI2002 208))(POS (PAPER.LINK CADOLI2002 "http://citeseer.ist.psu.edu/641562.html"))(POS (PAPER.RANK CADOLI2002 "[***]"))(POS (PAPER.DESCRIPTION CADOLI2002 "
Cadoli describes a class of propositional knowledge compilation  where
the problem is transformed into a database and a second-order
query over that database.  The database is a straight-forward representation
of the clausal form of the input.  The authors give syntactic conditions
under which the problem can be compiled into P using this technique.
"))(POS (PAPER.TOPIC CADOLI2002 "Knowledge Base Compilation"))(POS (PAPER.INSTANCE CADOLI97))(POS (PAPER.BIBTEX CADOLI97 ARTICLE))(POS (PAPER.AUTHOR CADOLI97 "Marco Cadoli and Francesco M. Donini"))(POS (PAPER.TITLE CADOLI97 "A Survey on Knowledge Compilation"))(POS (PAPER.PUBLICATION CADOLI97 "AI Communications"))(POS (PAPER.VOLUME CADOLI97 "10(3-4)"))(POS (PAPER.STARTPAGE CADOLI97 137))(POS (PAPER.ENDPAGE CADOLI97 150))(POS (PAPER.LINK CADOLI97 "http://citeseer.ist.psu.edu/cadoli98survey.html"))(POS (PAPER.YEAR CADOLI97 1997))(POS (PAPER.RANK CADOLI97 "[***]"))(POS (PAPER.DESCRIPTION CADOLI97 "
Cadoli and Donini review techniques for propositional knowledge base compilation.  
The goal
is to rewrite a KB in a form that will answer queries more quickly.  They survey
exact compilation: prime implicates and implicants, unit-resolution-complete 
methods, and theory prime implicates.  They look at approximate compilation:
anytime versions of exact methods, horn approximations (can result in unsound
inference).  They consider compiling non-monotonic knowledge bases with
circumscription, default logic, and belief revision.  All those techniques aim
to reduce intractable query answering to tractable query answering.  Lastly,
Cadoli and Donini mention compilations of _polynomial-time_ query answering,
compilations into something other than a KB, and compare compilation to 
fixed-parameter tractability.
"))(POS (PAPER.TOPIC CADOLI97 "Knowledge Base Compilation"))(POS (PAPER.INSTANCE CASEAU94))(POS (PAPER.AUTHOR CASEAU94 "Yves Caseau"))(POS (PAPER.TITLE CASEAU94 "Constraint Satisfaction with an Object-Oriented Knowledge
Representation Language"))(POS (PAPER.PUBLICATION CASEAU94 "Applied Intelligence "))(POS (PAPER.VOLUME CASEAU94 "4(2)"))(POS (PAPER.STARTPAGE CASEAU94 157))(POS (PAPER.ENDPAGE CASEAU94 184))(POS (PAPER.LINK CASEAU94 "http://citeseer.ist.psu.edu/caseau94constraint.html"))(POS (PAPER.YEAR CASEAU94 1994))(POS (PAPER.RANK CASEAU94 "[***]"))(POS (PAPER.DESCRIPTION CASEAU94 "
Caseau describes how one might solve constraint satisfaction problems
using Laure, an object-oriented language that combines declarative
and procedural knowledge.  In Laure, a Database is used to model
the world; solving a problem amounts to finding objects to fill
goals and satisfy constraints.  Those objects are completions of
the database.  CSPs can be represented by attaching constraints
to objects; a finite number of these objects allows standard 
CSP techniques, e.g. arc consistency, to find solutions.
"))(POS (PAPER.TOPIC CASEAU94 "OO Languages with Native Constraint Satisfaction"))(POS (PAPER.INSTANCE CASEAU96))(POS (PAPER.BIBTEX CASEAU96 ARTICLE))(POS (PAPER.AUTHOR CASEAU96 "Yves Caseau, Francois Laburthe"))(POS (PAPER.TITLE CASEAU96 "CLAIRE: a brief overview"))(POS (PAPER.PUBLICATION CASEAU96 ""))(POS (PAPER.LINK CASEAU96 "http://citeseer.ist.psu.edu/caseau96claire.html"))(POS (PAPER.YEAR CASEAU96 1996))(POS (PAPER.RANK CASEAU96 "[**]"))(POS (PAPER.DESCRIPTION CASEAU96 "
CLAIRE is a programming language designed to be C++ compliant that  
can compute using constraints natively.
"))(POS (PAPER.TOPIC CASEAU96 "OO Languages with Native Constraint Satisfaction"))(POS (PAPER.INSTANCE CHANGLEE))(POS (PAPER.BIBTEX CHANGLEE BOOK))(POS (PAPER.AUTHOR CHANGLEE "Chin-Liang Chang and Richard Lee"))(POS (PAPER.TITLE CHANGLEE "Symbolic Logic and Mechanical Theorem Proving"))(POS (PAPER.PUBLISHER CHANGLEE "Academic Press"))(POS (PAPER.LINK CHANGLEE "http://www.amazon.com/exec/obidos/ASIN/0121703509/qid%3D965533387/sr%3D1-1/102-6107129-2481765"))(POS (PAPER.YEAR CHANGLEE 1973))(POS (PAPER.RANK CHANGLEE ""))(POS (PAPER.DESCRIPTION CHANGLEE "
A classic text for automated reasoning.  Chang and Lee cover propositional and
first-order logic, Herbrand's theorem, resolution (standard, semantic, lock,
and linear) and equality.  They discuss an alternative to resolution, 
Prawitz's procedure and V-resolution.  A chapter on program analysis
leads to query answering and program synthesis in the final chapter.
"))(POS (PAPER.TOPIC CHANGLEE ""))(POS (PAPER.INSTANCE CHEN2000))(POS (PAPER.AUTHOR CHEN2000 "Hubie Chen"))(POS (PAPER.TITLE CHEN2000 "A Theory of Average-Case Compilability in Knowledge Representation"))(POS (PAPER.LINK CHEN2000 "http://citeseer.ist.psu.edu/590465.html"))(POS (PAPER.RANK CHEN2000 "[***]"))(POS (PAPER.DESCRIPTION CHEN2000 "Chen gives an overview of the Compilability hierarchy given
by Cadoli2000.  Then Chen gives theorems concerning average-case
compilability, i.e. analogs of the Cadoli hierarchy when there is a 
distribution over the space of knowledge representations within a class.
The results are pretty densely presented.  
"))(POS (PAPER.TOPIC CHEN2000 "Knowledge Base Compilation"))(POS (PAPER.INSTANCE CHIRKOVA2002))(POS (PAPER.BIBTEX CHIRKOVA2002 PHDTHESIS))(POS (PAPER.AUTHOR CHIRKOVA2002 "Rada Chirkova"))(POS (PAPER.TITLE CHIRKOVA2002 "Automated Database Restructuring"))(POS (PAPER.PUBLISHER CHIRKOVA2002 "Stanford University"))(POS (PAPER.LINK CHIRKOVA2002 ""))(POS (PAPER.YEAR CHIRKOVA2002 2002))(POS (PAPER.RANK CHIRKOVA2002 "[****]"))(POS (PAPER.DESCRIPTION CHIRKOVA2002 "
Chirkova's thesis presents algorithms for computing the set of views
that if materialized would allow queries to be answered optimally.  That is
there is no set of views that if materialized would answer those queries
any more efficiently.  Three results: the problem is decidable, it
has a triply exponential upper bound in the queries, and it has an
exponential lower bound.  Only conjunctions, i.e. SPJ,
are considered, both for view definitions and the queries.
"))(POS (PAPER.TOPIC CHIRKOVA2002 "Databases"))(POS (PAPER.INSTANCE CHOI2000))(POS (PAPER.BIBTEX CHOI2000 MISC))(POS (PAPER.AUTHOR CHOI2000 "Seungyeob Choi"))(POS (PAPER.TITLE CHOI2000 "Semantically Guided Proof Planning"))(POS (PAPER.LINK CHOI2000 "http://citeseer.ist.psu.edu/464153.html"))(POS (PAPER.YEAR CHOI2000 2000))(POS (PAPER.RANK CHOI2000 "[***]"))(POS (PAPER.DESCRIPTION CHOI2000 "
This thesis proposal focuses on adding semantic guidance to
automated theorem proving in two ways: 1) by incorporating
the use of models with a clause graph procedure and 2) by
incorporating the use of models with a proof planning
procedure.  This gives a good overview of various theorem
proving techniques and semantic techniques.
"))(POS (PAPER.TOPIC CHOI2000 "Model-Guided Proof Techniques"))(POS (PAPER.INSTANCE CHOMICKI95))(POS (PAPER.AUTHOR CHOMICKI95 "Jan Chomicki"))(POS (PAPER.TITLE CHOMICKI95 "Efficient Checking of Temporal Integrity Constraints Using Bounded History Encoding"))(POS (PAPER.PUBLICATION CHOMICKI95 "ACM Transactions on Database Systems"))(POS (PAPER.VOLUME CHOMICKI95 "20(2)"))(POS (PAPER.STARTPAGE CHOMICKI95 149))(POS (PAPER.ENDPAGE CHOMICKI95 186))(POS (PAPER.LINK CHOMICKI95 "http://citeseer.ist.psu.edu/chomicki95efficient.html"))(POS (PAPER.YEAR CHOMICKI95 1995))(POS (PAPER.RANK CHOMICKI95 "[**]"))(POS (PAPER.DESCRIPTION CHOMICKI95 "
Chomicki describes an algorithm for maintaining temporal constraints on a database, which are written in past first order temporal logic.  Instead of storing the entire history of the database, Chomicki describes a way to roll up the history (in a lossy way) into auxiliary relations in the database.  She assumes the set of constraints is fixed, which means a single auxiliary relation can be stored for each sentence in the constraints.  She proves this encoding to be polynomially-bounded in the number of domain values that appear in the database over time.  Chomicki extends this work to include real-time constraints, which refer to a clock.
"))(POS (PAPER.TOPIC CHOMICKI95 "Hypothetical Temporal DB Queries"))(POS (PAPER.INSTANCE CHRISTIAN93))(POS (PAPER.BIBTEX CHRISTIAN93 ARTICLE))(POS (PAPER.AUTHOR CHRISTIAN93 "Jim Christian"))(POS (PAPER.TITLE CHRISTIAN93 "Flatterms, Discrimination Nets, and Fast Term Rewriting"))(POS (PAPER.PUBLICATION CHRISTIAN93 "Journal of Automated Reasoning
"))(POS (PAPER.VOLUME CHRISTIAN93 "10"))(POS (PAPER.STARTPAGE CHRISTIAN93 95))(POS (PAPER.ENDPAGE CHRISTIAN93 113))(POS (PAPER.LINK CHRISTIAN93 ""))(POS (PAPER.YEAR CHRISTIAN93 1993))(POS (PAPER.RANK CHRISTIAN93 ""))(POS (PAPER.DESCRIPTION CHRISTIAN93 "
One of the early papers on Discrimination Nets, which is argued as
a reason for representing terms as flat terms.
"))(POS (PAPER.TOPIC CHRISTIAN93 "Indexing"))(POS (PAPER.INSTANCE CLAESSEN2003))(POS (PAPER.BIBTEX CLAESSEN2003 INPROCEEDINGS))(POS (PAPER.AUTHOR CLAESSEN2003 "K. Claessen and N. Sorensson"))(POS (PAPER.TITLE CLAESSEN2003 "New Techniues that Improve MACE-style Finite Model Finding"))(POS (PAPER.PUBLICATION CLAESSEN2003 "CADE-19 Workshop on Model Computation"))(POS (PAPER.LINK CLAESSEN2003 "http://citeseer.ist.psu.edu/claessen03new.html"))(POS (PAPER.YEAR CLAESSEN2003 2003))(POS (PAPER.DESCRIPTION CLAESSEN2003 "
A serieis of techniques are introduced for constructing a finite model
by conversion to SAT, aka the MACE-style model building.  A/the paradox paper.
"))(POS (PAPER.TOPIC CLAESSEN2003 "Model Building"))(POS (PAPER.INSTANCE CLARKE))(POS (PAPER.BIBTEX CLARKE BOOK))(POS (PAPER.AUTHOR CLARKE "Edmund M. Clarke Jr. and Orna Grumberg and Doron Peled"))(POS (PAPER.TITLE CLARKE "Model Checking"))(POS (PAPER.PUBLISHER CLARKE "The MIT Press"))(POS (PAPER.LINK CLARKE "http://mitpress.mit.edu/catalog/item/default.asp?ttype=2&tid=3730"))(POS (PAPER.YEAR CLARKE 1999))(POS (PAPER.RANK CLARKE "[*****]"))(POS (PAPER.DESCRIPTION CLARKE "
An introduction to model checking as performed by the formal methods community.
"))(POS (PAPER.TOPIC CLARKE ""))(POS (PAPER.INSTANCE COHEN90))(POS (PAPER.AUTHOR COHEN90 "P.R. Cohen and H.J. Levesque"))(POS (PAPER.TITLE COHEN90 "Intention is choice with commitment"))(POS (PAPER.PUBLICATION COHEN90 "Artificial Intelligence"))(POS (PAPER.VOLUME COHEN90 "42(3)"))(POS (PAPER.YEAR COHEN90 1990))(POS (PAPER.RANK COHEN90 "[*]"))(POS (PAPER.DESCRIPTION COHEN90 "
Cohen and Levesque use modal operators without explicit mention of time to describe an agent's persistent goals.  These goals will be worked upon until 1) they are achieved or 2) they are deemed impossible.  No work was done here on planning to achieve these goals. 
"))(POS (PAPER.TOPIC COHEN90 "Behavioral Goals"))(POS (PAPER.INSTANCE COMON99))(POS (PAPER.BIBTEX COMON99 ARTICLE))(POS (PAPER.AUTHOR COMON99 "Hubert Comon and Mehmet Dincbas and Jean-pierre Jouannaud and Claude Kirchner"))(POS (PAPER.TITLE COMON99 "A Methodological View of Constraint Solving"))(POS (PAPER.PUBLICATION COMON99 "Constraints"))(POS (PAPER.VOLUME COMON99 "4"))(POS (PAPER.STARTPAGE COMON99 337))(POS (PAPER.ENDPAGE COMON99 361))(POS (PAPER.LINK COMON99 "http://citeseer.ist.psu.edu/13836.html"))(POS (PAPER.YEAR COMON99 1999))(POS (PAPER.DESCRIPTION COMON99 "
The authors motivate why sets are described using constraints and go on to survey the various techniques that have been used for processing those constraints, i.e. (1) determining whether an element belongs to a set or (2) determining whether one set is included entirely in another set (entailment).  They discuss 3 types of techniques: syntactic, semantic, and hybrid.  Syntactic techniques translate a formula into another formula.  Semantic techniques translate formulas into automata or another such formalism.  Hybrid techniques use both.  For more info on automata, try http://www.grappa.univ-lille3.fr/tata/.
"))(POS (PAPER.TOPIC COMON99 "General"))(POS (PAPER.INSTANCE COOK71))(POS (PAPER.BIBTEX COOK71 ARTICLE))(POS (PAPER.AUTHOR COOK71 "Stephen Cook"))(POS (PAPER.TITLE COOK71 "The Complexity of Theorem-Proving Procedures"))(POS (PAPER.PUBLICATION COOK71 "Symposium on the Theory of Computing (STOC)"))(POS (PAPER.STARTPAGE COOK71 151))(POS (PAPER.ENDPAGE COOK71 158))(POS (PAPER.LINK COOK71 "http://citeseer.ist.psu.edu/context/5446/0"))(POS (PAPER.YEAR COOK71 1971))(POS (PAPER.RANK COOK71 "[*]"))(POS (PAPER.DESCRIPTION COOK71 "
This is Cook's paper which introduces the theory of NP completeness
and polynomial reductions.  He gives complexity bounds on theorem-
proving procedures relative to the minimum number of copies of 
axioms required for propositional unsatisfiability.
"))(POS (PAPER.TOPIC COOK71 "Comparative Analysis"))(POS (PAPER.INSTANCE CRAIG2004))(POS (PAPER.BIBTEX CRAIG2004 ARTICLE))(POS (PAPER.AUTHOR CRAIG2004 "S. Craig and J. Gallagher and M. Leuschel and K. Henriksen"))(POS (PAPER.TITLE CRAIG2004 "Fully Automatic Binding-Time Analysis for Prolog"))(POS (PAPER.PUBLICATION CRAIG2004 "14th International Symposium, Logic Based Program Synthesis and Trnasformation (LOPSTR)"))(POS (PAPER.STARTPAGE CRAIG2004 53))(POS (PAPER.ENDPAGE CRAIG2004 68))(POS (PAPER.LINK CRAIG2004 "http://wotan.liu.edu/docis/dbl/lopstr/index.html"))(POS (PAPER.YEAR CRAIG2004 2004))(POS (PAPER.DESCRIPTION CRAIG2004 "
The authors consider the problem of computing modes, i.e. binding
patterns, for prolog relations, and whether to unroll or inline
such relations.  The first computes a set of disjoint types 
from regular types and then propagates them.  The second 
uses binary clause semantics and convex hull abstraction
to determine which relations will not terminate.  Apparently,
very similar work was done in 2001 by Vanhoof and Bruynooghe
in 2001.
"))(POS (PAPER.TOPIC CRAIG2004 "Reformulation"))(POS (PAPER.INSTANCE CYRLUK96SHOSTAKS))(POS (PAPER.BIBTEX CYRLUK96SHOSTAKS INPROCEEDINGS))(POS (PAPER.AUTHOR CYRLUK96SHOSTAKS "David Cyrluk, Patrick Lincoln, and Natarajan Shankar"))(POS (PAPER.TITLE CYRLUK96SHOSTAKS "On Shostak's Decision Procedure for Combinations of Theories"))(POS (PAPER.PUBLICATION CYRLUK96SHOSTAKS "13th International Conference on Automated Deduction
           "))(POS (PAPER.LINK CYRLUK96SHOSTAKS "http://citeseer.ist.psu.edu/cyrluk96shostaks.html"))(POS (PAPER.YEAR CYRLUK96SHOSTAKS 1996))(POS (PAPER.RANK CYRLUK96SHOSTAKS "[****]"))(POS (PAPER.DESCRIPTION CYRLUK96SHOSTAKS "
Cyrluk, Lincoln, and Shankar give a crisp description of the Shostak
procedure and sketch proofs of its properties.  It breaks the algorithm
down into 1) a congruence closure computation and 2) the interpretation
of functions through canonization.  This version of Shostak and all its
counterparts were later shown incomplete.
"))(POS (PAPER.TOPIC CYRLUK96SHOSTAKS "Nelson-Oppen and Shostak"))(POS (PAPER.RELATED CYRLUK96SHOSTAKS SHOSTAK84))(POS (PAPER.RELATED CYRLUK96SHOSTAKS RUEB2000DECONSTRUCTING))(POS (PAPER.INSTANCE DANTSIN2001))(POS (PAPER.AUTHOR DANTSIN2001 "Evgeny Dantsin and Thomas Eiter and Georg Gottlob and Andrei Voronkov"))(POS (PAPER.TITLE DANTSIN2001 "Complexity and Expressive Power of Logic Programming"))(POS (PAPER.PUBLICATION DANTSIN2001 "ACM Computing Surveys"))(POS (PAPER.VOLUME DANTSIN2001 "33(3)"))(POS (PAPER.STARTPAGE DANTSIN2001 374))(POS (PAPER.ENDPAGE DANTSIN2001 425))(POS (PAPER.LINK DANTSIN2001 "http://portal.acm.org/citation.cfm?id=502810&dl=ACM&coll=GUIDE"))(POS (PAPER.YEAR DANTSIN2001 2001))(POS (PAPER.DESCRIPTION DANTSIN2001 "
Complexity results for logic programming.
"))(POS (PAPER.TOPIC DANTSIN2001 "Logic Programming"))(POS (PAPER.INSTANCE DARWICHE2002))(POS (PAPER.BIBTEX DARWICHE2002 ARTICLE))(POS (PAPER.AUTHOR DARWICHE2002 "Adnan Darwiche and Pierre Marquis"))(POS (PAPER.TITLE DARWICHE2002 "A Knowledge Compilation Map"))(POS (PAPER.PUBLICATION DARWICHE2002 "Journal of Artificial Intelligence Research"))(POS (PAPER.VOLUME DARWICHE2002 "17"))(POS (PAPER.STARTPAGE DARWICHE2002 229))(POS (PAPER.ENDPAGE DARWICHE2002 264))(POS (PAPER.LINK DARWICHE2002 "http://citeseer.ist.psu.edu/497263.html"))(POS (PAPER.YEAR DARWICHE2002 2002))(POS (PAPER.DESCRIPTION DARWICHE2002 "
The authors analyze knowledge compilation on two axes: the succinctness of
the target language and the class of queries and transformations that the
language supports in polytime.  They analyze a large number of existing
approaches.
"))(POS (PAPER.TOPIC DARWICHE2002 "Knowledge Base Compilation"))(POS (PAPER.INSTANCE DAVIS60))(POS (PAPER.BIBTEX DAVIS60 ARTICLE))(POS (PAPER.AUTHOR DAVIS60 "M. Davis and H. Putnam"))(POS (PAPER.TITLE DAVIS60 "A Machine Program for Theorem Proving"))(POS (PAPER.PUBLICATION DAVIS60 "Journal of the ACM"))(POS (PAPER.VOLUME DAVIS60 "7"))(POS (PAPER.STARTPAGE DAVIS60 201))(POS (PAPER.ENDPAGE DAVIS60 215))(POS (PAPER.YEAR DAVIS60 1960))(POS (PAPER.DESCRIPTION DAVIS60 "
One of the DPLL papers.
"))(POS (PAPER.TOPIC DAVIS60 "Calculi"))(POS (PAPER.INSTANCE DAVIS62))(POS (PAPER.BIBTEX DAVIS62 ARTICLE))(POS (PAPER.AUTHOR DAVIS62 "M. Davis and G. Logemann an D. Loveland"))(POS (PAPER.TITLE DAVIS62 "A Computing Procedure for Quantification Theory"))(POS (PAPER.PUBLICATION DAVIS62 "Communications of the ACM"))(POS (PAPER.VOLUME DAVIS62 "5"))(POS (PAPER.STARTPAGE DAVIS62 394))(POS (PAPER.ENDPAGE DAVIS62 397))(POS (PAPER.YEAR DAVIS62 1962))(POS (PAPER.DESCRIPTION DAVIS62 "
One of the DPLL papers.
"))(POS (PAPER.TOPIC DAVIS62 "Calculi"))(POS (PAPER.INSTANCE DAVIS94))(POS (PAPER.BIBTEX DAVIS94 TECHREPORT))(POS (PAPER.AUTHOR DAVIS94 "Ernest Davis"))(POS (PAPER.TITLE DAVIS94 "Lucid Representations"))(POS (PAPER.PUBLISHER DAVIS94 "New York University"))(POS (PAPER.LINK DAVIS94 "http://citeseer.ist.psu.edu/davis94lucid.html"))(POS (PAPER.YEAR DAVIS94 1994))(POS (PAPER.RANK DAVIS94 "[****]"))(POS (PAPER.DESCRIPTION DAVIS94 "
Davis writes Lucid Representations in part to argue Levesque's
Making Believers Out of Computers paper.  Davis claims Levesque argues
that the only representations one should allow are complete ones,
in the database sense to ensure reasoning is fast.  Davis argues
that no AI system could get by with only complete information.
Incomplete information is imperative.  Davis attempts to propose
a technique for achieving the benefits of complete information
from starting from incomplete information by first instantiating
to complete the theory, then reasoning quickly, and finally 
ignoring those results which were artificially  introduced by
the process of instantiation.  This is a position piece trying to
refute Levesque's vision of the future and replacing
it with a vision of its own.
"))(POS (PAPER.TOPIC DAVIS94 "Logical Knowledge Representation"))(POS (PAPER.INSTANCE DEBRAY93))(POS (PAPER.BIBTEX DEBRAY93 ARTICLE))(POS (PAPER.AUTHOR DEBRAY93 "Saumya Debray and Nai-Wei Lin"))(POS (PAPER.TITLE DEBRAY93 "Cost Analysis of Logic Programs"))(POS (PAPER.PUBLICATION DEBRAY93 "ACM Transactions on Programming Languages and Systems>"))(POS (PAPER.VOLUME DEBRAY93 "15(5)"))(POS (PAPER.STARTPAGE DEBRAY93 826))(POS (PAPER.ENDPAGE DEBRAY93 875))(POS (PAPER.YEAR DEBRAY93 1993))(POS (PAPER.DESCRIPTION DEBRAY93 "
Debray and Lin outline techniques for computing upper bounds on the cost
of a logic program, taking in account multiple solutions and nondeterminism.
Based on relationship between argument size, moded relations, and typed 
relations.
"))(POS (PAPER.TOPIC DEBRAY93 "Logic Programming"))(POS (PAPER.INSTANCE DECHTER92))(POS (PAPER.BIBTEX DECHTER92 ARTICLE))(POS (PAPER.AUTHOR DECHTER92 "Rina Dechter and Judea Pearl"))(POS (PAPER.TITLE DECHTER92 "Structure Identificatioin in Relational Data"))(POS (PAPER.PUBLICATION DECHTER92 "Artificial Intelligence"))(POS (PAPER.VOLUME DECHTER92 "58(1-3)"))(POS (PAPER.STARTPAGE DECHTER92 237))(POS (PAPER.ENDPAGE DECHTER92 270))(POS (PAPER.LINK DECHTER92 "http://citeseer.ist.psu.edu/dechter97structure.html"))(POS (PAPER.YEAR DECHTER92 1992))(POS (PAPER.RANK DECHTER92 "[**]"))(POS (PAPER.DESCRIPTION DECHTER92 "
Dechter and Pearl describe building a propositional Horn representation
of a given set of models.  Identifying whether such a representation 
exists turns out to be polynomial in the size of the models.  Building
such a representation is polynomial in the size of the models and
the number of variables.  For k-Horn theories, a tightest approximation
can also be calculated in polynomial time.  
"))(POS (PAPER.TOPIC DECHTER92 "Knowledge Base Compilation"))(POS (PAPER.INSTANCE DELVAL96))(POS (PAPER.BIBTEX DELVAL96 INPROCEEDINGS))(POS (PAPER.AUTHOR DELVAL96 "Alvaro del Val"))(POS (PAPER.TITLE DELVAL96 "Approximate Knowledge Compilation: The First Order Case"))(POS (PAPER.PUBLICATION DELVAL96 "AAAI"))(POS (PAPER.STARTPAGE DELVAL96 498))(POS (PAPER.ENDPAGE DELVAL96 503))(POS (PAPER.LINK DELVAL96 "http://citeseer.ist.psu.edu/delval96approximate.html"))(POS (PAPER.YEAR DELVAL96 1996))(POS (PAPER.RANK DELVAL96 "[****]"))(POS (PAPER.DESCRIPTION DELVAL96 "
This seems to be the seminal work on Knowledge Compilation for FOL.  
del Val introduces a new algorithm for computing the Least Upper
Bound approximation for a propositional knowledge base, at times
exponentially better than the previously known algorithm.  He then
lifts both algorithms to first order logic under some restrictions.
"))(POS (PAPER.TOPIC DELVAL96 "Knowledge Base Compilation"))(POS (PAPER.RELATED DELVAL96 SELMAN91))(POS (PAPER.INSTANCE DERSHOWITZ82))(POS (PAPER.AUTHOR DERSHOWITZ82 "Nachum Dershowitz"))(POS (PAPER.TITLE DERSHOWITZ82 "Orderings for Term-rewriting Systems"))(POS (PAPER.PUBLICATION DERSHOWITZ82 "Theoretical Computer Science"))(POS (PAPER.VOLUME DERSHOWITZ82 "17"))(POS (PAPER.STARTPAGE DERSHOWITZ82 279))(POS (PAPER.ENDPAGE DERSHOWITZ82 301))(POS (PAPER.LINK DERSHOWITZ82 "http://citeseer.ist.psu.edu/context/20249/0"))(POS (PAPER.YEAR DERSHOWITZ82 1982))(POS (PAPER.DESCRIPTION DERSHOWITZ82 "
This paper confronts termination in term-rewriting systems.  
Dershowitz first defines the notion of a non-terminating rewrite system,
i.e. one with an infinite homeomorphic self-embedding derivation.  Then
he defines a simplification ordering as a partial ordering with
the replacement (monotonicity), subterm, and deletion properties.  If there
is a simplification ordering for a term rewriting system such that l > r for
every rewrite rule l -> r then the rewrite system terminates.  Dershowitz
goes on to define a quasi-simplification ordering, which is weaker than
a simplification ordering, making it easier to prove rewrite systems
terminate.  The reason this paper is located in this section is that
the notion of a recursive path ordering is then defined.  RPO and
variants thereof are used in modern theorem provers when ordering
is necessary.  The last section goes through a series of examples
that demonstrate how to prove rewrite systems terminate.
"))(POS (PAPER.TOPIC DERSHOWITZ82 "Orderings"))(POS (PAPER.INSTANCE DERSHOWITZ93))(POS (PAPER.BIBTEX DERSHOWITZ93 INBOOK))(POS (PAPER.AUTHOR DERSHOWITZ93 "Nachum Dershowitz"))(POS (PAPER.TITLE DERSHOWITZ93 "A Taste of Rewrite Systems"))(POS (PAPER.PUBLICATION DERSHOWITZ93 "Functional Programming, Concurrency, Simulation, and
Automated Reasoning"))(POS (PAPER.STARTPAGE DERSHOWITZ93 199))(POS (PAPER.ENDPAGE DERSHOWITZ93 228))(POS (PAPER.LINK DERSHOWITZ93 "http://citeseer.ist.psu.edu/dershowitz93taste.html"))(POS (PAPER.YEAR DERSHOWITZ93 1993))(POS (PAPER.RANK DERSHOWITZ93 ""))(POS (PAPER.DESCRIPTION DERSHOWITZ93 "
Dershowitz gives a whirlwind tour of rewrite systems, covering the
basic properties termination (existence of normal forms), 
confluence (the uniqueness of those forms), completion (how to construct 
confluent systems), checking entailment and solving equations via 
basically abduction.  He also discusses special techniques for dealing
with associative and commutative systems and conditional rewriting rules.
Applications include theorem proving and programming
"))(POS (PAPER.TOPIC DERSHOWITZ93 "Theorem Proving"))(POS (PAPER.INSTANCE DOYLE91))(POS (PAPER.BIBTEX DOYLE91 ARTICLE))(POS (PAPER.AUTHOR DOYLE91 "Jon Doyle and Ramesh Patil"))(POS (PAPER.TITLE DOYLE91 "Two Theses of Knowledge Representation: Language Restrictions, Taxonomic Classification, and the Utility of Representation Services"))(POS (PAPER.PUBLICATION DOYLE91 "Artificial Intelligence"))(POS (PAPER.VOLUME DOYLE91 "48(3)"))(POS (PAPER.STARTPAGE DOYLE91 261))(POS (PAPER.ENDPAGE DOYLE91 298))(POS (PAPER.LINK DOYLE91 "http://citeseer.ist.psu.edu/doyle91two.html"))(POS (PAPER.YEAR DOYLE91 1991))(POS (PAPER.RANK DOYLE91 "[****]"))(POS (PAPER.DESCRIPTION DOYLE91 "
Doyle and Patil argue against Levesque and Brachman's position that a
general purpose KB system must be able to answer all questions 
in a bounded amount of time.  In particular, they examine KL-ONE
and its variants, enumerating classes of problems that a restricted
language cannot express but that would be natural for use in a KB
system.  They argue that worst-case complexity is the right measure for
just a small fraction of all potential applications of a Knowledge-based
system.  
"))(POS (PAPER.TOPIC DOYLE91 "Logical Knowledge Representation"))(POS (PAPER.INSTANCE DYMETMAN91))(POS (PAPER.BIBTEX DYMETMAN91 ARTICLE))(POS (PAPER.AUTHOR DYMETMAN91 "M. Dymetman"))(POS (PAPER.TITLE DYMETMAN91 "Inherently Reversible Grammars, Logic Programming and Computability"))(POS (PAPER.LINK DYMETMAN91 "http://acl.ldc.upenn.edu/W/W91/W91-0104.pdf"))(POS (PAPER.YEAR DYMETMAN91 1991))(POS (PAPER.RANK DYMETMAN91 "[***]"))(POS (PAPER.DESCRIPTION DYMETMAN91 "
Dymetman offers a decoupling of the term reversible grammar into (1)
uniformity of implementation for parsers and generators and (2) 
reversibility as an inherent property of a grammar.  He formalizes
the second idea, which includes various notions about the completeness
and termination of answer extraction for logic programming.
"))(POS (PAPER.TOPIC DYMETMAN91 "Natural Language Processing"))(POS (PAPER.INSTANCE EBBINGHAUS))(POS (PAPER.BIBTEX EBBINGHAUS BOOK))(POS (PAPER.AUTHOR EBBINGHAUS "Heinz-Dieter Ebbinghaus and Jorg Flum"))(POS (PAPER.TITLE EBBINGHAUS "Finite Model Theory"))(POS (PAPER.PUBLISHER EBBINGHAUS "Springer-Verlag"))(POS (PAPER.LINK EBBINGHAUS "http://www.amazon.com/Finite-Theory-Springer-Monographs-Mathematics/dp/3540287876"))(POS (PAPER.YEAR EBBINGHAUS 1999))(POS (PAPER.RANK EBBINGHAUS "[*****]"))(POS (PAPER.DESCRIPTION EBBINGHAUS "
The authors introduce Finite Model Theory, a logic that is identical to first-order
logic but where a model is defined as having a finite universe.  Topics covered
include Ehrenfeucht-Fraisse Method, 01 laws, finite automata, descriptive
complexity theory, fixed-point operators, logic programs, logics for PTIME, 
and logical reductions.
"))(POS (PAPER.TOPIC EBBINGHAUS ""))(POS (PAPER.INSTANCE EITER2001))(POS (PAPER.BIBTEX EITER2001 INPROCEEDINGS))(POS (PAPER.AUTHOR EITER2001 "Thomas Eiter and Toshihide Ibaraki and Kazuhisa Makino"))(POS (PAPER.TITLE EITER2001 "Disjunctions of Horn Theories and their Cores"))(POS (PAPER.PUBLICATION EITER2001 "ISAAC"))(POS (PAPER.LINK EITER2001 "http://citeseer.ist.psu.edu/eiter01disjunctions.html"))(POS (PAPER.YEAR EITER2001 2001))(POS (PAPER.RANK EITER2001 "[*]"))(POS (PAPER.DESCRIPTION EITER2001 "
This paper studies the problem of determining whether a disjunction of 
Horn theories is Horn and if not computing a Horn core and envelope.
Eiter et. al. investigate both the characteristic model representation
of Horn theories and the CNF representation.  For both representations 
the problem is intractable.
"))(POS (PAPER.TOPIC EITER2001 "Characteristic Models"))(POS (PAPER.INSTANCE EITER2004))(POS (PAPER.BIBTEX EITER2004 INPROCEEDINGS))(POS (PAPER.AUTHOR EITER2004 "Thomas Eiter and Thomas Lukasiewicz and Roman Schindlauer and Hans Tompits"))(POS (PAPER.TITLE EITER2004 "Combining Answer Set Programming with Description Logics for the Semantic Web"))(POS (PAPER.PUBLICATION EITER2004 "Proceedings of Knowledge Representation and Reasoning"))(POS (PAPER.LINK EITER2004 "http://citeseer.ist.psu.edu/727609.html"))(POS (PAPER.YEAR EITER2004 2004))(POS (PAPER.DESCRIPTION EITER2004 "
A language that integrates SHIF(D) and SHOIN(D) with answer set programming
"))(POS (PAPER.TOPIC EITER2004 "Semantic Web"))(POS (PAPER.INSTANCE EITER98))(POS (PAPER.BIBTEX EITER98 INPROCEEDINGS))(POS (PAPER.AUTHOR EITER98 "Thomas Eiter and Thoshihide Ibaraki and Kazuhisa Makino"))(POS (PAPER.TITLE EITER98 "Computing Intersections of Horn Theories for Reasoning with Models"))(POS (PAPER.PUBLICATION EITER98 "AAAI"))(POS (PAPER.LINK EITER98 "http://citeseer.ist.psu.edu/537461.html"))(POS (PAPER.YEAR EITER98 1998))(POS (PAPER.RANK EITER98 "[****]"))(POS (PAPER.DESCRIPTION EITER98 "
The authors examine complexity issues that arise when intersecting several
propositional horn knowledge bases, which are represented with 
characteristic models.  Finding
the unique minimal model (which is a characteristic model) can be done
in linear time in the number of KBs.  Finding all-models can be solved
with polynomial delay (a polynomial amount of time between outputting
models).  In a sense, that means the procedure is polynomial, but the 
number of outputs could be exponential.  Finding all characteristic
models of the intersection has no polynomial time algorithm (even if
P = NP).  Answering deductive queries can still be accomplished in
polynomial time by looking at each KB independently.  Finally, abduction
is shown to be intractable, which differs from the result of a single
KB (where it is polynomial).
"))(POS (PAPER.TOPIC EITER98 "Characteristic Models"))(POS (PAPER.INSTANCE ENDERTON))(POS (PAPER.BIBTEX ENDERTON BOOK))(POS (PAPER.AUTHOR ENDERTON "Herbert Enderton"))(POS (PAPER.TITLE ENDERTON "A Mathematical Introduction to Logic"))(POS (PAPER.PUBLISHER ENDERTON "Academic Press"))(POS (PAPER.LINK ENDERTON "http://www.amazon.com/exec/obidos/tg/detail/-/0122384520/qid=1062605496/sr=1-6/ref=sr_1_6/102-6107129-2481765?v=glance&s=books"))(POS (PAPER.YEAR ENDERTON 2000))(POS (PAPER.RANK ENDERTON "[*****]"))(POS (PAPER.DESCRIPTION ENDERTON "
The definitive text on introductory mathematical logic.  Enderton covers both 
propositional (sentential),  and first-order logic including compactness, completeness,
and soundness proofs.  The third chapter covers undecidability, Godel's 
incompleteness proof, and Church's and Tarski's theorems.  The last chapter
covers second-order logic. 
"))(POS (PAPER.TOPIC ENDERTON ""))(POS (PAPER.INSTANCE ETHERINGTON89))(POS (PAPER.BIBTEX ETHERINGTON89 ARTICLE))(POS (PAPER.AUTHOR ETHERINGTON89 "David Etherington and Alex Borgida and Ronald Brachman and Henry Kautz"))(POS (PAPER.TITLE ETHERINGTON89 "Vivid Knowledge and Tractable Reasoning"))(POS (PAPER.PUBLICATION ETHERINGTON89 "IJCAI"))(POS (PAPER.STARTPAGE ETHERINGTON89 1146))(POS (PAPER.ENDPAGE ETHERINGTON89 1152))(POS (PAPER.LINK ETHERINGTON89 "http://citeseer.ist.psu.edu/etherington89vivid.html"))(POS (PAPER.YEAR ETHERINGTON89 1989))(POS (PAPER.RANK ETHERINGTON89 "[****]"))(POS (PAPER.DESCRIPTION ETHERINGTON89 "
Etherington, et.al. give a preliminary description of representing a KB with a set of atoms.  They try to motivate the work by appealing to the speed of humans' commonsense reasoning facilities as evidence that much such reasoning is done via lookup.   A set of atoms is not very expressive, so the first extension is to allow definite clauses: a(x)=>b(x).  To deal with this they use a closed world assumption.  Second extension tries to deal with disjunction: age(joe,53) | age(joe,55) is replaced by age(joe,x)^in50s(x).  Third extension uses skolems to remove disjunction: p(a) | p(b) becomes p(k). 
"))(POS (PAPER.TOPIC ETHERINGTON89 "Logical Knowledge Representation"))(POS (PAPER.INSTANCE FAGIN82))(POS (PAPER.BIBTEX FAGIN82 ARTICLE))(POS (PAPER.AUTHOR FAGIN82 "Ronald Fagin"))(POS (PAPER.TITLE FAGIN82 "Horn Clauses and Database Dependencies"))(POS (PAPER.PUBLICATION FAGIN82 "Journal of the ACM"))(POS (PAPER.VOLUME FAGIN82 "29(4)"))(POS (PAPER.STARTPAGE FAGIN82 952))(POS (PAPER.ENDPAGE FAGIN82 985))(POS (PAPER.LINK FAGIN82 "http://citeseer.ist.psu.edu/context/62052/0"))(POS (PAPER.YEAR FAGIN82 1982))(POS (PAPER.RANK FAGIN82 "[****]"))(POS (PAPER.DESCRIPTION FAGIN82 "
Fagin generalizes dependencies in the database literature and
shows the following are all equivalent for a given set of sentences
S.  1) There is an operator O that maps nonempty families of models
into models such that if sigma is a sentence in S and R_i is a
nonempty family of models, then sigma holds for O(R_i) iff sigma
holds for each R_i.  2) Whenever Sigma is a consistent subset of S
and Sigma* is the set of sentences in S that are logical consequences
of Sigma, there is an Armstrong model--it obeys Sigma* and no other
sentences in S.  3) Whenever Sigma is a subset of S and phi_i is a 
nonempty subset of S then Sigma |= V phi_i iff there is some i for
which Sigma |= phi_i.  For FOL in general, there is no Armstrong relation for 
first-order axiom sets.  Take the empty set of axioms, and assume
there is an Armstrong relation R.  R will either entail or not
entail any non-tautology sigma, which means R is not an Armstrong
relation for the axiom set.  A corollary to this theorem shows
that any axiom set Delta in a Horn-related subset of FOL can be
represented with a single, infinite model.
"))(POS (PAPER.TOPIC FAGIN82 "Characteristic Models"))(POS (PAPER.INSTANCE FIKES71))(POS (PAPER.AUTHOR FIKES71 "R.E. Fikes and N.J. Nilsson"))(POS (PAPER.TITLE FIKES71 "STRIPS: a new approach to the application of theorem proving to problem solving"))(POS (PAPER.PUBLICATION FIKES71 "Artificial Intelligence"))(POS (PAPER.VOLUME FIKES71 "2(3-4)"))(POS (PAPER.STARTPAGE FIKES71 189))(POS (PAPER.ENDPAGE FIKES71 208))(POS (PAPER.YEAR FIKES71 1971))(POS (PAPER.DESCRIPTION FIKES71 "
The STRIPS paper.  Fikes and Nilsson allow first-order formulas to describe the action preconditions and effects (add/delete lists) but maintain that each operator instanatiation must be ground.  They note that the case of non-ground instantiations needs more study.  Interestingly, they generate successor states in the search tree using a form of residue from a proof that a given world state achieves a given subgoal.  They implement a world state as being a set of changes from the initial state.
"))(POS (PAPER.TOPIC FIKES71 "Historical"))(POS (PAPER.INSTANCE FIKES72))(POS (PAPER.AUTHOR FIKES72 "Richard Fikes, Peter Hart and Nils Nilsson"))(POS (PAPER.TITLE FIKES72 "Learning and Executing Generalized Robot Plans"))(POS (PAPER.PUBLICATION FIKES72 "Artificial Intelligence"))(POS (PAPER.VOLUME FIKES72 "3(4)"))(POS (PAPER.STARTPAGE FIKES72 251))(POS (PAPER.ENDPAGE FIKES72 288))(POS (PAPER.YEAR FIKES72 1972))(POS (PAPER.DESCRIPTION FIKES72 "
Fikes, Hart, and Nillson take a STRIPS planner, 1) describe a concise
representation for plans (triangle tables), 2) develop a method for
generalizing plans to make new primitive actions (MACROPs), 3) describe
an execution engine (PLANEX) that uses these Macrops that does replanning and
handles coincidental goal achievement.  They go on to describe needed future
improvements: 1) creating a set of abstractions for the new primitives actions
to avoid dealing with large numbers of preconditions and 2) discarding
subsumed or otherwise unused primitive operators to avoid an ever-growing
operator set.
"))(POS (PAPER.TOPIC FIKES72 "Historical"))(POS (PAPER.INSTANCE FIKES93))(POS (PAPER.AUTHOR FIKES93 "R.E. Fikes and N.J. Nilsson"))(POS (PAPER.TITLE FIKES93 "STRIPS, a retrospective"))(POS (PAPER.PUBLICATION FIKES93 "Artificial Intelligence"))(POS (PAPER.VOLUME FIKES93 "59(1-2)"))(POS (PAPER.STARTPAGE FIKES93 227))(POS (PAPER.ENDPAGE FIKES93 232))(POS (PAPER.YEAR FIKES93 1993))(POS (PAPER.DESCRIPTION FIKES93 "
This short paper puts the STRIPS work in a historical context, examining both the plan generator and execution monitor.  Green's work on deductive plan synthesis was the first real planner, but most researchers didn't explore monitoring execution (they were assuming computational environments).  Fikes and Nilsson used 'kernels' to represent the sentences that must be true at each stage of the plan for the rest of the plan to succeed.  They also used the notion of a 'triangle table' to represent plans so that serendipitous acts and action-failure-but-that's-all-you-can-do-so-just-try-again events would not require replanning.
"))(POS (PAPER.TOPIC FIKES93 "Historical"))(POS (PAPER.INSTANCE FITTING2007))(POS (PAPER.BIBTEX FITTING2007 ARTICLE))(POS (PAPER.AUTHOR FITTING2007 "Melvin Fitting"))(POS (PAPER.TITLE FITTING2007 "Intensional Logic"))(POS (PAPER.PUBLICATION FITTING2007 "The Stanford Encyclopedia of Philosophy (Spring 2007 Edition), Edward N. Zalta (ed.)"))(POS (PAPER.LINK FITTING2007 "http://plato.stanford.edu/archives/spr2007/entries/logic-intensional/"))(POS (PAPER.YEAR FITTING2007 2007))(POS (PAPER.DESCRIPTION FITTING2007 "
The mathematical foundations of logical query languages.
"))(POS (PAPER.TOPIC FITTING2007 "Logical Knowledge Representation"))(POS (PAPER.INSTANCE FOLLETT80))(POS (PAPER.BIBTEX FOLLETT80 ARTICLE))(POS (PAPER.AUTHOR FOLLETT80 "Ria Follett"))(POS (PAPER.TITLE FOLLETT80 "Synthesising Recursive Functions with Side Effects"))(POS (PAPER.PUBLICATION FOLLETT80 "Artificial Intelligence"))(POS (PAPER.VOLUME FOLLETT80 "13:3"))(POS (PAPER.STARTPAGE FOLLETT80 175))(POS (PAPER.ENDPAGE FOLLETT80 200))(POS (PAPER.YEAR FOLLETT80 1980))(POS (PAPER.RANK FOLLETT80 "[*]"))(POS (PAPER.DESCRIPTION FOLLETT80 "
"))(POS (PAPER.TOPIC FOLLETT80 "Theorem Proving with Attachments"))(POS (PAPER.INSTANCE FRANCONI2004))(POS (PAPER.BIBTEX FRANCONI2004 INPROCEEDINGS))(POS (PAPER.AUTHOR FRANCONI2004 "Enrico Franconi and Sergio Tessaris"))(POS (PAPER.TITLE FRANCONI2004 "Rules and Queries with Ontologies: A Unified Logical Framework"))(POS (PAPER.PUBLICATION FRANCONI2004 "Proceedings of Principles and Practice of Semantic Web Reasoning"))(POS (PAPER.LINK FRANCONI2004 "http://www.springerlink.com/content/1hnwcggw510elp4y/"))(POS (PAPER.YEAR FRANCONI2004 2004))(POS (PAPER.DESCRIPTION FRANCONI2004 "
A comparison of various techniques for integrating logic programming with 
description logics.
"))(POS (PAPER.TOPIC FRANCONI2004 "Semantic Web"))(POS (PAPER.INSTANCE GAMMER2007))(POS (PAPER.BIBTEX GAMMER2007 INPROCEEDINGS))(POS (PAPER.AUTHOR GAMMER2007 "Igor Gammer and Eyal Amir"))(POS (PAPER.TITLE GAMMER2007 "Solving Satisfiability in Ground Logic with Equality by Efficient Conversion to Propositional Logic"))(POS (PAPER.PUBLICATION GAMMER2007 "Proc. 7th Symposium on Abstraction, Reformulation, and Approximation"))(POS (PAPER.LINK GAMMER2007 "http://reason.cs.uiuc.edu/eyal/paper.html"))(POS (PAPER.YEAR GAMMER2007 2007))(POS (PAPER.DESCRIPTION GAMMER2007 "
The authors consider ground first-order logic with equality and show
how one can employ Craig's Interpolation theorem to reduce the cost
of grounding out the usual axiomatization of equality.
"))(POS (PAPER.TOPIC GAMMER2007 "Reformulation"))(POS (PAPER.INSTANCE GEDDIS95))(POS (PAPER.BIBTEX GEDDIS95 PHDTHESIS))(POS (PAPER.AUTHOR GEDDIS95 "Don Geddis"))(POS (PAPER.TITLE GEDDIS95 "Caching and Non-Horn Inference in Model Elimination Theorem Provers"))(POS (PAPER.PUBLISHER GEDDIS95 "Stanford University"))(POS (PAPER.LINK GEDDIS95 "http://library.stanford.edu/depts/mathcs/mathcscoll/techreports.html"))(POS (PAPER.YEAR GEDDIS95 1995))(POS (PAPER.RANK GEDDIS95 "[***]"))(POS (PAPER.DESCRIPTION GEDDIS95 "
Geddis investigates Nonhorn caching for model elimination.  Astrachan and
Stickel did the seminal work on caching for the Horn case.  Nonhorn
caching is made difficult by the reduction operation, i.e. proofs of
subgoals are context dependent.  Previous work stored the context and
the proven subgoal.  Geddis shows that if a literal has a completion in
one context, it has a completion in every context.  Thus, if a subgoal
cannot be completed, it can be added to a failure cache.  A completion is
not the same as a proof, however, and there are no results for success
caching.  If a depth-limited search-strategy is used, incompleteness can
result; Geddis found no solution for this problem.  Also discussed is an
extension to David Smith's work: postponement caching.  It basically avoids
infinite recursions if possible by 'enslaving' a subgoal to an ancestor
if the two unify.  It is complete for Horn and incomplete for nonHorn.
"))(POS (PAPER.TOPIC GEDDIS95 "Theorem Proving with Attachments"))(POS (PAPER.INSTANCE GELERNTER63))(POS (PAPER.BIBTEX GELERNTER63 ARTICLE))(POS (PAPER.AUTHOR GELERNTER63 "H. Gelernter"))(POS (PAPER.TITLE GELERNTER63 "Realization of a Geometry-Theorem Proving Machine"))(POS (PAPER.PUBLICATION GELERNTER63 "Computers and Thought"))(POS (PAPER.STARTPAGE GELERNTER63 134))(POS (PAPER.ENDPAGE GELERNTER63 152))(POS (PAPER.YEAR GELERNTER63 1963))(POS (PAPER.RANK GELERNTER63 "[*]"))(POS (PAPER.DESCRIPTION GELERNTER63 "
Gelernter describes the Geometry Machine, an ad hoc theorem prover
for Euclidian geometry.  It uses a diagram as a heuristic to guide
the theorem prover's search, eliminating subgoals when not 
satisfied by the diagram.  Sometimes that diagram prunes too much,
in which case multiple diagrams need to be generated to achieve
completeness.  The system is also unique in the fact that it does
not give the theorem prover a complete axiomitization of geometry,
but rather allows it to add axioms that are 'obvious' from the 
diagram, much as a human might do.
"))(POS (PAPER.TOPIC GELERNTER63 "Graphical Reasoning Techniques"))(POS (PAPER.INSTANCE GELFOND88))(POS (PAPER.BIBTEX GELFOND88 ARTICLE))(POS (PAPER.AUTHOR GELFOND88 "Michael Gelfond and Vladimir Lifschitz"))(POS (PAPER.TITLE GELFOND88 "The Stable Model Semantics for Logic Programming"))(POS (PAPER.PUBLICATION GELFOND88 "Proceedings of the Fifth International Conference on Logic Programming"))(POS (PAPER.STARTPAGE GELFOND88 1070))(POS (PAPER.ENDPAGE GELFOND88 1080))(POS (PAPER.LINK GELFOND88 "http://citeseer.ist.psu.edu/gelfond88stable.html"))(POS (PAPER.YEAR GELFOND88 1988))(POS (PAPER.DESCRIPTION GELFOND88 "
Stable model semantics for logic programming.
"))(POS (PAPER.TOPIC GELFOND88 "Logic Programming"))(POS (PAPER.INSTANCE GENESERETH87))(POS (PAPER.BIBTEX GENESERETH87 BOOK))(POS (PAPER.AUTHOR GENESERETH87 "Michael Genesereth and Nils Nilsson"))(POS (PAPER.TITLE GENESERETH87 "Logical Foundations of Artificial Intelligence"))(POS (PAPER.PUBLISHER GENESERETH87 "Morgan Kaufmann Publishers"))(POS (PAPER.LINK GENESERETH87 "http://www.amazon.com/Foundations-Artificial-Intelligence-Michael-Genesereth/dp/0934613311"))(POS (PAPER.YEAR GENESERETH87 1987))(POS (PAPER.RANK GENESERETH87 "[*****]"))(POS (PAPER.DESCRIPTION GENESERETH87 "
Genesereth and Nilsson construct the foundations of AI using logic.  Covers logic, resolution and various strategies, nonmonotonic reasoning, induction, uncertainty, belief,
metaknowledge and metareasoning, a changing environment, and agent architectures.
"))(POS (PAPER.TOPIC GENESERETH87 ""))(POS (PAPER.INSTANCE GIACOMO2000))(POS (PAPER.AUTHOR GIACOMO2000 "G. De Giacomo, Y. Lesperance, and H.J. Levesque"))(POS (PAPER.TITLE GIACOMO2000 "ConGolog, a concurrent prrogramming language based on the situation calculus"))(POS (PAPER.PUBLICATION GIACOMO2000 "Artificial Intelligence"))(POS (PAPER.VOLUME GIACOMO2000 "121"))(POS (PAPER.STARTPAGE GIACOMO2000 109))(POS (PAPER.ENDPAGE GIACOMO2000 169))(POS (PAPER.LINK GIACOMO2000 "http://www.cs.yorku.ca/~lesperan/publications.html"))(POS (PAPER.YEAR GIACOMO2000 2000))(POS (PAPER.DESCRIPTION GIACOMO2000 "
ConGolog extends Golog (both implementations being in Prolog) to include concurrent actions (conceptualized as interleaving actions of different processes that can block, in the OS sense).  The constructs introduced here include synchronized conditionals (test-and-set), synchronized loops, concurrent execution, concurrency with different priorities (the lower priority process can only execute if the higher priority one is blocked or finished), concurrent iteration, and interrupts.  Nondeterminstic iteration can be useful when an unspecified number of programs need to be run concurrently, e.g. an FTP server.  Some more work is required to handle procedures.  The semantics given in the original Golog paper were evaluation semantics.  Here the authors switch to transition semantics and require all the macros of Golog to become embedded in the language.
Exogenous events are handled by allowing the user to specify which primitive actions may occurs outside the control of the program.  A predefined program for choosing a possible exogenous action, checking its preconditions, and executing it if possible is run concurrently with the user-defined program. To handle truly overlapping actions such as filling-bath-tub and singing-do-re-mi, the authors suggest thinking of filling-bath-tub as not an action, but rather as a state, which requires the start-filling action to enter the state and the stop-filling action to exit the state.  This way, interleaving filling-bath-tub and singing-do-re-mi can happen at the same time.
"))(POS (PAPER.TOPIC GIACOMO2000 "Logic Programming"))(POS (PAPER.INSTANCE GIUNCHIGLIA92))(POS (PAPER.BIBTEX GIUNCHIGLIA92 ARTICLE))(POS (PAPER.AUTHOR GIUNCHIGLIA92 "Fausto Giunchiglia and Toby Walsh"))(POS (PAPER.TITLE GIUNCHIGLIA92 "A theory of abstraction"))(POS (PAPER.PUBLICATION GIUNCHIGLIA92 "Artificial Intelligence"))(POS (PAPER.VOLUME GIUNCHIGLIA92 "57"))(POS (PAPER.STARTPAGE GIUNCHIGLIA92 323))(POS (PAPER.ENDPAGE GIUNCHIGLIA92 389))(POS (PAPER.LINK GIUNCHIGLIA92 "http://citeseer.ist.psu.edu/27696.html"))(POS (PAPER.YEAR GIUNCHIGLIA92 1992))(POS (PAPER.RANK GIUNCHIGLIA92 "[****]"))(POS (PAPER.DESCRIPTION GIUNCHIGLIA92 "
Giunchiglia and Walsh describe a theory of abstraction in very general terms,
which is intended to be independent of proof system.  Most generally,
an abstraction is a mapping between a pair of formal systems, where a
formal system consists of a language and a subset of that language defining
the axioms.  Axiomatic formal systems include an extra element: the
proof system.  Abstractions are categorized by whether they increase, decrease, or
leave constant the set of consequences of the theory: TI, TD, TC.  The authors
claim the TI abstractions is the true meaning of abstraction.  TD abstractions
can be used to prove entailment, i.e. if TD(Delta) |= phi then Delta |= phi.
TI abstractions can be used to prove negative entailment, i.e. if
TI(Delta) |/= phi then Delta |/= phi.  Refutation systems are concerned
not with provability but with inconsistency.  Abstractions in this setting
are characterized as NTI, NTD, and NTC.  If the formal system includes
negation and the abstraction f is negation preserving, i.e. f(-phi) = -f(phi)
then NT* and T* are equivalent.  Further classifications are made of abstractions,
depending on how independently an abstraction translates axioms, inference rules, etc.
A large section explaining how various peoples' work fits into this framework follows.
Then sections follow on inconsistent abstract spaces, operations performed
on abstractions, ordering abstractions, hierarchies of abstraction spaces, and building
abstractions.
"))(POS (PAPER.TOPIC GIUNCHIGLIA92 "Abstraction"))(POS (PAPER.INSTANCE GIUNCHIGLIA96REASONING))(POS (PAPER.BIBTEX GIUNCHIGLIA96REASONING INPROCEEDINGS))(POS (PAPER.AUTHOR GIUNCHIGLIA96REASONING "Fausto Giunchiglia and Paolo Pecchiari and Carolyn Talcott"))(POS (PAPER.TITLE GIUNCHIGLIA96REASONING "Reasoning Theories - Towards an Architecture for Open Mechanized Reasoning Systems"))(POS (PAPER.PUBLICATION GIUNCHIGLIA96REASONING "1st International Workshop: Frontiers of Combining Systems
           "))(POS (PAPER.STARTPAGE GIUNCHIGLIA96REASONING 157))(POS (PAPER.ENDPAGE GIUNCHIGLIA96REASONING 174))(POS (PAPER.LINK GIUNCHIGLIA96REASONING "http://citeseer.ist.psu.edu/354680.html"))(POS (PAPER.YEAR GIUNCHIGLIA96REASONING 1996))(POS (PAPER.RANK GIUNCHIGLIA96REASONING "[***]"))(POS (PAPER.DESCRIPTION GIUNCHIGLIA96REASONING "Giunchiglia et al. describe a formalization of logical reasoners.  Such
reasoners (quoting) might be based on different logics; have different domain models;
use different vocabularies and data structures; use different reasoning
strategies; and have different interaction capabilities.  The authors
put forth a general architecture called Open Mechanized Reasoning Systems
(OMRS) for integrating reasoners described by what they call a
Reasoning Theory.  They use NQTHM as an example to illustrate the construction
of a Reasoning Theory.
"))(POS (PAPER.TOPIC GIUNCHIGLIA96REASONING "Architectures"))(POS (PAPER.INSTANCE GIUNCHIGLIA99APPLYING))(POS (PAPER.BIBTEX GIUNCHIGLIA99APPLYING INPROCEEDINGS))(POS (PAPER.AUTHOR GIUNCHIGLIA99APPLYING "Enrico Giunchiglia and Roberto Sebastiani"))(POS (PAPER.TITLE GIUNCHIGLIA99APPLYING "Applying the Davis-Putnam Procedure to Non-clausal Formulas"))(POS (PAPER.PUBLICATION GIUNCHIGLIA99APPLYING "Proceedings of the 6th Congress of the Italian Association for Artificial Intelligence on Advances in Artificial Intelligence"))(POS (PAPER.STARTPAGE GIUNCHIGLIA99APPLYING 84))(POS (PAPER.ENDPAGE GIUNCHIGLIA99APPLYING 94))(POS (PAPER.LINK GIUNCHIGLIA99APPLYING "http://citeseer.ist.psu.edu/giunchiglia99applying.html"))(POS (PAPER.YEAR GIUNCHIGLIA99APPLYING 1999))(POS (PAPER.DESCRIPTION GIUNCHIGLIA99APPLYING "
Continuation of their earlier work on building a SAT solver that handles
non-clausal form by translating the problem into CNF in such a way that 
the search space of the non-CNF problem is preserved in some way.
"))(POS (PAPER.TOPIC GIUNCHIGLIA99APPLYING "SAT Solving"))(POS (PAPER.INSTANCE GIUNCHIGLIA99PLANNING))(POS (PAPER.BIBTEX GIUNCHIGLIA99PLANNING INPROCEEDINGS))(POS (PAPER.AUTHOR GIUNCHIGLIA99PLANNING "Fausto Giunchiglia and Paolo Traverso"))(POS (PAPER.TITLE GIUNCHIGLIA99PLANNING "Planning as Model Checking"))(POS (PAPER.LINK GIUNCHIGLIA99PLANNING "http://citeseer.ist.psu.edu/giunchiglia99planning.html"))(POS (PAPER.YEAR GIUNCHIGLIA99PLANNING 1999))(POS (PAPER.RANK GIUNCHIGLIA99PLANNING "[*]"))(POS (PAPER.DESCRIPTION GIUNCHIGLIA99PLANNING "
This paper gives an introduction to Planning as Model Checking for
both deterministic and nondeterministic domains.  It explains
the model checking problem, planning as model checking, 
planning in nondeterministic domains, an implementation, and
related work.  They look at problems formalized in Computation
Tree Logic (CTL).
"))(POS (PAPER.TOPIC GIUNCHIGLIA99PLANNING "Model Checking"))(POS (PAPER.INSTANCE GRAMLICH2005))(POS (PAPER.BIBTEX GRAMLICH2005 ARTICLE))(POS (PAPER.AUTHOR GRAMLICH2005 "Bernhard Gramlich"))(POS (PAPER.TITLE GRAMLICH2005 "Strategic issues, Problems and Challenges in Inductive Theorem Proving"))(POS (PAPER.LINK GRAMLICH2005 "http://www.logic.at/staff/gramlich/ papers/strategies04-entcs05.pdf.gz"))(POS (PAPER.YEAR GRAMLICH2005 2005))(POS (PAPER.RANK GRAMLICH2005 "[***]"))(POS (PAPER.DESCRIPTION GRAMLICH2005 "
Gramlich outlines the inductive theorem proving, how it differs from
first-order theorem proving, and some of the obstacles that must be
overcome to make automated inductive theorem proving a reality.
"))(POS (PAPER.TOPIC GRAMLICH2005 "Herbrand Logic"))(POS (PAPER.INSTANCE GREEN69))(POS (PAPER.AUTHOR GREEN69 "C. Green"))(POS (PAPER.TITLE GREEN69 "Theorem-proving by resolution as a basis for question-answering systems."))(POS (PAPER.PUBLICATION GREEN69 "Machine Intelligence 4"))(POS (PAPER.STARTPAGE GREEN69 183))(POS (PAPER.ENDPAGE GREEN69 205))(POS (PAPER.YEAR GREEN69 1969))(POS (PAPER.DESCRIPTION GREEN69 "
Green describes using a theorem prover, QA3, to build a question-answering system.  Both statements and questions are written in FOL.  Questions can be True/False or Constructive (i.e. ask for an x such that ...).  Constructive answers are produced by adding the rule question-of-user(x) => Answer(x).  Green goes on to describe what we now call deductive plan synthesis, i.e. answer extraction of situation calculus axioms.  QA3 uses subsumption, duplicate literal elimination, unit preference, a variant on set of support, and no equality (yet).
"))(POS (PAPER.TOPIC GREEN69 "Fundamentals"))(POS (PAPER.INSTANCE GREINER91))(POS (PAPER.BIBTEX GREINER91 ARTICLE))(POS (PAPER.AUTHOR GREINER91 "Russell Greiner and Charles Elkan"))(POS (PAPER.TITLE GREINER91 "Measuring and Improving the Effectiveness of Representations"))(POS (PAPER.PUBLICATION GREINER91 "IJCAI"))(POS (PAPER.STARTPAGE GREINER91 518))(POS (PAPER.ENDPAGE GREINER91 524))(POS (PAPER.LINK GREINER91 "http://citeseer.ist.psu.edu/114212.html"))(POS (PAPER.YEAR GREINER91 1991))(POS (PAPER.RANK GREINER91 "[****]"))(POS (PAPER.DESCRIPTION GREINER91 "
Greiner and Elkan give axes upon which a representation, i.e. black box
for answering questions, can be evaluated: accuracy (how often the answer
given is correct), categoricity (how often the answer is I don't know), and
efficiency. A representation is thus evaluated wrt a query stream.  This 
external form of evaluation captures what any system using a representation
system actually cares about -- how well that representation works.  The
internal representation might also be evaluated by, for example, its
conciseness or elegance, but that is not covered here.  They also formalize
all bounded, linearly separable utility measures, i.e. ways of combining
evaluations wrt the 3 axes above.  Finally the authors confront statistical
approaches for performing evaluation, comparing representations, and improving
existing representations.   Well written.
"))(POS (PAPER.TOPIC GREINER91 "Logical Knowledge Representation"))(POS (PAPER.INSTANCE GREINER98))(POS (PAPER.BIBTEX GREINER98 ARTICLE))(POS (PAPER.AUTHOR GREINER98 "Russell Greiner and Christian Darken and N. Santoso"))(POS (PAPER.TITLE GREINER98 "Efficient Reasoning"))(POS (PAPER.PUBLICATION GREINER98 "ACM Computing Surveys"))(POS (PAPER.VOLUME GREINER98 "33(1)"))(POS (PAPER.STARTPAGE GREINER98 1))(POS (PAPER.ENDPAGE GREINER98 30))(POS (PAPER.LINK GREINER98 "http://citeseer.ist.psu.edu/greiner98efficient.html"))(POS (PAPER.YEAR GREINER98 1998))(POS (PAPER.RANK GREINER98 "[*]"))(POS (PAPER.DESCRIPTION GREINER98 "
Greiner gives a survey of techniques for efficient reasoning: both deductive 
and probabilistic.  He talks about the various techniques available for
dealing with exponential run times: unsound inference, incompleteness, etc.
"))(POS (PAPER.TOPIC GREINER98 "Logical Knowledge Representation"))(POS (PAPER.INSTANCE GROHE2001))(POS (PAPER.BIBTEX GROHE2001 INPROCEEDINGS))(POS (PAPER.AUTHOR GROHE2001 "Martin Grohe"))(POS (PAPER.TITLE GROHE2001 "Generalized Model-Checking Problems for First-Order Logic"))(POS (PAPER.PUBLICATION GROHE2001 "Symposium on Theoretical Aspects of Computer Science"))(POS (PAPER.STARTPAGE GROHE2001 12))(POS (PAPER.ENDPAGE GROHE2001 26))(POS (PAPER.LINK GROHE2001 "http://www.dcs.ed.ac.uk/home/grohe/pub.html"))(POS (PAPER.YEAR GROHE2001 2001))(POS (PAPER.RANK GROHE2001 "[****]"))(POS (PAPER.DESCRIPTION GROHE2001 "
Grohe investigates the parameterized complexity of various model-checking
problems in first-order logic.  In general, the problem is PSPACE-complete
for the combined size of the query and the model.  Under the assumption
of a small query, the parameterized complexity is still AW[*].  However,
some types of formulas and models lend themselves to tractable algorithms:
those with an underlying tree structure.  This paper gives a survey
of various model-checking complexity results for first-order logic.
"))(POS (PAPER.TOPIC GROHE2001 "Model Checking"))(POS (PAPER.RELATED GROHE2001 GROHE2002))(POS (PAPER.INSTANCE GROHE2002))(POS (PAPER.BIBTEX GROHE2002 ARTICLE))(POS (PAPER.AUTHOR GROHE2002 "Martin Grohe"))(POS (PAPER.TITLE GROHE2002 "Parameterized Complexity for the Database Theorist"))(POS (PAPER.PUBLICATION GROHE2002 "SIGMOD"))(POS (PAPER.VOLUME GROHE2002 "31(4)"))(POS (PAPER.LINK GROHE2002 "http://www.dcs.ed.ac.uk/home/grohe/pub.html"))(POS (PAPER.YEAR GROHE2002 2002))(POS (PAPER.RANK GROHE2002 "[*]"))(POS (PAPER.DESCRIPTION GROHE2002 "
Grohe gives a gentle introduction to Parameterized Complexity Theory for
database theorists.  The theory defines a complexity hierarchy for
problems with nonstandard constraints and reductions for proofs
of problem locations within the hierarchy.
These parameterized problems include more information than their standard
counterparts, and thus, can have better solutions.
"))(POS (PAPER.TOPIC GROHE2002 "Knowledge Base Compilation"))(POS (PAPER.INSTANCE GROSOF2003))(POS (PAPER.BIBTEX GROSOF2003 INPROCEEDINGS))(POS (PAPER.AUTHOR GROSOF2003 "Benjamin Grosof and Ian Horrocks and Raphael Volz and Stefan Decker"))(POS (PAPER.TITLE GROSOF2003 "Description Logic Programs: Combining Logic Programs with Description Logic"))(POS (PAPER.PUBLICATION GROSOF2003 "Proceedings of the 12th International Conference on the World Wide Web"))(POS (PAPER.LINK GROSOF2003 "http://citeseer.ist.psu.edu/grosof03description.html"))(POS (PAPER.YEAR GROSOF2003 2003))(POS (PAPER.DESCRIPTION GROSOF2003 "
Description Logic Programs are introduced, which lie in the intersection 
of logic programming and OWL DL.  In addition, mechanisms for reasoning
about this fragment with either description logic or logic programming
tools are introduced.
"))(POS (PAPER.TOPIC GROSOF2003 "Semantic Web"))(POS (PAPER.INSTANCE GUREVICH90))(POS (PAPER.BIBTEX GUREVICH90 ARTICLE))(POS (PAPER.AUTHOR GUREVICH90 "Yuri Gurevich"))(POS (PAPER.TITLE GUREVICH90 "On the Classical Decision Problem"))(POS (PAPER.PUBLICATION GUREVICH90 "Bulletin of the European Association for Theoretical Computer Science"))(POS (PAPER.VOLUME GUREVICH90 "42"))(POS (PAPER.STARTPAGE GUREVICH90 140))(POS (PAPER.ENDPAGE GUREVICH90 150))(POS (PAPER.LINK GUREVICH90 "http://citeseer.ist.psu.edu/gurevich93classical.html"))(POS (PAPER.YEAR GUREVICH90 1990))(POS (PAPER.RANK GUREVICH90 "[*]"))(POS (PAPER.DESCRIPTION GUREVICH90 "
This paper takes the form of a dialogue between the Author and Quisani.
It gives an introduction to the problem of determining whether a first-
order formula is satisfiable (or valid).  The classic decision problem
is whether this problem is decidable.  Church and Turing showed
it to be undecidable.  Then the question becomes, for which
formulas is this decidable?  Classes are given based on the 
quantifier prefixes that are decidable.  More interestingly, 
a certain set of 4 prefixes are enough to completely solve the
decision problem for prefix classes.
"))(POS (PAPER.TOPIC GUREVICH90 "Decidable Fragments of First-Order Logic"))(POS (PAPER.INSTANCE HAAS86))(POS (PAPER.AUTHOR HAAS86 "Andrew R. Haas"))(POS (PAPER.TITLE HAAS86 "A Syntactic Theory of Belief and Action"))(POS (PAPER.PUBLICATION HAAS86 "Artificial Intelligence"))(POS (PAPER.VOLUME HAAS86 "28(3)"))(POS (PAPER.STARTPAGE HAAS86 245))(POS (PAPER.ENDPAGE HAAS86 292))(POS (PAPER.LINK HAAS86 "http://www.reviews.com/Review/Review_review.cfm?media_id=778843&reviewer=110938&pos=3&page=4"))(POS (PAPER.YEAR HAAS86 1986))(POS (PAPER.DESCRIPTION HAAS86 "
Haas describes an approach for reasoning about belief, both an agent's own
beliefs and another agent's belief's.  First, we represent an agent's belief's
with Believes(agent, sentence), where sentence names a sentence of FOL.  Haas
names sentences of FOL by quoting each component, i.e. p(a) is named 'p('a)
(it looks cleaner in prefix notation).  He also gives names for intervals of
time so he can state how long it will take for an agent to believe a certain
sentence; afterall inference is not instantaneous.   In order to give an agent
the ability to determine what another agent will infer, Haas borrows
Konolige's suggestion of implanting an agent's inference rules into the
Believes statements.  Then, Haas introduces The Reflection Schema to do
inference.  Specifically,
Ax1,..,xn. (ClosedTerm x1)^...^(ClosedTerm xn) => IsProof(s)
s is a proof quoted appropriately.  He shows this schema sound and complete.
Haas goes on to define 'Knowing What' in terms of the context of what was asked.
'Knowing How' means a robot has a program to execute.  Finally, Haas connnects
belief and truth using the truth predicate: 'true(quote p) 'iff 'p.  The
Liar's paradox shows up here, but Haas avoids it by proving if p is ground,
true produces no contradictions.
"))(POS (PAPER.TOPIC HAAS86 "Metalevel Reasoning"))(POS (PAPER.INSTANCE HAHNLE2002))(POS (PAPER.AUTHOR HAHNLE2002 "Reiner Hahnle and Neil Murray and Erik Rosenthal"))(POS (PAPER.TITLE HAHNLE2002 "Ordered Resolution vs. Connection Graph Resolution"))(POS (PAPER.LINK HAHNLE2002 "http://citeseer.ist.psu.edu/446349.html"))(POS (PAPER.YEAR HAHNLE2002 2002))(POS (PAPER.DESCRIPTION HAHNLE2002 "
Hahnle et. al. first describe connection graph resolution for
propositional logic, introduced by Kowalski in 1975.  
CGR begins with a graph of clauses with
edges between complementary literals.  Activating an edge
means performing a step of resolution, producing a new 
clause graph.  Then they show that ordered resolution
is a special case of cg-resolution (for prop logic) and then
that ordered cg-resolution will always terminate.  Ordered
cg-resolution enforces a total ordering on literals so
that resolution is applied only to the maximally ordered
literal in a clause.  It is a little unclear to what extent
the results are new, but apparently
the proofs are simpler than those given in the past.  At the end,
the authors discuss issues for lifting this to first-order and
give Eisinger's example that shows unrestricted cg-resolution
is non-terminal.  
"))(POS (PAPER.TOPIC HAHNLE2002 "Calculi"))(POS (PAPER.INSTANCE HALEVY2001))(POS (PAPER.BIBTEX HALEVY2001 ARTICLE))(POS (PAPER.AUTHOR HALEVY2001 "Alon Halevy"))(POS (PAPER.TITLE HALEVY2001 "Answering Queries Using Views: A Survey"))(POS (PAPER.PUBLICATION HALEVY2001 "VLDB Journal: Very Large Data Bases"))(POS (PAPER.VOLUME HALEVY2001 "10(4)"))(POS (PAPER.STARTPAGE HALEVY2001 270))(POS (PAPER.ENDPAGE HALEVY2001 294))(POS (PAPER.LINK HALEVY2001 "http://citeseer.ist.psu.edu/halevy00answering.html"))(POS (PAPER.YEAR HALEVY2001 2001))(POS (PAPER.RANK HALEVY2001 "[****]"))(POS (PAPER.DESCRIPTION HALEVY2001 "
Halevy's survey splits the work that answers queries using views into two
cateogires: using materialized views to speed up query answering and
data integration.  In the former setting, materialized views have the potential
to speed up query answering because some portion of the query may have already
been computed and stored in the db as a materialized view.  The goal here is
to produce an efficient execution plan that uses base tables and materialized views.
In the latter setting, data integration techniques provide a schema, sometimes
called the mediated schema, for a user to query a large number of separate
databases.  To define how each individual schema relates to the mediated schema,
the tables in the individual schemas are expressed as views of the mediated schema.
Here the work focuses on rewriting the query in terms of the views of the mediated
schema, i.e. in terms of the database schema that actually exist.  This case is
particularly interesting because it requires the views to be treated as
incomplete, e.g. both the database of american cars and the database of foreign
cars contribute to the car table.
"))(POS (PAPER.TOPIC HALEVY2001 "Databases"))(POS (PAPER.INSTANCE HALMOS))(POS (PAPER.BIBTEX HALMOS BOOK))(POS (PAPER.AUTHOR HALMOS "Paul Halmos"))(POS (PAPER.TITLE HALMOS "Naive Set Theory"))(POS (PAPER.PUBLISHER HALMOS "Van Nostrand Reinhold Company"))(POS (PAPER.LINK HALMOS "http://www.amazon.com/Naive-Theory-Undergraduate-Texts-Mathematics/dp/0387900926"))(POS (PAPER.YEAR HALMOS 1960))(POS (PAPER.RANK HALMOS ""))(POS (PAPER.DESCRIPTION HALMOS "
A 100-page book on naive set theory.
"))(POS (PAPER.TOPIC HALMOS ""))(POS (PAPER.INSTANCE HALPERN91))(POS (PAPER.AUTHOR HALPERN91 "Joseph Halpern and Moshe Vardi"))(POS (PAPER.TITLE HALPERN91 "Model Checking vs. Theorem Proving: A Manifesto"))(POS (PAPER.PUBLICATION HALPERN91 "Artificial and mathematical Theory of Computation
       (Papers in Honor of John McCarthy)"))(POS (PAPER.LINK HALPERN91 "http://www.cs.cornell.edu/home/halpern/abstract.html#bookart4"))(POS (PAPER.YEAR HALPERN91 1991))(POS (PAPER.RANK HALPERN91 "[****]"))(POS (PAPER.DESCRIPTION HALPERN91 "
Halpern and Vardi prescribe using a semantic model to represent an agent's
knowledge and use model checking to determine logical entailment.  This differs
greatly from the standard approach of using logical sentences to represent
knowledge and then doing theorem proving to check entailment.  The authors
outline constructing such models in a few contexts and consider problems with
the model checking.
"))(POS (PAPER.TOPIC HALPERN91 "Model Checking"))(POS (PAPER.INSTANCE HAMMER93))(POS (PAPER.BIBTEX HAMMER93 ARTICLE))(POS (PAPER.AUTHOR HAMMER93 "Peter Hammer and Alexander Kogan"))(POS (PAPER.TITLE HAMMER93 "Optimal Compression of Propositional Horn Knowledge Bases: Complexity and Approximation"))(POS (PAPER.PUBLICATION HAMMER93 "Artificial Intelligence"))(POS (PAPER.VOLUME HAMMER93 "64(1)"))(POS (PAPER.STARTPAGE HAMMER93 131))(POS (PAPER.ENDPAGE HAMMER93 145))(POS (PAPER.LINK HAMMER93 "http://citeseer.ist.psu.edu/hammer93optimal.html"))(POS (PAPER.YEAR HAMMER93 1993))(POS (PAPER.RANK HAMMER93 "[*]"))(POS (PAPER.DESCRIPTION HAMMER93 "
Hammer and Kogan show that finding the minimum propositional Horn
KB of a given Horn KB is NP-Complete.  They also show a previous
O(n^2) approximation algorithm to be a good one since it allows
no more than a linear factor more rules.
"))(POS (PAPER.TOPIC HAMMER93 "Knowledge Base Compilation"))(POS (PAPER.INSTANCE HAYES75))(POS (PAPER.AUTHOR HAYES75 "Philip J. Hayes"))(POS (PAPER.TITLE HAYES75 "A Representation for Robot Plans"))(POS (PAPER.PUBLICATION HAYES75 "IJCAI"))(POS (PAPER.STARTPAGE HAYES75 181))(POS (PAPER.ENDPAGE HAYES75 188))(POS (PAPER.YEAR HAYES75 1975))(POS (PAPER.DESCRIPTION HAYES75 "
Due to the need for replanning, Hayes advocates producing plans that consist
of two data structures: a subgoal tree and a decision graph.  The subgoal tree represents the plan in a hierarchical-type planner, i.e. root is the overall
goal; each internal node is a reduction of its parent; each leaf is a
primitive action.  The decision graph records the decisions made by the planner while producing the plan.  Links exist between the decision graph and the
subgoal tree so that when a failure occurs during plan execution, the
appropriate parts of both data structures can be removed.
"))(POS (PAPER.TOPIC HAYES75 "Historical"))(POS (PAPER.INSTANCE HENTENRYCK89))(POS (PAPER.BIBTEX HENTENRYCK89 BOOK))(POS (PAPER.AUTHOR HENTENRYCK89 "Pascal Van Hentenryck"))(POS (PAPER.TITLE HENTENRYCK89 "Constraint Satisfaction in Logic Programming"))(POS (PAPER.PUBLISHER HENTENRYCK89 "MIT Press"))(POS (PAPER.YEAR HENTENRYCK89 1989))(POS (PAPER.DESCRIPTION HENTENRYCK89 "
This is an extended form of Hentenryck's thesis.  It concerns the integration
of two standard CSP techniques (forward checking and arc consistency) into
Prolog.  First, there is a thorough introduction to Prolog--syntax,
semantics, proof theory.  Then he formally shows how to do the
integration.  Next he explains an implementation of the integration
that allows users the ability to specify when to apply the
new techniques.  
"))(POS (PAPER.TOPIC HENTENRYCK89 "Logic Programming"))(POS (PAPER.INSTANCE HEYMANS2003))(POS (PAPER.BIBTEX HEYMANS2003 INPROCEEDINGS))(POS (PAPER.AUTHOR HEYMANS2003 "S. Heymans and D. Vermeir"))(POS (PAPER.TITLE HEYMANS2003 "Integrating Semantic Web Reasoning and Answer Set Programming"))(POS (PAPER.PUBLICATION HEYMANS2003 "Proceedings of the 2nd International ASP Workshop"))(POS (PAPER.LINK HEYMANS2003 "http://citeseer.ist.psu.edu/727609.html"))(POS (PAPER.YEAR HEYMANS2003 2003))(POS (PAPER.DESCRIPTION HEYMANS2003 "
Translating another description logic into logic programming, this time
using stable model semantics.
"))(POS (PAPER.TOPIC HEYMANS2003 "Semantic Web"))(POS (PAPER.INSTANCE HINRICHS2004))(POS (PAPER.BIBTEX HINRICHS2004 ARTICLE))(POS (PAPER.BIBTEX HINRICHS2004 PROCEEDINGS))(POS (PAPER.AUTHOR HINRICHS2004 "T. Hinrichs and N. Love and C. Petrie and L. Ramshaw and A. Sahai and S. Singhal."))(POS (PAPER.AUTHOR HINRICHS2004 "Tim Hinrichs, Nathaniel Love, Charles Petrie, Lyle Ramshaw, Akhil Sahai and Sharad Singhal"))(POS (PAPER.TITLE HINRICHS2004 "Using Object-Oriented Constraint Satisfaction for Automated Configuration Generation"))(POS (PAPER.TITLE HINRICHS2004 "Using Object-Oriented Constraint Satisfaction for Automated Configuration Generation"))(POS (PAPER.PUBLICATION HINRICHS2004 "DSOM"))(POS (PAPER.PUBLICATION HINRICHS2004 "Utility Computing: 15th IFIP/IEEE International Workshop on Distributed Systems: Operations and Management, DSOM 2004"))(POS (PAPER.LINK HINRICHS2004 "http://logic.stanford.edu/~thinrich/publications.htm"))(POS (PAPER.LINK HINRICHS2004 "papers/hinrichs2004using.pdf"))(POS (PAPER.YEAR HINRICHS2004 2004))(POS (PAPER.YEAR HINRICHS2004 2004))(POS (PAPER.RANK HINRICHS2004 ""))(POS (PAPER.DESCRIPTION HINRICHS2004 "
Hinrichs, et. al. describe an application of Object-Oriented Constraint 
Satisfaction to configuration management.
"))(POS (PAPER.DESCRIPTION HINRICHS2004 "
In this paper, we describe an approach for automatically generating configurations for complex applications. Automated generation of system configurations is required to allow large-scale deployment of custom applications within utility computing environments. Our approach models the configuration management problem as an Object-Oriented Constraint Satisfaction Problem (OOCSP) that can be solved efficiently using a resolution-based theorem-prover. We outline the approach and discuss both the benefits of the approach as well as its limitations, and highlight certain unresolved issues that require further work. We demonstrate the viability of this approach using an e-Commerce site as an example, and provide results on the complexity and time required to solve for the configuration of such an application.
"))(POS (PAPER.TOPIC HINRICHS2004 "Object Oriented Constraint Satisfaction"))(POS (PAPER.TOPIC HINRICHS2004 "References"))(POS (PAPER.INSTANCE HINRICHS2005AXIOM))(POS (PAPER.BIBTEX HINRICHS2005AXIOM INPROCEEDINGS))(POS (PAPER.AUTHOR HINRICHS2005AXIOM "Timothy Hinrichs and Michael Genesereth"))(POS (PAPER.TITLE HINRICHS2005AXIOM "Axiom Schemata as Metalevel Axioms: Model Theory"))(POS (PAPER.PUBLICATION HINRICHS2005AXIOM "In proceedings of American Association for Aritificial Intelligence"))(POS (PAPER.LINK HINRICHS2005AXIOM "http://logic.stanford.edu/~thinrich/papers/hinrichs2005axiom.pdf"))(POS (PAPER.YEAR HINRICHS2005AXIOM 2005))(POS (PAPER.DESCRIPTION HINRICHS2005AXIOM "
Logicians frequently use axiom schemata to encode (potentially infinite) sets of sentences with particular syntactic form. In this paper we examine a first-order language in which it is possible to write expressions that both describe sentences and assert the truth of the sentences so described. The effect of adding such expressions to a knowledge base is the same as directly including the set of described sentences. 
"))(POS (PAPER.TOPIC HINRICHS2005AXIOM "References"))(POS (PAPER.INSTANCE HINRICHS2006HERBRAND))(POS (PAPER.BIBTEX HINRICHS2006HERBRAND TECHREPORT))(POS (PAPER.AUTHOR HINRICHS2006HERBRAND "Timothy Hinrichs and Michael Genesereth"))(POS (PAPER.TITLE HINRICHS2006HERBRAND "Herbrand Logic"))(POS (PAPER.PUBLISHER HINRICHS2006HERBRAND "Stanford University"))(POS (PAPER.LINK HINRICHS2006HERBRAND "http://logic.stanford.edu/reports/LG-2006-02.pdf"))(POS (PAPER.YEAR HINRICHS2006HERBRAND 2006))(POS (PAPER.DESCRIPTION HINRICHS2006HERBRAND "
Herbrand logic has the same syntax as first-order logic but has Herbrand semantics. That is, the only models that exist in Herbrand logic are the Herbrand models. This logic is easier to learn than first-order logic and is often better suited for modeling and manipulating today's computer systems, the central concerns of computer science. In Herbrand logic, arithmetic using the natural numbers if finitely axiomatizable; however, neither entailment nor satisfiability are semi-decidable. Nevertheless, four of the most industrially successful applications of logic in computer science have been built within fragments of Herbrand logic: deductive databases, logic programming, constraint satisfaction, and formal verification. In this paper, we define Herbrand logic formally, prove several of its properties, discuss Goedel's incompleteness result with respect to Herbrand logic, and demonstrate how each of the four applications mentioned above can be formalized within Herbrand logic. 
"))(POS (PAPER.TOPIC HINRICHS2006HERBRAND "References"))(POS (PAPER.INSTANCE HINRICHS2007EXTENSIONAL))(POS (PAPER.BIBTEX HINRICHS2007EXTENSIONAL INPROCEEDINGS))(POS (PAPER.AUTHOR HINRICHS2007EXTENSIONAL "Timothy Hinrichs and Michael Genesereth"))(POS (PAPER.TITLE HINRICHS2007EXTENSIONAL "Extensional Reasoning"))(POS (PAPER.PUBLICATION HINRICHS2007EXTENSIONAL "In proceedings of CADE Workshop on Empirically Successful Automated Reasoning in Large Theories (ESARLT)"))(POS (PAPER.LINK HINRICHS2007EXTENSIONAL "http://logic.stanford.edu/~thinrich/papers/hinrichs2007extensional.pdf"))(POS (PAPER.YEAR HINRICHS2007EXTENSIONAL 2007))(POS (PAPER.DESCRIPTION HINRICHS2007EXTENSIONAL "
Relational databases are one of the most industrially successful applications of logic in computer science, built for handling massive amounts of data. The power of the paradigm is clear both because of its widespread adoption and theoretical analysis. Today, automated theorem provers are not able to take advantage of database query engines and therefore do not routinely leverage that source of power. Extensional Reasoning is an approach to automated theorem proving where the machine automatically translates a logical entailment query into a database, a set of view definitions, and a database query such that the entailment query can be answered by answering the database query. This paper discusses the framework for Extensional Reasoning, describes algorithms that enable a theorem prover to leverage the power of the database in the case of axiomatically complete theories, and discusses theory resolution for handling incomplete theories. 
"))(POS (PAPER.TOPIC HINRICHS2007EXTENSIONAL "References"))(POS (PAPER.INSTANCE HINRICHS2007REFORMULATION))(POS (PAPER.BIBTEX HINRICHS2007REFORMULATION INPROCEEDINGS))(POS (PAPER.AUTHOR HINRICHS2007REFORMULATION "Timothy Hinrichs and Michael Genesereth"))(POS (PAPER.TITLE HINRICHS2007REFORMULATION "Reformulation for Extensional Reasoning"))(POS (PAPER.PUBLICATION HINRICHS2007REFORMULATION "In proceedings of the Symposium of Abstraction, Reformulation, and Approximation (SARA)"))(POS (PAPER.LINK HINRICHS2007REFORMULATION "http://logic.stanford.edu/~thinrich/papers/hinrichs2007reformulation.pdf"))(POS (PAPER.YEAR HINRICHS2007REFORMULATION 2007))(POS (PAPER.DESCRIPTION HINRICHS2007REFORMULATION "
Relational databases have had great industrial success in computer science. The power of the paradigm is made clear both by its widespread adoption and by theoretical analysis. Today, automated theorem provers are not able to take advantage of database query engines and therefore do not routinely leverage that source of power. Extensional Reasoning (ER) is an approach to automated theorem proving where the machine automatically translates a logical entailment query into a database, a set of view definitions, and a database query such that the entailment query can be answered by answering the database query. The techniques developed for ER to date are applicable only when the logical theory is axiomatically complete. This paper discusses techniques for reformulating an incomplete theory into a complete theory so that Extensional Reasoning techniques can be applied. 

"))(POS (PAPER.TOPIC HINRICHS2007REFORMULATION "References"))(POS (PAPER.INSTANCE HITZLER2005))(POS (PAPER.BIBTEX HITZLER2005 INPROCEEDINGS))(POS (PAPER.AUTHOR HITZLER2005 "Pascal Hitzler and Peter Haase and Markus Krotzsch and York Sure and Rudi Studer"))(POS (PAPER.TITLE HITZLER2005 "DLP isn't so bad after all"))(POS (PAPER.PUBLICATION HITZLER2005 "Proceedings of the WS OWL -- Experiences and Directions"))(POS (PAPER.LINK HITZLER2005 "http://citeseer.ist.psu.edu/733286.html"))(POS (PAPER.YEAR HITZLER2005 2005))(POS (PAPER.DESCRIPTION HITZLER2005 "
The authors try to clarify the controversy surrounding Description Logic
Programs, which is a fragment of OWL DL that can be reasoned about effectively
with logic programming engines.  
"))(POS (PAPER.TOPIC HITZLER2005 "Semantic Web"))(POS (PAPER.INSTANCE HODGSON2002))(POS (PAPER.BIBTEX HODGSON2002 ARTICLE))(POS (PAPER.AUTHOR HODGSON2002 "Kahlil Hodgson and John Slaney"))(POS (PAPER.TITLE HODGSON2002 "TPTP, CASC and the development of a semantically guided 
theorem prover"))(POS (PAPER.PUBLICATION HODGSON2002 "AI Communications"))(POS (PAPER.VOLUME HODGSON2002 "15"))(POS (PAPER.STARTPAGE HODGSON2002 135))(POS (PAPER.ENDPAGE HODGSON2002 146))(POS (PAPER.LINK HODGSON2002 "http://citeseer.ist.psu.edu/558093.html"))(POS (PAPER.YEAR HODGSON2002 2002))(POS (PAPER.RANK HODGSON2002 ""))(POS (PAPER.DESCRIPTION HODGSON2002 "
Hodgson and Slaney describe SCOTT 5, the fifth generation of
semantically constrained otter.  The authors give a quick
description of the differences between the five versions
and explain the algorithm for the newest.  Instead of
maintaining a single model that satisfies some of the
constraints, they maintain several models.  Moreover,
sometimes they use these models to implement the semantic
queue strategy.  Pick the largest set of clauses known
to be satisfiable and if the number of clauses complementary
to a clause in S in the passive list is small, into the
active list. If none of these so called co-NMCSs are small
enough, cycle through them and add clauses to the active
queue.  SCOTT keeps separate the model builder and the theorem
prover from semantic guidance routines to allow, in principle,
a plug and play architecture.
"))(POS (PAPER.TOPIC HODGSON2002 "System Designs"))(POS (PAPER.INSTANCE HOHFELD88))(POS (PAPER.BIBTEX HOHFELD88 ARTICLE))(POS (PAPER.AUTHOR HOHFELD88 "M. Hohfeld and Gert Smolka"))(POS (PAPER.TITLE HOHFELD88 "Definite Relations over Constraint Languages"))(POS (PAPER.LINK HOHFELD88 "http://citeseer.ist.psu.edu/hohfeld88definite.html"))(POS (PAPER.YEAR HOHFELD88 1988))(POS (PAPER.RANK HOHFELD88 "[****]"))(POS (PAPER.DESCRIPTION HOHFELD88 "
Hohfeld and Smolka generalize the previous formal foundations of Constraint
Logic Programming by allowing arbitrary constraints placed on definite
logic programming clauses.  Their definition for constraint states  that
it is simply a restriction on variables; predicate logic is simply a special
case.  They give a generalization of SLD resolution that is sound and 
complete for this broader definition of CLP.  The authors go on to give a 'semantic type discipline' for these CLP clause sets.
"))(POS (PAPER.TOPIC HOHFELD88 "Constraint Logic Programming"))(POS (PAPER.INSTANCE HORIYAMA99))(POS (PAPER.BIBTEX HORIYAMA99 INPROCEEDINGS))(POS (PAPER.AUTHOR HORIYAMA99 "Takashi Horiyama and Toshihide ibaraki"))(POS (PAPER.TITLE HORIYAMA99 "Ordered Binary Decision Diagrams as Knowledge-Bases"))(POS (PAPER.PUBLICATION HORIYAMA99 "International Symposium on Algorithms and Computation"))(POS (PAPER.LINK HORIYAMA99 "http://citeseer.ist.psu.edu/horiyama99ordered.html"))(POS (PAPER.YEAR HORIYAMA99 1999))(POS (PAPER.RANK HORIYAMA99 "[*]"))(POS (PAPER.DESCRIPTION HORIYAMA99 "
Ordered binary decision diagrams can be used to represent propositional 
knowledge bases.  Deduction can be done from such a representation in 
polynomial time; not surprisingly, some knowledge bases require exponential
space while others require only polynomial space.  On the up-side, the
space requirements are not correlated with either characteristic models
(see kautz and khardon) or standard CNF representations.
"))(POS (PAPER.TOPIC HORIYAMA99 "Model-Based Reasoning"))(POS (PAPER.RELATED HORIYAMA99 KAUTZ93))(POS (PAPER.RELATED HORIYAMA99 KHARDON94))(POS (PAPER.INSTANCE HOWER96))(POS (PAPER.BIBTEX HOWER96 ARTICLE))(POS (PAPER.AUTHOR HOWER96 "Walter Hower and Winfried Graf"))(POS (PAPER.TITLE HOWER96 "A bibliographical survey of constraint-based approaches to CAD,
graphics, layout, visualization, and related topics"))(POS (PAPER.PUBLICATION HOWER96 "Knowledge-Based Systems
"))(POS (PAPER.VOLUME HOWER96 "9(7)"))(POS (PAPER.STARTPAGE HOWER96 449))(POS (PAPER.ENDPAGE HOWER96 464))(POS (PAPER.LINK HOWER96 "http://citeseer.ist.psu.edu/hower96bibliographical.html"))(POS (PAPER.YEAR HOWER96 1996))(POS (PAPER.RANK HOWER96 "[**]"))(POS (PAPER.DESCRIPTION HOWER96 "
Survey paper on just what the title indicates.  There are a few paragraphs
on object-oriented approaches most of which is orthogonal.
"))(POS (PAPER.TOPIC HOWER96 "Miscellaneous"))(POS (PAPER.INSTANCE JACKSON98))(POS (PAPER.BIBTEX JACKSON98 ARTICLE))(POS (PAPER.AUTHOR JACKSON98 "Daniel Jackson and Somesh Jha and Craig Damon"))(POS (PAPER.TITLE JACKSON98 "Isomorph-free model enumeration: a new method for checking relational specifications"))(POS (PAPER.PUBLICATION JACKSON98 "ACM Transactions on Programming Languages and Systems"))(POS (PAPER.LINK JACKSON98 "http://portal.acm.org/citation.cfm?id=276396&dl=ACM&coll=portal"))(POS (PAPER.YEAR JACKSON98 1998))(POS (PAPER.DESCRIPTION JACKSON98 "
Methods for building models while avoiding the enumeration of isomorphic candidates for the language Nitpick.
"))(POS (PAPER.TOPIC JACKSON98 "Model Building"))(POS (PAPER.INSTANCE JAFFAR87))(POS (PAPER.BIBTEX JAFFAR87 ARTICLE))(POS (PAPER.AUTHOR JAFFAR87 "J. Jaffar and J.L. Lassez"))(POS (PAPER.TITLE JAFFAR87 "Constraint Logic Programming"))(POS (PAPER.PUBLICATION JAFFAR87 "ACM Symposium on Principles of Programming Languages"))(POS (PAPER.STARTPAGE JAFFAR87 111))(POS (PAPER.ENDPAGE JAFFAR87 119))(POS (PAPER.LINK JAFFAR87 "http://portal.acm.org/citation.cfm?id=41635&dl=GUIDE&coll=GUIDE"))(POS (PAPER.YEAR JAFFAR87 1987))(POS (PAPER.RANK JAFFAR87 "[****]"))(POS (PAPER.DESCRIPTION JAFFAR87 "
Jaffar and Lassez introduce constraint logic programming as a class
of logic programming languages, one for each domain of discourse.  
Every rule has associated with it a set of constraints 
over that domain.  Hohfeld and Smolka in '88 generalize this 
framework, but this is the seminal paper.  Solution to a CLP problem
is a set of constraints; thus, logic programming is a special form
of CLP where those constraints must be equality constraints.
"))(POS (PAPER.TOPIC JAFFAR87 "Constraint Logic Programming"))(POS (PAPER.INSTANCE JANICIC2002))(POS (PAPER.BIBTEX JANICIC2002 ARTICLE))(POS (PAPER.AUTHOR JANICIC2002 "Predrag Janicic and Alan Bundy"))(POS (PAPER.TITLE JANICIC2002 "A General Setting for Flexibly Combining and Augmenting Decision Procedures"))(POS (PAPER.PUBLICATION JANICIC2002 "Journal of Automated Reasoning
           "))(POS (PAPER.VOLUME JANICIC2002 "28(3)"))(POS (PAPER.STARTPAGE JANICIC2002 257))(POS (PAPER.ENDPAGE JANICIC2002 305))(POS (PAPER.LINK JANICIC2002 "http://www.inf.ed.ac.uk/publications/report/0095.html"))(POS (PAPER.YEAR JANICIC2002 2002))(POS (PAPER.RANK JANICIC2002 "[***]"))(POS (PAPER.DESCRIPTION JANICIC2002 "
Janicic and Bundy invent a set of macro rewrite rules that can be used
to build a reasoner out of a set of decision procedures.  They provide
a good overview of the main influences in the field of combining
and augmenting decision procedures.  They build a prototype system
and report comparison results for Nelson-Oppen, Shostak, etc.
"))(POS (PAPER.TOPIC JANICIC2002 "Architectures"))(POS (PAPER.INSTANCE JEAVONS99))(POS (PAPER.BIBTEX JEAVONS99 ARTICLE))(POS (PAPER.AUTHOR JEAVONS99 "Peter Jeavons and David Cohen and Marc Gyssens"))(POS (PAPER.TITLE JEAVONS99 "How to Determine the Expressive Power of Constraints"))(POS (PAPER.PUBLICATION JEAVONS99 "Constraints"))(POS (PAPER.VOLUME JEAVONS99 "4"))(POS (PAPER.STARTPAGE JEAVONS99 113))(POS (PAPER.ENDPAGE JEAVONS99 131))(POS (PAPER.LINK JEAVONS99 "http://citeseer.ist.psu.edu/jeavons98how.html"))(POS (PAPER.YEAR JEAVONS99 1999))(POS (PAPER.DESCRIPTION JEAVONS99 "
The authors define expresssive power as the set of relations definable
from another set of relations.  They show how to compute which algebraic 
operators are closed for a given set of relations by solving a particular
kind of CSP for the given relations.  Then they show that the set of
relations definable from a given set is equal to the set of relations
that are closed under the same operations as that given set.  If some set
R is closed under the set of operations O and every operation in O is 
what they call essentially unary, the problem is NP-complete.  Moreover,
if O includes an operation that is not essentially unary, it includes
an operation that has arity at most max(3, the size of the domain).
Thus, this paper details sufficient conditions for checking whether
a particular CSP is NP-complete: (1) compute the set of operations
that are closed over the permissible tables in the constraints of the CSP.
(2) If that set includes just essentially-unary operations (which can
be deduced by checking for operations of arity up to max(3, size of domain), 
we are assured the problem is NP-complete.
"))(POS (PAPER.TOPIC JEAVONS99 "General"))(POS (PAPER.INSTANCE KAUTZ91))(POS (PAPER.BIBTEX KAUTZ91 INPROCEEDINGS))(POS (PAPER.AUTHOR KAUTZ91 "Henry Kautz and Bart Selman"))(POS (PAPER.TITLE KAUTZ91 "A General Framework for Knowledge Compilation"))(POS (PAPER.PUBLICATION KAUTZ91 "International Workshop on Processing Declarative Knowledge"))(POS (PAPER.LINK KAUTZ91 "http://citeseer.ist.psu.edu/kautz91general.html"))(POS (PAPER.YEAR KAUTZ91 1991))(POS (PAPER.RANK KAUTZ91 "[****]"))(POS (PAPER.DESCRIPTION KAUTZ91 "
This follows up on selman91 and generalizes the Knowledge Compilation 
idea into a framework.  It says that it lifts the algorithms for
Least Upper Bound and Greatest Lower Bound Horn approximations to first-
order, but the proofs of computability are nonexistent.  
"))(POS (PAPER.TOPIC KAUTZ91 "Knowledge Base Compilation"))(POS (PAPER.RELATED KAUTZ91 SELMAN91))(POS (PAPER.INSTANCE KAUTZ92))(POS (PAPER.BIBTEX KAUTZ92 INPROCEEDINGS))(POS (PAPER.AUTHOR KAUTZ92 "Henry Kautz and Bart Selman"))(POS (PAPER.TITLE KAUTZ92 "Forming Concepts for Fast Inference"))(POS (PAPER.PUBLICATION KAUTZ92 "ECAI-Workshop on Knowledge Representation and Reasoning
      "))(POS (PAPER.STARTPAGE KAUTZ92 200))(POS (PAPER.ENDPAGE KAUTZ92 215))(POS (PAPER.LINK KAUTZ92 "http://citeseer.ist.psu.edu/kautz92forming.html"))(POS (PAPER.YEAR KAUTZ92 1992))(POS (PAPER.RANK KAUTZ92 "[**]"))(POS (PAPER.DESCRIPTION KAUTZ92 "
Kautz and Selman show the Least Upper Bound Horn approximation to a 
propositional knowledge base can be exponential in size.  In general,
there do exist knowledge bases (quoting) whose LUBs cannot be represented 
in a form that is both small and tractable.  This paper mainly
considers the utility of learning new concepts to reduce the size
of the LUB.  
"))(POS (PAPER.TOPIC KAUTZ92 "Knowledge Base Compilation"))(POS (PAPER.RELATED KAUTZ92 SELMAN91))(POS (PAPER.INSTANCE KAUTZ93))(POS (PAPER.BIBTEX KAUTZ93 INPROCEEDINGS))(POS (PAPER.AUTHOR KAUTZ93 "Henry Kautz and Michael Kearns and Bart Selman"))(POS (PAPER.TITLE KAUTZ93 "Reasoning with Characteristic Models"))(POS (PAPER.PUBLICATION KAUTZ93 "AAAI"))(POS (PAPER.LINK KAUTZ93 "http://citeseer.ist.psu.edu/kautz93reasoning.html"))(POS (PAPER.YEAR KAUTZ93 1993))(POS (PAPER.RANK KAUTZ93 "[*****]"))(POS (PAPER.DESCRIPTION KAUTZ93 "
This is the seminal work on characteristic models.  The authors
define the characteristic models of a set M of models as those that cannot 
be derived by intersecting other models of M.  For propositional Horn
theories, these characteristic models are sufficient for computing 
entailment in time linear in the size of the characteristic models and
the conjecture.  In some cases the clausal representation requires 
exponentially more space than the characteristic representation, but
in others just the reverse is true.  Abduction using characteristic
models can be done in time polynomial in the size of the assumption set 
and the size of the characteristic set.  Very clean paper overall.
"))(POS (PAPER.TOPIC KAUTZ93 "Characteristic Models"))(POS (PAPER.INSTANCE KAUTZ95))(POS (PAPER.BIBTEX KAUTZ95 ARTICLE))(POS (PAPER.AUTHOR KAUTZ95 "Henry Kautz and Michael Kearns and Bart Selman"))(POS (PAPER.TITLE KAUTZ95 "Horn Approximations of Empirical Data"))(POS (PAPER.PUBLICATION KAUTZ95 "Artificial Intelligence"))(POS (PAPER.VOLUME KAUTZ95 "74(1)"))(POS (PAPER.STARTPAGE KAUTZ95 129))(POS (PAPER.ENDPAGE KAUTZ95 145))(POS (PAPER.LINK KAUTZ95 "http://citeseer.ist.psu.edu/kautz95horn.html"))(POS (PAPER.YEAR KAUTZ95 1995))(POS (PAPER.RANK KAUTZ95 "[****]"))(POS (PAPER.DESCRIPTION KAUTZ95 "
This paper essentially rehashes that of kautz93, except it also looks
at the problem of converting a given set of models into either clausal
form or characteristic model form.  This idea of extracting structure
from 'empirical data' was first addressed in dechter92.
"))(POS (PAPER.TOPIC KAUTZ95 "Characteristic Models"))(POS (PAPER.RELATED KAUTZ95 KAUTZ93))(POS (PAPER.RELATED KAUTZ95 DECHTER92))(POS (PAPER.INSTANCE KAVVADIAS93))(POS (PAPER.BIBTEX KAVVADIAS93 INPROCEEDINGS))(POS (PAPER.AUTHOR KAVVADIAS93 "D. Kavvadias and C. Papadimitriou and M. Sideri"))(POS (PAPER.TITLE KAVVADIAS93 "On Horn Envelopes and Hypergraph Transversals"))(POS (PAPER.PUBLICATION KAVVADIAS93 "ISAAC"))(POS (PAPER.LINK KAVVADIAS93 "http://www.aueb.gr/Users/sideri/publicat.htm"))(POS (PAPER.YEAR KAVVADIAS93 1993))(POS (PAPER.RANK KAVVADIAS93 "[**]"))(POS (PAPER.DESCRIPTION KAVVADIAS93 "
This is the seminal work relating hypergraph transversals to
characteristic models.  Kavvadias et. al. look into the complexity
of computing the Horn envelope of a set of boolean models (the minimal
set of clauses that entail all the models) and the Horn core
(the maximal set of clauses that entail a subset of the models).
"))(POS (PAPER.TOPIC KAVVADIAS93 "Characteristic Models"))(POS (PAPER.INSTANCE KHARDON94))(POS (PAPER.BIBTEX KHARDON94 INPROCEEDINGS))(POS (PAPER.AUTHOR KHARDON94 "Roni Khardon and Dan Roth"))(POS (PAPER.TITLE KHARDON94 "Reasoning with Models"))(POS (PAPER.PUBLICATION KHARDON94 "AAAI"))(POS (PAPER.LINK KHARDON94 "http://citeseer.ist.psu.edu/khardon96reasoning.html"))(POS (PAPER.YEAR KHARDON94 1994))(POS (PAPER.RANK KHARDON94 "[****]"))(POS (PAPER.DESCRIPTION KHARDON94 "
This paper describes a method for determining entailment and abduction
through model-
checking for a KB of full propositional logic over a restricted set of 
queries.   It extends the work of Kautz, et. al. who wrote the seminal
work for propositional Horn KBs.  The definition for characteristic
models relies on Monotone Theory, which describes properties of 
Boolean functions.  It is important to note that these characteristic
models are defined with respect to a class of queries; that is, given
a class of queries, one can compute the characteristic models for
a propositional KB.  That set of models is then the optimal set, 
meaning all models are needed for correct entailment and abduction.
This paper does a thorough treatment of the issues it
brings up, but it is hard to penetrate.  Section 4 is a list of definitions
of Monotone theory, with little motivation or intuition as to the
utility of each definition.  Of course, the rest of the paper relies
on these definitions.  Reread! 
"))(POS (PAPER.TOPIC KHARDON94 "Characteristic Models"))(POS (PAPER.RELATED KHARDON94 KAUTZ93))(POS (PAPER.INSTANCE KHARDON94A))(POS (PAPER.BIBTEX KHARDON94A INPROCEEDINGS))(POS (PAPER.AUTHOR KHARDON94A "Roni Khardon and Dan Roth"))(POS (PAPER.TITLE KHARDON94A "Exploiting Relevance through Model-Based Reasoning"))(POS (PAPER.PUBLICATION KHARDON94A "AAAI"))(POS (PAPER.LINK KHARDON94A "http://citeseer.ist.psu.edu/40071.html"))(POS (PAPER.YEAR KHARDON94A 1994))(POS (PAPER.RANK KHARDON94A "[*****]"))(POS (PAPER.DESCRIPTION KHARDON94A "
Khardon and Roth outline three cases when the relevance can be exploited
to reason more efficiently.  The first deals with context.  Instead of using
all models for logical entailment, use just those that are relevant to 
the current context.  The second use of relevance is in using the Least
Upper Bound approximation of a theory to determine entailment when all 
queries will be answered correctly by the LUB.  Lastly, machine learning
is used to make reasoning easier as it gains experience in the world.
"))(POS (PAPER.TOPIC KHARDON94A "Model-Based Reasoning"))(POS (PAPER.INSTANCE KHARDON95))(POS (PAPER.BIBTEX KHARDON95 ARTICLE))(POS (PAPER.AUTHOR KHARDON95 "Roni Khardon"))(POS (PAPER.TITLE KHARDON95 "Translating between Horn Representations and their Characteristic Models"))(POS (PAPER.PUBLICATION KHARDON95 "Journal of Artificial Intelligence Research"))(POS (PAPER.VOLUME KHARDON95 "3"))(POS (PAPER.STARTPAGE KHARDON95 349))(POS (PAPER.ENDPAGE KHARDON95 372))(POS (PAPER.LINK KHARDON95 "http://citeseer.ist.psu.edu/khardon95translating.html"))(POS (PAPER.YEAR KHARDON95 1995))(POS (PAPER.RANK KHARDON95 "[***]"))(POS (PAPER.DESCRIPTION KHARDON95 "
Khardon builds on the previous work in kautz93 and khardon94 and investigates
the complexity of translating between propositional 
characteristic models and their
horn representations.  He shows that translating either way is polynomial-
reducible to the other, and that both are equivalent to deciding whether
a given set of models is the set of characteristic models of a given
set of horn clauses.  All these problems are at least as hard as converting
a monotone (no negations) CNF formula into a monotone DNF formula.  This
problem has a sub-exponential time solution of n^O(log n).
This paper also gives references to equivalent work in the database 
community under the name Armstrong relations.
"))(POS (PAPER.TOPIC KHARDON95 "Characteristic Models"))(POS (PAPER.RELATED KHARDON95 KAUTZ93))(POS (PAPER.RELATED KHARDON95 KHARDON95))(POS (PAPER.INSTANCE KHARDON95B))(POS (PAPER.BIBTEX KHARDON95B ARTICLE))(POS (PAPER.AUTHOR KHARDON95B "Roni Khardon and Heikki Mannila and Dan Roth"))(POS (PAPER.TITLE KHARDON95B "Reasoning with Examples: Propositional Formulae and Database Dependencies"))(POS (PAPER.PUBLICATION KHARDON95B "Techical Report: Harvard University"))(POS (PAPER.LINK KHARDON95B "http://citeseer.ist.psu.edu/170480.html"))(POS (PAPER.YEAR KHARDON95B 1995))(POS (PAPER.RANK KHARDON95B "[***]"))(POS (PAPER.DESCRIPTION KHARDON95B "
The authors show the connection between characteristic models and Armstrong
relations, i.e. relations that are sufficient for determining logical
entailment of functional dependencies.  They strengthen some of the
results on Armstrong relations and demonstrate a connection between
finding keys and abduction.
"))(POS (PAPER.TOPIC KHARDON95B "Characteristic Models"))(POS (PAPER.RELATED KHARDON95B KAUTZ93))(POS (PAPER.RELATED KHARDON95B KHARDON95))(POS (PAPER.INSTANCE KHARDON97))(POS (PAPER.BIBTEX KHARDON97 ARTICLE))(POS (PAPER.AUTHOR KHARDON97 "Roni Khardon and Dan Roth"))(POS (PAPER.TITLE KHARDON97 "Defaults and Relevance in Model Based Reasoning"))(POS (PAPER.PUBLICATION KHARDON97 "Artificial Intelligence"))(POS (PAPER.VOLUME KHARDON97 "97(1-2)"))(POS (PAPER.STARTPAGE KHARDON97 169))(POS (PAPER.ENDPAGE KHARDON97 193))(POS (PAPER.LINK KHARDON97 "http://citeseer.ist.psu.edu/khardon97defaults.html"))(POS (PAPER.YEAR KHARDON97 1997))(POS (PAPER.RANK KHARDON97 "[****]"))(POS (PAPER.DESCRIPTION KHARDON97 "
This paper explains how model-based reasoning can be used to model reasoning
with context.  Suppose the KB is represented by a set of models M.  As the agent's
context changes, new sentences appear that define that context.  Entailment in
the context then means that the sentence holds in the subset of models M that
satisfy those new sentences.  By representing the theory as a set of models,
as context changes, that set can be reduced online.  In this paper, context
change is represented using default logic.  Algorithms are given for both
skeptical and credulous default reasoning where the knowledge base is represented
as a set of models.  Conditions are given under which these algorithms work
correctly.  Finally, the learning to reason paradigm is brought up as a third
argument for representing a KB as the set of models that satisfy it.  All three,
context, defaults, and learning to reason, sometimes produce computational
benefits because models are used to represent knowledge.
"))(POS (PAPER.TOPIC KHARDON97 "Characteristic Models"))(POS (PAPER.INSTANCE KHARDON98))(POS (PAPER.BIBTEX KHARDON98 ARTICLE))(POS (PAPER.AUTHOR KHARDON98 "Roni Khardon and Heikki Manilla and Dan Roth"))(POS (PAPER.TITLE KHARDON98 "Reasoning with Examples: Propositional Formulae and Database Dependencies"))(POS (PAPER.PUBLICATION KHARDON98 "Acta Informatica"))(POS (PAPER.VOLUME KHARDON98 "36(4)"))(POS (PAPER.STARTPAGE KHARDON98 267))(POS (PAPER.ENDPAGE KHARDON98 286))(POS (PAPER.LINK KHARDON98 "http://citeseer.ist.psu.edu/170480.html"))(POS (PAPER.YEAR KHARDON98 1998))(POS (PAPER.RANK KHARDON98 "[***]"))(POS (PAPER.DESCRIPTION KHARDON98 "
Reasoning with Examples means reasoning with enough models to correctly
determine entailment.  This technique shows up both in the database
literature under the name 'Armstrong Relations' and in the automated
reasoning literature under the name 'Characteristic Models'.  While
the latter refers to a set of examples, the former refers to a single
example.  The number of models needed in Characteristic Models for
propositional logic is bounded by |B|*|DNF(kb)|, where B is the 
basis for the knowledge base kb.  The bulk of this paper shows how the 
two concepts are closely intertwined; it goes on to show that finding 
the keys of a DB is akin to finding abductive explanations in a propositional
knowledge base. 
"))(POS (PAPER.TOPIC KHARDON98 "Characteristic Models"))(POS (PAPER.RELATED KHARDON98 FAGIN82))(POS (PAPER.RELATED KHARDON98 KHARDON95))(POS (PAPER.INSTANCE KIM87))(POS (PAPER.BIBTEX KIM87 ARTICLE))(POS (PAPER.AUTHOR KIM87 "Myung Won Kim"))(POS (PAPER.TITLE KIM87 "On Automatically Generating and Using Examples in a Computational Logic System"))(POS (PAPER.PUBLICATION KIM87 "Technical Report"))(POS (PAPER.LINK KIM87 "http://citeseer.ist.psu.edu/342499.html"))(POS (PAPER.YEAR KIM87 1987))(POS (PAPER.RANK KIM87 "[*]"))(POS (PAPER.DESCRIPTION KIM87 "
Kim's dissertation explores an algorithm for automatically generating 
examples that satisfy a particular constraint given other such examples.
He also explores how such an algorithm can be used to help prune
a theorem-proving search space.  The logic is the Boyer-Moore theory,
and the theorem prover is the Boyer Moore theorem prover.
"))(POS (PAPER.TOPIC KIM87 "Reasoning with Examples"))(POS (PAPER.INSTANCE KIM94))(POS (PAPER.BIBTEX KIM94 INPROCEEDINGS))(POS (PAPER.AUTHOR KIM94 "Sun Kim and Hantao Zhang"))(POS (PAPER.TITLE KIM94 "ModGen: Theorem Proving by Model Generation"))(POS (PAPER.PUBLICATION KIM94 "AAAI"))(POS (PAPER.LINK KIM94 "http://citeseer.ist.psu.edu/kim94modgen.html"))(POS (PAPER.YEAR KIM94 1994))(POS (PAPER.RANK KIM94 "[**]"))(POS (PAPER.DESCRIPTION KIM94 "
The authors describe a system that propositionalizes Otter sentences and then
applies model-checking.  The limitation here is the requirement of a 
finite Herbrand universe.
"))(POS (PAPER.TOPIC KIM94 "Model-Based Reasoning"))(POS (PAPER.INSTANCE KLEER84))(POS (PAPER.BIBTEX KLEER84 INPROCEEDINGS))(POS (PAPER.AUTHOR KLEER84 "Johan de Kleer"))(POS (PAPER.TITLE KLEER84 "Choices without Backtracking"))(POS (PAPER.PUBLICATION KLEER84 "AAAI"))(POS (PAPER.YEAR KLEER84 1984))(POS (PAPER.RANK KLEER84 "[**]"))(POS (PAPER.DESCRIPTION KLEER84 "
Kleer describes a method for increasing the efficiency of problem solving
by storing the assumptions of a derived fact along with that fact.  Doing
this limits the amount of backtracking necessary.  This might be applicable
when backtracking with data structures.  Here it is situated within a truth
maintenance system.
"))(POS (PAPER.TOPIC KLEER84 "Theorem Proving with Attachments"))(POS (PAPER.INSTANCE KOWALSKI69))(POS (PAPER.BIBTEX KOWALSKI69 INBOOK))(POS (PAPER.AUTHOR KOWALSKI69 "Robert Kowalski"))(POS (PAPER.TITLE KOWALSKI69 "Search Strategies for Theorem-Proving"))(POS (PAPER.PUBLICATION KOWALSKI69 "Machine Intelligence"))(POS (PAPER.VOLUME KOWALSKI69 "5"))(POS (PAPER.STARTPAGE KOWALSKI69 181))(POS (PAPER.ENDPAGE KOWALSKI69 201))(POS (PAPER.YEAR KOWALSKI69 1969))(POS (PAPER.RANK KOWALSKI69 "[***]"))(POS (PAPER.DESCRIPTION KOWALSKI69 "
Kowalski abstractly defines the theorem-proving problem in terms of an 
'abstract theorem-proving graph'.  He defines the search space by giving
a specification for each state, the operators that act on those 
states, and a termination condition.  In this case, the tp graph initially
consists of a set of nodes, one for each input axiom.  Further nodes 
(states) are reached (generated) by applying an inference rule to a set
of already reached (generated) nodes.   A search strategy is a mapping
from sets of nodes to other sets of nodes.  Kowalski gives sufficient
(abstract) conditions under which a search strategy is complete.  The
last few sections cover heuristics, their optimality and their 
admissibility.
"))(POS (PAPER.TOPIC KOWALSKI69 "Comparative Analysis"))(POS (PAPER.INSTANCE KOWALSKI79))(POS (PAPER.AUTHOR KOWALSKI79 "Robert Kowalski"))(POS (PAPER.TITLE KOWALSKI79 "Algorithm = Logic + Control"))(POS (PAPER.PUBLICATION KOWALSKI79 "Communications of the ACM"))(POS (PAPER.VOLUME KOWALSKI79 "22(7)"))(POS (PAPER.STARTPAGE KOWALSKI79 424))(POS (PAPER.ENDPAGE KOWALSKI79 436))(POS (PAPER.LINK KOWALSKI79 "http://portal.acm.org/citation.cfm?id=359136&dl=ACM&coll=portal&CFID=6287538&CFTOKEN=93143078"))(POS (PAPER.YEAR KOWALSKI79 1979))(POS (PAPER.RANK KOWALSKI79 "[*****]"))(POS (PAPER.DESCRIPTION KOWALSKI79 "
Kowalski defines an algorithm as Logic and Control.  Logic specifies what the
algorithm does or the knowledge used in
solving a problem.  Control determines the problem-solving strategies, namely
top-down, bottom -up, a combination of the two, and
orthogonally parallelization.  Ideally, the bulk of efficiency concerns
should fall under Control; however, we can improve the efficiency of an
algorithm by adjusting either the Logic or the Control.  
Quote: Computer programs
will be more often correct, more easily improved, and more readily adapted to
new problems when programming languages separate logic and control.
"))(POS (PAPER.TOPIC KOWALSKI79 "Logical Knowledge Representation"))(POS (PAPER.INSTANCE KROTZSCH2005))(POS (PAPER.BIBTEX KROTZSCH2005 TECHREPORT))(POS (PAPER.AUTHOR KROTZSCH2005 "Markus Krotzsch and Pascal Hitzler and Michael Sintek and Denny Vrandecic"))(POS (PAPER.TITLE KROTZSCH2005 "Expressive OWL Reasoning"))(POS (PAPER.PUBLISHER KROTZSCH2005 "University of Kalrsruhe"))(POS (PAPER.LINK KROTZSCH2005 "http://citeseer.ist.psu.edu/733293.html"))(POS (PAPER.YEAR KROTZSCH2005 2005))(POS (PAPER.DESCRIPTION KROTZSCH2005 "
The authors enlarge the class of formulas in OWL DL that can be reasoned
about with a logic programming engine; in addition they present
an alternative characterization of Description Logic Programming.
"))(POS (PAPER.TOPIC KROTZSCH2005 "Semantic Web"))(POS (PAPER.INSTANCE LENAT90))(POS (PAPER.BIBTEX LENAT90 BOOK))(POS (PAPER.AUTHOR LENAT90 "D.B. Lenat and R.V. Guha"))(POS (PAPER.TITLE LENAT90 "Building Large Knowledge-Based Systems: Representation and Inference in the CYC Project"))(POS (PAPER.PUBLISHER LENAT90 "Addison-Wesley"))(POS (PAPER.YEAR LENAT90 1990))(POS (PAPER.DESCRIPTION LENAT90 "
Book on Cyc, the large common-sense knowledge base in Texas.
"))(POS (PAPER.TOPIC LENAT90 "Logical Knowledge Representation"))(POS (PAPER.INSTANCE LENZ98))(POS (PAPER.BIBTEX LENZ98 BOOK))(POS (PAPER.AUTHOR LENZ98 "(ed.) Mario Lenz, et. al."))(POS (PAPER.TITLE LENZ98 "Case-Based Reasoning Technology:From Foundations to Applications (Lecture Notes in Artificial Intelligence)"))(POS (PAPER.LINK LENZ98 "http://www.amazon.com/exec/obidos/tg/detail/-/3540645721/104-6992918-7685512?vi=glance"))(POS (PAPER.YEAR LENZ98 1998))(POS (PAPER.RANK LENZ98 "[***]"))(POS (PAPER.DESCRIPTION LENZ98 "
Case-based reasoning analogically produces solutions to problems through
the use of a case library.  Chapter 1 tries to situate it in the field of
knowledge representation, explain the fundamental process, and describe
the problems to be solved.
"))(POS (PAPER.TOPIC LENZ98 "Case-Based Reasoning"))(POS (PAPER.INSTANCE LESPERANCE95))(POS (PAPER.AUTHOR LESPERANCE95 "Yves Lesperance, Hector J. Levesque, Fangzhen Lin, and Richard B.
Scherl"))(POS (PAPER.TITLE LESPERANCE95 "Ability and Knowing How in the Situation Calculus"))(POS (PAPER.LINK LESPERANCE95 "http://citeseer.ist.psu.edu/lesperance95ability.html"))(POS (PAPER.YEAR LESPERANCE95 1995))(POS (PAPER.DESCRIPTION LESPERANCE95 "
Lesperance et. al. describe 1) a formalism for showing that a given goal can or cannot be accomplished
without simply producing a plan to accomplish it.  This involves discovering whether there is a path of
actions that will lead to the goal at the metalevel.  2) In the plan space that includes sensing actions, nondeterministic
branching, nondeterministic argument-passing, and nondeterministic primitive action choice, the authors formalize the notion that a dumb execution
engine cannot execute all the same plans as an intelligent execution engine.  Building on (1), they
define DumbKnowHow (DKH) and SmartKnowHow (SKH) predicates.  Cool ideas here.  There is also a nice summary
of a formalization of these sensing actions.
"))(POS (PAPER.TOPIC LESPERANCE95 "Fundamentals"))(POS (PAPER.INSTANCE LEUSCHEL2002))(POS (PAPER.BIBTEX LEUSCHEL2002 ARTICLE))(POS (PAPER.AUTHOR LEUSCHEL2002 "Michael Leuschel and Maurice Bruynooghe"))(POS (PAPER.TITLE LEUSCHEL2002 "Logic Program Specialisation Through Partial Deduction: Control Issues"))(POS (PAPER.PUBLICATION LEUSCHEL2002 "Theory and Practice of Logic Programming"))(POS (PAPER.VOLUME LEUSCHEL2002 "2(4-5)"))(POS (PAPER.STARTPAGE LEUSCHEL2002 461))(POS (PAPER.ENDPAGE LEUSCHEL2002 515))(POS (PAPER.LINK LEUSCHEL2002 ""))(POS (PAPER.YEAR LEUSCHEL2002 2002))(POS (PAPER.DESCRIPTION LEUSCHEL2002 "
The authors go through some of the work on partial evaluation in the case
of pure logic programming, which is called partial deduction.  (It differs
from partial evaluation in LP because axioms can be partially partially 
evaluated in the case of non-ground static arguments.)  Partial deduction
means constructing a partial SLDNF tree for a query, and using the fringe
to imply the goal as the output.  Interestingly, with negation, most work 
focuses on preserving operational semantics, as the well-founded semantics
are preserved for all groundings of the goal(s).  This paper focuses on
control issues surrounding the constructing of these SLDNF trees: (1)
given a goal atom A, how do we construct a tree, the local control
problem, and (2) what is the set of all goal atoms, the global control. 
The second problem only occurs because of the desire to preserve
procedural semantics.  The process of unfolding, i.e. constructing
the tree, is difficult because applying too many resolutions can 
result in local code explosion, work duplication, and non
termination.  If the unfold function is guaranteed to produce a tree 
with at most one non-failing
branch, it is said to be determinate; determine unfolding will not
produce code explosion or work duplication.  It is undecidable to determine
whether a tree with at most one non-failing branch can be constructed.
Approximations are usually used.   To deal with termination, binding-time
analysis is used (sometimes computed using abstract interpretation), which
creates annotations that have decided whether to unfold or not.  Instead of
handling termination offline, another approach handles it online--during
specialisation.  Well-founded and well-quasi orders are popular here.  
There is also a discussion of global control issues.  Interestingly,
tabling with partial deduction can turn a terminating program into
a nonterminating program.  Long reference list.
"))(POS (PAPER.TOPIC LEUSCHEL2002 "Reformulation"))(POS (PAPER.INSTANCE LEVESQUE84))(POS (PAPER.BIBTEX LEVESQUE84 CHAPTER))(POS (PAPER.AUTHOR LEVESQUE84 "Hector J. Levesque"))(POS (PAPER.TITLE LEVESQUE84 "The Logic of Incomplete Knowledge Bases"))(POS (PAPER.PUBLISHER LEVESQUE84 "Springer-Verlag"))(POS (PAPER.PUBLICATION LEVESQUE84 "On Conceptual Modelling"))(POS (PAPER.STARTPAGE LEVESQUE84 165))(POS (PAPER.ENDPAGE LEVESQUE84 189))(POS (PAPER.LINK LEVESQUE84 ""))(POS (PAPER.YEAR LEVESQUE84 1984))(POS (PAPER.RANK LEVESQUE84 "[**]"))(POS (PAPER.DESCRIPTION LEVESQUE84 "
Levesque attacks the problem of querying an incomplete knowledge base about its
incompleteness.  How else does one know how accurately the KB represents the domain
it is modeling?  If a query is not entailed, without being able to ask whether the
query itself is known to the KB, we do not know if the query is false or whether
the KB simply doesn't know.  Levesque introduces a language, KL, based on the operator
K for dealing with this problem.  In the end, he claims the interaction of a KB
with a user should be done using this  language, but that any such query can be
translated into straight-up FOL without K.
"))(POS (PAPER.TOPIC LEVESQUE84 "Logical Knowledge Representation"))(POS (PAPER.INSTANCE LEVESQUE85))(POS (PAPER.BIBTEX LEVESQUE85 INBOOK))(POS (PAPER.AUTHOR LEVESQUE85 "Hector J. Levesque and Ronald J. Brachman"))(POS (PAPER.TITLE LEVESQUE85 "A Fundamental Tradeoff in Knowledge Representation and Reasoning"))(POS (PAPER.PUBLISHER LEVESQUE85 "Morgan Kaufmann Publishers"))(POS (PAPER.PUBLICATION LEVESQUE85 "Readings in Knowledge Representation and Reasoning
           "))(POS (PAPER.LINK LEVESQUE85 "http://citeseer.ist.psu.edu/context/54197/0"))(POS (PAPER.YEAR LEVESQUE85 1985))(POS (PAPER.RANK LEVESQUE85 "[***]"))(POS (PAPER.DESCRIPTION LEVESQUE85 "
Levesque and Brachman argue that a perfect representation language does not
exist.  Rather, languages vary in expressiveness and tractability, and some
are only more interesting than others for certain uses.  The authors examine
first-order logic, databases, semantic nets, and frame systems as examples.
"))(POS (PAPER.TOPIC LEVESQUE85 "Logical Knowledge Representation"))(POS (PAPER.INSTANCE LEVESQUE86))(POS (PAPER.AUTHOR LEVESQUE86 "Hector J. Levesque"))(POS (PAPER.TITLE LEVESQUE86 "Making Believers Out of Computers"))(POS (PAPER.PUBLICATION LEVESQUE86 "Artificial Intelligence"))(POS (PAPER.VOLUME LEVESQUE86 "30(1)"))(POS (PAPER.STARTPAGE LEVESQUE86 81))(POS (PAPER.ENDPAGE LEVESQUE86 108))(POS (PAPER.YEAR LEVESQUE86 1986))(POS (PAPER.RANK LEVESQUE86 "[***]"))(POS (PAPER.DESCRIPTION LEVESQUE86 "
Levesque argues that the combinatorial explosion of exponential-time
algorithms cannot be tolerated for AI systems, except for a 'puzzle-mode'.  
To that end, he advises building knowledge bases using languages that
only allow complete ('vivid') information and using 
reasoning methods that may at times be unsound and/or incomplete.  His
examples invoke the reader's imagination to invent a pictures that model
the example descriptions.  Such descriptions can then be considered vivid.
"))(POS (PAPER.TOPIC LEVESQUE86 "Logical Knowledge Representation"))(POS (PAPER.INSTANCE LEVESQUE96))(POS (PAPER.AUTHOR LEVESQUE96 "Hector J. Levesque"))(POS (PAPER.TITLE LEVESQUE96 "What is Planning in the presence of sensing?"))(POS (PAPER.LINK LEVESQUE96 "http://www.cs.toronto.edu/cogrobo/Papers/sensing.pdf"))(POS (PAPER.YEAR LEVESQUE96 1996))(POS (PAPER.DESCRIPTION LEVESQUE96 "

Intro: Classical planning doesn't deal with the problem of sensing or looping, e.g. it cannot produce plans that will successfully achieve the Airport or the Omlette examples.  Sensing is necessary iff there are properties of the world that cannot be deduced at plan time but that are required for achieving the goal.

<br><br>Classical Planning: Use sit calc to formally define the classical planning problem.  It is unclear to me whether the sit calc he is using would somehow allow there to be partial order plans, e.g. return something like (do (parallel a b c) (do (parallel e f) (do h s0))).  For now let's say it can't and sitcalc plans must be total orders.  We might argue that because his definition is tied to sitcalc, which produces only totally ordered plans, his 'definition' of the classical planning problem is wrong.  But it doesn't really matter for the rest of what he is going to say.

Incorporating sensing actions: gives an overview of another one of his papers which introduces sensing actions into sitcalc, and reviews some related work.

<br><br>Robot programs: introduces a language for describing plans that is more expressive than the standard sitcalc (do a (do b (do .... s0)))) and partial order languages.  Includes loops and branches.  He defines the semantics of the language in situation calculus, relying on a new second order construct for defining the semantics of a loop.  Finally, he states the first theorem, which amounts to a set of rewrite rules for each of the new constructs in the robot language, where the rewrite rules allow one to construct an interpreter for the language.  That is, the obvious interpreter for the language does the right thing, and the theorem proves that.

The revised planning task: formalize, using the machinery built up above, the planning problem as it includes loops, branches, and sensing.  Remember this is all sitcalc in first-order logic + a couple second-order constructs.  The rest of the section works through the Airport example.

<br><br>Note: Importantly, all the examples thusfar, as well as the definition of the planning task requires a _deductive_ solution.  That is, the airport example includes the axiom AtGate(a) | AtGate(b).  At plan-time we can prove that the plan (seq goto-airport (if check-gate(a) then goto-gate-a else goto-gate-b)) will work.  This is unlike our room reservation example since there may be no room to reserve, but we won't know that until plan execution time.  At plan-time, there is no plan we can prove will work.

<br><br>Are robot programs enough?: They claim the original plan language is not sufficient for expressing plans for every solvable planning problem.  The reason is that there is no memory available for the program to use.  Asking for a plan that returns the number of eggs it is given at runtime cannot be achieved without (infinite) memory.  Levesque adds 5 actions (left, right, mark, erase, read_mark) that can be used to expand the plans expressible by his robot language to include (he claims) everything that is computable.  That is, his planning language with these additional actions would force a planner to construct a Turing Machine that achieves the given goal.  Of course, that problem is undecidable.  

<br><br>A two sentence summary.  Levesque introduces a plan description language that includes branching and loops (with an extension that he claims makes the language Turing complete), for the simple reason that solving some real world planning problems requires sensing and looping.  He formalizes the planning problem as one of deduction, which has the benefit that deductive solutions will always be right but has the drawback that it eliminates plans that we might expect a machine to produce, e.g. room reservation.


"))(POS (PAPER.TOPIC LEVESQUE96 "Planning with Sensing Actions"))(POS (PAPER.INSTANCE LEVESQUE97))(POS (PAPER.AUTHOR LEVESQUE97 "Levesque, et al."))(POS (PAPER.TITLE LEVESQUE97 "Golog: A Logic Programming Language for Dynamic Domains"))(POS (PAPER.LINK LEVESQUE97 "http://citeseer.ist.psu.edu/27198.html"))(POS (PAPER.YEAR LEVESQUE97 1997))(POS (PAPER.DESCRIPTION LEVESQUE97 "
Golog does macro-replacement into situation calculus from nondeterministic parameter choice, nondeterministic action choice, nondeterministic iteration, test actions, and procedures.  This macro-replacement means answer extraction cannot be used to extract a complex plan using the above constructs.  Instead, given a complex plan, the Golog interpreter produces an equivalent situation calculus plan(I think--still fuzzy here).
"))(POS (PAPER.TOPIC LEVESQUE97 "Logic Programming"))(POS (PAPER.INSTANCE LEVESQUE98))(POS (PAPER.AUTHOR LEVESQUE98 "Hector Levesque, Fiora Pirri, and Ray Reiter"))(POS (PAPER.TITLE LEVESQUE98 "Foundations for the Situation Calculus"))(POS (PAPER.PUBLICATION LEVESQUE98 "Linkoping Electronic Articles in Computer and Information Science"))(POS (PAPER.VOLUME LEVESQUE98 "3"))(POS (PAPER.LINK LEVESQUE98 "http://citeseer.ist.psu.edu/levesque98foundations.html"))(POS (PAPER.YEAR LEVESQUE98 1998))(POS (PAPER.RANK LEVESQUE98 "[***]"))(POS (PAPER.DESCRIPTION LEVESQUE98 "
This is a rehash of Pirri99, except they add in a
section describing sensing and knowledge in Situation Calculus.  They extend
their definition of a basic action theory to include knowledge-producing
actions.  Namely, a knowledge-action theory D_e = Sigma_e U D_ss U D_ap U D_una
U D_S0 U D_sf U D_k0.  Sigma_e is an expanded set of foundational axioms; D_ss
are the successor state axioms; D_ap are the action precondition axioms;
D_una are the unique name axioms for actions; D_s0 is the initial situation;
D_k0 is an initial knowldge axiom (what the agent knows in S0).  This stuff
gets pretty messy, but eventually they provide a solution to the knowledge
frame problem, i.e. "))(POS (PAPER.TOPIC LEVESQUE98 "Fundamentals"))(POS (PAPER.INSTANCE LIFSCHITZ2002))(POS (PAPER.BIBTEX LIFSCHITZ2002 ARTICLE))(POS (PAPER.AUTHOR LIFSCHITZ2002 "V. Lifschitz"))(POS (PAPER.TITLE LIFSCHITZ2002 "Answer set programming and plan generation"))(POS (PAPER.PUBLICATION LIFSCHITZ2002 "Artificial Intelligence"))(POS (PAPER.VOLUME LIFSCHITZ2002 "138(1-2)"))(POS (PAPER.STARTPAGE LIFSCHITZ2002 39))(POS (PAPER.ENDPAGE LIFSCHITZ2002 54))(POS (PAPER.LINK LIFSCHITZ2002 "http://citeseer.ist.psu.edu/301403.html"))(POS (PAPER.YEAR LIFSCHITZ2002 2002))(POS (PAPER.DESCRIPTION LIFSCHITZ2002 "
Answer set programming paper by Lifschitz.
"))(POS (PAPER.TOPIC LIFSCHITZ2002 "Logic Programming"))(POS (PAPER.INSTANCE LIFSCHITZ85))(POS (PAPER.BIBTEX LIFSCHITZ85 ARTICLE))(POS (PAPER.AUTHOR LIFSCHITZ85 "Vladimir Lifschitz"))(POS (PAPER.TITLE LIFSCHITZ85 "Closed World Databases and Circumscription"))(POS (PAPER.PUBLICATION LIFSCHITZ85 "Artificial Intelligence"))(POS (PAPER.VOLUME LIFSCHITZ85 "27(2)"))(POS (PAPER.STARTPAGE LIFSCHITZ85 229))(POS (PAPER.ENDPAGE LIFSCHITZ85 235))(POS (PAPER.YEAR LIFSCHITZ85 1985))(POS (PAPER.DESCRIPTION LIFSCHITZ85 "
Lifschitz proves the following theorem.  If CWA is consistent,
then CWA and Circumscription produce 
equivalent theories when applied to universal, closed sentences in a
function-free, equality-free vocabulary with finitely many relation and
object constants whenever the domain closure assumption and unique
names assumption are in play.
"))(POS (PAPER.TOPIC LIFSCHITZ85 "Non-monotonic Reasoning"))(POS (PAPER.INSTANCE LIFSCHITZ87))(POS (PAPER.AUTHOR LIFSCHITZ87 "V. Lifschitz"))(POS (PAPER.TITLE LIFSCHITZ87 "On the semantics of STRIPS"))(POS (PAPER.PUBLICATION LIFSCHITZ87 "Reasoning About Actions and Plans"))(POS (PAPER.STARTPAGE LIFSCHITZ87 1))(POS (PAPER.ENDPAGE LIFSCHITZ87 9))(POS (PAPER.LINK LIFSCHITZ87 "http://www.cs.utexas.edu/users/vl/papers-old.html"))(POS (PAPER.YEAR LIFSCHITZ87 1987))(POS (PAPER.DESCRIPTION LIFSCHITZ87 "
Lifschitz gives semantics to Fike's and Nilsson's STRIPS.  He gives one definition of a STRIPS system's soundness that relies on atomic sentences for both the add and delete lists (effectively).  All non-atomic sentences must be true in all worlds.  The preconditions can still be full FOL.  Lifschitz goes on to explain how to deal with peculiarities to improve efficiency, e.g. only including nextTo(a,b) when nextTo(x,y) is symmetric.
"))(POS (PAPER.TOPIC LIFSCHITZ87 "Historical"))(POS (PAPER.INSTANCE LIFSCHITZ96))(POS (PAPER.BIBTEX LIFSCHITZ96 CHAPTER))(POS (PAPER.AUTHOR LIFSCHITZ96 "Vladimir Lifschitz"))(POS (PAPER.TITLE LIFSCHITZ96 "Foundations of Logic Programming"))(POS (PAPER.PUBLICATION LIFSCHITZ96 "Principles of Knowledge Representation"))(POS (PAPER.STARTPAGE LIFSCHITZ96 69))(POS (PAPER.ENDPAGE LIFSCHITZ96 127))(POS (PAPER.LINK LIFSCHITZ96 "http://citeseer.ist.psu.edu/lifschitz96foundations.html"))(POS (PAPER.YEAR LIFSCHITZ96 1996))(POS (PAPER.DESCRIPTION LIFSCHITZ96 "
Survey of logic programming theory.
"))(POS (PAPER.TOPIC LIFSCHITZ96 "Logic Programming"))(POS (PAPER.INSTANCE LIN94))(POS (PAPER.AUTHOR LIN94 "Fangzhen Lin and Ray Reiter"))(POS (PAPER.TITLE LIN94 "How to Progress a Database (and Why) I. Logical Foundations"))(POS (PAPER.PUBLICATION LIN94 "Principles of Knowledge Representation and Reasoning "))(POS (PAPER.STARTPAGE LIN94 425))(POS (PAPER.ENDPAGE LIN94 436))(POS (PAPER.LINK LIN94 "http://citeseer.ist.psu.edu/11152.html"))(POS (PAPER.YEAR LIN94 1994))(POS (PAPER.RANK LIN94 "[****]"))(POS (PAPER.DESCRIPTION LIN94 "
Lin and Reiter argue that STRIPS (planning) can be thought of as progressing an initial database S0 with an action sequence A to a final database SA.  They prove the general problem cannot be solved using only FOL, but in fact properly needs induction.  The special cases of 'relatively complete' initial databases and 'context-free' action theories (with certain restrictions on the initial database) yield first-order theories.
"))(POS (PAPER.TOPIC LIN94 "Theories of Action"))(POS (PAPER.INSTANCE LIN95A))(POS (PAPER.AUTHOR LIN95A "Fangzhen Lin and Ray Reiter"))(POS (PAPER.TITLE LIN95A "How to Progress a Database II: The STRIPS Connection"))(POS (PAPER.PUBLICATION LIN95A "IJCAI"))(POS (PAPER.STARTPAGE LIN95A 2001))(POS (PAPER.ENDPAGE LIN95A 2009))(POS (PAPER.LINK LIN95A "http://citeseer.ist.psu.edu/lin94how.html"))(POS (PAPER.YEAR LIN95A 1995))(POS (PAPER.RANK LIN95A "[*]"))(POS (PAPER.DESCRIPTION LIN95A "
Lin and Reiter build on the first part of this paper and give certain varieties of STRIPS semantics based on progressing a database.  
"))(POS (PAPER.TOPIC LIN95A "Theories of Action"))(POS (PAPER.RELATED LIN95A LIN94))(POS (PAPER.INSTANCE LIN95B))(POS (PAPER.AUTHOR LIN95B "Fangzhen Lin and Yoav Shoham"))(POS (PAPER.TITLE LIN95B "Provably Correct Theories of Action"))(POS (PAPER.PUBLICATION LIN95B "Journal of the ACM"))(POS (PAPER.VOLUME LIN95B "42(2)"))(POS (PAPER.STARTPAGE LIN95B 293))(POS (PAPER.ENDPAGE LIN95B 320))(POS (PAPER.LINK LIN95B "http://citeseer.ist.psu.edu/lin91provably.html"))(POS (PAPER.YEAR LIN95B 1995))(POS (PAPER.RANK LIN95B "[****]"))(POS (PAPER.DESCRIPTION LIN95B "
Lin and Shoham give a formal definition for epistemologically complete theories of action.  They explain monotonic and nonmonotonic completions of action theories; the former requires frame axioms and the latter circumscription.   They go on to extend situation calculus to handle concurrent actions by bundling primitive actions together into 'global actions'.  They extend their definition for epistemological completeness to encompass this variation of sitcalc.
"))(POS (PAPER.TOPIC LIN95B "Theories of Action"))(POS (PAPER.INSTANCE LLOYD))(POS (PAPER.BIBTEX LLOYD BOOK))(POS (PAPER.AUTHOR LLOYD "John Lloyd"))(POS (PAPER.TITLE LLOYD "Foundations of Logic Programming"))(POS (PAPER.PUBLISHER LLOYD "Springer Verlag"))(POS (PAPER.LINK LLOYD "http://www.amazon.com/Foundations-Logic-Programming-Symbolic-Computation/dp/0387181997"))(POS (PAPER.YEAR LLOYD 1984))(POS (PAPER.RANK LLOYD "[*****]"))(POS (PAPER.DESCRIPTION LLOYD "
Lloyd covers the declarative and procedural semantics of logic programming without
negation and then considers the case of an acyclic logic program with negation,
and proves soundness and completeness via predicate completion.  The classic text.
"))(POS (PAPER.TOPIC LLOYD ""))(POS (PAPER.INSTANCE LLOYD84))(POS (PAPER.BIBTEX LLOYD84 ARTICLE))(POS (PAPER.AUTHOR LLOYD84 "J. Lloyd and R. Topor"))(POS (PAPER.TITLE LLOYD84 "Making Prolog more expressive"))(POS (PAPER.PUBLICATION LLOYD84 "Journal of Logic Programming"))(POS (PAPER.VOLUME LLOYD84 "1(3)"))(POS (PAPER.STARTPAGE LLOYD84 225))(POS (PAPER.ENDPAGE LLOYD84 240))(POS (PAPER.YEAR LLOYD84 1984))(POS (PAPER.DESCRIPTION LLOYD84 "
Includes the Lloyd-Topor transformation.
"))(POS (PAPER.TOPIC LLOYD84 "Logic Programming"))(POS (PAPER.INSTANCE LOBO))(POS (PAPER.BIBTEX LOBO BOOK))(POS (PAPER.AUTHOR LOBO "Jorge Lobo and Jack Minker and Arcot Rajasekar"))(POS (PAPER.TITLE LOBO "Foundations of Disjunctive Logic Programming"))(POS (PAPER.PUBLISHER LOBO "The MIT Press"))(POS (PAPER.LINK LOBO "http://mitpress.mit.edu/catalog/item/default.asp?ttype=2&tid=5834"))(POS (PAPER.YEAR LOBO 1992))(POS (PAPER.DESCRIPTION LOBO "
Book laying the foundations of disjunctive logic programming.
"))(POS (PAPER.TOPIC LOBO ""))(POS (PAPER.INSTANCE LOCHNER02))(POS (PAPER.BIBTEX LOCHNER02 ARTICLE))(POS (PAPER.AUTHOR LOCHNER02 "Bernd Loechner and Thomas Hillenbrand"))(POS (PAPER.TITLE LOCHNER02 "A phytography of Waldmeister"))(POS (PAPER.PUBLICATION LOCHNER02 "AI Communications"))(POS (PAPER.VOLUME LOCHNER02 "15"))(POS (PAPER.STARTPAGE LOCHNER02 127))(POS (PAPER.ENDPAGE LOCHNER02 133))(POS (PAPER.LINK LOCHNER02 "http://citeseer.ist.psu.edu/558093.html"))(POS (PAPER.YEAR LOCHNER02 2002))(POS (PAPER.RANK LOCHNER02 ""))(POS (PAPER.DESCRIPTION LOCHNER02 "
Waldmeister is a unit equation theorem prover based on
unfailing completion.  Its architecture is the same
Discount algorithm found in Vampire and E.  Written in C,
it uses perfect discrimination trees (a variation on the trie)
to index terms.  It also includes automated tuning of 
its parameters, based on TPTP experience.
"))(POS (PAPER.TOPIC LOCHNER02 "System Designs"))(POS (PAPER.INSTANCE LOECHNER2004))(POS (PAPER.AUTHOR LOECHNER2004 "Bernd Loechner"))(POS (PAPER.TITLE LOECHNER2004 "Things to know when implementing LPO"))(POS (PAPER.PUBLICATION LOECHNER2004 "Workshop on Empirically Successful First Ordering Reasoning"))(POS (PAPER.LINK LOECHNER2004 ""))(POS (PAPER.YEAR LOECHNER2004 2004))(POS (PAPER.DESCRIPTION LOECHNER2004 "
Loechner explains that the naive implementation of Lexicographic Path
Ordering is exponential but then goes on to show how to make it
multiplicative in the size of the two terms.  
"))(POS (PAPER.TOPIC LOECHNER2004 "Orderings"))(POS (PAPER.INSTANCE LOPEZGARCIA2004))(POS (PAPER.BIBTEX LOPEZGARCIA2004 ARTICLE))(POS (PAPER.AUTHOR LOPEZGARCIA2004 "P. Lopez-Garcia and F. Bueno and M. Hermenegildo"))(POS (PAPER.TITLE LOPEZGARCIA2004 "Determinacy Analysis for Logic Programs Using Mode and Type Information"))(POS (PAPER.PUBLICATION LOPEZGARCIA2004 "14th International Symposium, Logic Based Program Synthesis and Trnasformation (LOPSTR)"))(POS (PAPER.STARTPAGE LOPEZGARCIA2004 19))(POS (PAPER.ENDPAGE LOPEZGARCIA2004 35))(POS (PAPER.LINK LOPEZGARCIA2004 "http://wotan.liu.edu/docis/dbl/lopstr/index.html"))(POS (PAPER.YEAR LOPEZGARCIA2004 2004))(POS (PAPER.DESCRIPTION LOPEZGARCIA2004 "
In the context of Logic programming, the authors consider two problems:
(1) detecting whether a relation will ever return more than one answer
through all control paths, i.e. whether the relation is determinate,
 and (2) determining whether more than one
rule with for a relation will ever be satisfied for
the same query, i.e. whether the rules defining that relation
are mutually exclusive.  Addressing these questions relies on type
information, i.e. all the possible queries asked for a relation, and
mode information, i.e. whether a variable is used for validation or
for generation.  For r to be determinate, it is sufficient
that every relation that is a subgoal of r be mutually exclusive.
Thus an approximation of (1) can be accomplished by computing (2).  The test
for mutual exclusion offered here will return true only when all the 
rules for a relation contain procedural attachments that can be shown
to be mutually exclusive for all the types of the relation.  Experimental
results are shown for the case where the procedural attachments are
equality/distinction/inequality.
"))(POS (PAPER.TOPIC LOPEZGARCIA2004 "Reformulation"))(POS (PAPER.INSTANCE MANNA86))(POS (PAPER.AUTHOR MANNA86 "Zohar Manna"))(POS (PAPER.TITLE MANNA86 "How to Clear a Block: A Theory of Plans"))(POS (PAPER.LINK MANNA86 "http://library.stanford.edu/depts/mathcs/mathcscoll/techreports.html"))(POS (PAPER.YEAR MANNA86 1986))(POS (PAPER.DESCRIPTION MANNA86 "
This is the recursive plan paper everyone cites; not surprisingly, it shows up in the context of
program synthesis.  Manna uses Deductive Tableaux to produce programs that contain conditionals
(via a special inference rule) and recursion (using a well-founded mathematical
induction axiom).  The problem with Manna's recursion lies in the need for what he calls
Generalization, i.e. automatically strengthening the stated goal.  Manna also deals
with equality by building it into the unification algorithm.
"))(POS (PAPER.TOPIC MANNA86 "Recursive Plan Generation"))(POS (PAPER.INSTANCE MANNA94))(POS (PAPER.BIBTEX MANNA94 INBOOK))(POS (PAPER.AUTHOR MANNA94 "Zohar Manna et. al."))(POS (PAPER.TITLE MANNA94 "STeP: the Stanford Temporal Prover"))(POS (PAPER.PUBLICATION MANNA94 "TAPSOFT"))(POS (PAPER.LINK MANNA94 "http://citeseer.ist.psu.edu/manna94step.html"))(POS (PAPER.YEAR MANNA94 1994))(POS (PAPER.RANK MANNA94 "[*]"))(POS (PAPER.DESCRIPTION MANNA94 "
STeP is a verification system that proves first order temporal 
formulas valid in concurrent, reactive systems described in SPL.  
It combines equational and arithmetic simplification, model 
checking, interactive first-order theorem proving, and automatic
invariant generation.  The model checking is done through 
Streett automaton and behavior automaton.  The first-order
theorem proving is automated with non-clausal resolution
and paramodulation and utilizes lemmas.  The interactive
theorem proving is handled with a Gentzen-style prover:
both first-order and temporal first-order.  Propositional
temporal formulas can be automatically verified.
This paper is well-written and clear, but assumes knowledge
of temporal logic and transition systems.
"))(POS (PAPER.TOPIC MANNA94 "Model Checking"))(POS (PAPER.INSTANCE MANTHEY88))(POS (PAPER.BIBTEX MANTHEY88 INPROCEEDINGS))(POS (PAPER.AUTHOR MANTHEY88 "Rainer Manthey and Francois Bry"))(POS (PAPER.TITLE MANTHEY88 "SATCHMO: A Theorem Prover Implemented in Prolog"))(POS (PAPER.PUBLICATION MANTHEY88 "Proceedings of the Conference on Automated Deduction"))(POS (PAPER.STARTPAGE MANTHEY88 415))(POS (PAPER.ENDPAGE MANTHEY88 434))(POS (PAPER.YEAR MANTHEY88 1988))(POS (PAPER.DESCRIPTION MANTHEY88 "
Tableaux-style prover implemented in Prolog, using assert and retract.
"))(POS (PAPER.TOPIC MANTHEY88 "Calculi"))(POS (PAPER.INSTANCE MARRAFA91))(POS (PAPER.BIBTEX MARRAFA91 ARTICLE))(POS (PAPER.AUTHOR MARRAFA91 "Palmira Marrafa and Patrick Saint-Dizier"))(POS (PAPER.TITLE MARRAFA91 "Reversibility in a Constraint and Type based Logic Grammar"))(POS (PAPER.LINK MARRAFA91 "http://acl.ldc.upenn.edu/W/W91/W91-0102.pdf"))(POS (PAPER.YEAR MARRAFA91 1991))(POS (PAPER.RANK MARRAFA91 "[***]"))(POS (PAPER.DESCRIPTION MARRAFA91 "
In the topic of reversible grammars.
Marrafa and Saint-Dizier introduce a mathematical language for 
describing natural languages.  The mathematical language includes certain
object-oriented concepts. In addition, abstract machines for parsing and
generating languages so described are given.
"))(POS (PAPER.TOPIC MARRAFA91 "Natural Language Processing"))(POS (PAPER.INSTANCE MASTERS2003))(POS (PAPER.BIBTEX MASTERS2003 ARTICLE))(POS (PAPER.AUTHOR MASTERS2003 "James Masters and Zelai Gungordu"))(POS (PAPER.TITLE MASTERS2003 "Semantic Knowledge Source Integration: A Progress Report"))(POS (PAPER.PUBLICATION MASTERS2003 "Integration of Knowledge Intensive Multi-Agent Systems"))(POS (PAPER.YEAR MASTERS2003 2003))(POS (PAPER.RANK MASTERS2003 ""))(POS (PAPER.DESCRIPTION MASTERS2003 "
Paper on using a database to speed up theorem proving.  Here they want togive a TP access to the information contained in several databases.
"))(POS (PAPER.TOPIC MASTERS2003 "Theorem Proving with Attachments"))(POS (PAPER.INSTANCE MATZINGER97))(POS (PAPER.BIBTEX MATZINGER97 TECHREPORT))(POS (PAPER.AUTHOR MATZINGER97 "Robert Matzinger"))(POS (PAPER.TITLE MATZINGER97 "Comparing Computational Representations of Herbrand Models"))(POS (PAPER.LINK MATZINGER97 "http://www.kr.tuwien.ac.at/guests/matzi/publications.html"))(POS (PAPER.YEAR MATZINGER97 1997))(POS (PAPER.RANK MATZINGER97 "[*****]"))(POS (PAPER.DESCRIPTION MATZINGER97 "
Matzinger investigates various representations of models and
answers three complexity questions for each representation:
ground atom entailment, clause entailment, model equivalence.
The two representations of finite models examined are
context-free grammers and atom representations.  Both CFGs
and ground atoms plus ground equations are equivalent
to finite models, i.e. both representations have an associated
finite model and every finite model has a submodel that
is equivalent to both representations.
Different subsets of all infinite models can be represented by 
term schematizations and constrained atoms.  They seem to be
incomparable.  This paper is pretty dense, but also very important.
"))(POS (PAPER.TOPIC MATZINGER97 "Model-Based Reasoning"))(POS (PAPER.INSTANCE MCCARTHY59))(POS (PAPER.AUTHOR MCCARTHY59 "John McCarthy"))(POS (PAPER.TITLE MCCARTHY59 "Programs with Common Sense"))(POS (PAPER.PUBLICATION MCCARTHY59 "Proceedings of the Teddington Conference on the
                Mechanization of Thought Processes"))(POS (PAPER.STARTPAGE MCCARTHY59 77))(POS (PAPER.ENDPAGE MCCARTHY59 81))(POS (PAPER.LINK MCCARTHY59 "http://www-formal.stanford.edu/jmc/mcc59.html"))(POS (PAPER.YEAR MCCARTHY59 1958))(POS (PAPER.RANK MCCARTHY59 "[*****]"))(POS (PAPER.DESCRIPTION MCCARTHY59 "
Most likely the first paper on logical AI, i.e. the advice taker paper.
It describes a system(the advice taker) that can be told sentences in logic
and can draw conclusions about the world from its knowledge base.
"))(POS (PAPER.TOPIC MCCARTHY59 "Logical Knowledge Representation"))(POS (PAPER.INSTANCE MCCARTHY80))(POS (PAPER.BIBTEX MCCARTHY80 ARTICLE))(POS (PAPER.AUTHOR MCCARTHY80 "John McCarthy"))(POS (PAPER.TITLE MCCARTHY80 "Circumscription -- a form of non-monotonic reasoning"))(POS (PAPER.PUBLICATION MCCARTHY80 "Artificial Intelligence"))(POS (PAPER.VOLUME MCCARTHY80 "13"))(POS (PAPER.STARTPAGE MCCARTHY80 27))(POS (PAPER.ENDPAGE MCCARTHY80 39))(POS (PAPER.YEAR MCCARTHY80 1988))(POS (PAPER.DESCRIPTION MCCARTHY80 "
Circumscription.
"))(POS (PAPER.TOPIC MCCARTHY80 "Non-monotonic Reasoning"))(POS (PAPER.INSTANCE MCCARTHY82))(POS (PAPER.BIBTEX MCCARTHY82 TECHREPORT))(POS (PAPER.AUTHOR MCCARTHY82 "John McCarthy"))(POS (PAPER.TITLE MCCARTHY82 "Coloring Maps and the Kowalski Doctrine"))(POS (PAPER.PUBLISHER MCCARTHY82 "Stanford University"))(POS (PAPER.YEAR MCCARTHY82 1982))(POS (PAPER.DESCRIPTION MCCARTHY82 "
Paper that analyzes various formulations of the map coloring problem
written in Prolog.  Looks at various reorderings of subgoals.
"))(POS (PAPER.TOPIC MCCARTHY82 "Logic Programming"))(POS (PAPER.INSTANCE MCCHAY69))(POS (PAPER.AUTHOR MCCHAY69 "John McCarthy and Patrick J. Hayes"))(POS (PAPER.TITLE MCCHAY69 "Some Philosophical Problems from the Standpoint of Artificial Intelligence"))(POS (PAPER.PUBLICATION MCCHAY69 "Machine Intelligence 4"))(POS (PAPER.STARTPAGE MCCHAY69 463))(POS (PAPER.ENDPAGE MCCHAY69 502))(POS (PAPER.LINK MCCHAY69 "http://www-formal.stanford.edu/jmc/mcchay69.html"))(POS (PAPER.YEAR MCCHAY69 1969))(POS (PAPER.DESCRIPTION MCCHAY69 "
The basic situation calculus paper.  McCarthy and Hayes consider not only the classic planning environment (fully-observable), but also a partially-observable one, introducing what are now referred to as 'sensing actions'.  They attempt a self-proclaimed ad-hoc approach to handling these sensing actions.  They also point out the frame problem, alluding to a state vector as a possible solution.  The qualification problem (though they don't name it that) shows up here, along with the introduction of the modal operators consistent(phi), probably(phi), and normally(phi) as a tentative solution avenue.  Finally, McCarthy and Hayes look into embedding Modal Logic, Logic of Knowledge (Hintikka), Tense Logics, and a couple of others into situation calculus.
"))(POS (PAPER.TOPIC MCCHAY69 "Historical"))(POS (PAPER.INSTANCE MCCUNE2001))(POS (PAPER.BIBTEX MCCUNE2001 MISC))(POS (PAPER.AUTHOR MCCUNE2001 "William McCune"))(POS (PAPER.TITLE MCCUNE2001 "Mace 2.0 Reference Manual and Guide"))(POS (PAPER.LINK MCCUNE2001 "http://citeseer.ist.psu.edu/464179.html"))(POS (PAPER.YEAR MCCUNE2001 2001))(POS (PAPER.DESCRIPTION MCCUNE2001 "
Manual for Mace 2.0, a finite model builder that grounds out formulas
and relies on a SAT solver.
"))(POS (PAPER.TOPIC MCCUNE2001 "Model Building"))(POS (PAPER.INSTANCE MCCUNE2003))(POS (PAPER.BIBTEX MCCUNE2003 TECHREPORT))(POS (PAPER.AUTHOR MCCUNE2003 "William McCune"))(POS (PAPER.TITLE MCCUNE2003 "Mace4 Reference Manual and Guide"))(POS (PAPER.PUBLISHER MCCUNE2003 "Argonne National Laboratory"))(POS (PAPER.LINK MCCUNE2003 "http://www-unix.mcs.anl.gov/AR/mace4/July-2005/doc/mace4.pdf"))(POS (PAPER.YEAR MCCUNE2003 2003))(POS (PAPER.DESCRIPTION MCCUNE2003 "
The reference manual for Mace4.  Unlike its predecessors, which flattened
formulas, ground them, and used a SAT solver, Mace4 incrementally constructs
a model and after each instantiation computes the consequences of the
instantiation wrt the sentences of interest.
"))(POS (PAPER.TOPIC MCCUNE2003 "Model Building"))(POS (PAPER.INSTANCE MCDONALD91))(POS (PAPER.BIBTEX MCDONALD91 ARTICLE))(POS (PAPER.AUTHOR MCDONALD91 "D. McDonald"))(POS (PAPER.TITLE MCDONALD91 "Reversible NLP by Deriving the Grammars from the Knowledge Base"))(POS (PAPER.LINK MCDONALD91 "http://acl.ldc.upenn.edu/W/W91/W91-0106.pdf"))(POS (PAPER.YEAR MCDONALD91 1991))(POS (PAPER.RANK MCDONALD91 "[***]"))(POS (PAPER.DESCRIPTION MCDONALD91 "
Reversible grammars.
McDonald presents an architecture for constructing a parsing grammar and
an acceptance grammar from a single knowledge base and semantic model.  Thus
the strongest techniques for both parsing and generation can be used without
losing the simplicity of maintenance derived from  using a single, 
reversible grammar.
"))(POS (PAPER.TOPIC MCDONALD91 "Natural Language Processing"))(POS (PAPER.INSTANCE MCILRAITH98))(POS (PAPER.BIBTEX MCILRAITH98 ARTICLE))(POS (PAPER.AUTHOR MCILRAITH98 "Sheila McIlraith"))(POS (PAPER.TITLE MCILRAITH98 "Logic-based Abductive Inference"))(POS (PAPER.PUBLICATION MCILRAITH98 "Knowledge Systems Lab Technical Report KSL98-19"))(POS (PAPER.LINK MCILRAITH98 "http://citeseer.ist.psu.edu/mcilraith98logicbased.html"))(POS (PAPER.YEAR MCILRAITH98 1998))(POS (PAPER.DESCRIPTION MCILRAITH98 "
McIlraith covers various ways to operationalize abduction, i.e. finding
an augmentation to a logical knowledge base such that a given query
is entailed. 
"))(POS (PAPER.TOPIC MCILRAITH98 "Abduction"))(POS (PAPER.INSTANCE MCKENZIE97))(POS (PAPER.BIBTEX MCKENZIE97 TECHREPORT))(POS (PAPER.AUTHOR MCKENZIE97 "Bruce McKenzie"))(POS (PAPER.TITLE MCKENZIE97 "Generating Strings at Random from a Context Free Grammar"))(POS (PAPER.LINK MCKENZIE97 "http://coscweb2.cosc.canterbury.ac.nz/research/reports/TechReps/#year1997"))(POS (PAPER.YEAR MCKENZIE97 1997))(POS (PAPER.RANK MCKENZIE97 "[***]"))(POS (PAPER.DESCRIPTION MCKENZIE97 "
McKenzie gives an algorithm for generating strings of length n from a CFG 
so that all strings of length n are equally likely.  The preprocessing
portion of the algorithm requires O(n^2) time and O(n^2) space.  The
generation portion requires O(n) time and space.
"))(POS (PAPER.TOPIC MCKENZIE97 "Context Free Grammars"))(POS (PAPER.INSTANCE MENG20067))(POS (PAPER.AUTHOR MENG20067 "Jia Meng and L.C. Paulson"))(POS (PAPER.TITLE MENG20067 "Lightweight Relevance Filtering for Machine-Generated Resolution Problems"))(POS (PAPER.PUBLICATION MENG20067 "ESCoR: Empirically Successful Computerized Reasoning"))(POS (PAPER.LINK MENG20067 "http://www.cl.cam.ac.uk/~lp15/papers/frameset.html"))(POS (PAPER.YEAR MENG20067 2006))(POS (PAPER.DESCRIPTION MENG20067 "
The authors argue for the case that large axiom sets are the norm when
an entailment query is constructed by a machine; moreover, it is often the
case that only a small fraction of those axioms are relevant to the query
at hand, and thus determining which clauses are relevant is a good first
step toward solving the problem.  The criteria for relevance they use
is based on the presence of function symbols in the clauses.
"))(POS (PAPER.TOPIC MENG20067 "Transformations"))(POS (PAPER.INSTANCE MERZ2001))(POS (PAPER.BIBTEX MERZ2001 INBOOK))(POS (PAPER.AUTHOR MERZ2001 "Stephan Merz"))(POS (PAPER.TITLE MERZ2001 "Model Checking: A Tutorial Overview"))(POS (PAPER.PUBLISHER MERZ2001 "Springer-Verlag"))(POS (PAPER.PUBLICATION MERZ2001 "Modeling and Verification of Parallel Processes"))(POS (PAPER.VOLUME MERZ2001 "2067"))(POS (PAPER.STARTPAGE MERZ2001 3))(POS (PAPER.ENDPAGE MERZ2001 38))(POS (PAPER.LINK MERZ2001 "http://www.loria.fr/~merz/papers/mc-tutorial.html"))(POS (PAPER.YEAR MERZ2001 2001))(POS (PAPER.RANK MERZ2001 "[****]"))(POS (PAPER.DESCRIPTION MERZ2001 "
The model checking problem is to determine if a sentence s is entailed
by a model M.  It is mainly used to analyze reactive systems, i.e. systems
that continually interact with their environment.  These systems are usually
modelled with a Kripke structure or an omega(Buchi)-Automaton.  The sentence s 
is usually written in Propositional Temporal Logic (PTL) (which allows only
universal statements), Computation Tree Logic (CTL) (which allows 
universal and existential statements), CTL*, or propositional mu-calculus.
PTL and CTL are not comparable (neither is more expressive than the other).
CTL* is strictly more expressive than CTL and PTL, and propositional
mu-calculus subsumes CTL*.  Model checking algorithms can either be local
(PTL), global (CTL), or symbolic.  Symbolic formulas can be represented
with ordered binary decision diagrams.
"))(POS (PAPER.TOPIC MERZ2001 "Model Checking"))(POS (PAPER.INSTANCE MILLER94))(POS (PAPER.AUTHOR MILLER94 "Rob Miller and Muray Shanahan"))(POS (PAPER.TITLE MILLER94 "Narratives in the Situation Calculus"))(POS (PAPER.PUBLICATION MILLER94 "Journal of Logic and Computation"))(POS (PAPER.VOLUME MILLER94 "4(5)"))(POS (PAPER.STARTPAGE MILLER94 513))(POS (PAPER.ENDPAGE MILLER94 530))(POS (PAPER.LINK MILLER94 "http://citeseer.ist.psu.edu/miller94narratives.html"))(POS (PAPER.YEAR MILLER94 1994))(POS (PAPER.RANK MILLER94 "[*]"))(POS (PAPER.DESCRIPTION MILLER94 "
Miller and Shanahan take a first crack at embedding narratives in the Situation calculus.  They use a new sort for times, define Happens(action, time), and define Duration(action).  Using these, they can represent narratives, noninstantaneous actions, and overlapping actions.   Miller and Shanahan rely heavily on circumscription.  
"))(POS (PAPER.TOPIC MILLER94 "Behavioral Goals"))(POS (PAPER.INSTANCE MITTAL90))(POS (PAPER.BIBTEX MITTAL90 ARTICLE))(POS (PAPER.AUTHOR MITTAL90 "Sanjay Mittal and Brian Falkenhainer"))(POS (PAPER.TITLE MITTAL90 "Dynamic Constraint Satisfaction Problems "))(POS (PAPER.PUBLICATION MITTAL90 "AAAI 90 "))(POS (PAPER.STARTPAGE MITTAL90 25))(POS (PAPER.ENDPAGE MITTAL90 32))(POS (PAPER.YEAR MITTAL90 1990))(POS (PAPER.RANK MITTAL90 "[****]"))(POS (PAPER.DESCRIPTION MITTAL90 "
Mittal and Falkenhainer describe a version of CSPs where the 
number of variables is partially determined by the values of other
variables.  To accomplish this they provide a constraint language that
can express conditions under which variables must be assigned values
and conditions under which variables need not be assigned values.  For 
every variable vi there is a propositional constant active:vi.  If 
active:vi must hold given the values of other variables, vi must
be assigned a value.  If ~active:vi must hold, vi need not be assigned
a value.  It is unclear what happens if neither active:vi nor ~active:vi 
holds.  They use an assumption-based truth maintenance system to build
a Dynamic CSP solver. 
"))(POS (PAPER.TOPIC MITTAL90 "Various Forms of Constraint Satisfaction"))(POS (PAPER.INSTANCE MOORE77))(POS (PAPER.AUTHOR MOORE77 "Robert C. Moore"))(POS (PAPER.TITLE MOORE77 "Reasoning about knowledge and action"))(POS (PAPER.PUBLICATION MOORE77 "Proceedings of the 5th International Joint
Conference on Artificial Intelligence (IJCAI-77, MIT)"))(POS (PAPER.STARTPAGE MOORE77 223))(POS (PAPER.ENDPAGE MOORE77 227))(POS (PAPER.YEAR MOORE77 1977))(POS (PAPER.DESCRIPTION MOORE77 "
Moore contributes the following formalization (after a little tweaking):
1. T(p, s): p is true in world s.
2. K(Agent, s, s'): Given what Agent knows in s, s' would be another possible world.
3. As,a,p.(True(Know(a, p), s) =def= As'.(K(a, s, s') => T(p, s')): "))(POS (PAPER.TOPIC MOORE77 "Planning with Sensing Actions"))(POS (PAPER.INSTANCE MOORE82))(POS (PAPER.BIBTEX MOORE82 ARTICLE))(POS (PAPER.AUTHOR MOORE82 "Robert C. Moore"))(POS (PAPER.TITLE MOORE82 "The Role of Logic in Knowledge Representation and Commonsense Reasoning"))(POS (PAPER.PUBLICATION MOORE82 "AAAI 82"))(POS (PAPER.LINK MOORE82 ""))(POS (PAPER.YEAR MOORE82 1982))(POS (PAPER.RANK MOORE82 "[**]"))(POS (PAPER.DESCRIPTION MOORE82 "
Moore tries to convince AI researchers that logic can be a useful method for reasoning and not just the analysis of systems.  He points out that some of the early experiments that supposedly showed logical reasoning too inefficient only showed that a particular method of inference and control were too inefficient to be used for every reasoning task.
"))(POS (PAPER.TOPIC MOORE82 "Logical Knowledge Representation"))(POS (PAPER.INSTANCE MOSES96))(POS (PAPER.BIBTEX MOSES96 ARTICLE))(POS (PAPER.AUTHOR MOSES96 "Yoram Moses and Moshe Tennenholtz"))(POS (PAPER.TITLE MOSES96 "Off-line reasoning for on-line efficiency: knowledge bases"))(POS (PAPER.PUBLICATION MOSES96 "Artificial Intelligence"))(POS (PAPER.VOLUME MOSES96 "83(2)"))(POS (PAPER.STARTPAGE MOSES96 229))(POS (PAPER.ENDPAGE MOSES96 239))(POS (PAPER.LINK MOSES96 "http://citeseer.ist.psu.edu/moses96offline.html"))(POS (PAPER.YEAR MOSES96 1996))(POS (PAPER.RANK MOSES96 "[***]"))(POS (PAPER.DESCRIPTION MOSES96 "
Moses and Tennenholtz give conditions under which compiling a KB is
worthwhile.  The results given focus almost entirely on propositional
logic.  If a KB has a basis under which all queries
can be computed via conjunctions of the basis, compilation is a good
idea if the basis can be computed in polynomial time.  The process
of compilation essentially stores all the elements of the basis
in a binary tree.  Thus, any query can be answered in (log n)*|query|.
"))(POS (PAPER.TOPIC MOSES96 "Knowledge Base Compilation"))(POS (PAPER.INSTANCE MOSKEWICZ2001))(POS (PAPER.BIBTEX MOSKEWICZ2001 ARTICLE))(POS (PAPER.AUTHOR MOSKEWICZ2001 "Matthew Moskewicz and Conor Madigan and Ying Zhao and Lintao Zhang and Sharad Malik"))(POS (PAPER.TITLE MOSKEWICZ2001 "Chaff: Engineering an Efficient SAT Solver"))(POS (PAPER.PUBLICATION MOSKEWICZ2001 "39th Design Automation Conference"))(POS (PAPER.LINK MOSKEWICZ2001 "http://citeseer.csail.mit.edu/moskewicz01chaff.html"))(POS (PAPER.YEAR MOSKEWICZ2001 2001))(POS (PAPER.DESCRIPTION MOSKEWICZ2001 "
The authors give an overview of DPLL and how it is implemented in Chaff.
Nice read.
"))(POS (PAPER.TOPIC MOSKEWICZ2001 "Solvers"))(POS (PAPER.INSTANCE MOTIK2007BRIDGING))(POS (PAPER.BIBTEX MOTIK2007BRIDGING INPROCEEDINGS))(POS (PAPER.AUTHOR MOTIK2007BRIDGING "Boris Motik and Ian Horrocks and Ulrike Sattler"))(POS (PAPER.TITLE MOTIK2007BRIDGING "Bridging the Gap Between OWL and Relational Databases"))(POS (PAPER.PUBLICATION MOTIK2007BRIDGING "Proceedings of the 16th Conference on the World Wide Web "))(POS (PAPER.LINK MOTIK2007BRIDGING ""))(POS (PAPER.YEAR MOTIK2007BRIDGING 2007))(POS (PAPER.DESCRIPTION MOTIK2007BRIDGING "
The paper attempts to implement integrity constraints as defined in the 
database literature into OWL.
"))(POS (PAPER.TOPIC MOTIK2007BRIDGING "Semantic Web"))(POS (PAPER.INSTANCE MOTIK2007FAITHFUL))(POS (PAPER.BIBTEX MOTIK2007FAITHFUL INPROCEEDINGS))(POS (PAPER.AUTHOR MOTIK2007FAITHFUL "Boris Motik and Riccardo Rosati"))(POS (PAPER.TITLE MOTIK2007FAITHFUL "A Faithful Integration of Description Logics with Logic Programming"))(POS (PAPER.PUBLICATION MOTIK2007FAITHFUL "Proceedings of International Joint Conference on Artificial Intelligence"))(POS (PAPER.LINK MOTIK2007FAITHFUL ""))(POS (PAPER.YEAR MOTIK2007FAITHFUL 2007))(POS (PAPER.DESCRIPTION MOTIK2007FAITHFUL "
The paper introduces hybrid MKNF knowledge bases, a formalism that integrates
logic programming and description logics, which reduces to LP semantics
when the DL portion is empty and to DL semantics when the LP portion is empty.
Also gives complexity results for certain classes of the logic.
"))(POS (PAPER.TOPIC MOTIK2007FAITHFUL "Semantic Web"))(POS (PAPER.INSTANCE MOTTA91))(POS (PAPER.BIBTEX MOTTA91 ARTICLE))(POS (PAPER.AUTHOR MOTTA91 "Enrico Motta and Arthur Stutt"))(POS (PAPER.TITLE MOTTA91 "An Architecture for the Integration of Heterogenous Inference Systems"))(POS (PAPER.PUBLICATION MOTTA91 "Open University Technical Report"))(POS (PAPER.LINK MOTTA91 "http://citeseer.ist.psu.edu/motta91architecture.html"))(POS (PAPER.YEAR MOTTA91 1991))(POS (PAPER.RANK MOTTA91 "[*]"))(POS (PAPER.DESCRIPTION MOTTA91 "
The authors describe an architecture for integrating specialized reasoners
where each reasoner is known to handle a particular vocabulary.
"))(POS (PAPER.TOPIC MOTTA91 "Architectures"))(POS (PAPER.INSTANCE MUHAMMED2006))(POS (PAPER.BIBTEX MUHAMMED2006 INPROCEEDINGS))(POS (PAPER.AUTHOR MUHAMMED2006 "R. Muhammed and P.J. Stuckey"))(POS (PAPER.TITLE MUHAMMED2006 "A stochastic Non-CNF SAT Solver"))(POS (PAPER.PUBLICATION MUHAMMED2006 "In Proceedings 9th Biennial Pacific Rim International Conference on Artificial Intelligence"))(POS (PAPER.STARTPAGE MUHAMMED2006 120))(POS (PAPER.ENDPAGE MUHAMMED2006 129))(POS (PAPER.LINK MUHAMMED2006 "http://www.cs.mu.oz.au/~pjs/papers.html"))(POS (PAPER.YEAR MUHAMMED2006 2006))(POS (PAPER.DESCRIPTION MUHAMMED2006 "
Paper on a stochastic SAT solver whose input is allowed to be 
in something other than CNF.
"))(POS (PAPER.TOPIC MUHAMMED2006 "SAT Solving"))(POS (PAPER.INSTANCE MYERS90))(POS (PAPER.BIBTEX MYERS90 INPROCEEDINGS))(POS (PAPER.AUTHOR MYERS90 "Karen Myers"))(POS (PAPER.TITLE MYERS90 "Automatically Generating Universal Attachments through Compilation"))(POS (PAPER.PUBLICATION MYERS90 "AAAI"))(POS (PAPER.LINK MYERS90 "http://www.ai.sri.com/~myers/"))(POS (PAPER.YEAR MYERS90 1990))(POS (PAPER.RANK MYERS90 "[**]"))(POS (PAPER.DESCRIPTION MYERS90 "
Myers describes a method for generating new universal attachments.
"))(POS (PAPER.TOPIC MYERS90 "Theorem Proving with Attachments"))(POS (PAPER.INSTANCE MYERS90T))(POS (PAPER.BIBTEX MYERS90T PHDTHESIS))(POS (PAPER.AUTHOR MYERS90T "Karen Myers"))(POS (PAPER.TITLE MYERS90T "Universal Attachments: A Logical Framework for Hybrid Reasoning"))(POS (PAPER.PUBLISHER MYERS90T "Stanford University"))(POS (PAPER.LINK MYERS90T "http://library.stanford.edu/depts/mathcs/mathcscoll/techreports.html"))(POS (PAPER.YEAR MYERS90T 1990))(POS (PAPER.RANK MYERS90T "[***]"))(POS (PAPER.DESCRIPTION MYERS90T "
"))(POS (PAPER.TOPIC MYERS90T "Theorem Proving with Attachments"))(POS (PAPER.INSTANCE NAREYEK99))(POS (PAPER.BIBTEX NAREYEK99 ARTICLE))(POS (PAPER.AUTHOR NAREYEK99 "Alexander Nareyek"))(POS (PAPER.TITLE NAREYEK99 "Structural Constraint Satisfaction"))(POS (PAPER.PUBLICATION NAREYEK99 "AAAI Workshop on Configurations"))(POS (PAPER.STARTPAGE NAREYEK99 76))(POS (PAPER.ENDPAGE NAREYEK99 82))(POS (PAPER.LINK NAREYEK99 "http://citeseer.ist.psu.edu/nareyek99structural.html"))(POS (PAPER.YEAR NAREYEK99 1999))(POS (PAPER.RANK NAREYEK99 "[***]"))(POS (PAPER.DESCRIPTION NAREYEK99 "
It is a little hard to follow what's happening here.  Nareyek seems
to be introducing generalization of CSPs where in addition to constraints
on tuples of variables, there are constraints on the structure of those
constraints.  These meta constraints are implemented via Graph Grammars.
Narayek states that solving these problems is undecidable, but gives
no proof.
"))(POS (PAPER.TOPIC NAREYEK99 "Various Forms of Constraint Satisfaction"))(POS (PAPER.INSTANCE NAYAK95))(POS (PAPER.BIBTEX NAYAK95 PROCEEDINGS))(POS (PAPER.AUTHOR NAYAK95 "P. Nayak and Alon Levy"))(POS (PAPER.TITLE NAYAK95 "A Semantic Theory of Abstractions"))(POS (PAPER.PUBLICATION NAYAK95 "IJCAI"))(POS (PAPER.LINK NAYAK95 "http://citeseer.ist.psu.edu/nayak94semantic.html"))(POS (PAPER.YEAR NAYAK95 1995))(POS (PAPER.RANK NAYAK95 "[***]"))(POS (PAPER.DESCRIPTION NAYAK95 "
Nayak and Levy explain a new approach to producing abstractions of
axioms.  Instead of simply mapping axioms to axioms as is done in
previous work, first abstract the axioms to an intended domain
model, and then find sentences that capture that model.  The
theoretical component of this paper, which accounts for the
majority of it, is very clean.  It gives model-theoretic
explainations for good (allowing no 'false proofs') and bad
(allowing 'false proofs') abstractions.
"))(POS (PAPER.TOPIC NAYAK95 "Abstraction"))(POS (PAPER.INSTANCE NELSON79))(POS (PAPER.BIBTEX NELSON79 INPROCEEDINGS))(POS (PAPER.AUTHOR NELSON79 "Greg Nelson and Derek Oppen"))(POS (PAPER.TITLE NELSON79 "Simplification by Cooperating Decision Procedures"))(POS (PAPER.PUBLICATION NELSON79 "ACM Transactions on Programming Languages and Systems
           "))(POS (PAPER.VOLUME NELSON79 "1(2)"))(POS (PAPER.STARTPAGE NELSON79 245))(POS (PAPER.ENDPAGE NELSON79 257))(POS (PAPER.LINK NELSON79 ""))(POS (PAPER.YEAR NELSON79 1979))(POS (PAPER.RANK NELSON79 "[****]"))(POS (PAPER.DESCRIPTION NELSON79 "
Nelson and Oppen describe a method for combining decision procedures
for disjoint equational theories.
To determine the satisfiability of a set of quantifier-free formulas,
partition based on the theory to which the vocabulary belongs.  If 
a term from one theory is embedded in a relation from another theory,
introduce a new variable, replace the term with that variable, and include
the sentence where that variable is set to the term in the appropriate
partition.  If any of the partitions are unsatisfiable, the entire thing
is unsatisfiable.  Otherwise, compute all the strongest equality theorems
including only variables for each of the partitions and pass to all the 
other partitions.  If the theory is nonconvex, case analysis is
necessary.
Check for unsatisfiability and repeat.  Nelson and Oppen prove correctness
and termination.
"))(POS (PAPER.TOPIC NELSON79 "Nelson-Oppen and Shostak"))(POS (PAPER.INSTANCE NEWELL63))(POS (PAPER.AUTHOR NEWELL63 "Allen Newell and H.A. Simon"))(POS (PAPER.TITLE NEWELL63 "GPS, A Program that Simulates Human Thought"))(POS (PAPER.PUBLICATION NEWELL63 "Computers and Thought, Feigenbaum and Feldman (eds.)"))(POS (PAPER.STARTPAGE NEWELL63 279))(POS (PAPER.ENDPAGE NEWELL63 293))(POS (PAPER.YEAR NEWELL63 1963))(POS (PAPER.DESCRIPTION NEWELL63 "
Description of probably the first planner. Newell et. al. compare an inexperienced student doing a logic proof to how GPS solves the same problem.  GPS takes a goal and can perform any of four operations: transform object A into object B (unification?), reduce the difference D between object A and object B (satisfaction of a subgoal of A?), and apply operator Q to object A (reduction of A to subgoals?).
"))(POS (PAPER.TOPIC NEWELL63 "Historical"))(POS (PAPER.INSTANCE NIEUWENHUIS2003))(POS (PAPER.AUTHOR NIEUWENHUIS2003 "Robert Nieuwenhuis and Thomas Hillenbrand and Alexandre Riazanov and Andrei Voronkov"))(POS (PAPER.TITLE NIEUWENHUIS2003 "On the Evaluation of Indexing Techniques for Theorem Proving"))(POS (PAPER.LINK NIEUWENHUIS2003 "http://citeseer.ist.psu.edu/nieuwenhuis03evaluation.html"))(POS (PAPER.YEAR NIEUWENHUIS2003 2003))(POS (PAPER.DESCRIPTION NIEUWENHUIS2003 "
Nieuwenhuis, et. al. describe a methodology for comparing indexing schemes.
To demonstrate it, they compare Waldmeister's discrimination trees,
Context trees, and Vampire's code trees for term indexing.  The scenario tested
involved both additions and deletions from the index and queries where
only one answer need be reported (e.g. for forward subsumption).  They
reported both space and time results.
"))(POS (PAPER.TOPIC NIEUWENHUIS2003 "Indexing"))(POS (PAPER.INSTANCE NILES2001))(POS (PAPER.BIBTEX NILES2001 INPROCEEDINGS))(POS (PAPER.AUTHOR NILES2001 "Ian Niles and Adam Pease"))(POS (PAPER.TITLE NILES2001 "Formal Ontology in Information Systems"))(POS (PAPER.PUBLICATION NILES2001 "Proceedings of the International Conference on Formal Ontology in Information Systems"))(POS (PAPER.STARTPAGE NILES2001 2))(POS (PAPER.ENDPAGE NILES2001 9))(POS (PAPER.LINK NILES2001 "http://portal.acm.org/citation.cfm?id=505170"))(POS (PAPER.YEAR NILES2001 2001))(POS (PAPER.DESCRIPTION NILES2001 "
Primary paper on SUMO, the Suggested Upper Merged Ontology.
"))(POS (PAPER.TOPIC NILES2001 "Logical Knowledge Representation"))(POS (PAPER.INSTANCE ORMAN98))(POS (PAPER.BIBTEX ORMAN98 ARTICLE))(POS (PAPER.AUTHOR ORMAN98 "Levent Orman"))(POS (PAPER.TITLE ORMAN98 "Differential Relational Calculus for Integrity Maintenance"))(POS (PAPER.PUBLICATION ORMAN98 "IEEE Transactions of Knowledge and Data Engineering"))(POS (PAPER.VOLUME ORMAN98 "10(2)"))(POS (PAPER.STARTPAGE ORMAN98 328))(POS (PAPER.ENDPAGE ORMAN98 341))(POS (PAPER.LINK ORMAN98 "http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=683760&isnumber=15039"))(POS (PAPER.YEAR ORMAN98 1998))(POS (PAPER.RANK ORMAN98 "[****]"))(POS (PAPER.DESCRIPTION ORMAN98 "
Orman defines differential relational calculus.  Given a 
database constraint V such that V is true if and only if there is an integrity
constraint violation and a transaction T, what are the necessary and
sufficient conditions for computing whether there is would be an integrity
violation after execution T, assuming there was no violation to start with?
"))(POS (PAPER.TOPIC ORMAN98 "Databases"))(POS (PAPER.INSTANCE OWRE96))(POS (PAPER.BIBTEX OWRE96 INPROCEEDINGS))(POS (PAPER.AUTHOR OWRE96 "S. Owre et. al."))(POS (PAPER.TITLE OWRE96 "PVS: Combining Specification, Proof Checking, and Model Checking"))(POS (PAPER.PUBLICATION OWRE96 "Computer Aided Verification"))(POS (PAPER.STARTPAGE OWRE96 411))(POS (PAPER.ENDPAGE OWRE96 414))(POS (PAPER.LINK OWRE96 "http://citeseer.ist.psu.edu/246180.html"))(POS (PAPER.YEAR OWRE96 1996))(POS (PAPER.RANK OWRE96 "[*]"))(POS (PAPER.DESCRIPTION OWRE96 "
PVS (Prototype Verification System) allows a user to construct a
machine-verified proof.  It combines interactive theorem
proving, typechecking, a set of decision procedures including
a model checker, and strategies to avoid tedious proof step 
repetitions for the user.   The strategies can be extended
if necessary.
"))(POS (PAPER.TOPIC OWRE96 "Model Checking"))(POS (PAPER.INSTANCE PALTRINIERI94))(POS (PAPER.BIBTEX PALTRINIERI94 ARTICLE))(POS (PAPER.AUTHOR PALTRINIERI94 "Massimo Paltrinieri"))(POS (PAPER.TITLE PALTRINIERI94 "Some Remarks on the Design of Constraint Satisfaction
Problems"))(POS (PAPER.PUBLICATION PALTRINIERI94 "Second International Workshop on the Principles
and Practice of Constraint Programming"))(POS (PAPER.STARTPAGE PALTRINIERI94 299))(POS (PAPER.ENDPAGE PALTRINIERI94 311))(POS (PAPER.LINK PALTRINIERI94 "http://citeseer.ist.psu.edu/paltrinieri94some.html"))(POS (PAPER.YEAR PALTRINIERI94 1994))(POS (PAPER.RANK PALTRINIERI94 "[****]"))(POS (PAPER.DESCRIPTION PALTRINIERI94 "
Paltrinieri gives a loose definition for an object-oriented constraint
satisfaction problem and goes on to show its utility for modelling
some CSPs.  His formulation of an OOCSP is no more expressive than
a standard CSP; solving an OOCSP then amounts to translating it into
a CSP.  To do this, find all the instances of objects needed to solve
the OOCSP and replicate the class constraints for each instance.
"))(POS (PAPER.TOPIC PALTRINIERI94 "Object Oriented Constraint Satisfaction"))(POS (PAPER.INSTANCE PALTRINIERI95))(POS (PAPER.BIBTEX PALTRINIERI95 ARTICLE))(POS (PAPER.AUTHOR PALTRINIERI95 "Massimo Paltrinieri"))(POS (PAPER.TITLE PALTRINIERI95 "A Visual Environment for Constraint Programming"))(POS (PAPER.PUBLICATION PALTRINIERI95 "Proceedings 11th International IEEE Symposium on Visual
Langauges"))(POS (PAPER.STARTPAGE PALTRINIERI95 118))(POS (PAPER.ENDPAGE PALTRINIERI95 119))(POS (PAPER.LINK PALTRINIERI95 "
http://citeseer.ist.psu.edu/paltrinieri95visual.html"))(POS (PAPER.YEAR PALTRINIERI95 1995))(POS (PAPER.RANK PALTRINIERI95 "[****]"))(POS (PAPER.DESCRIPTION PALTRINIERI95 "
Paltrinieri gives a 2-page description of a generalization of CSPs to
object-oriented CSPs.  He also describes a visual environment for 
dealing with OOCSPs.
"))(POS (PAPER.TOPIC PALTRINIERI95 "Object Oriented Constraint Satisfaction"))(POS (PAPER.INSTANCE PASTRE78))(POS (PAPER.BIBTEX PASTRE78 ARTICLE))(POS (PAPER.AUTHOR PASTRE78 "D. Pastre"))(POS (PAPER.TITLE PASTRE78 "Automatic Theorem Proving in Set Theory"))(POS (PAPER.PUBLICATION PASTRE78 "Artificial Intelligence"))(POS (PAPER.VOLUME PASTRE78 "10(1)"))(POS (PAPER.STARTPAGE PASTRE78 1))(POS (PAPER.ENDPAGE PASTRE78 27))(POS (PAPER.LINK PASTRE78 ""))(POS (PAPER.YEAR PASTRE78 1978))(POS (PAPER.RANK PASTRE78 "[**]"))(POS (PAPER.DESCRIPTION PASTRE78 "
Pastre describes PROVER, a theorem prover for set theory that builds
diagrams from axioms in order to prune the search space of theorem proving.
Pastre admits the methods to be incomplete, but claims an incomplete
method may prove more theorems than a complete one in practice.
"))(POS (PAPER.TOPIC PASTRE78 "Graphical Reasoning Techniques"))(POS (PAPER.INSTANCE PELTIER2000))(POS (PAPER.BIBTEX PELTIER2000 ARTICLE))(POS (PAPER.AUTHOR PELTIER2000 "Nicolas Peltier"))(POS (PAPER.TITLE PELTIER2000 "Model Building with Ordered Resolution"))(POS (PAPER.PUBLICATION PELTIER2000 "International Workshop on First Order Theorem Proving (FTP)"))(POS (PAPER.LINK PELTIER2000 "http://citeseer.ist.psu.edu/peltier00model.html"))(POS (PAPER.YEAR PELTIER2000 2000))(POS (PAPER.RANK PELTIER2000 "[****]"))(POS (PAPER.DESCRIPTION PELTIER2000 "
Peltier describes two algorithms that can be used after an ordered
resolution proof has failed: (1) to extract from the resolution closure
a set of formulas that have a single Herbrand model where that model
satisfies the original clauseset and (2) to turn those formulas into
a set of clauses.  Peltier's Herbrand model is represented by a clauseset,
and since the clauseset is guaranteed to have exactly one Herbrand model,
proof by consistency can be used to check whether that model satisfies
a particular sentence; moreover, for ground literals, satisfaction is decidable
since either the literal or its negation must be consistent and the 
clauseset is satisfiable, exactly one is consistent, which ensures one
is inconsistent.  Any off-the- shelf first-order entailment algorithm will 
find an inconsistency.  The technique is based on predicate completion,
which only works when there is a strict ordering among the clauses. 
"))(POS (PAPER.TOPIC PELTIER2000 "Model Building"))(POS (PAPER.INSTANCE PEREIRA80))(POS (PAPER.BIBTEX PEREIRA80 INPROCEEDINGS))(POS (PAPER.AUTHOR PEREIRA80 "Pereira and Porto"))(POS (PAPER.TITLE PEREIRA80 "Selective Backtracking for Logic Programs"))(POS (PAPER.PUBLICATION PEREIRA80 "In Proceedings of the Conference on Automated Deduction"))(POS (PAPER.YEAR PEREIRA80 1980))(POS (PAPER.DESCRIPTION PEREIRA80 "
One of the papers that uses the Logic Programming formulation of map coloring.
"))(POS (PAPER.TOPIC PEREIRA80 "Logic Programming"))(POS (PAPER.INSTANCE PETERSON98))(POS (PAPER.BIBTEX PETERSON98 INPROCEEDINGS))(POS (PAPER.AUTHOR PETERSON98 "Brian Peterson and William Anderson and Joshua Engel"))(POS (PAPER.TITLE PETERSON98 "Knowledge Bus: Generating Application-focused Databases from Large Ontologies"))(POS (PAPER.PUBLICATION PETERSON98 "Knowledge Representation Meets Databases"))(POS (PAPER.LINK PETERSON98 "http://citeseer.ist.psu.edu/peterson98knowledge.html"))(POS (PAPER.YEAR PETERSON98 1998))(POS (PAPER.DESCRIPTION PETERSON98 "
The authors attempt to construct a logic program from Cyc for answering a
given set of queries.  Their transformation is lossy, and it is unclear
to what extent the logical consequences are preserved.
"))(POS (PAPER.TOPIC PETERSON98 "Reformulation"))(POS (PAPER.INSTANCE PETRIE2004))(POS (PAPER.BIBTEX PETRIE2004 ARTICLE))(POS (PAPER.AUTHOR PETRIE2004 "Charles J. Petrie, Michael R. Genesereth, Hans Bjornsson, Rada Chirkova, Martin Ekstrom, Hidehito Gomi, Tim Hinrichs, Rob Hoskins, Michael Kassoff, Daishi Kato, Kyohei Kawazoe, Jung Ung Min, and Waqar Mohsin"))(POS (PAPER.TITLE PETRIE2004 "Adding AI to Web Services"))(POS (PAPER.PUBLICATION PETRIE2004 "Lecture Notes in Artificial Intelligence"))(POS (PAPER.VOLUME PETRIE2004 "2926"))(POS (PAPER.STARTPAGE PETRIE2004 322))(POS (PAPER.ENDPAGE PETRIE2004 338))(POS (PAPER.LINK PETRIE2004 "papers/petrie2004adding.pdf"))(POS (PAPER.YEAR PETRIE2004 2004))(POS (PAPER.DESCRIPTION PETRIE2004 "
The FX-Agents project consisted of members of the Stanford Logic Group 
and industrial visitors from NEC and Intec Web and Genome working together 
to develop new technologies based upon the combination of Web services and 
techniques from artificial intelligence, using our experience in AI-based 
software agents. This two-year project ran from April 2001 until March 2002 
and explored the then emerging functionality of Web services. This paper is 
a result of our findings. In particular, this paper discusses the shortcomings 
of current Web service standards like WSDL and how logical AI techniques 
like declarative commands, agents, and planning can be used to address some 
of these shortcomings. The primary problems that we address are automated 
Web service discovery and composition of Web services. 
"))(POS (PAPER.TOPIC PETRIE2004 "References"))(POS (PAPER.INSTANCE PICHLER2000))(POS (PAPER.BIBTEX PICHLER2000 ARTICLE))(POS (PAPER.AUTHOR PICHLER2000 "Reinhard Pichler"))(POS (PAPER.TITLE PICHLER2000 "On the Complexity of Equational Problems in CNF over a Finite Domain"))(POS (PAPER.LINK PICHLER2000 "http://citeseer.ist.psu.edu/478741.html"))(POS (PAPER.YEAR PICHLER2000 2000))(POS (PAPER.RANK PICHLER2000 "[**]"))(POS (PAPER.DESCRIPTION PICHLER2000 "
Pichler shows that the complexity of satisfiability of a purely equational 
Herbrand logic sentence E*A*.M, where M is in CNF, is Sigma_2^p-complete.
"))(POS (PAPER.TOPIC PICHLER2000 "Herbrand Logic"))(POS (PAPER.INSTANCE PINTO94))(POS (PAPER.AUTHOR PINTO94 "Javier Pinto"))(POS (PAPER.TITLE PINTO94 "Temporal Reasoning in the Situation Calculus"))(POS (PAPER.LINK PINTO94 "http://citeseer.ist.psu.edu/pinto94temporal.html"))(POS (PAPER.YEAR PINTO94 1994))(POS (PAPER.RANK PINTO94 "[**]"))(POS (PAPER.DESCRIPTION PINTO94 "
Pinto's thesis extends situation calculus to cover temporal reasoning.  He includes ACTUAL PATHS (narratives), concurrent actions, and continuous time with natural events.  He goes on to compare his situation calculus with interval temporal logic, the calculus of events, and modal temporal logics.  He later reworked his approach to narratives in [pinto98], which does not call for circumscription.  Reiter published a paper on 'Natural Actions, Concurrency, and Continuous Time' [reiter96] after Pinto--should probably read that one instead.
"))(POS (PAPER.TOPIC PINTO94 "Behavioral Goals"))(POS (PAPER.RELATED PINTO94 REITER96))(POS (PAPER.RELATED PINTO94 PINTO98))(POS (PAPER.INSTANCE PINTO98))(POS (PAPER.AUTHOR PINTO98 "Javier Pinto"))(POS (PAPER.TITLE PINTO98 "Occurrences and Narratives as Constraints in the Branching Structure of the Situation Calculus"))(POS (PAPER.PUBLICATION PINTO98 "Journal of Logic and Computation"))(POS (PAPER.VOLUME PINTO98 "8(6)"))(POS (PAPER.STARTPAGE PINTO98 777))(POS (PAPER.ENDPAGE PINTO98 808))(POS (PAPER.LINK PINTO98 "http://citeseer.ist.psu.edu/pinto96occurrences.html"))(POS (PAPER.YEAR PINTO98 1998))(POS (PAPER.RANK PINTO98 "[*****]"))(POS (PAPER.DESCRIPTION PINTO98 "
Pinto tackles the problem of expressing occurrences in situation calculus.  Occurrences are sequences of events that really do happen in every hypothetical branch of the situation tree.  In deductive plan synthesis via the Green method, we want all plans returned to include all the occurrences given.  Pinto names two specific types of occurrences: narratives (a partial specification of a sequence of events known to happen) and triggers (as in the database sense).  His formulation assigns time values to situations, a second order induction axiom, along with an extension to the sitcalc ontology to define 'nonpreventable occurrences', 'conditional occurrences', and 'simple occurrences'.  He defines 'legal(s)' in terms of these 3 occurrence types to mean that a situation s includes all the mentioned occurrences and is a valid sitcalc situation.  Pinto goes on to define when one situation is preferred to another: s preferred-to s' iff s' has the same actions as s with extra actions appended to the end.  For planning, Pinto shows that instead of finding an s s.t. goal(s) is true, we can find an s s.t. goal(s) ^ legal(s) is true. 
"))(POS (PAPER.TOPIC PINTO98 "Behavioral Goals"))(POS (PAPER.INSTANCE PIRRI99))(POS (PAPER.AUTHOR PIRRI99 "Fiora Pirri and Ray Reiter"))(POS (PAPER.TITLE PIRRI99 "Some Contributions to the Metatheory of the Situation Calculus"))(POS (PAPER.PUBLICATION PIRRI99 "Journal of the ACM"))(POS (PAPER.VOLUME PIRRI99 "46(3)"))(POS (PAPER.STARTPAGE PIRRI99 325))(POS (PAPER.ENDPAGE PIRRI99 361))(POS (PAPER.LINK PIRRI99 "http://citeseer.ist.psu.edu/pirri99some.html"))(POS (PAPER.YEAR PIRRI99 1999))(POS (PAPER.RANK PIRRI99 "[****]"))(POS (PAPER.DESCRIPTION PIRRI99 "
Pirri and Reiter formalize the theory of situation calculus and define basic
action theories as D = Sigma U D_ss U D_ap U D_una U D_s0.  Sigma are the
foundational axioms (induction, situation ordering, equality, unique names
for situations); D_ss are
successor state axioms; D_ap are action precondition axioms; D_una are unique
name axioms for actions; D_s0 are initial state axioms.  This definition
appears throughout later work on the situation calculus.  Well written.
They also define Regression (in a clearer way than reiter91--the
Frame problem...), which means rewriting a regressable formula so that the only
situations referenced are S0.  Entailment of a regressed formula requires
only knowledge
of D_s0 and D_una.  Pirri and Reiter also give conditions when induction is
not needed for entailment, as well as when other components of Sigma are
unnecessary.  They go on to show that Sigma is unnecessary for GOLOG programs.
"))(POS (PAPER.TOPIC PIRRI99 "Fundamentals"))(POS (PAPER.INSTANCE PLAISTED81))(POS (PAPER.BIBTEX PLAISTED81 ARTICLE))(POS (PAPER.AUTHOR PLAISTED81 "David Plaisted"))(POS (PAPER.TITLE PLAISTED81 "Theorem Proving with Abstraction"))(POS (PAPER.PUBLICATION PLAISTED81 "Artificial Intelligence"))(POS (PAPER.VOLUME PLAISTED81 "16(1)"))(POS (PAPER.STARTPAGE PLAISTED81 47))(POS (PAPER.ENDPAGE PLAISTED81 107))(POS (PAPER.LINK PLAISTED81 ""))(POS (PAPER.YEAR PLAISTED81 1981))(POS (PAPER.DESCRIPTION PLAISTED81 "
Plaisted defines the notion of an abstraction of a literal and a clause and
shows that under this definition, the union and composition of two
abstractions is another abstraction.  He also gives local conditions
under which a mapping is an abstraction, which can be practically used.
He goes on to discuss abstract resolution proofs and multi-clauses (which
admit simpler proof procedures than regular clauses).  He discusses
using more than one abstraction at a time.  Using these abstractions admits
a complete proof procedure.  Finally, he introduces a variant
of the multi-clause notion and considers a version of completeness for it.
"))(POS (PAPER.TOPIC PLAISTED81 "Abstraction"))(POS (PAPER.INSTANCE PLAISTED94))(POS (PAPER.BIBTEX PLAISTED94 INPROCEEDINGS))(POS (PAPER.AUTHOR PLAISTED94 "David Plaisted"))(POS (PAPER.TITLE PLAISTED94 "The Search Efficiency of Theorem Proving Strategies: An Analytical Comparison"))(POS (PAPER.PUBLICATION PLAISTED94 "CADE"))(POS (PAPER.STARTPAGE PLAISTED94 1))(POS (PAPER.ENDPAGE PLAISTED94 40))(POS (PAPER.LINK PLAISTED94 "http://citeseer.ist.psu.edu/plaisted94search.html"))(POS (PAPER.YEAR PLAISTED94 1994))(POS (PAPER.RANK PLAISTED94 "[***]"))(POS (PAPER.DESCRIPTION PLAISTED94 "
Plaisted does a comparison of a slew of clausal, refutation 
theorem-proving strategies for
propositional Horn clauses.  He gives three measures for the search
spaces generated by each strategy: iterated duplication, case-analysis
duplication, and combination duplication, the produce of which bounds
the total size of the search space.  The first measures the longest path,
the second measures the number of paths, and the third measures the
maximum size of clauses generated in any state. 
"))(POS (PAPER.TOPIC PLAISTED94 "Comparative Analysis"))(POS (PAPER.INSTANCE PLAISTED97))(POS (PAPER.BIBTEX PLAISTED97 INPROCEEDINGS))(POS (PAPER.AUTHOR PLAISTED97 "David Plaisted and Yunshan Zhu"))(POS (PAPER.TITLE PLAISTED97 "Ordered Semantic Hyper Linking"))(POS (PAPER.PUBLICATION PLAISTED97 "AAAI"))(POS (PAPER.LINK PLAISTED97 "http://citeseer.ist.psu.edu/218207.html"))(POS (PAPER.YEAR PLAISTED97 1997))(POS (PAPER.RANK PLAISTED97 "[***]"))(POS (PAPER.DESCRIPTION PLAISTED97 "
Ordered Semantic Hyper Linking is a proof procedure based on
model-building.  In includes a total ordering on
formulae to remove redundant interpretations.  OSHL allows the user
to give an initial interpretation to guide the search.
It propositionalizes first order theories to build its models.  
The paper claims soundness and completeness, but no proofs are
supplied (probably due to lack of space).
"))(POS (PAPER.TOPIC PLAISTED97 "Resolution Variants"))(POS (PAPER.INSTANCE PLUMMER95))(POS (PAPER.BIBTEX PLUMMER95 MISC))(POS (PAPER.AUTHOR PLUMMER95 "Dave Barker-Plummer and Sidney Bailin"))(POS (PAPER.TITLE PLUMMER95 "Proofs and Pictures: Proving the Diamond lemma with the GROVER Theorem Proving System"))(POS (PAPER.LINK PLUMMER95 "http://citeseer.ist.psu.edu/193199.html"))(POS (PAPER.YEAR PLUMMER95 1995))(POS (PAPER.RANK PLUMMER95 "[*]"))(POS (PAPER.DESCRIPTION PLUMMER95 "
The authors describe a theorem proving system that takes a set of axioms, Delta,
a diagram, D, and a conjecture phi.  It proves Delta |= phi by 1) examining D and 
determining that D |= phi, and 2) proving Delta |= D.  The method seems to be 
ad hoc with no guarantees of soundness or completeness; however, given enough
hints, GROVER was able to prove the Diamond Lemma.
"))(POS (PAPER.TOPIC PLUMMER95 "Graphical Reasoning Techniques"))(POS (PAPER.INSTANCE PRASAD2005))(POS (PAPER.BIBTEX PRASAD2005 ARTICLE))(POS (PAPER.AUTHOR PRASAD2005 "Mukul Prasad and Armin Biere and Aarti Gupta"))(POS (PAPER.TITLE PRASAD2005 "A Survey of Recent Advances in SAT-Based Formal Verification"))(POS (PAPER.PUBLICATION PRASAD2005 "Software Tools for Technology Transfer"))(POS (PAPER.VOLUME PRASAD2005 "7(2)"))(POS (PAPER.STARTPAGE PRASAD2005 156))(POS (PAPER.ENDPAGE PRASAD2005 173))(POS (PAPER.LINK PRASAD2005 "http://www.cerc.utexas.edu/~jay/fv_surveys/"))(POS (PAPER.YEAR PRASAD2005 2005))(POS (PAPER.DESCRIPTION PRASAD2005 "
A survey paper discussing how boolean SAT solvers are being used
for formal verification.
"))(POS (PAPER.TOPIC PRASAD2005 "Formal Verification"))(POS (PAPER.INSTANCE PUEBLA2004))(POS (PAPER.BIBTEX PUEBLA2004 ARTICLE))(POS (PAPER.AUTHOR PUEBLA2004 "G. Puebla and E. Albert and M. Hermenegildo"))(POS (PAPER.TITLE PUEBLA2004 "Efficient Local Unfolding with Ancestor Stacks for Full Prolog"))(POS (PAPER.PUBLICATION PUEBLA2004 "14th International Symposium, Logic Based Program Synthesis and Transformation (LOPSTR)"))(POS (PAPER.STARTPAGE PUEBLA2004 1))(POS (PAPER.ENDPAGE PUEBLA2004 18))(POS (PAPER.LINK PUEBLA2004 "http://wotan.liu.edu/docis/dbl/lopstr/index.html"))(POS (PAPER.YEAR PUEBLA2004 2004))(POS (PAPER.DESCRIPTION PUEBLA2004 "
In the context of Horn prolog with built-ins, the authors address the
problem of efficiently unfolding of recursive relations.  That is,
one implementation of partial evaluation/partial deduction is to produce
a partial SLD tree and using the fringe as the body of a rule for proving
the goal.  The problem with this approach is that the recursive relations 
produce infinite SLD trees, unless the recursion is cut off.  To determine
when the recursion should be cut off, a common practice is to apply a
recursive rule only when the subgoal is smaller, according to some
ordering, e.g. well-founded, well-quasi, than all its ancestors.  To
implement that, all the ancestors of each goal have in the past 
been stored, which is expensive both in time to check and in space
to store.  This paper tackles this problem by expanding the tree in a 
variant of depth-first search so that only the current call stack need
be stored.  They also consider the case of built-in predicates.
"))(POS (PAPER.TOPIC PUEBLA2004 "Reformulation"))(POS (PAPER.INSTANCE RAMACHANDRAN2005))(POS (PAPER.BIBTEX RAMACHANDRAN2005 ARTICLE))(POS (PAPER.AUTHOR RAMACHANDRAN2005 "D. Ramachandran and E. Amir"))(POS (PAPER.TITLE RAMACHANDRAN2005 "Compact Propositional Encodings of First-Order Theories"))(POS (PAPER.PUBLICATION RAMACHANDRAN2005 "20th National Conference on Artificial Intelligence"))(POS (PAPER.LINK RAMACHANDRAN2005 "http://reason.cs.uiuc.edu/eyal/paper.html"))(POS (PAPER.YEAR RAMACHANDRAN2005 2005))(POS (PAPER.DESCRIPTION RAMACHANDRAN2005 "
The authors introduce polynomial-time algorithms for converting
first-order logic (sometimes with a DCA) into propositional logic,
where the goal is a small output size.  Relies on a certain
structure within the FOL theory.
"))(POS (PAPER.TOPIC RAMACHANDRAN2005 "Reformulation"))(POS (PAPER.INSTANCE RAO2004))(POS (PAPER.BIBTEX RAO2004 ARTICLE))(POS (PAPER.AUTHOR RAO2004 "M.R.K. Krishna Rao"))(POS (PAPER.TITLE RAO2004 "Input-Termination of Logic Programs"))(POS (PAPER.PUBLICATION RAO2004 "14th International Symposium, Logic Based Program Synthesis and Transformation (LOPSTR)"))(POS (PAPER.STARTPAGE RAO2004 215))(POS (PAPER.ENDPAGE RAO2004 230))(POS (PAPER.LINK RAO2004 "http://wotan.liu.edu/docis/dbl/lopstr/index.html"))(POS (PAPER.YEAR RAO2004 2004))(POS (PAPER.DESCRIPTION RAO2004 "
Rao defines a class of logic programs, linear bounded programs,
and show that such programs are input-terminating under Prolog's 
selection rule.  Rao also shows that all simply-moded linear bounded
programs are input-terminating.  Importantly, determining whether
a program is linearly bounded is decidable, unlike previous work
which gave necessary and sufficient conditions for a class of 
decidable programs, but checking those conditions is undecidable.  Input-
consuming derivations do not instantiate variables that only occur
in the input positions of the initial query, and input-termination is the
property that all input-consuming derivations are finite.
"))(POS (PAPER.TOPIC RAO2004 "Reformulation"))(POS (PAPER.INSTANCE REITER2000))(POS (PAPER.AUTHOR REITER2000 "Ray Reiter"))(POS (PAPER.TITLE REITER2000 "Narratives as Programs"))(POS (PAPER.PUBLICATION REITER2000 "Principles of Knowledge Representation and Reasoning"))(POS (PAPER.STARTPAGE REITER2000 99))(POS (PAPER.ENDPAGE REITER2000 108))(POS (PAPER.LINK REITER2000 "http://citeseer.ist.psu.edu/reiter00narratives.html"))(POS (PAPER.YEAR REITER2000 2000))(POS (PAPER.RANK REITER2000 "[*]"))(POS (PAPER.DESCRIPTION REITER2000 "
Reiter argues that narratives (a sequence of events known to occur) are actually programs.  He uses GOLOG to represent narratives and shows that making a query Q(s) over a narrative is identical to proving a property about a program, as in program verification.  In GOLOG terms, we want to ask whether Q holds on a program v; we simply show that SitcalcAxioms |= As.(Do(v,S0,s)=>Q(s)).
"))(POS (PAPER.TOPIC REITER2000 "Behavioral Goals"))(POS (PAPER.INSTANCE REITER73))(POS (PAPER.BIBTEX REITER73 INPROCEEDINGS))(POS (PAPER.AUTHOR REITER73 "Ray Reiter"))(POS (PAPER.TITLE REITER73 "A Semantically Guided Deductive System for Automatic Theorem-Proving"))(POS (PAPER.PUBLICATION REITER73 "IJCAI"))(POS (PAPER.YEAR REITER73 1973))(POS (PAPER.RANK REITER73 "[**]"))(POS (PAPER.DESCRIPTION REITER73 "
Reiter describes a system for natural deduction that intertwines model-
building and deduction, where each affects the other.  The system itself
is composed of 12 inference rules which manipulate both axioms and 
models.  This may have been the seminal work on using an explicit 
model to aid theorem-proving; previous work used heuristics, which
Reiter characterized as implicit semantics. 
"))(POS (PAPER.TOPIC REITER73 "Model-Guided Proof Techniques"))(POS (PAPER.INSTANCE REITER78))(POS (PAPER.BIBTEX REITER78 INPROCEEDINGS))(POS (PAPER.AUTHOR REITER78 "Ray Reiter"))(POS (PAPER.TITLE REITER78 "On Closed World Databases"))(POS (PAPER.PUBLICATION REITER78 "In proceedings of 1978 ACM SIGMOD International Conference on Management of Data"))(POS (PAPER.YEAR REITER78 1978))(POS (PAPER.DESCRIPTION REITER78 "
The closed world assumption (CWA).
"))(POS (PAPER.TOPIC REITER78 "Logical Knowledge Representation"))(POS (PAPER.INSTANCE REITER80))(POS (PAPER.BIBTEX REITER80 ARTICLE))(POS (PAPER.AUTHOR REITER80 "Raymond Reiter"))(POS (PAPER.TITLE REITER80 "Equality and Domain Closure in First-Order Databases"))(POS (PAPER.PUBLICATION REITER80 "Journal of the ACM"))(POS (PAPER.VOLUME REITER80 "27(2)"))(POS (PAPER.STARTPAGE REITER80 235))(POS (PAPER.ENDPAGE REITER80 249))(POS (PAPER.LINK REITER80 "http://portal.acm.org/citation.cfm?id=322189"))(POS (PAPER.YEAR REITER80 1980))(POS (PAPER.RANK REITER80 "[**]"))(POS (PAPER.DESCRIPTION REITER80 "
Reiter explores techniques for doing first-order reasoning with 
a Domain Closure Axiom
(x=a1 | x=a2 | ... | x=an).  He focuses on axiom sets for which there
are a finite number of object constants, no function constants, and when
written in prenex form include no existential quantifiers.
To do so he (1) shows that existential queries will never require
the DCA, for algorithms exploiting Herbrand's theorem, and 
(2) how to build on this fact 
to answer any kind of query by peeling away quantifiers to build an 
existential query.  The second step uses a generalization of the 
relational database division operator for universal quantifiers and a 
generalization of the projection operator for existential quantifiers. 
Next it is shown that Horn databases and positive existential queries never 
require computing disjunctive answers. 
Then conditions are given for the removal of all but the x=x equality axiom: 
E-saturation, i.e.
unique names over all the constants.  Lastly it is
shown that extending DCA to include infinitely many constants can result in
an infinite disjunction as an answer to a query.  Very thorough, as always.
"))(POS (PAPER.TOPIC REITER80 "Logical Knowledge Representation"))(POS (PAPER.INSTANCE REITER84))(POS (PAPER.BIBTEX REITER84 CHAPTER))(POS (PAPER.AUTHOR REITER84 "Raymond Reiter"))(POS (PAPER.TITLE REITER84 "Towards a Logical Reconstruction of Relational Database Theory"))(POS (PAPER.PUBLISHER REITER84 "Springer-Verlag"))(POS (PAPER.PUBLICATION REITER84 "On Conceptual Modelling"))(POS (PAPER.STARTPAGE REITER84 191))(POS (PAPER.ENDPAGE REITER84 238))(POS (PAPER.LINK REITER84 ""))(POS (PAPER.YEAR REITER84 1984))(POS (PAPER.RANK REITER84 "[***]"))(POS (PAPER.DESCRIPTION REITER84 "
Reiter formalizes Database theory from a logical perspective.  Databases in this view are first-order models, and integrity constraints are sentences that such a model satisfies.  A relational theory (the set of sentences entailed by a relational database) can be defined as the set of ground atoms in the DB, a completion axiom for each table ensuring that those ground atoms not in the table are false, unique-names axioms, a domain closure axiom, and equality/substitution axioms.   Proof is provided.  Next Reiter goes on to generalize this definition to handle positive disjunction, which requires altering the completion axioms.  Lastly he shows how to deal with null values by changing the DCA and the completion axioms. 
"))(POS (PAPER.TOPIC REITER84 "Logical Knowledge Representation"))(POS (PAPER.INSTANCE REITER91))(POS (PAPER.AUTHOR REITER91 "Raymond Reiter"))(POS (PAPER.TITLE REITER91 "The Frame Problem in the Situation Calculus: A Simple Solution (Sometimes) and a Completeness Result for Goal Regression"))(POS (PAPER.PUBLICATION REITER91 "Artificial Intelligence and Mathematical Theory of Computation: Papers in Honor of John McCarthy"))(POS (PAPER.LINK REITER91 "http://ftp.cs.toronto.edu/pub/cogrob/README.html"))(POS (PAPER.YEAR REITER91 1991))(POS (PAPER.RANK REITER91 "[**]"))(POS (PAPER.DESCRIPTION REITER91 "
Reiter describes his solution to the frame problem, namely successor state
axioms of the form
Poss(a,s)=>[R(do(a,s)) =def= r_pos(a,s) V R(s) ^ ~r_neg(a,s)].  Poss(a,s) is
the action precondition axiom; R(do(a,s)) is the fluent, r_pos(a,s) is the
positive effect axiom for R; r_neg(a,s) is the negative effect axiom for R.
This works when also given a single definition for Poss(A,s) for each action A,
unique naming axioms for actions and states.  This technique requires F+A
axioms instead of 2*A*F axioms to describe frame and effect axioms for a
domain, where F is the number of fluents and A the number of actions.
Reiter also discusses a regression operator, which does deductive plan synthesis by taking a normal situation calculus axiomitization (using successor state axioms) and rewrites it so that every fluent only mentions S0.  Under certain conditions, Reiter shows that the rewriting can be done iff Es.G(s).
"))(POS (PAPER.TOPIC REITER91 "Fundamentals"))(POS (PAPER.INSTANCE REITER93))(POS (PAPER.AUTHOR REITER93 "Raymond Reiter"))(POS (PAPER.TITLE REITER93 "Proving Properties of States in the Situation Calculus"))(POS (PAPER.PUBLICATION REITER93 "Artificial Intelligence"))(POS (PAPER.VOLUME REITER93 "64(2)"))(POS (PAPER.STARTPAGE REITER93 337))(POS (PAPER.ENDPAGE REITER93 351))(POS (PAPER.LINK REITER93 "http://citeseer.ist.psu.edu/reiter93proving.html"))(POS (PAPER.YEAR REITER93 1993))(POS (PAPER.RANK REITER93 "[****]"))(POS (PAPER.DESCRIPTION REITER93 "
Reiter motivates the need to prove properties about states by citing the examples in the physical world (once broken, an object stays that way), planning (showing there is no plan to achieve a goal), and integrity constraints on a database.  He formulates an induction axiom sufficient for proving P(s) for all states s>=S0.  He relies on explanation closure axioms, proposed by Schubert and Haas, which are logically equivalent to frame axioms.
"))(POS (PAPER.TOPIC REITER93 "Theories of Action"))(POS (PAPER.INSTANCE REITER95))(POS (PAPER.AUTHOR REITER95 "Ray Reiter"))(POS (PAPER.TITLE REITER95 "On Specifying Database Updates"))(POS (PAPER.PUBLICATION REITER95 "Journal of Logic Programming"))(POS (PAPER.VOLUME REITER95 "25(1)"))(POS (PAPER.STARTPAGE REITER95 53))(POS (PAPER.ENDPAGE REITER95 91))(POS (PAPER.LINK REITER95 "http://citeseer.ist.psu.edu/reiter92specifying.html"))(POS (PAPER.YEAR REITER95 1995))(POS (PAPER.RANK REITER95 "[*]"))(POS (PAPER.DESCRIPTION REITER95 "
Reiter summarizes several previous pieces of work including proving properties of states in Situation Calculus and formalizing the querying of a database transaction.  He also compares this approach to other database query techniques.
"))(POS (PAPER.TOPIC REITER95 "Hypothetical Temporal DB Queries"))(POS (PAPER.INSTANCE REITER96))(POS (PAPER.AUTHOR REITER96 "Ray Reiter"))(POS (PAPER.TITLE REITER96 "Natural Actions, Concurrency and Continuous Time in the Situation Calculus"))(POS (PAPER.PUBLICATION REITER96 "Principles of Knowledge Representation and Reasoning: Proceedings of the Fifth International Conference"))(POS (PAPER.STARTPAGE REITER96 2))(POS (PAPER.ENDPAGE REITER96 13))(POS (PAPER.LINK REITER96 "http://ftp.cs.toronto.edu/pub/cogrob/README.html"))(POS (PAPER.YEAR REITER96 1996))(POS (PAPER.RANK REITER96 "[*****]"))(POS (PAPER.DESCRIPTION REITER96 "
Reiter gives an axiomitization for Concurrent, Temporal Situation Calculus.  He mentions any solution to the Precondition Interaction Problem (where two actions preconditions may both be satisfied yet the 2 actions are mutually exclusive) works within the given framework.  The axiomitization allows actions following the laws of physics to occur at the same time an agent is acting in the world.  Plans can consequently be produced that take these laws into account.
"))(POS (PAPER.TOPIC REITER96 "Behavioral Goals"))(POS (PAPER.INSTANCE RIAZANOV02))(POS (PAPER.BIBTEX RIAZANOV02 ARTICLE))(POS (PAPER.AUTHOR RIAZANOV02 "Alexandre Riazanov and Andrei Voronkov"))(POS (PAPER.TITLE RIAZANOV02 "The design and implementation of Vampire"))(POS (PAPER.PUBLICATION RIAZANOV02 "AI Communications"))(POS (PAPER.VOLUME RIAZANOV02 "15"))(POS (PAPER.STARTPAGE RIAZANOV02 91))(POS (PAPER.ENDPAGE RIAZANOV02 110))(POS (PAPER.LINK RIAZANOV02 ""))(POS (PAPER.YEAR RIAZANOV02 2002))(POS (PAPER.RANK RIAZANOV02 ""))(POS (PAPER.DESCRIPTION RIAZANOV02 "
Riazanov and Voronkov describe Vampire v2.0.  They first give an overview
of the high-level functionality, then give a more detailed discussion
of the architecture based on DISCOUNT, talk about term-indexing, 
and delve into representational
issues (e.g. shared terms) along with memory management.  
"))(POS (PAPER.TOPIC RIAZANOV02 "System Designs"))(POS (PAPER.INSTANCE RIAZANOV2001))(POS (PAPER.AUTHOR RIAZANOV2001 "Alexandre Riazanov and Andrei Voronkov"))(POS (PAPER.TITLE RIAZANOV2001 "Splitting without Backtracking"))(POS (PAPER.PUBLICATION RIAZANOV2001 "IJCAI"))(POS (PAPER.STARTPAGE RIAZANOV2001 611))(POS (PAPER.ENDPAGE RIAZANOV2001 617))(POS (PAPER.LINK RIAZANOV2001 "http://rpc25.cs.man.ac.uk/voronkov/all_publications.html"))(POS (PAPER.YEAR RIAZANOV2001 2001))(POS (PAPER.DESCRIPTION RIAZANOV2001 "
The authors describe a technique for resolution that allows resolution
to break a clause apart when variables are not shared between pieces.
Suppose the clause C can be partitioned into 2 parts D and E, where each
part shares no variables with any other part.  Splitting replaces
C with the clauses D | p and E | -p.  This only makes sense when there
is an ordering imposed on the literals so that p and -p are not immediately
resolved together undoing the work of splitting.  The authors investigate
two orders: blocking and parallel.  In blocking, the -p literals 
are ranked highest; the non p literals are ranked next with negative
bigger than positive; the p atoms are ranked lowest.  In parallel,
the p literals (positive or negative) are ranked last.  Also, 
these p literals are considered names.  If there is another clause 
C' with partition D and F, then C' is split into F | -p.  Some
experimental results from TPTP show that splitting is a bad idea
with equality but that Parallel ordering with Naming is a good idea
without equaity. 
"))(POS (PAPER.TOPIC RIAZANOV2001 "Calculi"))(POS (PAPER.INSTANCE RIAZANOV2003))(POS (PAPER.AUTHOR RIAZANOV2003 "Alexandre Riazanov and Andrei Voronkov"))(POS (PAPER.TITLE RIAZANOV2003 "Efficient Instance Retrieval with Standard and Relational Path Indexing
"))(POS (PAPER.LINK RIAZANOV2003 "http://citeseer.ist.psu.edu/594779.html"))(POS (PAPER.YEAR RIAZANOV2003 2003))(POS (PAPER.DESCRIPTION RIAZANOV2003 "
Riazanov and Voronkov follow on their first indexing paper with this one.
They compare discrimination trees and path indexing for the case of instance
retrieval.  Given a term t, find all terms u and substitutions sigma such that 
t.sigma = u.  Discrimination trees represent terms as strings; path
indexing represents terms as trees.  The authors show that with the
standard implementation of path indexing is slower than DT.  Then
they augment PI with skip lists, early cleaning to more closely
approximate perfect filtering, and a couple of other improvements.  Then
they argue for relational path indexing, utilizing database theory
to conceptualize the integration of cleaning after imperfect filtering
into the imperfect filtering.  They show how this idea makes
commutative indexing and backward subsumption on multiliteral
clauses.
"))(POS (PAPER.TOPIC RIAZANOV2003 "Indexing"))(POS (PAPER.INSTANCE ROBINSON))(POS (PAPER.BIBTEX ROBINSON BOOK))(POS (PAPER.AUTHOR ROBINSON "Alan Robinson and Andrei Voronkov"))(POS (PAPER.TITLE ROBINSON "Handbook of Automated Reasoning"))(POS (PAPER.PUBLISHER ROBINSON "MIT Press and Elsevier Science"))(POS (PAPER.LINK ROBINSON "http://www.amazon.com/Handbook-Automated-Reasoning-Alan-Robinson/dp/0262182238"))(POS (PAPER.YEAR ROBINSON 2001))(POS (PAPER.RANK ROBINSON "[*****]"))(POS (PAPER.DESCRIPTION ROBINSON "
Robinson and Voronkov edit this two volume handbook.  The first volume covers
a history of the field, methods for first-order logic, methods for equality and
other built-in theories, and induction.  The second volume covers higher-order
logics, nonclassical logics, decidable classes and model building, and implementational
details.
"))(POS (PAPER.TOPIC ROBINSON ""))(POS (PAPER.INSTANCE ROBINSON65MACHINE))(POS (PAPER.BIBTEX ROBINSON65MACHINE ARTICLE))(POS (PAPER.AUTHOR ROBINSON65MACHINE "J.A. Robinson"))(POS (PAPER.TITLE ROBINSON65MACHINE "A Machine-Oriented Logic Based on the Resolution Principle"))(POS (PAPER.PUBLICATION ROBINSON65MACHINE "Journal of the ACM"))(POS (PAPER.VOLUME ROBINSON65MACHINE "12(1)"))(POS (PAPER.STARTPAGE ROBINSON65MACHINE 23))(POS (PAPER.ENDPAGE ROBINSON65MACHINE 41))(POS (PAPER.YEAR ROBINSON65MACHINE 1965))(POS (PAPER.RANK ROBINSON65MACHINE ""))(POS (PAPER.DESCRIPTION ROBINSON65MACHINE "
The resolution paper.
"))(POS (PAPER.TOPIC ROBINSON65MACHINE "Theorem Proving"))(POS (PAPER.INSTANCE ROY2000))(POS (PAPER.BIBTEX ROY2000 ARTICLE))(POS (PAPER.AUTHOR ROY2000 "Pierre Roy, Anne Liret, Francois Pachet"))(POS (PAPER.TITLE ROY2000 "The Framework Approach for Constraint Satisfaction"))(POS (PAPER.PUBLICATION ROY2000 "ACM Computing Surveys"))(POS (PAPER.VOLUME ROY2000 "32"))(POS (PAPER.STARTPAGE ROY2000 13))(POS (PAPER.ENDPAGE ROY2000 16))(POS (PAPER.LINK ROY2000 "http://citeseer.ist.psu.edu/roy00framework.html"))(POS (PAPER.YEAR ROY2000 2000))(POS (PAPER.RANK ROY2000 "[**]"))(POS (PAPER.DESCRIPTION ROY2000 "
The authors argue that a Framework is a better paradigm for
allowing a user to solve CSPs than either a Library of generic
constraints or a Language built for writing solvers of CSPs. 
The former approach is too coarsely-grained, and the latter is
too finely-grained.  The framework approach sits nicely in the
middle. 
"))(POS (PAPER.TOPIC ROY2000 "OO Languages with Native Constraint Satisfaction"))(POS (PAPER.INSTANCE ROY97))(POS (PAPER.AUTHOR ROY97 "Pierre Roy, Francois Pachet"))(POS (PAPER.TITLE ROY97 "Reifying Constraint Satisfaction in Smalltalk"))(POS (PAPER.PUBLICATION ROY97 "Journal of Object-Oriented Programming"))(POS (PAPER.VOLUME ROY97 "10(4)"))(POS (PAPER.STARTPAGE ROY97 43))(POS (PAPER.ENDPAGE ROY97 51))(POS (PAPER.LINK ROY97 "http://citeseer.ist.psu.edu/roy97reifying.html"))(POS (PAPER.YEAR ROY97 1997))(POS (PAPER.RANK ROY97 "[**]"))(POS (PAPER.DESCRIPTION ROY97 "
Roy describes Backtalk, a system that allows a library of
generic CSP algorithms to be written.
Doing so requires reifying
the notion of a constraint, a CSP problem, a solution, etc..
"))(POS (PAPER.TOPIC ROY97 "OO Languages with Native Constraint Satisfaction"))(POS (PAPER.INSTANCE RUEB2000DECONSTRUCTING))(POS (PAPER.BIBTEX RUEB2000DECONSTRUCTING INPROCEEDINGS))(POS (PAPER.AUTHOR RUEB2000DECONSTRUCTING "Harald Rueb and Nataranjan Shankar"))(POS (PAPER.TITLE RUEB2000DECONSTRUCTING "Deconstructing Shostak"))(POS (PAPER.PUBLICATION RUEB2000DECONSTRUCTING "17th International Conference on Automated Deduction
           "))(POS (PAPER.LINK RUEB2000DECONSTRUCTING "http://citeseer.ist.psu.edu/290082.html"))(POS (PAPER.YEAR RUEB2000DECONSTRUCTING 2000))(POS (PAPER.RANK RUEB2000DECONSTRUCTING "[****]"))(POS (PAPER.DESCRIPTION RUEB2000DECONSTRUCTING "
Rueb and Shankar show the crisply outlined Shostak procedure outlined
in cyrluk96shostaks and all its variants to date are incomplete.  They
go further and give a complete version of the Shostak procedure and
finally give soundness and completeness proofs.
"))(POS (PAPER.TOPIC RUEB2000DECONSTRUCTING "Nelson-Oppen and Shostak"))(POS (PAPER.RELATED RUEB2000DECONSTRUCTING CYRLUK96SHOSTAKS))(POS (PAPER.RELATED RUEB2000DECONSTRUCTING SHOSTAK84))(POS (PAPER.INSTANCE SABIN96))(POS (PAPER.BIBTEX SABIN96 ARTICLE))(POS (PAPER.AUTHOR SABIN96 "D. Sabin and E. Freuder"))(POS (PAPER.TITLE SABIN96 "Configuration as Composite Constraint Satisfaction"))(POS (PAPER.PUBLICATION SABIN96 " AAAI Configuration Workshop"))(POS (PAPER.STARTPAGE SABIN96 28))(POS (PAPER.ENDPAGE SABIN96 36))(POS (PAPER.LINK SABIN96 "http://citeseer.ist.psu.edu/sabin96configuration.html"))(POS (PAPER.YEAR SABIN96 1996))(POS (PAPER.RANK SABIN96 "[****]"))(POS (PAPER.DESCRIPTION SABIN96 "
Sabin and Freuder define a new form of CSP which generalizes 
Meta CSPs, conditional CSPs, and hierarchical domain CSPs.
Composite CSP domain values are the set of solutions to an
entire subproblem.
"))(POS (PAPER.TOPIC SABIN96 "Various Forms of Constraint Satisfaction"))(POS (PAPER.INSTANCE SACERDOTI74))(POS (PAPER.AUTHOR SACERDOTI74 "Earl D. Sacerdoti"))(POS (PAPER.TITLE SACERDOTI74 "Planning in a Hierarchy of Abstraction Spaces"))(POS (PAPER.PUBLICATION SACERDOTI74 "Artificial Intelligence"))(POS (PAPER.VOLUME SACERDOTI74 "5"))(POS (PAPER.STARTPAGE SACERDOTI74 115))(POS (PAPER.ENDPAGE SACERDOTI74 135))(POS (PAPER.YEAR SACERDOTI74 1974))(POS (PAPER.DESCRIPTION SACERDOTI74 "
The ABSTRIPS (Abstraction-based STRIPS) paper.  In 1969, McCarthy and Hayes' asserted that knowledge representation should be epistemologically adequate and also define heuristic adequacy.  Sufficiently complex problems contain too many details to be epistemologically adequate and have adequeate heuristics.  To that end, Sacerdoti first plans through an abstract plan space and then refines a solution in that space to ensure the details support the abstraction.  To implement this idea, Sacerdoti extends STRIPS by assigning 'criticality' measures to each precondition of an action.  These measures define a hierarchy of abstraction spaces.  The planner finds a solution at the highest level of abstraction, and proceeds recursively to the next highest level.  Control of the search (i.e. the cost assigned to nodes in the search space) changes based on the level of abstraction.
"))(POS (PAPER.TOPIC SACERDOTI74 "Historical"))(POS (PAPER.INSTANCE SACERDOTI75))(POS (PAPER.AUTHOR SACERDOTI75 "Earl D. Sacerdoti"))(POS (PAPER.TITLE SACERDOTI75 "The Nonlinear Nature of Plans"))(POS (PAPER.PUBLICATION SACERDOTI75 "Aritificial Intelligence"))(POS (PAPER.VOLUME SACERDOTI75 "32"))(POS (PAPER.STARTPAGE SACERDOTI75 333))(POS (PAPER.ENDPAGE SACERDOTI75 377))(POS (PAPER.YEAR SACERDOTI75 1975))(POS (PAPER.DESCRIPTION SACERDOTI75 "
Sacerdoti describes NOAH (Nets Of Action Hierarchies), the first partial order
planner that relies heavily on the concept of a procedural net.  A 'procedural
net' is the data structure that maintains the
partially-ordered plan.  Much like his earlier work on
Hierarchical Planning, NOAH begins with an abstract
plan and continually refines it, alleviating conflicts through the use of
critics, until the plan consists of primitive actions.
"))(POS (PAPER.TOPIC SACERDOTI75 "Historical"))(POS (PAPER.INSTANCE SAGONAS94))(POS (PAPER.BIBTEX SAGONAS94 INPROCEEDINGS))(POS (PAPER.AUTHOR SAGONAS94 "K. Sagonas and T. Swift and D. S. Warren"))(POS (PAPER.TITLE SAGONAS94 "XSB as an Efficient Deductive Database Engine"))(POS (PAPER.PUBLICATION SAGONAS94 "Proceedings of the ACM SIGMOD International Conference on the Management of Data>"))(POS (PAPER.STARTPAGE SAGONAS94 442))(POS (PAPER.ENDPAGE SAGONAS94 453))(POS (PAPER.YEAR SAGONAS94 1994))(POS (PAPER.DESCRIPTION SAGONAS94 "
XSB is Warren's current Prolog implementation, which includes tabling.
"))(POS (PAPER.TOPIC SAGONAS94 "Logic Programming"))(POS (PAPER.INSTANCE SAIS94))(POS (PAPER.BIBTEX SAIS94 INPROCEEDINGS))(POS (PAPER.AUTHOR SAIS94 "Lakhdar Sais"))(POS (PAPER.TITLE SAIS94 "Characterization of the Set of Models by Means of Symmetries"))(POS (PAPER.PUBLICATION SAIS94 "Second International Workshop on Principles and Practice of Constraint Programming"))(POS (PAPER.LINK SAIS94 "http://citeseer.ist.psu.edu/162645.html"))(POS (PAPER.YEAR SAIS94 1994))(POS (PAPER.RANK SAIS94 "[**]"))(POS (PAPER.DESCRIPTION SAIS94 "
Sais gives an algorithm that seems to compute the characteristic models
of a given propositional, CNF theory.  There is no proof that the models
generated are exactly a set of characteristic models, but rather that
the models generated are non-symmetric.  [Maybe the equivalence is obvious,
but there is no theorem stating it.]
"))(POS (PAPER.TOPIC SAIS94 "Characteristic Models"))(POS (PAPER.INSTANCE SANDFORD80))(POS (PAPER.BIBTEX SANDFORD80 ARTICLE))(POS (PAPER.AUTHOR SANDFORD80 "David Sandford"))(POS (PAPER.TITLE SANDFORD80 "Using Sophisticated Models in Resolution Theorem Proving"))(POS (PAPER.PUBLISHER SANDFORD80 "Springer-Verlag"))(POS (PAPER.PUBLICATION SANDFORD80 "Lecture Notes in Computer Science"))(POS (PAPER.VOLUME SANDFORD80 "90"))(POS (PAPER.LINK SANDFORD80 ""))(POS (PAPER.YEAR SANDFORD80 1980))(POS (PAPER.RANK SANDFORD80 "[**]"))(POS (PAPER.DESCRIPTION SANDFORD80 "
Sandford describes a new refinement of semantic resolution, hereditary 
lock resolution, and a new approach for representing models as required 
in semantic resolution.  The pertinent part of the work is the model 
representation.  Semantic resolution puts clauses into two bins throughout 
the resolution process.  Part of the input to the procedure is a model, 
any model, and those clauses that are satisfied by the model are put into 
bin 1 while clauses not satisfied by the model are put into bin 2.  
This partitioning of clauses shrinks the search space since every resolution 
must use at least one clause from the set of unsatisfied clauses.  
Sandford describes a method for using a set of sentences to define that 
model (in possibly a totally different language) and using a satisfaction 
test to determine whether a clause belongs in bin 1 or 2.   Of course, 
the computational and complexity properties could be horrible, but so 
long as the satisfaction test is sound (only returns true when the sentences 
and clause are satisfiable), we retain completeness. 
"))(POS (PAPER.TOPIC SANDFORD80 "Model-Guided Proof Techniques"))(POS (PAPER.INSTANCE SCHULZ2001))(POS (PAPER.BIBTEX SCHULZ2001 INPROCEEDINGS))(POS (PAPER.AUTHOR SCHULZ2001 "S. Schulz"))(POS (PAPER.TITLE SCHULZ2001 "A Comparison of Different Techniques for Grounding Near-Propositional CNF Formulae"))(POS (PAPER.PUBLICATION SCHULZ2001 "Proc. 15th International FLAIRS Conference"))(POS (PAPER.STARTPAGE SCHULZ2001 72))(POS (PAPER.ENDPAGE SCHULZ2001 76))(POS (PAPER.LINK SCHULZ2001 "http://citeseer.ist.psu.edu/565512.html"))(POS (PAPER.YEAR SCHULZ2001 2002))(POS (PAPER.DESCRIPTION SCHULZ2001 "
Paper comparing various approaches for grounding a set of first-order, function-free clauses.  Won best-paper at FLAIR 2002.
"))(POS (PAPER.TOPIC SCHULZ2001 "Reformulation"))(POS (PAPER.INSTANCE SCHULZ2002))(POS (PAPER.BIBTEX SCHULZ2002 INPROCEEDINGS))(POS (PAPER.BIBTEX SCHULZ2002 ARTICLE))(POS (PAPER.AUTHOR SCHULZ2002 "Stephan Schulz"))(POS (PAPER.AUTHOR SCHULZ2002 "Stephan Schulz"))(POS (PAPER.TITLE SCHULZ2002 "A Comparison of Different Techniques for Grounding Near-Propositional CNF Formulae"))(POS (PAPER.TITLE SCHULZ2002 "E - A brainiac theorem prover"))(POS (PAPER.PUBLICATION SCHULZ2002 "Proceedings, 15th International FLAIRS Conference"))(POS (PAPER.PUBLICATION SCHULZ2002 "AI Communications"))(POS (PAPER.VOLUME SCHULZ2002 "15"))(POS (PAPER.STARTPAGE SCHULZ2002 72))(POS (PAPER.STARTPAGE SCHULZ2002 111))(POS (PAPER.ENDPAGE SCHULZ2002 76))(POS (PAPER.ENDPAGE SCHULZ2002 126))(POS (PAPER.LINK SCHULZ2002 "http://citeseer.ist.psu.edu/565512.html"))(POS (PAPER.LINK SCHULZ2002 "http://citeseer.ist.psu.edu/560030.html"))(POS (PAPER.YEAR SCHULZ2002 2002))(POS (PAPER.YEAR SCHULZ2002 2002))(POS (PAPER.RANK SCHULZ2002 ""))(POS (PAPER.DESCRIPTION SCHULZ2002 "
Schulz compares three techniques for reducing the cost of generating 
the grounding of universal clause sets without function symbols.  The
first is hypersplitting, a generalization of which is (now) used in
the model builders that ground and use SAT solvers, structural constraints,
restricting instantiations to avoid the creation of pure literals, and 
post-processing the grounded sentences via unit subsumption, unit
propagation, and tautology deletion.  The combination of all three
outperformed any one of the techniques.
"))(POS (PAPER.DESCRIPTION SCHULZ2002 "
Schulz describes E, a full first-order theorem prover with
equality.  It is a saturation-based prover from a purely 
equational view. It is based on the superposition calculus
with literal selection and was one of the first to use
the DISCOUNT algorithm.  The paper first describes the 
calculus, gives the proof search algorithm, discusses
search control by way of clause and literal selection,
term orderings, and auto configuration.  It delves into
implementation details: shared terms and indexing.
"))(POS (PAPER.TOPIC SCHULZ2002 "Herbrand Logic"))(POS (PAPER.TOPIC SCHULZ2002 "System Designs"))(POS (PAPER.INSTANCE SCHUTZ96))(POS (PAPER.BIBTEX SCHUTZ96 ARTICLE))(POS (PAPER.AUTHOR SCHUTZ96 "Heribert Schutz"))(POS (PAPER.TITLE SCHUTZ96 "Comparison of Two Complementary Herbrand Model Generators"))(POS (PAPER.LINK SCHUTZ96 "http://citeseer.ist.psu.edu/122874.html"))(POS (PAPER.YEAR SCHUTZ96 1996))(POS (PAPER.RANK SCHUTZ96 "[**]"))(POS (PAPER.DESCRIPTION SCHUTZ96 "
Schutz describes and analyzes two different Herbrand model-building 
techniques built on hyperresolution.  He shows that some of the 
strengths of one can be used to help on cases where the other is weak
and vice versa.  
"))(POS (PAPER.TOPIC SCHUTZ96 "Model Building"))(POS (PAPER.INSTANCE SELMAN91))(POS (PAPER.BIBTEX SELMAN91 INPROCEEDINGS))(POS (PAPER.AUTHOR SELMAN91 "Bart Selman and Henry Kautz"))(POS (PAPER.TITLE SELMAN91 "Knowledge Compilation Using Horn Approximations"))(POS (PAPER.PUBLICATION SELMAN91 "AAAI"))(POS (PAPER.LINK SELMAN91 "http://citeseer.ist.psu.edu/selman91knowledge.html"))(POS (PAPER.YEAR SELMAN91 1991))(POS (PAPER.RANK SELMAN91 "[****]"))(POS (PAPER.DESCRIPTION SELMAN91 "
This seems to be the seminal work on Knowledge Compilation.  Selman and
Kautz investigate finding two Horn approximations for a propositional 
knowledge base: one that is too strong and one that is too weak.  The 
algorithms for computing those approximations are anytime algorithms. 
To determine whether a given sentence p is entailed by the original
knowledge base, return yes if the strong approximation entails it and
no if the weak one doesn't.  If neither of these two cases hold, resort
to the original knowledge base.  Since entailment for propositional Horn
requires linear time, the worst case wastes O(2n) computation time, but
the best case might save exponential time.
"))(POS (PAPER.TOPIC SELMAN91 "Knowledge Base Compilation"))(POS (PAPER.INSTANCE SELMAN96))(POS (PAPER.BIBTEX SELMAN96 ARTICLE))(POS (PAPER.AUTHOR SELMAN96 "Bart Selman and Henry Kautz"))(POS (PAPER.TITLE SELMAN96 "Knowledge Compilation and Theory Approximation"))(POS (PAPER.PUBLICATION SELMAN96 "Journal of the ACM "))(POS (PAPER.VOLUME SELMAN96 "43(2)"))(POS (PAPER.STARTPAGE SELMAN96 193))(POS (PAPER.ENDPAGE SELMAN96 224))(POS (PAPER.LINK SELMAN96 "http://citeseer.ist.psu.edu/41052.html"))(POS (PAPER.YEAR SELMAN96 1996))(POS (PAPER.RANK SELMAN96 "[*****]"))(POS (PAPER.DESCRIPTION SELMAN96 "
This paper essentially glues together the work of kautz91, selman91,
kautz92,  and kautz95.  Especially noteworthy is the thorough related
work section.  It also brought together the fact that the Greatest
Upper Bound approximation of a propositional theory is always linear
in the size of the theory, but the Least Upper Bound can be exponential
in the size of the theory.
"))(POS (PAPER.TOPIC SELMAN96 "Knowledge Base Compilation"))(POS (PAPER.RELATED SELMAN96 SELMAN91))(POS (PAPER.RELATED SELMAN96 KAUTZ91))(POS (PAPER.RELATED SELMAN96 KAUTZ92))(POS (PAPER.RELATED SELMAN96 KAUTZ95))(POS (PAPER.INSTANCE SHERL93))(POS (PAPER.AUTHOR SHERL93 "R. Sherl and H. Levesque"))(POS (PAPER.TITLE SHERL93 "The frame problem and knowledge-producing actions"))(POS (PAPER.LINK SHERL93 "http://citeseer.ist.psu.edu/scherl93frame.html"))(POS (PAPER.YEAR SHERL93 1993))(POS (PAPER.DESCRIPTION SHERL93 "None yet.
"))(POS (PAPER.TOPIC SHERL93 "Planning with Sensing Actions"))(POS (PAPER.INSTANCE SHOSTAK84))(POS (PAPER.BIBTEX SHOSTAK84 ARTICLE))(POS (PAPER.AUTHOR SHOSTAK84 "Robert Shostak"))(POS (PAPER.TITLE SHOSTAK84 "Deciding Combinations of Theories"))(POS (PAPER.PUBLICATION SHOSTAK84 "Journal of the ACM
           "))(POS (PAPER.VOLUME SHOSTAK84 "31"))(POS (PAPER.STARTPAGE SHOSTAK84 1))(POS (PAPER.ENDPAGE SHOSTAK84 12))(POS (PAPER.LINK SHOSTAK84 "http://portal.acm.org/citation.cfm?id=322411&dl=ACM&coll=portal"))(POS (PAPER.YEAR SHOSTAK84 1984))(POS (PAPER.RANK SHOSTAK84 "[****]"))(POS (PAPER.DESCRIPTION SHOSTAK84 "
Shostak describes what is now commonly known as Shostak's decision procedure.
The decision procedure works on algebraically solvable and canonizable 
equational theories.  It functions by computing the congruence closure of 
the terms in the language representing each one by their canonical forms.  
The canonization takes into account both interpreted and unintepreted
functions.  Unlike Nelson Oppen, Shostak shows how to merge the decision
procedures for two theories by taking a solver and canonizer for each and
building a single solver and canonizer pair for the union of the theories.
"))(POS (PAPER.TOPIC SHOSTAK84 "Nelson-Oppen and Shostak"))(POS (PAPER.RELATED SHOSTAK84 NELSON79))(POS (PAPER.INSTANCE SIKKA96))(POS (PAPER.BIBTEX SIKKA96 PHDTHESIS))(POS (PAPER.AUTHOR SIKKA96 "Vishal Sikka"))(POS (PAPER.TITLE SIKKA96 "Integrating Specialized Procedures into Proof Systems"))(POS (PAPER.PUBLISHER SIKKA96 "Stanford University"))(POS (PAPER.LINK SIKKA96 "http://library.stanford.edu/depts/mathcs/mathcscoll/techreports.html"))(POS (PAPER.YEAR SIKKA96 1996))(POS (PAPER.RANK SIKKA96 "[*****]"))(POS (PAPER.DESCRIPTION SIKKA96 "
Compiled code can be used by a theorem prover to expedite a proof.  
Sikka describes a general method for integrating such specialized 
procedures into proof systems using function constants, data 
structure constants, and the 'apply' operator.  
"))(POS (PAPER.TOPIC SIKKA96 "Theorem Proving with Attachments"))(POS (PAPER.INSTANCE SIPSER))(POS (PAPER.BIBTEX SIPSER BOOK))(POS (PAPER.AUTHOR SIPSER "Michael Sipser"))(POS (PAPER.TITLE SIPSER "Introduction to the Theory of Computation"))(POS (PAPER.PUBLISHER SIPSER "Brooks Cole"))(POS (PAPER.LINK SIPSER "http://www.amazon.com/exec/obidos/tg/detail/-/053494728X/qid=1062605920/sr=1-1/ref=sr_1_1/102-6107129-2481765?v=glance&s=books"))(POS (PAPER.YEAR SIPSER 1996))(POS (PAPER.RANK SIPSER "[*****]"))(POS (PAPER.DESCRIPTION SIPSER "
One of the two definitive introductions to the theory of computation.  Sipser
covers automata and languages, computability theory, and complexity theory.
"))(POS (PAPER.TOPIC SIPSER ""))(POS (PAPER.INSTANCE SLANEY93))(POS (PAPER.BIBTEX SLANEY93 INPROCEEDINGS))(POS (PAPER.AUTHOR SLANEY93 "John Slaney"))(POS (PAPER.TITLE SLANEY93 "SCOTT: A Model-Guided Theorem Prover"))(POS (PAPER.PUBLICATION SLANEY93 "IJCAI"))(POS (PAPER.LINK SLANEY93 "http://citeseer.ist.psu.edu/slaney93scott.html"))(POS (PAPER.YEAR SLANEY93 1993))(POS (PAPER.RANK SLANEY93 "[***]"))(POS (PAPER.DESCRIPTION SLANEY93 "
Slaney describes a case study of SCOTT (Semantically Constrained
Otter).  SCOTT consists of OTTER augmented with a model-generator
FINDER.  It restricts the resolutions done by Otter to include one
parent clause not true in the model being generated.  A new model
is generated every time a new clause is generated that is false
in the current model (up to 100 clauses).  If no new model can 
be found, the old one is used.  SCOTT retains completeness
for binary resolution since every model generated is a model of the
usable list (those axioms assumed to be consistent).  
"))(POS (PAPER.TOPIC SLANEY93 "Model-Guided Proof Techniques"))(POS (PAPER.INSTANCE SLANEY94))(POS (PAPER.BIBTEX SLANEY94 INPROCEEDINGS))(POS (PAPER.BIBTEX SLANEY94 INPROCEEDINGS))(POS (PAPER.AUTHOR SLANEY94 "John Slaney"))(POS (PAPER.AUTHOR SLANEY94 "John Slaney"))(POS (PAPER.TITLE SLANEY94 "Finder: Finite Domain Enumerator System Description"))(POS (PAPER.TITLE SLANEY94 "The Crisis in Finite Mathematics: Automated Reasoning as Cause and Cure"))(POS (PAPER.PUBLICATION SLANEY94 "In proceedings, CADE-12"))(POS (PAPER.PUBLICATION SLANEY94 "CADE"))(POS (PAPER.LINK SLANEY94 "http://citeseer.ist.psu.edu/252758.html"))(POS (PAPER.LINK SLANEY94 "http://arp.anu.edu.au/~jks/constraints.html"))(POS (PAPER.YEAR SLANEY94 1994))(POS (PAPER.YEAR SLANEY94 1994))(POS (PAPER.RANK SLANEY94 ""))(POS (PAPER.DESCRIPTION SLANEY94 "
Very short description of Finder, a model builder for FOL.  It grounds and
then uses a combination of tableaux and negative hyperresolution.  Used
in SCOTT to constrain the search space of Otter.
"))(POS (PAPER.DESCRIPTION SLANEY94 "
Slaney describes the problems associated with using machines to exhaustively
check a solution space as proof of the non-existence of a solution.  Is that
really a proof?  Afterall, no one will actually verify such a proof.
But, if a theorem prover outputs a trace, we can check the trace with an
independent proof checker.  This trace-checking may be much easier than
proving the correctness of a theorem prover.
"))(POS (PAPER.TOPIC SLANEY94 "Model Building"))(POS (PAPER.TOPIC SLANEY94 "Theorem Proving"))(POS (PAPER.INSTANCE SOUTCHANSKI2000))(POS (PAPER.AUTHOR SOUTCHANSKI2000 "Mikhail Soutchanski"))(POS (PAPER.TITLE SOUTCHANSKI2000 "An On-line Decision-Theoretic Golog Interpreter"))(POS (PAPER.PUBLICATION SOUTCHANSKI2000 "AAAI"))(POS (PAPER.LINK SOUTCHANSKI2000 "http://www.cs.toronto.edu/~cebly/papers.html"))(POS (PAPER.YEAR SOUTCHANSKI2000 2000))(POS (PAPER.DESCRIPTION SOUTCHANSKI2000 "
Building on previous work, Southchanski couples Golog with a decision-theoretic planner based on Markov decision processes.  The original work found a optimal conditional policy, the probability that the policy could be executed, and the expected utility of the policy all offline.  This is really only possible in an environment without sensing actions with continuous return values.  Soutchanski also points out that only a single policy can be computed for an entire program, even if the program could be easily partitioned into two independent portions.  Soutchanski introduces optimize(p1);p2 to indicate that a single policy should be found for program p1 and another for program p2.  He also gives a new formulation of sensing actions of the form sense(act, value, s), meaning the result of executing the action act is value in situation s.  Since Golog is an online interpreter, sensing actions with continuous return values can be handled.
"))(POS (PAPER.TOPIC SOUTCHANSKI2000 "Logic Programming"))(POS (PAPER.INSTANCE SQALLI2001))(POS (PAPER.AUTHOR SQALLI2001 "Mohammed Sqalli and Eugene Freuder"))(POS (PAPER.TITLE SQALLI2001 "Solving InterOperability Problems Using Object-Oriented CSP 
 Modeling"))(POS (PAPER.LINK SQALLI2001 "http://citeseer.ist.psu.edu/487285.html"))(POS (PAPER.YEAR SQALLI2001 2001))(POS (PAPER.RANK SQALLI2001 "[**]"))(POS (PAPER.DESCRIPTION SQALLI2001 "
Sqalli and Freuder describe a combination of Case-based reasoning
and constraint satisfaction.  They use Paltrinieri's OOCSP definition
except that they add methods to classes.  To solve an OOCSP, they
convert it to a standard CSP.  
"))(POS (PAPER.TOPIC SQALLI2001 "Object Oriented Constraint Satisfaction"))(POS (PAPER.INSTANCE STICKEL85))(POS (PAPER.BIBTEX STICKEL85 ARTICLE))(POS (PAPER.AUTHOR STICKEL85 "Mark Stickel"))(POS (PAPER.TITLE STICKEL85 "Automated Deduction by Theory Resolution"))(POS (PAPER.PUBLICATION STICKEL85 "Journal of Automated Reasoning"))(POS (PAPER.VOLUME STICKEL85 "1"))(POS (PAPER.STARTPAGE STICKEL85 333))(POS (PAPER.ENDPAGE STICKEL85 356))(POS (PAPER.LINK STICKEL85 "http://citeseer.ist.psu.edu/stickel85automated.html"))(POS (PAPER.YEAR STICKEL85 1985))(POS (PAPER.RANK STICKEL85 "[***]"))(POS (PAPER.DESCRIPTION STICKEL85 "
The theory resolution paper.
"))(POS (PAPER.TOPIC STICKEL85 "Theorem Proving with Attachments"))(POS (PAPER.INSTANCE STICKEL87))(POS (PAPER.AUTHOR STICKEL87 "Mark Stickel"))(POS (PAPER.TITLE STICKEL87 "A Prolog Technology Theorem Prover"))(POS (PAPER.LINK STICKEL87 "http://citeseer.ist.psu.edu/stickel87prolog.html"))(POS (PAPER.YEAR STICKEL87 1987))(POS (PAPER.DESCRIPTION STICKEL87 "
"))(POS (PAPER.TOPIC STICKEL87 "Calculi"))(POS (PAPER.INSTANCE STICKEL94))(POS (PAPER.BIBTEX STICKEL94 ARTICLE))(POS (PAPER.AUTHOR STICKEL94 "Mark Stickel and Richard Waldinger and Michael Lowry and Thomas Pressburger and Ian Underwood"))(POS (PAPER.TITLE STICKEL94 "Deductive Composition of Astronomical Software from Subroutine Libraries"))(POS (PAPER.PUBLICATION STICKEL94 "Conference on Automated Deduction"))(POS (PAPER.STARTPAGE STICKEL94 341))(POS (PAPER.ENDPAGE STICKEL94 355))(POS (PAPER.LINK STICKEL94 "http://citeseer.ist.psu.edu/67907.html"))(POS (PAPER.YEAR STICKEL94 1994))(POS (PAPER.RANK STICKEL94 "[*]"))(POS (PAPER.DESCRIPTION STICKEL94 "
The authors describe a system that allows a user to graphically describe
a specification for a system relying on subroutine libraries and then uses
automated deduction techniques to produce a proof of the specification from
axioms describing the library.  That proof is then translated into a 
Fortran program.
"))(POS (PAPER.TOPIC STICKEL94 "Miscellaneous"))(POS (PAPER.INSTANCE STONE))(POS (PAPER.BIBTEX STONE ARTICLE))(POS (PAPER.AUTHOR STONE "Nicholas Stone"))(POS (PAPER.TITLE STONE "Object-Oriented Constraint Satisfaction Planning for Whole Farm
Management"))(POS (PAPER.PUBLICATION STONE "AI Applications"))(POS (PAPER.LINK STONE "http://everest.ento.vt.edu/Publications/NDS-Paper-.html"))(POS (PAPER.YEAR STONE NIL))(POS (PAPER.RANK STONE "[*]"))(POS (PAPER.DESCRIPTION STONE "
Stone describes an Object-oriented approach to writing a planner.
"))(POS (PAPER.TOPIC STONE "Miscellaneous"))(POS (PAPER.INSTANCE STRZALKOWSKI91))(POS (PAPER.BIBTEX STRZALKOWSKI91 ARTICLE))(POS (PAPER.AUTHOR STRZALKOWSKI91 "Tomek Strzalkowski"))(POS (PAPER.TITLE STRZALKOWSKI91 "A General Computational Method for Grammar Inversion"))(POS (PAPER.LINK STRZALKOWSKI91 "http://acl.ldc.upenn.edu/W/W91/W91-0112.pdf"))(POS (PAPER.YEAR STRZALKOWSKI91 1991))(POS (PAPER.RANK STRZALKOWSKI91 "[***]"))(POS (PAPER.DESCRIPTION STRZALKOWSKI91 "
Strzalkowski describes a procedure for converting a unification grammar defined in Prolog, which was built for sentence parsing, into another set of Prolog rules for sentence generation.
"))(POS (PAPER.TOPIC STRZALKOWSKI91 "Natural Language Processing"))(POS (PAPER.INSTANCE SUCHENEK93))(POS (PAPER.BIBTEX SUCHENEK93 ARTICLE))(POS (PAPER.AUTHOR SUCHENEK93 "Marek Suchenek"))(POS (PAPER.TITLE SUCHENEK93 "First-Order Syntactic Characterizations of Minimal Entailment, Domain-Minimal Entailment, and Herbrand Entailment"))(POS (PAPER.LINK SUCHENEK93 "www.springerlink.com/index/L14483241892Q613.pdf"))(POS (PAPER.YEAR SUCHENEK93 1993))(POS (PAPER.RANK SUCHENEK93 "[***]"))(POS (PAPER.DESCRIPTION SUCHENEK93 "
Suchenek treats formally three types of minimal-model theory: minimal
entailment (cwa), Herbrand entailment (only the Herbrand models exist),
and domain-minimal entailment (only elements in the domain are those
that must be in the domain).  Touches on domain closure, unique-names,
deductive databases, closed world, non-mon.
"))(POS (PAPER.TOPIC SUCHENEK93 "Herbrand Logic"))(POS (PAPER.INSTANCE SUSSMAN74))(POS (PAPER.AUTHOR SUSSMAN74 "Gerald J. Sussman"))(POS (PAPER.TITLE SUSSMAN74 "The Virtuous Nature of Bugs"))(POS (PAPER.YEAR SUSSMAN74 1974))(POS (PAPER.DESCRIPTION SUSSMAN74 "
Sussman describes HACKER, a total-order planner that composes stored subroutines to achieve its goal.  If subgoals conflict, HACKER identifies a bug in the plan it has generated and debugs it.  To do so, it matches a model of the behavior of the misbehaving plan with prototypes of bugs.  Once a match is found, a 'critic' is compiled with what HACKER has learned from the debugging.  In future plans, critics are used to avoid pitfalls already seen.
"))(POS (PAPER.TOPIC SUSSMAN74 "Historical"))(POS (PAPER.INSTANCE SUTCLIFFE98))(POS (PAPER.BIBTEX SUTCLIFFE98 ARTICLE))(POS (PAPER.AUTHOR SUTCLIFFE98 "G. Sutcliffe and C.B. Suttner"))(POS (PAPER.TITLE SUTCLIFFE98 "The TPTP Problem Library: CNF Release v1.2.1"))(POS (PAPER.PUBLICATION SUTCLIFFE98 "Journal of Automated Reasoning"))(POS (PAPER.VOLUME SUTCLIFFE98 "21(2)"))(POS (PAPER.STARTPAGE SUTCLIFFE98 177))(POS (PAPER.ENDPAGE SUTCLIFFE98 203))(POS (PAPER.LINK SUTCLIFFE98 "http://citeseer.ist.psu.edu/30379.html"))(POS (PAPER.YEAR SUTCLIFFE98 1998))(POS (PAPER.RANK SUTCLIFFE98 ""))(POS (PAPER.DESCRIPTION SUTCLIFFE98 "
Paper on the TPTP library.
"))(POS (PAPER.TOPIC SUTCLIFFE98 "Theorem Proving"))(POS (PAPER.INSTANCE SUTCLIFFE98CADE))(POS (PAPER.BIBTEX SUTCLIFFE98CADE ARTICLE))(POS (PAPER.AUTHOR SUTCLIFFE98CADE "Christian Suttner and Geoff Sutcliffe"))(POS (PAPER.TITLE SUTCLIFFE98CADE "The CADE-14 ATP System Competition"))(POS (PAPER.PUBLICATION SUTCLIFFE98CADE "Journal of Automated Reasoning"))(POS (PAPER.VOLUME SUTCLIFFE98CADE "21(1)"))(POS (PAPER.STARTPAGE SUTCLIFFE98CADE 99))(POS (PAPER.ENDPAGE SUTCLIFFE98CADE 134))(POS (PAPER.LINK SUTCLIFFE98CADE "http://citeseer.ist.psu.edu/87162.html"))(POS (PAPER.YEAR SUTCLIFFE98CADE 1998))(POS (PAPER.RANK SUTCLIFFE98CADE ""))(POS (PAPER.DESCRIPTION SUTCLIFFE98CADE "
Paper on the results of one of the CASC competitions: the yearly first-order theorem proving competition held at CADE.
"))(POS (PAPER.TOPIC SUTCLIFFE98CADE "Theorem Proving"))(POS (PAPER.INSTANCE SWAMY2000))(POS (PAPER.BIBTEX SWAMY2000 PHDTHESIS))(POS (PAPER.AUTHOR SWAMY2000 "Nikhil Swamy"))(POS (PAPER.TITLE SWAMY2000 "A Study in Automated Reasoning about Abstract Algebra"))(POS (PAPER.LINK SWAMY2000 "http://www.cs.umd.edu/~nswamy/thesis/ch2-IntroToATP.ps"))(POS (PAPER.YEAR SWAMY2000 2000))(POS (PAPER.RANK SWAMY2000 ""))(POS (PAPER.DESCRIPTION SWAMY2000 "
Swamy's second chapter (Advanced theorem proving techniques) gives a good
overview of resolution-style theorem-proving and definitions/proofs
of UR-Resolution, Hyperresolution, factoring, paramodulation,
subsumption, demodulation, set of support, and Knuth-Bendix completion.
Link goes to said chapter.
"))(POS (PAPER.TOPIC SWAMY2000 "Theorem Proving"))(POS (PAPER.INSTANCE TAMMET2001))(POS (PAPER.BIBTEX TAMMET2001 MISC))(POS (PAPER.AUTHOR TAMMET2001 "Tanel Tammet"))(POS (PAPER.TITLE TAMMET2001 "Finite model building: improvements and comparisons"))(POS (PAPER.LINK TAMMET2001 "http://citeseer.ist.psu.edu/675660.html"))(POS (PAPER.YEAR TAMMET2001 2001))(POS (PAPER.DESCRIPTION TAMMET2001 "
Comparison of Mace 2.0 and Falcon-style finite model builders, along
with some enhancements to Falcon to produce Gandolf.  Mace 2.0 used flattening,
grounding, and boolean sat solvers.  Falcon used consequence finding during
incremental model generation, much like arc consistency in CSPs.
"))(POS (PAPER.TOPIC TAMMET2001 "Model Building"))(POS (PAPER.INSTANCE TAMMET2002))(POS (PAPER.BIBTEX TAMMET2002 ARTICLE))(POS (PAPER.AUTHOR TAMMET2002 "Tanel Tammete"))(POS (PAPER.TITLE TAMMET2002 "Finite model building: improvements and comparisons"))(POS (PAPER.LINK TAMMET2002 "http://citeseer.ist.psu.edu/675660.html"))(POS (PAPER.YEAR TAMMET2002 2002))(POS (PAPER.RANK TAMMET2002 ""))(POS (PAPER.DESCRIPTION TAMMET2002 "
Tammet gives an overview of two different styles of finite model builders
after situating the topic in the context of automated reasoning: Mace and
Falcon.  Mace operates by reducing the problem to one of propositional 
satisfiability and employing a SAT solver.  Tammet describes an augmentation
of Mace (nonground splitting) to reduce the number of distinct variables
in a clause (suboptimally).  Falcon works almost as a naive model builder
but makes certain inferences to prune the search.  Both the Mace-style
and Falcon-style builder were implemented  in Gandalf, a theorem-prover/
model checker written in Scheme and compiled into C.  Various versions
of the two builders were run over the 2002 satisfiable CASC problems,
and some conclusions were drawn.
"))(POS (PAPER.TOPIC TAMMET2002 "Model Building"))(POS (PAPER.INSTANCE THIFFAULT2004))(POS (PAPER.BIBTEX THIFFAULT2004 INPROCEEDINGS))(POS (PAPER.AUTHOR THIFFAULT2004 "Christian Thiffault and Fahiem Bacchus and Toby Walsh"))(POS (PAPER.TITLE THIFFAULT2004 "Solving Non-clausal Formulas with DPLL Search"))(POS (PAPER.PUBLICATION THIFFAULT2004 "Proceedings of the 10th International Conference on Principles and Practice of Constraint Programming"))(POS (PAPER.STARTPAGE THIFFAULT2004 663))(POS (PAPER.ENDPAGE THIFFAULT2004 678))(POS (PAPER.LINK THIFFAULT2004 "http://www.satisfiability.org/SAT04/accepted/71.html"))(POS (PAPER.YEAR THIFFAULT2004 2004))(POS (PAPER.DESCRIPTION THIFFAULT2004 "
A paper that adopts DPLL to handle Non-CNF directly.
"))(POS (PAPER.TOPIC THIFFAULT2004 "SAT Solving"))(POS (PAPER.INSTANCE TIN94))(POS (PAPER.BIBTEX TIN94 ARTICLE))(POS (PAPER.AUTHOR TIN94 "Erkan Tin and Varol Akman"))(POS (PAPER.TITLE TIN94 "Computatinal Situation Theory"))(POS (PAPER.PUBLICATION TIN94 "SIGART Bulletin"))(POS (PAPER.VOLUME TIN94 "5(4)"))(POS (PAPER.STARTPAGE TIN94 4))(POS (PAPER.ENDPAGE TIN94 17))(POS (PAPER.LINK TIN94 "http://portal.acm.org/citation.cfm?id=191604.191608"))(POS (PAPER.YEAR TIN94 1994))(POS (PAPER.RANK TIN94 "[*]"))(POS (PAPER.DESCRIPTION TIN94 "
Tin and Akman give an overview of Situation Theory, which allows
one to describe states of the world relative to spatio and temporal
positions.  This theory is used to give semantics to natural language
utterances.  The authors then overview several systems that deal
with situation theory.
"))(POS (PAPER.TOPIC TIN94 "Miscellaneous"))(POS (PAPER.INSTANCE TINELLI2000))(POS (PAPER.BIBTEX TINELLI2000 INPROCEEDINGS))(POS (PAPER.AUTHOR TINELLI2000 "Cesare Tinelli"))(POS (PAPER.TITLE TINELLI2000 "Cooperation of Background Reasoners in Theory Reasoning by
Residue Sharing"))(POS (PAPER.PUBLICATION TINELLI2000 "International Workshop on First Order Theorem Proving (FTP)
           "))(POS (PAPER.LINK TINELLI2000 "http://citeseer.ist.psu.edu/572497.html"))(POS (PAPER.YEAR TINELLI2000 2000))(POS (PAPER.RANK TINELLI2000 "[****]"))(POS (PAPER.DESCRIPTION TINELLI2000 "
Tinelli shows how to use theory reasoning to combine specialized reasoners in
a sound and complete way in the context of semantic tableaus.  The theories
those reasoners embody must be universal, a requirement for theory reasoning.
Tinelli's results hinge on an interpolation lemma that
requires all the background theory signatures to include all the
same functions.   This lemma shows that determining unsatisfiability of
wrt a set of theories requires only passing disjunctions of literals in
the common signature among the theories.  One can thus alter the tableau
procedure by allowing a new type of derivation: hand off a subset of the
literals on a particular branch which are of the appropriate signature
to the corresponding background reasoner.  If the reasoner returns
'unsatisfiable', close the branch; otherwise, add the residue to the
end of the branch.
"))(POS (PAPER.TOPIC TINELLI2000 "Theorem Proving with Attachments"))(POS (PAPER.INSTANCE TORLAK2006))(POS (PAPER.BIBTEX TORLAK2006 TECHREPORT))(POS (PAPER.AUTHOR TORLAK2006 "Emina Torlak and Daniel Jackson"))(POS (PAPER.TITLE TORLAK2006 "The Design of a Relational Engine"))(POS (PAPER.PUBLISHER TORLAK2006 "MIT-CSAIL"))(POS (PAPER.LINK TORLAK2006 "http://web.mit.edu/emina/www/kodkod.html"))(POS (PAPER.YEAR TORLAK2006 2006))(POS (PAPER.DESCRIPTION TORLAK2006 "
The authors describe a model-builder for a relational logic with transitive
closure and a finite domain.  The system does symmetry detection, compresses
expressions using compact boolean circuits, and
translates to propositional logic to answer queries using a SAT solver.
"))(POS (PAPER.TOPIC TORLAK2006 "Model Building"))(POS (PAPER.INSTANCE ULLMAN))(POS (PAPER.BIBTEX ULLMAN BOOK))(POS (PAPER.AUTHOR ULLMAN "J. Hopcroft and J. Ullman"))(POS (PAPER.TITLE ULLMAN "Introduction to Automata Theory, Languages, and Computation"))(POS (PAPER.PUBLISHER ULLMAN "Addison Wesley"))(POS (PAPER.LINK ULLMAN "http://www-db.stanford.edu/~ullman/ialc.html"))(POS (PAPER.YEAR ULLMAN 1979))(POS (PAPER.RANK ULLMAN "[*****]"))(POS (PAPER.DESCRIPTION ULLMAN "
One of the two definitive introductions to the theory of computation. Hopcroft
and Ullman--the classic.
"))(POS (PAPER.TOPIC ULLMAN ""))(POS (PAPER.INSTANCE ULLMAN96))(POS (PAPER.BIBTEX ULLMAN96 ARTICLE))(POS (PAPER.AUTHOR ULLMAN96 "Jeffrey Ullman"))(POS (PAPER.TITLE ULLMAN96 "The Database Approach to Knowledge Representation"))(POS (PAPER.PUBLICATION ULLMAN96 "AAAI"))(POS (PAPER.LINK ULLMAN96 "http://citeseer.ist.psu.edu/ullman96database.html"))(POS (PAPER.YEAR ULLMAN96 1996))(POS (PAPER.RANK ULLMAN96 "[****]"))(POS (PAPER.DESCRIPTION ULLMAN96 "
Ullman explains to the AI community the database perspective on
knowledge representation: start at low expressiveness and efficient computation
and work your way up.  Datalog (prolog w/o negation or functions)
is given the fixed-point semantics.  When extended with negation,
the least-fixed-point semantics are troublesome; stratified negation
and well-founded semantics have been developed to handle this.
Query containment of conjunctive queries is NP complete in general,
but is linear if no predicate appears more than twice in any
query.  Whether a conjunctive query is contained in a Datalog
program is exponential, and the reverse is decidable.  Rewriting
a query in terms of views has been done when the views are 
conjunctive queries as well as when the views are described
by Datalog programs.  
"))(POS (PAPER.TOPIC ULLMAN96 "Logical Knowledge Representation"))(POS (PAPER.INSTANCE ULLMANDB))(POS (PAPER.BIBTEX ULLMANDB BOOK))(POS (PAPER.AUTHOR ULLMANDB "Jeffrey Ullman"))(POS (PAPER.TITLE ULLMANDB "Principles of Database and Knowledge-Base Systems"))(POS (PAPER.PUBLISHER ULLMANDB "Computer Science Press"))(POS (PAPER.LINK ULLMANDB "http://www.amazon.com/exec/obidos/tg/detail/-/0716781581/qid=1110684085/sr=8-3/ref=sr_8_xs_ap_i3_xgl14/104-0791189-4759116?v=glance&s=books&n=507846"))(POS (PAPER.YEAR ULLMANDB 1989))(POS (PAPER.RANK ULLMANDB "[*****]"))(POS (PAPER.DESCRIPTION ULLMANDB "
This two-volume set describes how database principles can be applied to 
produce knowledge-based systems.
"))(POS (PAPER.TOPIC ULLMANDB ""))(POS (PAPER.INSTANCE URIBE2000))(POS (PAPER.BIBTEX URIBE2000 INPROCEEDINGS))(POS (PAPER.AUTHOR URIBE2000 "Tomas Uribe"))(POS (PAPER.TITLE URIBE2000 "Combinations of Model Checking and Theorem Proving"))(POS (PAPER.PUBLICATION URIBE2000 "Frontiers of Combining Systems (FroCoS)"))(POS (PAPER.STARTPAGE URIBE2000 151))(POS (PAPER.ENDPAGE URIBE2000 170))(POS (PAPER.LINK URIBE2000 "http://citeseer.ist.psu.edu/uribe00combinations.html"))(POS (PAPER.YEAR URIBE2000 2000))(POS (PAPER.RANK URIBE2000 "[****]"))(POS (PAPER.DESCRIPTION URIBE2000 "
Uribe surveys combinations of model checkers and theorem provers in the
context of formal verification.  The paper is pretty much self-contained,
explaining transition systems, fair transition systems,
finite-state model checking, deductive verification, abstraction, and
invariant generation.   Then Uribe discusses loosely coupled systems,
which treat the model checker/theorem prover as a black box. Modularity
and abstraction, general deductive environments (debugging, incremental
verification, and formal decomposition), and abstraction generation using
theorem proving have all been investigated in this loosely-coupled way.  
Lastly he considers tightly coupled systems.  Diagram-based
formalisms provide abstractions.  Model checking infinite-state systems
can also be attacked with abstraction.  A handful of tightly integrated
systems are also mentioned.  This survey feels like it is made up of a
hodge-podge of attempts--whether that is characteristic of the field
or the paper is unclear.
"))(POS (PAPER.TOPIC URIBE2000 "Model Checking"))(POS (PAPER.INSTANCE VANGELDER91))(POS (PAPER.BIBTEX VANGELDER91 ARTICLE))(POS (PAPER.AUTHOR VANGELDER91 "Allen van Gelder and Kenneth Ross and John Schlipf"))(POS (PAPER.TITLE VANGELDER91 "The Well-Founded Semantics for General Logic Programs"))(POS (PAPER.PUBLICATION VANGELDER91 "Journal of the ACM"))(POS (PAPER.VOLUME VANGELDER91 "38(3)"))(POS (PAPER.STARTPAGE VANGELDER91 620))(POS (PAPER.ENDPAGE VANGELDER91 650))(POS (PAPER.LINK VANGELDER91 "http://citeseer.ist.psu.edu/gelder91wellfounded.html"))(POS (PAPER.YEAR VANGELDER91 1991))(POS (PAPER.DESCRIPTION VANGELDER91 "
Well-founded semantics for logic programming.
"))(POS (PAPER.TOPIC VANGELDER91 "Logic Programming"))(POS (PAPER.INSTANCE VANHOOF2004))(POS (PAPER.BIBTEX VANHOOF2004 ARTICLE))(POS (PAPER.AUTHOR VANHOOF2004 "Wim Vanhoof"))(POS (PAPER.TITLE VANHOOF2004 "Searching Semantically Equivalent Code Fragments in Logic Programs"))(POS (PAPER.PUBLICATION VANHOOF2004 "14th International Symposium, Logic Based Program Synthesis and Trnasformation (LOPSTR)"))(POS (PAPER.STARTPAGE VANHOOF2004 1))(POS (PAPER.ENDPAGE VANHOOF2004 18))(POS (PAPER.LINK VANHOOF2004 "http://wotan.liu.edu/docis/dbl/lopstr/index.html"))(POS (PAPER.YEAR VANHOOF2004 2004))(POS (PAPER.DESCRIPTION VANHOOF2004 "
In the context of logic programming over Horn rules, 
Vanhoof considers three problems: (1) determining when some portion
of a rule body is equivalent to a portion of another rule body, (2) 
determining when two relations are identical up to argument permutation,
and (3) whether two portions of rule bodies share enough functionality
to be generalized as a higher-order rule, e.g. mapcar.  The nice
part about this topic of semantic equivalence in LP is that two
relations/conjunctions are equivalent iff they have the same extensions.
Vanhoof gives approximation algorithms, i.e. algorithms that are 
sufficient, for determining various kinds of semantic equivalences.
"))(POS (PAPER.TOPIC VANHOOF2004 "Reformulation"))(POS (PAPER.INSTANCE VARDI82))(POS (PAPER.BIBTEX VARDI82 INPROCEEDINGS))(POS (PAPER.AUTHOR VARDI82 "Moshe Vardi"))(POS (PAPER.TITLE VARDI82 "The complexity of relational query languages"))(POS (PAPER.PUBLICATION VARDI82 "Proceedings of the fourteenth annual ACM symposium on Theory of computing"))(POS (PAPER.STARTPAGE VARDI82 137))(POS (PAPER.ENDPAGE VARDI82 146))(POS (PAPER.LINK VARDI82 "http://portal.acm.org/citation.cfm?id=802186&dl=ACM&coll=GUIDE"))(POS (PAPER.YEAR VARDI82 1982))(POS (PAPER.DESCRIPTION VARDI82 "
Data and expression complexity results for various database query languages.
"))(POS (PAPER.TOPIC VARDI82 "Databases"))(POS (PAPER.INSTANCE VOROBYOV98))(POS (PAPER.BIBTEX VOROBYOV98 INPROCEEDINGS))(POS (PAPER.AUTHOR VOROBYOV98 "Sergei Vorobyov and Andrei Voronkov"))(POS (PAPER.TITLE VOROBYOV98 "Complexity of Nonrecursive Logic Programs with Complex Values"))(POS (PAPER.PUBLICATION VOROBYOV98 "Proceedings of the Seventeenth ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems"))(POS (PAPER.STARTPAGE VOROBYOV98 244))(POS (PAPER.ENDPAGE VOROBYOV98 253))(POS (PAPER.LINK VOROBYOV98 "http://citeseer.ist.psu.edu/258671.html"))(POS (PAPER.YEAR VOROBYOV98 1998))(POS (PAPER.DESCRIPTION VOROBYOV98 "
Breaks down the complexity of nonrecursive logic programs based on the 
signature/vocabulary of the program.
"))(POS (PAPER.TOPIC VOROBYOV98 "Logic Programming"))(POS (PAPER.INSTANCE WAAL93))(POS (PAPER.BIBTEX WAAL93 ARTICLE))(POS (PAPER.AUTHOR WAAL93 "D.A. de Waal and J. Gallagher"))(POS (PAPER.TITLE WAAL93 "The Applicability of Logic Program Analysis and Transformation to Theorem Proving"))(POS (PAPER.PUBLICATION WAAL93 "CADE"))(POS (PAPER.LINK WAAL93 "http://citeseer.ist.psu.edu/dewaal93applicability.html"))(POS (PAPER.YEAR WAAL93 1993))(POS (PAPER.RANK WAAL93 "[****]"))(POS (PAPER.DESCRIPTION WAAL93 "
de Waal and Gallagher show how to employ the results of (1) approximation
of logic programs and (2) partial evaluation to produce strategies
for pruning the search space of theorem proving procedures.  They model
a theorem proving algorithm as a logic program, add in the theory and query
in question, and run approximation techniques after partially evaluating
the constructed logic program.  Regular unary clauses (r(f(x1,...,xn) <= 
t1(x1) ^ ... ^ tn(xn))are used to
do the approximations, but the technique can be applied to different
approximations as well.  The authors demonstrate this technique on
a model-elimination procedure and a Naive nH-Prolog proof system.
"))(POS (PAPER.TOPIC WAAL93 "Metalevel Reasoning"))(POS (PAPER.INSTANCE WALDINGER75))(POS (PAPER.AUTHOR WALDINGER75 "R. Waldinger"))(POS (PAPER.TITLE WALDINGER75 "Achieving several goals simultaneously"))(POS (PAPER.PUBLICATION WALDINGER75 "Machine Intelligence 8"))(POS (PAPER.STARTPAGE WALDINGER75 94))(POS (PAPER.ENDPAGE WALDINGER75 138))(POS (PAPER.YEAR WALDINGER75 1975))(POS (PAPER.DESCRIPTION WALDINGER75 "
Waldinger examines planning where sugoals interfere with one another.  He introduces regression  planning, where totally ordered plan steps are reordered.  A solution is constructed incrementally for each subgoal, but when a later subgoal interferes, the position of that subgoal is moved earlier in the plan.  He also touches on the ramification problem (but doesn't call it that) in an effort to show the STRIPS assumption as an unsatisfactory solution to the frame problem.
"))(POS (PAPER.TOPIC WALDINGER75 "Historical"))(POS (PAPER.INSTANCE WALSH2000))(POS (PAPER.BIBTEX WALSH2000 ARTICLE))(POS (PAPER.AUTHOR WALSH2000 "Toby Walsh"))(POS (PAPER.TITLE WALSH2000 "Reformulating Propositional Satisfiability as Constraint Satisfaction"))(POS (PAPER.PUBLICATION WALSH2000 "Symposium on Abstraction, Reformulation, and Approximation (SARA)"))(POS (PAPER.STARTPAGE WALSH2000 233))(POS (PAPER.ENDPAGE WALSH2000 246))(POS (PAPER.LINK WALSH2000 "http://citeseer.ifi.unizh.ch/walsh00reformulating.html"))(POS (PAPER.YEAR WALSH2000 2000))(POS (PAPER.DESCRIPTION WALSH2000 "
Walsh gives an overview of various approaches to encoding propositional
satisfiability as CSPs.  Then he goes on to discuss how various
algorithms operate on those CSPs.
"))(POS (PAPER.TOPIC WALSH2000 "Reformulation"))(POS (PAPER.INSTANCE WAM))(POS (PAPER.BIBTEX WAM BOOK))(POS (PAPER.AUTHOR WAM "Hassan Ait-Kaci"))(POS (PAPER.TITLE WAM "Warren's Abstract Machine: A Tutorial Reconstruction"))(POS (PAPER.PUBLISHER WAM "MIT Press"))(POS (PAPER.LINK WAM "http://mitpress.mit.edu/catalog/item/default.asp?ttype=2&tid=7292"))(POS (PAPER.YEAR WAM 1991))(POS (PAPER.RANK WAM "[*****]"))(POS (PAPER.DESCRIPTION WAM "
Description of the original Prolog compiler.
"))(POS (PAPER.TOPIC WAM ""))(POS (PAPER.INSTANCE WANG85))(POS (PAPER.BIBTEX WANG85 INPROCEEDINGS))(POS (PAPER.AUTHOR WANG85 "Tie Cheng Wang"))(POS (PAPER.TITLE WANG85 "Designing Examples for Semantically Guided Hierarchical Deduction"))(POS (PAPER.PUBLICATION WANG85 "IJCAI"))(POS (PAPER.YEAR WANG85 1985))(POS (PAPER.RANK WANG85 "[*]"))(POS (PAPER.DESCRIPTION WANG85 "
This paper describes a hierarchical theorem prover guided by a model
and gives guidelines for humans to pick a good model.
"))(POS (PAPER.TOPIC WANG85 "Model-Guided Proof Techniques"))(POS (PAPER.INSTANCE WARREN74))(POS (PAPER.AUTHOR WARREN74 "D.H.D. Warren"))(POS (PAPER.TITLE WARREN74 "Extract from APIC Studies in Data Processing"))(POS (PAPER.YEAR WARREN74 1974))(POS (PAPER.DESCRIPTION WARREN74 "
Quick synopsis of the Prolog implementation of Warren's WARPLAN.  WARPLAN was the first planner implemented in Prolog.  It was not optimal, sometimes finding longer plans than needed.
"))(POS (PAPER.TOPIC WARREN74 "Historical"))(POS (PAPER.INSTANCE WEYHRAUCH80))(POS (PAPER.BIBTEX WEYHRAUCH80 ARTICLE))(POS (PAPER.AUTHOR WEYHRAUCH80 "Richard Weyhrauch"))(POS (PAPER.TITLE WEYHRAUCH80 "Prolegomena to a theory of mechanized formal reasoning"))(POS (PAPER.PUBLICATION WEYHRAUCH80 "Artificial Intelligence"))(POS (PAPER.VOLUME WEYHRAUCH80 "13"))(POS (PAPER.STARTPAGE WEYHRAUCH80 133))(POS (PAPER.ENDPAGE WEYHRAUCH80 170))(POS (PAPER.YEAR WEYHRAUCH80 1980))(POS (PAPER.RANK WEYHRAUCH80 "[***]"))(POS (PAPER.DESCRIPTION WEYHRAUCH80 "
Weyhrauch describes the FOL system.  FOL allows rules to be written that
produce semantic attachments, i.e. attaching Lisp addition to the function
symbol '+'.  It also allows rules that rewrite expressions.  FOL includes
an evaluator for first order logic that combines the rewrite rules with
the semantic attachments to do proofs.  FOL is a system that operates on
'LS pairs': a set of logical sentences, a set of attachments, and a set
of facts.  Because this is done uniformly, FOL allows multiple LS pairs
to be defined at the same time.  A special LS pair, Meta, is a theory
of LS pairs; reflection is achieved in FOL by allowing Meta to
operate on another LS pair.   Metametalevel reasoning
can be accomplished in the same way.  Self-reflection is another special
case of this mechanism--give Meta the LS pair Meta to operate on.
"))(POS (PAPER.TOPIC WEYHRAUCH80 "Theorem Proving with Attachments"))(POS (PAPER.INSTANCE YAMATOMOTO2000))(POS (PAPER.AUTHOR YAMATOMOTO2000 "Akihiro Yamatomoto, Bertram Fronhofer"))(POS (PAPER.TITLE YAMATOMOTO2000 "Hypothesis Finding via Residue Hypotheses with the Resolution Principle"))(POS (PAPER.LINK YAMATOMOTO2000 "http://link.springer.de/link/service/series/0558/bibs/1968/19680156.htm"))(POS (PAPER.YEAR YAMATOMOTO2000 2000))(POS (PAPER.DESCRIPTION YAMATOMOTO2000 "
Given a set of background sentences B that do not entail a positive example E, we want to find a hypothesis H such that
B and H entail E.  The authors argue for the use of anti-subsumption over anti-instantiation as a method for
finding residue hypotheses.
"))(POS (PAPER.TOPIC YAMATOMOTO2000 "Theorem Proving Applications"))(POS (PAPER.INSTANCE ZHANG90))(POS (PAPER.BIBTEX ZHANG90 ARTICLE))(POS (PAPER.AUTHOR ZHANG90 "Weining Zhang and Clement Yu and Daniel Troy"))(POS (PAPER.TITLE ZHANG90 "Necessary and Sufficient Conditions to Linearize Doubly Recursive Programs in Logic Databases"))(POS (PAPER.PUBLICATION ZHANG90 "ACM Transactions on Database Systems"))(POS (PAPER.VOLUME ZHANG90 "15(3)"))(POS (PAPER.STARTPAGE ZHANG90 459))(POS (PAPER.ENDPAGE ZHANG90 482))(POS (PAPER.LINK ZHANG90 "http://portal.acm.org/citation.cfm?coll=GUIDE&dl=GUIDE&id=89237"))(POS (PAPER.YEAR ZHANG90 1990))(POS (PAPER.DESCRIPTION ZHANG90 "
The authors examine conditions under which a doubly recursive program, i.e. a program of the form r(xbar) if s(xbar) and r(xbar) if r(ybar) ^ q(ybar') ^ r(ybar''), can be expressed as a linear recursive program, i.e. where the first recursive r definition is resolved with s(xbar).  The only assumption is that 
all the variables in the head appear somewhere in the body.  This result
strengthens previous results.  All rules are horn, and the semantics are LP. 
The necessary and sufficient conditions are nasty, as you might expect.
"))(POS (PAPER.TOPIC ZHANG90 "Reformulation"))(POS (PAPER.INSTANCE ZHANG95))(POS (PAPER.BIBTEX ZHANG95 INPROCEEDINGS))(POS (PAPER.AUTHOR ZHANG95 "J. Zhang and H. Zhang"))(POS (PAPER.TITLE ZHANG95 "SEM: A System for Enumerating Models"))(POS (PAPER.PUBLICATION ZHANG95 "In proceedings, IJCAI-95, Morgan Kaufmann"))(POS (PAPER.LINK ZHANG95 "http://citeseer.ist.psu.edu/context/34167/0"))(POS (PAPER.YEAR ZHANG95 1995))(POS (PAPER.DESCRIPTION ZHANG95 "
Model builder based on searching for a model directly and using the Least Number Heuristic, a method for reducing symmetry in the search space.
"))(POS (PAPER.TOPIC ZHANG95 "Model Building"))(POS (PAPER.INSTANCE ZHANG96))(POS (PAPER.BIBTEX ZHANG96 ARTICLE))(POS (PAPER.AUTHOR ZHANG96 "J. Zhang"))(POS (PAPER.TITLE ZHANG96 "Constructing Finite Algebras with FALCON"))(POS (PAPER.PUBLICATION ZHANG96 "Journal of Automated Reasoning"))(POS (PAPER.VOLUME ZHANG96 "17(1)"))(POS (PAPER.STARTPAGE ZHANG96 1))(POS (PAPER.ENDPAGE ZHANG96 22))(POS (PAPER.LINK ZHANG96 "http://citeseer.ist.psu.edu/context/254103/0"))(POS (PAPER.YEAR ZHANG96 1996))(POS (PAPER.DESCRIPTION ZHANG96 "
Model builder based on searching for a model directly, the so-called
Falcon-style approach.
"))(POS (PAPER.TOPIC ZHANG96 "Model Building"))(POS (PAPER.INSTANCE ZHANG97))(POS (PAPER.BIBTEX ZHANG97 ARTICLE))(POS (PAPER.AUTHOR ZHANG97 "Yan Zhang and Norman Foo"))(POS (PAPER.TITLE ZHANG97 "Deriving Invariants and Constraints from Action Theories"))(POS (PAPER.PUBLICATION ZHANG97 "Fundamenta Informaticae"))(POS (PAPER.VOLUME ZHANG97 "30(1)"))(POS (PAPER.STARTPAGE ZHANG97 109))(POS (PAPER.ENDPAGE ZHANG97 123))(POS (PAPER.LINK ZHANG97 "http://citeseer.ist.psu.edu/zhang96deriving.html"))(POS (PAPER.YEAR ZHANG97 1997))(POS (PAPER.RANK ZHANG97 "[*****]"))(POS (PAPER.DESCRIPTION ZHANG97 "
Zhang and Foo describe an approach to the construction of action invariants
(statements that hold in the predecessor and successor states when
executing a particular action) and state constraints (statements
true in all states reachable from an initial state).   It is based
on a state-based persistence formalism (Zhang's work), and assumes
a domain-closure axiom.  It considers actions with disjunctive effects
and preconditions, but does not provide complete results for those
cases.  It relies on the use of induction to prove a candidate
state constraint is actually a state constraint, but the generation
of these candidates is done algorithmically.
"))(POS (PAPER.TOPIC ZHANG97 "Theories of Action"))(POS (PAPER.INSTANCE ZHU98))(POS (PAPER.BIBTEX ZHU98 PHDTHESIS))(POS (PAPER.AUTHOR ZHU98 "Yunshan Zhu"))(POS (PAPER.TITLE ZHU98 "Efficient First-Order Semantic Deduction Techniques"))(POS (PAPER.LINK ZHU98 "http://citeseer.ist.psu.edu/zhu98efficient.html"))(POS (PAPER.YEAR ZHU98 1998))(POS (PAPER.RANK ZHU98 "[*]"))(POS (PAPER.DESCRIPTION ZHU98 "
This is Zhu's thesis on Ordered Semantic Hyperlinking, complexity
measures of theorem proving, and OSHL applied to planning.
Contains some good citations to semantically driven proof techniques
in section 2.1.
"))(POS (PAPER.TOPIC ZHU98 "Resolution Variants"))(POS (PAPER.RELATED ZHU98 PLAISTED97))(POS (EXAMPLE.INSTANCE DRESDENQUEENS))(POS (EXAMPLE.DATEENTERED DRESDENQUEENS 3355255579))(POS (EXAMPLE.DATEMODIFIED DRESDENQUEENS 3355255579))(POS (EXAMPLE.TECHNIQUE DRESDENQUEENS DATAEXTRACTION))(POS (EXAMPLE.TECHNIQUE DRESDENQUEENS GENERATEOVERGUESS))(POS (EXAMPLE.DESCRIPTION DRESDENQUEENS "We extracted the data out of the rules and relied on generation instead of guess and check."))(POS (EXAMPLE.SOURCE DRESDENQUEENS "  (<= (goal player ?s)
      (attacks ?n)
      (mapnum2val ?n ?s))
  (mapnum2val s0 100)
  (mapnum2val s2 90)
  (mapnum2val s3 80)
  (mapnum2val s4 70)
  (mapnum2val s5 60)
  (mapnum2val s6 50)
  (mapnum2val s7 40)
  (mapnum2val s8 0)
  (mapnum2val s9 0)
  (mapnum2val s10 0)
"))(POS (EXAMPLE.TARGET DRESDENQUEENS "  (<= (goal player 100)
      (attacks s0))
  (<= (goal player 90)
      (attacks s2))
  (<= (goal player 80)
      (attacks s3))
  (<= (goal player 70)
      (attacks s4))
  (<= (goal player 60)
      (attacks s5))
  (<= (goal player 50)
      (attacks s6))
  (<= (goal player 40)
      (attacks s7))
  (<= (goal player 0)
      (attacks s8))
  (<= (goal player 0)
      (attacks s9))
  (<= (goal player 0)
      (attacks s10))
"))(POS (EXAMPLE.INSTANCE TOETICTAC))(POS (EXAMPLE.DATEENTERED TOETICTAC 3355255669))(POS (EXAMPLE.DATEMODIFIED TOETICTAC 3355255669))(POS (EXAMPLE.TECHNIQUE TOETICTAC RELATIONALIZING))(POS (EXAMPLE.DESCRIPTION TOETICTAC "The old: each of the 9 cells is labelled with an x, an o, or a b: cell(x,y,label).  The new: each of the 9 cells (a,b,c,d,e,f,g,h,i) is either true of ecks or ohs or blank, each of which is a unary relation. "))(POS (EXAMPLE.EFFICIENCYGAINS TOETICTAC "Notes: tictactoe is the original theory and toetictac is the new one.
? (time (brute-force-playable tictactoe))
(BRUTE-FORCE-PLAYABLE TICTACTOE) took 56,488 milliseconds (56.488 seconds) to run.
Of that, 2,602 milliseconds (2.602 seconds) were spent in The Cooperative Multitasking Experience.
 88,240,736 bytes of memory allocated.
T
? (time (brute-force-playable toetictac))
;Compiler warnings :
;   Undeclared free variable TOETICTAC, in an anonymous lambda form.
(BRUTE-FORCE-PLAYABLE TOETICTAC) took 38,920 milliseconds (38.920 seconds) to run.
Of that, 1,514 milliseconds (1.514 seconds) were spent in The Cooperative Multitasking Experience.
 48,237,344 bytes of memory allocated.
T
"))(POS (EXAMPLE.SOURCE TOETICTAC "    (role white)
    (role black)
    (init (cell 1 1 b))
    (init (cell 1 2 b))
    (init (cell 1 3 b))
    (init (cell 2 1 b))
    (init (cell 2 2 b))
    (init (cell 2 3 b))
    (init (cell 3 1 b))
    (init (cell 3 2 b))
    (init (cell 3 3 b))
    (init (control white))
    (<= (next (cell ?m ?n x))
        (does white (mark ?m ?n))
        (true (cell ?m ?n b)))
    (<= (next (cell ?m ?n o))
        (does black (mark ?m ?n))
        (true (cell ?m ?n b)))
    (<= (next (cell ?m ?n ?w))
        (true (cell ?m ?n ?w))
        (distinct ?w b))
    (<= (next (cell ?m ?n b))
        (does ?w (mark ?j ?k))
        (true (cell ?m ?n b))
        (or (distinct ?m ?j) (distinct ?n ?k)))
    (<= (next (control white))
        (true (control black)))
    (<= (next (control black))
        (true (control white)))
    (<= (row ?m ?x)
        (true (cell ?m 1 ?x))
        (true (cell ?m 2 ?x))
        (true (cell ?m 3 ?x)))
    (<= (column ?n ?x)
        (true (cell 1 ?n ?x))
        (true (cell 2 ?n ?x))
        (true (cell 3 ?n ?x)))
    (<= (diagonal ?x)
        (true (cell 1 1 ?x))
        (true (cell 2 2 ?x))
        (true (cell 3 3 ?x)))
    (<= (diagonal ?x)
        (true (cell 1 3 ?x))
        (true (cell 2 2 ?x))
        (true (cell 3 1 ?x)))
    (<= (line ?x)
        (row ?m ?x))
    (<= (line ?x)
        (column ?m ?x))
    (<= (line ?x)
        (diagonal ?x))
    (<= open
        (true (cell ?m ?n b)))
    (<= (legal ?w (mark ?x ?y))
        (true (cell ?x ?y b))
        (true (control ?w)))
    (<= (legal white noop)
        (true (cell ?x ?y b))
        (true (control black)))
    (<= (legal black noop)
        (true (cell ?x ?y b))
        (true (control white)))
    (<= (goal white 100)
        (line x))
    (<= (goal white 50)
        (not (line x))
        (not (line o))
        (not open))
    (<= (goal white 0)
        (line o))
    (<= (goal black 100)
        (line o))
    (<= (goal black 50)
        (not (line x))
        (not (line o))
        (not open))
    (<= (goal black 0)
        (line x))
    (<= terminal
        (line x))
    (<= terminal
        (line o))
    (<= terminal
        (not open))
"))(POS (EXAMPLE.TARGET TOETICTAC "    (role xplayer)
    (role oplayer)
    (init (blank a))
    (init (blank b))
    (init (blank c))
    (init (blank d))
    (init (blank e))
    (init (blank f))
    (init (blank g))
    (init (blank h))
    (init (blank i))
    (init (control xplayer))
    (<= (next (ecks ?m))
        (does xplayer (mark ?m))
        (true (blank ?m)))
    (<= (next (oh ?m))
        (does oplayer (mark ?m))
        (true (blank ?m)))
    (<= (next (ecks ?m))
        (true (ecks ?m)))
    (<= (next (oh ?m))
        (true (oh ?m)))
    (<= (next (blank ?m))
        (does ?w (mark ?n))
        (true (blank ?m))
        (distinct ?m ?n))
    (<= (next (control xplayer))
        (true (control oplayer)))
    (<= (next (control oplayer))
        (true (control xplayer)))
    (line a b c)
    (line a d g)
    (line d e f)
    (line b e h)
    (line g h i)
    (line c f i)
    (line a e i)
    (line c e g)
    (<= xline
        (line ?a ?b ?c)
        (true (ecks ?a))
        (true (ecks ?b))
        (true (ecks ?c)))
    (<= oline
        (line ?a ?b ?c)
        (true (oh ?a))
        (true (oh ?b))
        (true (oh ?c)))
    (<= open
        (true (blank ?m)))
    (<= (legal ?player (mark ?y))
        (true (blank ?y))
        (true (control ?player)))
    (<= (legal oplayer noop)
        (true (control xplayer)))
    (<= (legal xplayer noop)
        (true (control oplayer)))
    (<= (goal xplayer 100)
        xline)
    (<= (goal xplayer 50)
        (not xline)
        (not oline)
        (not open))
    (<= (goal xplayer 0)
        oline)
    (<= (goal oplayer 100)
        oline)
    (<= (goal oplayer 50)
        (not xline)
        (not oline)
        (not open))
    (<= (goal oplayer 0)
        xline)
    (<= terminal
        xline)
    (<= terminal
        oline)
    (<= terminal
        (not open))
"))(POS (EXAMPLE.INSTANCE MAZEWORLD))(POS (EXAMPLE.DATEENTERED MAZEWORLD 3355255765))(POS (EXAMPLE.DATEMODIFIED MAZEWORLD 3355255765))(POS (EXAMPLE.TECHNIQUE MAZEWORLD CONSISTENCY2DEDUCTION))(POS (EXAMPLE.TECHNIQUE MAZEWORLD UNNAMED))(POS (EXAMPLE.DESCRIPTION MAZEWORLD "Original maze world is an incomplete information game.  The new maze world is a complete information game, where all the uncertainty has been built into the role world.  When building the game tree for a 2-player incomplete game, the branching factor for your opponent is all possible moves since we don't necessarily know what moves that player can legally make.  Sometimes, some of those moves are inconsistent with the current state of the world.  By compiling the incompleteness into the world player, we can enumerate just the legal moves that are consistent with the state of the game."))(POS (EXAMPLE.SOURCE MAZEWORLD "  (role robot)

    (initial 1)
    (successor 1 2)
    (successor 2 3)
    (successor 3 4)
    (successor 4 5)
    (successor 5 6)
    (successor 6 7)
    (successor 7 8)
    (successor 8 9)
    (successor 9 10)

    (adjacent a b)
    (adjacent b c)
    (adjacent c d)
    (adjacent d a)

    (percept robot bright)

    ;;;;

    (<= (legal robot move ?n))
    (<= (legal robot noop ?n))

    (<= (goal robot 100 ?n)
        (true (cell ?x) ?n)
        (true (gold ?x) ?n))
    
    (<= (goal robot 0 ?n)
        (true (cell ?x) ?n)
	(true (gold ?y) ?n)
        (distinct ?x ?y))
        
    (terminal 7)

    ;;;;
    
    ; state
    (true (cell a) 1)
    (not (true (gold a) 1))

    ; effector
    (<= (true (cell ?y) ?n)
        (successor ?m ?n)
        (does robot move ?m)
        (true (cell ?x) ?m)
        (adjacent ?x ?y))

    (<= (true (cell ?y) ?n)
        (successor ?m ?n)
        (does robot noop ?m)
        (true (cell ?y) ?n))
		
    
    ; state
    (<= (true (gold d) ?n)
        (not (true (gold a) ?n))
        (not (true (gold b) ?n))
        (not (true (gold c) ?n))
        (not (true (gold i) ?n)))

    
    ; gold sensor
    (<= (true (gold ?x) ?n)
        (sees robot bright ?n)
        (true (cell ?x) ?n))

    (<= (not (true (gold ?x) ?n))
        (not (sees robot bright ?n)) 
        (true (cell ?x) ?n))
    

    ; frame: monotonicity of gold
    (<= (true (gold ?x) ?n)
        (successor ?m ?n)
        (true (gold ?x) ?m))

    (<= (not (true (gold ?x) ?n))
        (successor ?m ?n)
        (not (true (gold ?x) ?m)))
"))(POS (EXAMPLE.TARGET MAZEWORLD "  (role robot)
  (role world)
  
  (successor 1 2)
  (successor 2 3)
  (successor 3 4)
  (successor 4 5)
  (successor 5 6)
  (successor 6 7)
  (successor 7 8)
  (successor 8 9)
  (successor 9 10)
  
  (adjacent a b)
  (adjacent b c)
  (adjacent c d)
  (adjacent d a)
  
  (percept robot bright)

  ;;;;

  (init (step 1))
  (init (listof * * *))
  (init (cell a))
  
  ;;;;
  
  (<= (legal robot move))
  (<= (legal robot noop))
  
  (<= (legal world (listof ?x ?u ?v))
      (true (listof * ?u ?v))
      (bit3 ?x ?u ?v))
  (<= (legal world (listof ?x ?u ?v))
      (true (listof ?x * ?v))
      (bit3 ?x ?u ?v))
  (<= (legal world (listof ?x ?u ?v))
      (true (listof ?x ?u *))
      (bit3 ?x ?u ?v))
  (<= (legal world (listof ?x ?u ?v))
      (true (listof * * ?v))
      (bit3 ?x ?u ?v))
  (<= (legal world (listof ?x ?u ?v))
      (true (listof * ?u *))
      (bit3 ?x ?u ?v))
  (<= (legal world (listof ?x ?u ?v))
      (true (listof ?x * *))
      (bit3 ?x ?u ?v))
  (<= (legal world (listof ?x ?u ?v))
      (true (listof * * *))
      (bit3 ?x ?u ?v))
  
  
  (<= (bit3 ?x ?y ?z) (bit ?x) (bit ?y) (bit ?z))
  (bit 1) 
  (bit 0)
  
  (<= (goal robot 100)
      (true (cell ?x))
      (true (real (gold ?x))))
  
  (<= (goal robot 0)
      (true (cell ?x))
      (true (real ?y))
      (distinct ?x ?y))
  
  ;;;;
  
  ; counter
  (<= (next (step ?x))
      (true (step ?y))
      (successor ?y ?x))
  
  ; effector: world
  (<= (next (real ?x))
      (does world ?y)
      (item-true ?x ?y))
  
  (<= (item-true (gold b) (listof 1 ?y ?z)))
  (<= (item-true (gold c) (listof ?x 1 ?z)))
  (<= (item-true (gold d) (listof ?x ?y 1)))
  (<= (item-false (gold b) (listof 0 ?y ?z)))
  (<= (item-false (gold c) (listof ?x 0 ?z)))
  (<= (item-false (gold d) (listof ?x ?y 0)))
  
  ; effector: robot
  (<= (next (cell ?y))
      (does robot move)
      (true (cell ?x))
      (adjacent ?x ?y))
  
  (<= (next (cell ?y))
      (does robot noop)
      (true (cell ?y)))
  
  
  ; frame and sensor: skolem
  (<= (next (listof ?x ?y ?z))
      (val (gold b) ?x)
      (val (gold c) ?y)
      (val (gold d) ?z))
  
  (<= (val ?x 1)
      (tru ?x))
  (<= (val ?x 1)
      (true (listof @y))
      (item-true ?x (listof @y)))

  (<= (val ?x 0)
      (nottru ?x))
  (<= (val ?x 0)
      (true (listof @y))
      (item-false ?x (listof @y)))

  (<= (val ?x *)
      (true (listof @y))
      (not (item-true ?x (listof @y)))
      (not (item-false ?x (listof @y)))
      (not  (tru ?x))
      (not (nottru ?x)))

  
  (<= (nottru (gold ?y))
      (does robot move)
      (true (cell ?x))
      (adjacent ?x ?y)
      (does world ?wm)
      (item-false (gold ?y) ?wm)) 
  
  (<= (tru (gold ?y))
      (does robot move)
      (true (cell ?x))
      (adjacent ?x ?y)
      (does world ?wm)
      (item-true (gold ?y) ?wm)) 
"))(POS (EXAMPLE.INSTANCE MAPCOLORING))(POS (EXAMPLE.DATEENTERED MAPCOLORING 3355255875))(POS (EXAMPLE.DATEMODIFIED MAPCOLORING 3355255875))(POS (EXAMPLE.TECHNIQUE MAPCOLORING CONSISTENCY2DEDUCTION))(POS (EXAMPLE.TECHNIQUE MAPCOLORING CHIRKOVAREFORMULATION))(POS (EXAMPLE.SOURCE MAPCOLORING "  (<= (not (color ?r ?c))
      (not (region ?r)))

  (<= (not (color ?r ?c))
      (not (hue ?c)))

  (<= (not (color ?r1 ?c))
      (adjacent ?r1 ?r2)
      (color ?r2 ?c))

  (region r1)
  (region r2)
  (region r3)

  (hue red)
  (hue blue)

  (adjacent r1 r2)
  (adjacent r2 r1)
  (adjacent r2 r3)
  (adjacent r3 r2)
"))(POS (EXAMPLE.SOURCEQUERY MAPCOLORING "(and (color r1 ?x) (color r2 ?y) (color r3 ?z))
"))(POS (EXAMPLE.TARGET MAPCOLORING "(next red blue)
(next blue red)"))(POS (EXAMPLE.TARGETQUERY MAPCOLORING "(and (next ?x ?y) (next ?y ?z))"))(POS (EXAMPLE.DESCRIPTION MAPCOLORING "The first version is not deductive; in fact, it entails which colorings are invalid.  The second version is deductive.  The first can be separated from region, hue, adjacent, but the second version builds all 3 into the formulation.  The first is more natural, but the second seems to be more efficient. Instead of building an arbitrary model for the axioms, we can use CSP/LP techniques to find an answer.  Actually, it is unclear to what extent the second formulation is faster than the first."))(POS (EXAMPLE.INSTANCE EXAMPLE.3355256133))(POS (EXAMPLE.DATEENTERED EXAMPLE.3355256133 3355256133))(POS (EXAMPLE.DATEMODIFIED EXAMPLE.3355256133 3355256133))(POS (EXAMPLE.DESCRIPTION EXAMPLE.3355256133 "test description"))(NEG (EXAMPLE.DESCRIPTION EXAMPLE.3355256133 "test description"))(POS (EXAMPLE.DESCRIPTION EXAMPLE.3355256133 "test description 2"))(NEG (EXAMPLE.EFFICIENCYGAINS TOETICTAC "Notes: tictactoe is the original theory and toetictac is the new one.
? (time (brute-force-playable tictactoe))
(BRUTE-FORCE-PLAYABLE TICTACTOE) took 56,488 milliseconds (56.488 seconds) to run.
Of that, 2,602 milliseconds (2.602 seconds) were spent in The Cooperative Multitasking Experience.
 88,240,736 bytes of memory allocated.
T
? (time (brute-force-playable toetictac))
;Compiler warnings :
;   Undeclared free variable TOETICTAC, in an anonymous lambda form.
(BRUTE-FORCE-PLAYABLE TOETICTAC) took 38,920 milliseconds (38.920 seconds) to run.
Of that, 1,514 milliseconds (1.514 seconds) were spent in The Cooperative Multitasking Experience.
 48,237,344 bytes of memory allocated.
T
"))(POS (EXAMPLE.EFFICIENCYGAINS TOETICTAC "(brute-force-playable source) takes 56.5 seconds.
(brute-force-playable target) takes 39 seconds."))(NEG (EXAMPLE.DATEENTERED EXAMPLE.3355256133 3355256133))(NEG (EXAMPLE.DATEMODIFIED EXAMPLE.3355256133 3355256133))(NEG (EXAMPLE.DESCRIPTION EXAMPLE.3355256133 "test description 2"))(NEG (EXAMPLE.INSTANCE EXAMPLE.3355256133))(POS (EXAMPLE.EFFICIENCYGAINS DRESDENQUEENS "(reward player ?x)
Source: 425 seconds, Target: 3 seconds"))(POS (PRETTYNAME DRESDENQUEENS "Dresden Queens"))(POS (PRETTYNAME MAPCOLORING "Map Coloring"))(POS (PRETTYNAME MAZEWORLD "Maze World"))(POS (PRETTYNAME TOETICTAC "Toetictac"))(POS (PRETTYNAME CHIRKOVAREFORMULATION "Chirkova"))(POS (PRETTYNAME CONSISTENCY2DEDUCTION "Consistency2Deduction"))(NEG (PRETTYNAME CHIRKOVAREFORMULATION "Chirkova"))(POS (PRETTYNAME CHIRKOVAREFORMULATION "Chirkova Reformulation"))(POS (PRETTYNAME DATAEXTRACTION "Data Extraction"))(POS (PRETTYNAME DATAINFUSION "Data Infusion"))(POS (PRETTYNAME GENERATEOVERGUESS "Generate Over Guess"))(POS (PRETTYNAME OBJECTIFYING "Objectifying"))(POS (PRETTYNAME REIFICATION "Reification"))(POS (PRETTYNAME RELATIONALIZING "Relationalizing"))(POS (PRETTYNAME UNNAMED "Unnamed"))(POS (SHORTNAME CHIRKOVAREFORMULATION "Chirkova"))(POS (SHORTNAME CONSISTENCY2DEDUCTION "C2D"))(POS (SHORTNAME DATAEXTRACTION "Extraction"))(POS (SHORTNAME DATAINFUSION "Infusion"))(POS (SHORTNAME GENERATEOVERGUESS "GOG"))(POS (SHORTNAME OBJECTIFYING "2Obj"))(POS (SHORTNAME REIFICATION "Reification"))(POS (SHORTNAME RELATIONALIZING "2Reln"))(POS (SHORTNAME UNNAMED "?"))(POS (COMPLETENESS.INSTANCE COMPLETE))(POS (COMPLETENESS.INSTANCE INCOMPLETE))(POS (EXAMPLE.COMPLETE DRESDENQUEENS COMPLETE))(POS (EXAMPLE.COMPLETE TOETICTAC COMPLETE))(POS (EXAMPLE.COMPLETE MAZEWORLD INCOMPLETE))(POS (EXAMPLE.COMPLETE MAPCOLORING INCOMPLETE))(POS (EXAMPLE.TECHNIQUE TOETICTAC UNNAMED))(NEG (EXAMPLE.DESCRIPTION DRESDENQUEENS "We extracted the data out of the rules and relied on generation instead of guess and check."))(POS (EXAMPLE.DESCRIPTION DRESDENQUEENS "When a GGP class was taught in Dresden, the 8-queens puzzle was used at some point.  The original axioms they wrote ran slowly when asking the query for the reward a player earned after having placed the 8 queens on the board.  The formulation was propositional: check if there are 8 queens that are attacked by some other queen; if so, award 0 points.  Then check if there are 7 queens that are attacked, and award 40 points.  And so on.  Nat changed the axioms so that first they compute how many queens are attacked and then use a lookup table to compute the points awarded."))(NEG (EXAMPLE.DESCRIPTION TOETICTAC "The old: each of the 9 cells is labelled with an x, an o, or a b: cell(x,y,label).  The new: each of the 9 cells (a,b,c,d,e,f,g,h,i) is either true of ecks or ohs or blank, each of which is a unary relation. "))(POS (EXAMPLE.DESCRIPTION TOETICTAC "Toetictac is a reconceptualization of the original axioms for tictactoe.  In the original version each of the 9 cells is labelled with an x, an o, or a b: cell(x,y,label).  In the new version each of the 9 cells (a,b,c,d,e,f,g,h,i) is either true of ecks or ohs or blank, each of which is a unary relation."))(POS (TECHNIQUE.INSTANCE NAF))(POS (TECHNIQUE.DESCRIPTION NAF "Negation as failure is a meta-inference rule: if the closed sentence p is not entailed (cannot be proven) then infer -p.  We've found it useful for performing iteration, and it is also useful in complete theories when failing to prove p in the positive space is easier than proving -p directly.  "))(POS (PRETTYNAME NAF "Negation as Failure"))(POS (SHORTNAME NAF "NAF"))(POS (BOOLEAN.INSTANCE TRUE))(POS (PRETTYNAME TRUE "True"))(POS (SHORTNAME TRUE "T"))(POS (BOOLEAN.INSTANCE FALSE))(POS (PRETTYNAME FALSE "False"))(POS (SHORTNAME FALSE "F"))(POS (MATRIXSHOW CONSISTENCY2DEDUCTION TRUE))(POS (MATRIXSHOW DRESDENQUEENS TRUE))(POS (MATRIXSHOW REIFICATION TRUE))(POS (MATRIXSHOW UNNAMED TRUE))(POS (MATRIXSHOW RELATIONALIZING FALSE))(POS (MATRIXSHOW OBJECTIFYING FALSE))(POS (MATRIXSHOW GENERATEOVERGUESS TRUE))(POS (MATRIXSHOW DATAEXTRACTION TRUE))(POS (MATRIXSHOW DATAINFUSION TRUE))(POS (MATRIXSHOW CHIRKOVAREFORMULATION TRUE))(POS (MATRIXSHOW NAF TRUE))(POS (MATRIXSHOW TOETICTAC TRUE))(POS (MATRIXSHOW MAZEWORLD TRUE))(POS (MATRIXSHOW MAPCOLORING TRUE))(POS (EXAMPLE.INSTANCE EXAMPLE.3355774383))(POS (PRETTYNAME EXAMPLE.3355774383 "Exponential negation"))(POS (SHORTNAME EXAMPLE.3355774383 "ExpNeg"))(POS (EXAMPLE.COMPLETE EXAMPLE.3355774383 COMPLETE))(POS (EXAMPLE.TECHNIQUE EXAMPLE.3355774383 NAF))(POS (EXAMPLE.DESCRIPTION EXAMPLE.3355774383 "An iff can be used to compactly define a complete relation; however, when converting an iff to clausal form, negating the body can produce a large number of rules.  This example shows that an exponential number of rules can be produced.  In general, if this example is generalized to include n disjuncts of conjunctions of length m, there are m^n rules of length m for defining the negative space.  There would be n rules of length m for defining the positive space."))(POS (EXAMPLE.EFFICIENCYGAINS EXAMPLE.3355774383 "6/4 unis/infs to explore positive space versus 54/28 unis/infs to explore negative space"))(POS (MATRIXSHOW EXAMPLE.3355774383 TRUE))(POS (EXAMPLE.SOURCEQUERY EXAMPLE.3355774383 "(not illegal)"))(POS (EXAMPLE.SOURCE EXAMPLE.3355774383 "(<=> illegal (or (and p1 p2 p3) (and q1 q2 q3) (and r1 r2 r3)))
"))(POS (EXAMPLE.TARGETQUERY EXAMPLE.3355774383 "(not illegal)"))(POS (EXAMPLE.TARGET EXAMPLE.3355774383 "(<= illegal (or (and p1 p2 p3) (and q1 q2 q3) (and r1 r2 r3)))
"))(POS (EXAMPLE.INSTANCE EXPONENTIALNEGATION))(POS (PRETTYNAME EXPONENTIALNEGATION "Exponential negation"))(POS (SHORTNAME EXPONENTIALNEGATION "ExpNeg"))(POS (EXAMPLE.COMPLETE EXPONENTIALNEGATION COMPLETE))(POS (EXAMPLE.TECHNIQUE EXPONENTIALNEGATION NAF))(POS (EXAMPLE.DESCRIPTION EXPONENTIALNEGATION "An iff can be used to compactly define a complete relation; however, when converting an iff to clausal form, negating the body can produce a large number of rules.  This example shows that an exponential number of rules can be produced.  In general, if this example is generalized to include n disjuncts of conjunctions of length m, there are m^n rules of length m for defining the negative space.  There would be n rules of length m for defining the positive space."))(POS (EXAMPLE.EFFICIENCYGAINS EXPONENTIALNEGATION "6/4 unis/infs to explore positive space versus 54/28 unis/infs to explore negative space"))(POS (MATRIXSHOW EXPONENTIALNEGATION TRUE))(POS (EXAMPLE.SOURCEQUERY EXPONENTIALNEGATION "(not illegal)"))(POS (EXAMPLE.SOURCE EXPONENTIALNEGATION "(<=> illegal (or (and p1 p2 p3) (and q1 q2 q3) (and r1 r2 r3)))
"))(POS (EXAMPLE.TARGETQUERY EXPONENTIALNEGATION "(not illegal)"))(POS (EXAMPLE.TARGET EXPONENTIALNEGATION "(<= illegal (or (and p1 p2 p3) (and q1 q2 q3) (and r1 r2 r3)))
"))(NEG (EXAMPLE.INSTANCE EXAMPLE.3355774383))(POS (EXAMPLE.INSTANCE JIGSAW))(POS (PRETTYNAME JIGSAW "Jigsaw"))(POS (SHORTNAME JIGSAW "Jigsaw"))(POS (EXAMPLE.COMPLETE JIGSAW INCOMPLETE))(POS (EXAMPLE.TECHNIQUE JIGSAW UNNAMED))(POS (EXAMPLE.DESCRIPTION JIGSAW "This is a 4-piece jigsaw puzzle.  The original jigsaw axioms are complicated, and converting them into clausal form is expensive.  Moreover, finding an answer after conversion takes a very, very long time.  Lastly, the relations included have modular definitions--they could be picked up and moved to other theories without (much) modification.  The new axioms include less information, but they include sufficient information to answer the query goal.  The new axioms find all answers in less than a second."))(POS (EXAMPLE.EFFICIENCYGAINS JIGSAW "13000x speedup"))(POS (MATRIXSHOW JIGSAW TRUE))(POS (EXAMPLE.SOURCEQUERY JIGSAW "(goal ?x ?y ?z ?w)"))(POS (EXAMPLE.SOURCE JIGSAW "  (<=> (cardinal ?x) (or (= ?x north) (= ?x south) (= ?x west) (= ?x east)))
  (<=> (piece ?x) (or (= ?x p1) (= ?x p2) (= ?x p3) (= ?x p4) (= ?x p0)))
  (<=> (orientation ?x) (or (= ?x 0) (= ?x 90) (= ?x 180) (= ?x 270)))

  ;(or (piece ?x) (orientation ?x) (cardinal ?x))

  (<=> (edge ?x ?y) 
       (or (and (= ?x p1) (or (= ?y east) (= ?y north)))
           (and (= ?x p2) (or (= ?y west) (= ?y north)))
           (and (= ?x p3) (or (= ?y west) (= ?y south)))
           (and (= ?x p4) (or (= ?y north) (= ?y east)))) )

  (<=> (rotate ?x ?amt ?y) 
       (or (and (= ?x north) (= ?amt 0) (= ?y north)) 
           (and (= ?x north) (= ?amt 90) (= ?y east))
           (and (= ?x north) (= ?amt 180) (= ?y south))
           (and (= ?x north) (= ?amt 270) (= ?y west))
           
           (and (= ?x south) (= ?amt 0) (= ?y south)) 
           (and (= ?x south) (= ?amt 90) (= ?y west))
           (and (= ?x south) (= ?amt 180) (= ?y north))
           (and (= ?x south) (= ?amt 270) (= ?y east))

           (and (= ?x east) (= ?amt 0) (= ?y east)) 
           (and (= ?x east) (= ?amt 90) (= ?y south))
           (and (= ?x east) (= ?amt 180) (= ?y west))
           (and (= ?x east) (= ?amt 270) (= ?y north))

           (and (= ?x west) (= ?amt 0) (= ?y west)) 
           (and (= ?x west) (= ?amt 90) (= ?y north))
           (and (= ?x west) (= ?amt 180) (= ?y east))
           (and (= ?x west) (= ?amt 270) (= ?y south))
           ))

  (<=> (orientededge ?x ?o ?e)
       (and (piece ?x) 
            (orientation ?o)
            (cardinal ?e)
            (or (and (edge ?x north)
                     (rotate north ?o ?e))
                (and (edge ?x south)
                     (rotate south ?o ?e))
                (and (edge ?x east)
                     (rotate east ?o ?e))
                (and (edge ?x west)
                     (rotate west ?o ?e)) )))

  (<=> (connectedh ?x ?xo ?y ?yo)
       (and (piece ?x)
            (orientation ?xo)
            (piece ?y)
            (orientation ?yo)
            (or (and (orientededge ?x ?xo east)
                     (orientededge ?y ?yo west))
                (and (not (orientededge ?x ?xo east))
                     (not (orientededge ?y ?yo west))) )))
 
  (<=> (connectedv ?x ?xo ?y ?yo)
       (and (piece ?x)
            (orientation ?xo)
            (piece ?y)
            (orientation ?yo)
            (or (and (orientededge ?x ?xo south)
                     (orientededge ?y ?yo north))
                (and (not (orientededge ?x ?xo south))
                     (not (orientededge ?y ?yo north))) )))

  ; border uses p0, a piece with no edges
  (<=> (border ?o1 ?o2 ?o3 ?o4)
       (and (connectedh p0 0 p1 ?o1)
            (connectedv p0 0 p1 ?o1)
            (connectedv p0 0 p2 ?o2)
            (connectedh p2 ?o2 p0 0)
            (connectedh p4 ?o4 p0 0)
            (connectedv p4 ?o4 p0 0)
            (connectedv p3 ?o3 p0 0)
            (connectedh p0 0 p3 ?o3)))

  (<=> (connected ?o1 ?o2 ?o3 ?o4)
       (and (connectedh p1 ?o1 p2 ?o2)
            (connectedh p3 ?o3 p4 ?o4)
            (connectedv p1 ?o1 p3 ?o3)
            (connectedv p2 ?o2 p4 ?o4)
            (border ?o1 ?o2 ?o3 ?o4)))

  (<= (goal ?o1 ?o2 ?o3 ?o4)
      (connected ?o1 ?o2 ?o3 ?o4))
 
"))(POS (EXAMPLE.TARGETQUERY JIGSAW "(goal ?x ?y ?z ?w)"))(POS (EXAMPLE.TARGET JIGSAW "  (piece p1) 
  (piece p2) 
  (piece p3) 
  (piece p4) 
   
  (rotation 0) 
  (rotation 90) 
  (rotation 180) 
  (rotation 270) 
   
  (cardinal north) 
  (cardinal south) 
  (cardinal east) 
  (cardinal west) 
   
  (edge p1 north) 
  (edge p1 east) 
  (edge p2 north) 
  (edge p2 west) 
  (edge p3 south) 
  (edge p3 west) 
  (edge p4 north) 
  (edge p4 east) 
   
  (<= (east ?p ?rot) 
      (or (and (edge ?p east) (same ?rot 0)) 
          (and (edge ?p north) (same ?rot 90)) 
          (and (edge ?p west) (same ?rot 180)) 
          (and (edge ?p south) (same ?rot 270)))) 
   
  (<= (west ?p ?rot) 
      (or (and (edge ?p west) (same ?rot 0)) 
          (and (edge ?p south) (same ?rot 90)) 
          (and (edge ?p east) (same ?rot 180)) 
          (and (edge ?p north) (same ?rot 270)))) 
   
  (<= (north ?p ?rot) 
      (or (and (edge ?p north) (same ?rot 0)) 
          (and (edge ?p west) (same ?rot 90)) 
          (and (edge ?p south) (same ?rot 180)) 
          (and (edge ?p east) (same ?rot 270)))) 
   
  (<= (south ?p ?rot) 
      (or (and (edge ?p south) (same ?rot 0)) 
          (and (edge ?p east) (same ?rot 90)) 
          (and (edge ?p north) (same ?rot 180)) 
          (and (edge ?p west) (same ?rot 270)))) 
   
   
  (<= (goal ?nw ?ne ?sw ?se) 
      (rotation ?nw) 
      (rotation ?ne) 
      (rotation ?sw) 
      (rotation ?se) 
      (east p1 ?nw) 
      (west p2 ?ne) 
      (east p3 ?sw) 
      (west p4 ?se) 
      (south p1 ?nw) 
      (north p3 ?sw) 
      (south p2 ?ne) 
      (north p4 ?se))
"))(POS (TECHNIQUE.INSTANCE RESIDUESREWRITE))(POS (PRETTYNAME RESIDUESREWRITE "Rewrite with Residues"))(POS (SHORTNAME RESIDUESREWRITE "Residue"))(POS (MATRIXSHOW RESIDUESREWRITE TRUE))(POS (TECHNIQUE.DESCRIPTION RESIDUESREWRITE "Given a query phi, a set of sentences Delta, and a set of relations R, find all residues for phi in Delta wrt R.  Turn the result into a disjunction and simplify it."))(NEG (EXAMPLE.TECHNIQUE JIGSAW UNNAMED))(POS (EXAMPLE.TECHNIQUE JIGSAW RESIDUESREWRITE))(POS (EXAMPLE.TECHNIQUE JIGSAW UNNAMED))(NEG (EXAMPLE.TARGET JIGSAW "  (piece p1) 
  (piece p2) 
  (piece p3) 
  (piece p4) 
   
  (rotation 0) 
  (rotation 90) 
  (rotation 180) 
  (rotation 270) 
   
  (cardinal north) 
  (cardinal south) 
  (cardinal east) 
  (cardinal west) 
   
  (edge p1 north) 
  (edge p1 east) 
  (edge p2 north) 
  (edge p2 west) 
  (edge p3 south) 
  (edge p3 west) 
  (edge p4 north) 
  (edge p4 east) 
   
  (<= (east ?p ?rot) 
      (or (and (edge ?p east) (same ?rot 0)) 
          (and (edge ?p north) (same ?rot 90)) 
          (and (edge ?p west) (same ?rot 180)) 
          (and (edge ?p south) (same ?rot 270)))) 
   
  (<= (west ?p ?rot) 
      (or (and (edge ?p west) (same ?rot 0)) 
          (and (edge ?p south) (same ?rot 90)) 
          (and (edge ?p east) (same ?rot 180)) 
          (and (edge ?p north) (same ?rot 270)))) 
   
  (<= (north ?p ?rot) 
      (or (and (edge ?p north) (same ?rot 0)) 
          (and (edge ?p west) (same ?rot 90)) 
          (and (edge ?p south) (same ?rot 180)) 
          (and (edge ?p east) (same ?rot 270)))) 
   
  (<= (south ?p ?rot) 
      (or (and (edge ?p south) (same ?rot 0)) 
          (and (edge ?p east) (same ?rot 90)) 
          (and (edge ?p north) (same ?rot 180)) 
          (and (edge ?p west) (same ?rot 270)))) 
   
   
  (<= (goal ?nw ?ne ?sw ?se) 
      (rotation ?nw) 
      (rotation ?ne) 
      (rotation ?sw) 
      (rotation ?se) 
      (east p1 ?nw) 
      (west p2 ?ne) 
      (east p3 ?sw) 
      (west p4 ?se) 
      (south p1 ?nw) 
      (north p3 ?sw) 
      (south p2 ?ne) 
      (north p4 ?se))
"))(POS (EXAMPLE.TARGET JIGSAW "  (piece p1) 
  (piece p2) 
  (piece p3) 
  (piece p4) 
   
  (rotation 0) 
  (rotation 90) 
  (rotation 180) 
  (rotation 270) 
   
  (cardinal north) 
  (cardinal south) 
  (cardinal east) 
  (cardinal west) 
   
  (edge p1 north) 
  (edge p1 east) 
  (edge p2 north) 
  (edge p2 west) 
  (edge p3 south) 
  (edge p3 west) 
  (edge p4 north) 
  (edge p4 east) 
   
  (<= (rotate ?p ?rot east) 
      (or (and (edge ?p east) (same ?rot 0)) 
          (and (edge ?p north) (same ?rot 90)) 
          (and (edge ?p west) (same ?rot 180)) 
          (and (edge ?p south) (same ?rot 270)))) 
   
  (<= (rotate ?p ?rot west) 
      (or (and (edge ?p west) (same ?rot 0)) 
          (and (edge ?p south) (same ?rot 90)) 
          (and (edge ?p east) (same ?rot 180)) 
          (and (edge ?p north) (same ?rot 270)))) 
   
  (<= (rotate ?p ?rot north) 
      (or (and (edge ?p north) (same ?rot 0)) 
          (and (edge ?p west) (same ?rot 90)) 
          (and (edge ?p south) (same ?rot 180)) 
          (and (edge ?p east) (same ?rot 270)))) 
   
  (<= (rotate ?p ?rot south) 
      (or (and (edge ?p south) (same ?rot 0)) 
          (and (edge ?p east) (same ?rot 90)) 
          (and (edge ?p north) (same ?rot 180)) 
          (and (edge ?p west) (same ?rot 270)))) 
   
   
  (<= (goal ?nw ?ne ?sw ?se) 
      (rotation ?nw) 
      (rotation ?ne) 
      (rotation ?sw) 
      (rotation ?se) 
      (rotate p1 ?nw east) 
      (rotate p2 ?ne west) 
      (rotate p3 ?sw east) 
      (rotate p4 ?se west) 
      (rotate p1 ?nw south) 
      (rotate p3 ?sw north) 
      (rotate p2 ?ne south) 
      (rotate p4 ?se north))
"))(NEG (EXAMPLE.TECHNIQUE JIGSAW UNNAMED))(POS (EXAMPLE.TECHNIQUE JIGSAW NAF))(POS (EXAMPLE.TECHNIQUE JIGSAW UNNAMED))(POS (TECHNIQUE.INSTANCE STATICCONJORDERING))(POS (PRETTYNAME STATICCONJORDERING "Static Conjunct Ordering"))(POS (SHORTNAME STATICCONJORDERING "statconjorder"))(POS (MATRIXSHOW STATICCONJORDERING TRUE))(POS (TECHNIQUE.DESCRIPTION STATICCONJORDERING "For model elimination, ordering conjuncts statically requires simply changing the sequence of literals in the body of the rules."))(POS (EXAMPLE.INSTANCE GUESS))(POS (PRETTYNAME GUESS "Guess"))(POS (SHORTNAME GUESS "Guess"))(POS (EXAMPLE.COMPLETE GUESS COMPLETE))(POS (EXAMPLE.TECHNIQUE GUESS STATICCONJORDERING))(POS (EXAMPLE.DESCRIPTION GUESS "Example where a bad conjunct ordering requires non-zero work to find legal moves because the ground conjuncts are not moved all the way to the front."))(POS (EXAMPLE.EFFICIENCYGAINS GUESS "In this game, search space shrinks from 64^2 to 1 per rule."))(POS (MATRIXSHOW GUESS TRUE))(POS (EXAMPLE.COMMENTS GUESS "There may be a bug in the game -- something about greater than."))(POS (EXAMPLE.SOURCEQUERY GUESS "(legal chooser ?x)"))(POS (EXAMPLE.SOURCE GUESS "  (role guesser)
  (role chooser)
  (<= (legal guesser ?g)
      (true (possible ?g))
      (true (control guesser))
  (<= (legal guesser wait)
      (true (control chooser))
  (<= (next (control guesser))
      (true (control chooser))
  (<= (next (control chooser))
      (true (control guesser))
  (<= (next (guess ?x))
      (does guesser ?x)
      (true (possible ?x))
  (<= (legal chooser higher)
      (true (possible ?n))
      (greater ?n ?x)
      (true (guess ?x))
      (true (control chooser))
  (<= (legal chooser lower)
      (true (possible ?n))
      (greater ?x ?n)
      (true (guess ?x))
      (true (control chooser))
  (<= (legal chooser wait)
      (true (control guesser))
  (<= (next (possible ?x))
      (true (possible ?x))
      (true (control guesser))
  (<= (next (possible ?x))
      (true (possible ?x))
      (greater ?x ?y)
      (true (guess ?y))
      (does chooser higher)
  (<= (next (possible ?x))
      (true (possible ?x))
      (greater ?y ?x)
      (true (guess ?y))
      (does chooser lower)
  (<= (next (step ?x))
      (true (step ?y))
      (succ ?y ?x)
  (<= (goal guesser 100)
      (not unfinished)
  (<= (goal guesser 0)
      unfinished
  (<= (goal chooser 100)
      unfinished
  (<= (goal chooser 0)
      (not unfinished)
  (<= terminal
      (not unfinished)
  (<= terminal
      (true (step 12))
  (<= unfinished
      (true (possible ?x))
      (true (possible ?y))
      (distinct ?x ?y)
  (<= (greater ?x ?y)
      (succ ?y ?x)
  (<= (greater ?x ?y)
      (succ ?x ?z)
      (greater ?z ?y)
  (init (step 1))
  (init (control guesser))
  (init (possible 1))
  (init (possible 2))
  (init (possible 3))
  (init (possible 4))
  (init (possible 5))
  (init (possible 6))
  (init (possible 7))
  (init (possible 8))
  (init (possible 9))
  (init (possible 10))
  (init (possible 11))
  (init (possible 12))
  (init (possible 13))
  (init (possible 14))
  (init (possible 15))
  (init (possible 16))
  (init (possible 17))
  (init (possible 18))
  (init (possible 19))
  (init (possible 20))
  (init (possible 21))
  (init (possible 22))
  (init (possible 23))
  (init (possible 24))
  (init (possible 25))
  (init (possible 26))
  (init (possible 27))
  (init (possible 28))
  (init (possible 29))
  (init (possible 30))
  (init (possible 31))
  (init (possible 32))
  (init (possible 33))
  (init (possible 34))
  (init (possible 35))
  (init (possible 36))
  (init (possible 37))
  (init (possible 38))
  (init (possible 39))
  (init (possible 40))
  (init (possible 41))
  (init (possible 42))
  (init (possible 43))
  (init (possible 44))
  (init (possible 45))
  (init (possible 46))
  (init (possible 47))
  (init (possible 48))
  (init (possible 49))
  (init (possible 50))
  (init (possible 51))
  (init (possible 52))
  (init (possible 53))
  (init (possible 54))
  (init (possible 55))
  (init (possible 56))
  (init (possible 57))
  (init (possible 58))
  (init (possible 59))
  (init (possible 60))
  (init (possible 61))
  (init (possible 62))
  (init (possible 63))
  (succ 1 2)
  (succ 2 3)
  (succ 3 4)
  (succ 4 5)
  (succ 5 6)
  (succ 6 7)
  (succ 7 8)
  (succ 8 9)
  (succ 9 10)
  (succ 10 11)
  (succ 11 12)
  (succ 12 13)
  (succ 13 14)
  (succ 14 15)
  (succ 15 16)
  (succ 16 17)
  (succ 17 18)
  (succ 18 19)
  (succ 19 20)
  (succ 20 21)
  (succ 21 22)
  (succ 22 23)
  (succ 23 24)
  (succ 24 25)
  (succ 25 26)
  (succ 26 27)
  (succ 27 28)
  (succ 28 29)
  (succ 29 30)
  (succ 30 31)
  (succ 31 32)
  (succ 32 33)
  (succ 33 34)
  (succ 34 35)
  (succ 35 36)
  (succ 36 37)
  (succ 37 38)
  (succ 38 39)
  (succ 39 40)
  (succ 40 41)
  (succ 41 42)
  (succ 42 43)
  (succ 43 44)
  (succ 44 45)
  (succ 45 46)
  (succ 46 47)
  (succ 47 48)
  (succ 48 49)
  (succ 49 50)
  (succ 50 51)
  (succ 51 52)
  (succ 52 53)
  (succ 53 54)
  (succ 54 55)
  (succ 55 56)
  (succ 56 57)
  (succ 57 58)
  (succ 58 59)
  (succ 59 60)
  (succ 60 61)
  (succ 61 62)
  (succ 62 63)"))(POS (EXAMPLE.TARGETQUERY GUESS "(legal chooser ?x)"))(POS (EXAMPLE.TARGET GUESS "  (role guesser)
  (role chooser)

  (<= (legal guesser ?g)
      (true (control guesser))
      (true (possible ?g)))

  (<= (legal guesser wait)
      (true (control chooser)))

  (<= (next (control guesser))
      (true (control chooser)))

  (<= (next (control chooser))
      (true (control guesser)))

  (<= (next (guess ?x))
      (does guesser ?x)
      (true (possible ?x)))

  (<= (legal chooser higher)
      (true (control chooser))
      (true (possible ?n))
      (greater ?n ?x)
      (true (guess ?x)))

  (<= (legal chooser lower)
      (true (control chooser))
      (true (possible ?n))
      (greater ?x ?n)
      (true (guess ?x)))

  (<= (legal chooser wait)
      (true (control guesser)))

  (<= (next (possible ?x))
      (true (control guesser))
      (true (possible ?x)))

  (<= (next (possible ?x))
      (does chooser higher)
      (true (possible ?x))
      (greater ?x ?y)
      (true (guess ?y)))

  (<= (next (possible ?x))
      (does chooser lower)
      (true (possible ?x))
      (greater ?y ?x)
      (true (guess ?y)))

  (<= (next (step ?x))
      (true (step ?y))
      (succ ?y ?x))

  (<= (goal guesser 100)
      (not unfinished))
  (<= (goal guesser 0)
      unfinished)
  (<= (goal chooser 100)
      unfinished)
  (<= (goal chooser 0)
      (not unfinished))
  (<= terminal
      (not unfinished))
  (<= terminal
      (true (step 12)))
  (<= unfinished
      (true (possible ?x))
      (true (possible ?y))
      (distinct ?x ?y))
  (<= (greater ?x ?y)
      (succ ?y ?x))
  (<= (greater ?x ?y)
      (succ ?x ?z)
      (greater ?z ?y))
  (init (step 1))
  (init (control guesser))
  (init (possible 1))
  (init (possible 2))
  (init (possible 3))
  (init (possible 4))
  (init (possible 5))
  (init (possible 6))
  (init (possible 7))
  (init (possible 8))
  (init (possible 9))
  (init (possible 10))
  (init (possible 11))
  (init (possible 12))
  (init (possible 13))
  (init (possible 14))
  (init (possible 15))
  (init (possible 16))
  (init (possible 17))
  (init (possible 18))
  (init (possible 19))
  (init (possible 20))
  (init (possible 21))
  (init (possible 22))
  (init (possible 23))
  (init (possible 24))
  (init (possible 25))
  (init (possible 26))
  (init (possible 27))
  (init (possible 28))
  (init (possible 29))
  (init (possible 30))
  (init (possible 31))
  (init (possible 32))
  (init (possible 33))
  (init (possible 34))
  (init (possible 35))
  (init (possible 36))
  (init (possible 37))
  (init (possible 38))
  (init (possible 39))
  (init (possible 40))
  (init (possible 41))
  (init (possible 42))
  (init (possible 43))
  (init (possible 44))
  (init (possible 45))
  (init (possible 46))
  (init (possible 47))
  (init (possible 48))
  (init (possible 49))
  (init (possible 50))
  (init (possible 51))
  (init (possible 52))
  (init (possible 53))
  (init (possible 54))
  (init (possible 55))
  (init (possible 56))
  (init (possible 57))
  (init (possible 58))
  (init (possible 59))
  (init (possible 60))
  (init (possible 61))
  (init (possible 62))
  (init (possible 63))
  (succ 1 2)
  (succ 2 3)
  (succ 3 4)
  (succ 4 5)
  (succ 5 6)
  (succ 6 7)
  (succ 7 8)
  (succ 8 9)
  (succ 9 10)
  (succ 10 11)
  (succ 11 12)
  (succ 12 13)
  (succ 13 14)
  (succ 14 15)
  (succ 15 16)
  (succ 16 17)
  (succ 17 18)
  (succ 18 19)
  (succ 19 20)
  (succ 20 21)
  (succ 21 22)
  (succ 22 23)
  (succ 23 24)
  (succ 24 25)
  (succ 25 26)
  (succ 26 27)
  (succ 27 28)
  (succ 28 29)
  (succ 29 30)
  (succ 30 31)
  (succ 31 32)
  (succ 32 33)
  (succ 33 34)
  (succ 34 35)
  (succ 35 36)
  (succ 36 37)
  (succ 37 38)
  (succ 38 39)
  (succ 39 40)
  (succ 40 41)
  (succ 41 42)
  (succ 42 43)
  (succ 43 44)
  (succ 44 45)
  (succ 45 46)
  (succ 46 47)
  (succ 47 48)
  (succ 48 49)
  (succ 49 50)
  (succ 50 51)
  (succ 51 52)
  (succ 52 53)
  (succ 53 54)
  (succ 54 55)
  (succ 55 56)
  (succ 56 57)
  (succ 57 58)
  (succ 58 59)
  (succ 59 60)
  (succ 60 61)
  (succ 61 62)
  (succ 62 63)"))(NEG (SHORTNAME STATICCONJORDERING "statconjorder"))(POS (SHORTNAME STATICCONJORDERING "StatCO"))(NEG (EXAMPLE.COMPLETE JIGSAW INCOMPLETE))(POS (EXAMPLE.COMPLETE JIGSAW COMPLETE))(POS (TECHNIQUE.INSTANCE BILEVEL))(POS (PRETTYNAME BILEVEL "Bilevel Reasoning"))(POS (SHORTNAME BILEVEL "Bi"))(POS (MATRIXSHOW BILEVEL TRUE))(POS (TECHNIQUE.DESCRIPTION BILEVEL "Split the problem into two pieces: the data and the axioms."))(POS (EXAMPLE.INSTANCE 4QUEENS))(POS (PRETTYNAME 4QUEENS "4-Queens"))(POS (SHORTNAME 4QUEENS "4queens"))(POS (EXAMPLE.COMPLETE 4QUEENS INCOMPLETE))(POS (EXAMPLE.TECHNIQUE 4QUEENS CONSISTENCY2DEDUCTION))(POS (EXAMPLE.TECHNIQUE 4QUEENS BILEVEL))(POS (EXAMPLE.TECHNIQUE 4QUEENS NAF))(POS (EXAMPLE.DESCRIPTION 4QUEENS "The traditional 8-queens puzzle, shrunken to a 4x4 board with 4 queens.  Two solutions exist to what is usually a CSP.  But in this example, we are asking an entailment query about those solutions: is the upper left square always blank?"))(POS (MATRIXSHOW 4QUEENS TRUE))(POS (EXAMPLE.COMMENTS 4QUEENS "Add in UNA and DCA for all object constants, i.e. this is finite Herbrand logic."))(POS (EXAMPLE.SOURCEQUERY 4QUEENS "      (forall (?x1 ?y1 ?x2 ?y2 ?x3 ?y3 ?x4 ?y4) 
              (=> (ans ?x1 ?y1 ?x2 ?y2 ?x3 ?y3 ?x4 ?y4)
                  (and (not (= ?x1 1))
                       (not (= ?y1 1))
                       (not (= ?x2 1))
                       (not (= ?y2 1))
                       (not (= ?x3 1))
                       (not (= ?y3 1))
                       (not (= ?x4 1))
                       (not (= ?y4 1))))"))(POS (EXAMPLE.SOURCE 4QUEENS "  (<= (ans ?x1 ?y1 ?x2 ?y2 ?x3 ?y3 ?x4 ?y4)
      (and (row q1 ?x1) (col q1 ?y1) (row q2 ?x2) (col q2 ?y2) (row q3 ?x3) (col q3 ?y3) (row q4 ?x4) (col q4 ?y4)))

  ; all the queens have different rows
  (<= (not (row ?x ?c))
      (row ?y ?c)
      (not (= ?x ?y)))

  ; all the queens have different columns
  (<= (not (col ?x ?c))
      (col ?y ?c)
      (not (= ?x ?y)))

  ; given a row and column, we can compute the two diagonals it is on.
  (<= (d ?q pos ?z) (row ?q ?x) (col ?q ?y) (sub ?y ?x ?z))
  (<= (d ?q neg ?z) (row ?q ?x) (col ?q ?y) (add ?y ?x ?z))

  ; all the queens have different diagonals
  (<= (not (d ?q1 ?sign ?z))
      (d ?q2 ?sign ?z)
      (not (= ?q1 ?q2)))

  ; add and subtract
  (add 1 1 2)
  (add 1 2 3)
  (add 1 3 4)
  (add 1 4 5)
  (add 2 1 3)
  (add 2 2 4)
  (add 2 3 5)
  (add 2 4 6)
  (add 3 1 4)
  (add 3 2 5)
  (add 3 3 6)
  (add 3 4 7)
  (add 4 1 5)
  (add 4 2 6)
  (add 4 3 7)
  (add 4 4 8)

  (sub 1 1 0)
  (sub 1 2 -1)
  (sub 1 3 -2)
  (sub 1 4 -3)
  (sub 2 1 1)
  (sub 2 2 0)
  (sub 2 3 -1)
  (sub 2 4 -2)
  (sub 3 1 2)
  (sub 3 2 1)
  (sub 3 3 0)
  (sub 3 4 -1)
  (sub 4 1 3)
  (sub 4 2 2)
  (sub 4 3 1)
  (sub 4 4 0)
"))(POS (EXAMPLE.TARGETQUERY 4QUEENS "ent"))(POS (EXAMPLE.TARGET 4QUEENS "  (<= ent
      (not notent))
  (<= notent
      (goal17 ?X1 ?Y1 ?X2 ?Y2 ?X3 ?Y3 ?X4 ?Y4)
      (not (phi ?X1 ?Y1 ?X2 ?Y2 ?X3 ?Y3 ?X4 ?Y4)))
 
  (<= (phi ?X1 ?Y1 ?X2 ?Y2 ?X3 ?Y3 ?X4 ?Y4)
      (or (distinct ?x1 1)
          (distinct ?y1 1))
      (or (distinct ?x2 1)
          (distinct ?y2 1))
      (or (distinct ?x3 1)
          (distinct ?y3 1))
      (or (distinct ?x4 1)
          (distinct ?y4 1)))
      
  ; below ne is the not equal table
  (<= (goal17 ?X1 ?Y1 ?X2 ?Y2 ?X3 ?Y3 ?X4 ?Y4)
      
      (sub ?y1 ?x1 ?neg1)
      (add ?y1 ?x1 ?pos1)
      (sub ?y2 ?x2 ?neg2)
      (distinct ?X1 ?X2)
      (distinct ?Y1 ?Y2)
      (distinct ?neg2 ?neg1)
      (add ?y2 ?x2 ?pos2)
      (distinct ?pos2 ?pos1)
      
      
      (sub ?y3 ?x3 ?neg3)
      (distinct ?X1 ?X3) 
      (distinct ?Y1 ?Y3)
      (distinct ?X2 ?X3)
      (distinct ?Y2 ?Y3)
      (distinct ?neg3 ?neg2)
      (distinct ?neg3 ?neg1)
      (add ?y3 ?x3 ?pos3)
      (distinct ?pos3 ?pos2)
      (distinct ?pos3 ?pos1)
      
      (sub ?y4 ?x4 ?neg4)
      (distinct ?X1 ?X4)
      (distinct ?X2 ?X4)
      (distinct ?X3 ?X4)
      (distinct ?Y1 ?Y4)
      (distinct ?Y2 ?Y4)
      (distinct ?Y3 ?Y4)
      (distinct ?neg4 ?neg3)
      (distinct ?neg4 ?neg2)
      (distinct ?neg4 ?neg1)
      (add ?y4 ?x4 ?pos4)
      (distinct ?pos4 ?pos3)
      (distinct ?pos4 ?pos2)
      (distinct ?pos4 ?pos1))
  
  (add 1 1 2)
  (add 1 2 3)
  (add 1 3 4)
  (add 1 4 5)
  (add 2 1 3)
  (add 2 2 4)
  (add 2 3 5)
  (add 2 4 6)
  (add 3 1 4)
  (add 3 2 5)
  (add 3 3 6)
  (add 3 4 7)
  (add 4 1 5)
  (add 4 2 6)
  (add 4 3 7)
  (add 4 4 8)

  (sub 1 1 0)
  (sub 1 2 -1)
  (sub 1 3 -2)
  (sub 1 4 -3)
  (sub 2 1 1)
  (sub 2 2 0)
  (sub 2 3 -1)
  (sub 2 4 -2)
  (sub 3 1 2)
  (sub 3 2 1)
  (sub 3 3 0)
  (sub 3 4 -1)
  (sub 4 1 3)
  (sub 4 2 2)
  (sub 4 3 1)
  (sub 4 4 0)"))(NEG (EXAMPLE.DESCRIPTION 4QUEENS "The traditional 8-queens puzzle, shrunken to a 4x4 board with 4 queens.  Two solutions exist to what is usually a CSP.  But in this example, we are asking an entailment query about those solutions: is the upper left square always blank?"))(POS (EXAMPLE.DESCRIPTION 4QUEENS "The traditional 8-queens puzzle, shrunken to a 4x4 board with 4 queens.  Two solutions exist to what is usually a CSP.  But in this example, we are asking an entailment query about those solutions: is the upper left square always blank?  This translation turns an entailment query stated in FHL into a datalog query."))(POS (EXAMPLE.TECHNIQUE 4QUEENS UNNAMED))(NEG (EXAMPLE.SOURCEQUERY 4QUEENS "      (forall (?x1 ?y1 ?x2 ?y2 ?x3 ?y3 ?x4 ?y4) 
              (=> (ans ?x1 ?y1 ?x2 ?y2 ?x3 ?y3 ?x4 ?y4)
                  (and (not (= ?x1 1))
                       (not (= ?y1 1))
                       (not (= ?x2 1))
                       (not (= ?y2 1))
                       (not (= ?x3 1))
                       (not (= ?y3 1))
                       (not (= ?x4 1))
                       (not (= ?y4 1))))"))(POS (EXAMPLE.SOURCEQUERY 4QUEENS "goal"))(NEG (EXAMPLE.SOURCE 4QUEENS "  (<= (ans ?x1 ?y1 ?x2 ?y2 ?x3 ?y3 ?x4 ?y4)
      (and (row q1 ?x1) (col q1 ?y1) (row q2 ?x2) (col q2 ?y2) (row q3 ?x3) (col q3 ?y3) (row q4 ?x4) (col q4 ?y4)))

  ; all the queens have different rows
  (<= (not (row ?x ?c))
      (row ?y ?c)
      (not (= ?x ?y)))

  ; all the queens have different columns
  (<= (not (col ?x ?c))
      (col ?y ?c)
      (not (= ?x ?y)))

  ; given a row and column, we can compute the two diagonals it is on.
  (<= (d ?q pos ?z) (row ?q ?x) (col ?q ?y) (sub ?y ?x ?z))
  (<= (d ?q neg ?z) (row ?q ?x) (col ?q ?y) (add ?y ?x ?z))

  ; all the queens have different diagonals
  (<= (not (d ?q1 ?sign ?z))
      (d ?q2 ?sign ?z)
      (not (= ?q1 ?q2)))

  ; add and subtract
  (add 1 1 2)
  (add 1 2 3)
  (add 1 3 4)
  (add 1 4 5)
  (add 2 1 3)
  (add 2 2 4)
  (add 2 3 5)
  (add 2 4 6)
  (add 3 1 4)
  (add 3 2 5)
  (add 3 3 6)
  (add 3 4 7)
  (add 4 1 5)
  (add 4 2 6)
  (add 4 3 7)
  (add 4 4 8)

  (sub 1 1 0)
  (sub 1 2 -1)
  (sub 1 3 -2)
  (sub 1 4 -3)
  (sub 2 1 1)
  (sub 2 2 0)
  (sub 2 3 -1)
  (sub 2 4 -2)
  (sub 3 1 2)
  (sub 3 2 1)
  (sub 3 3 0)
  (sub 3 4 -1)
  (sub 4 1 3)
  (sub 4 2 2)
  (sub 4 3 1)
  (sub 4 4 0)
"))(POS (EXAMPLE.SOURCE 4QUEENS "  (<= goal 
      (forall (?x1 ?y1 ?x2 ?y2 ?x3 ?y3 ?x4 ?y4) 
              (=> (and (row q1 ?x1) (col q1 ?y1) (row q2 ?x2) (col q2 ?y2) (row q3 ?x3) (col q3 ?y3) (row q4 ?x4) (col q4 ?y4))
                  (not (or (and (= ?x1 1) (= ?y1 1))
                           (and (= ?x2 1) (= ?y2 1))
                           (and (= ?x3 1) (= ?y3 1))
                           (and (= ?x4 1) (= ?y4 1)))))))

  ; all the queens have different rows
  (<= (not (row ?x ?c))
      (row ?y ?c)
      (not (= ?x ?y)))

  ; all the queens have different columns
  (<= (not (col ?x ?c))
      (col ?y ?c)
      (not (= ?x ?y)))

  ; given a row and column, we can compute the two diagonals it is on.
  (<= (d ?q pos ?z) (row ?q ?x) (col ?q ?y) (sub ?y ?x ?z))
  (<= (d ?q neg ?z) (row ?q ?x) (col ?q ?y) (add ?y ?x ?z))

  ; all the queens have different diagonals
  (<= (not (d ?q1 ?sign ?z))
      (d ?q2 ?sign ?z)
      (not (= ?q1 ?q2)))

  ; add and subtract
  (add 1 1 2)
  (add 1 2 3)
  (add 1 3 4)
  (add 1 4 5)
  (add 2 1 3)
  (add 2 2 4)
  (add 2 3 5)
  (add 2 4 6)
  (add 3 1 4)
  (add 3 2 5)
  (add 3 3 6)
  (add 3 4 7)
  (add 4 1 5)
  (add 4 2 6)
  (add 4 3 7)
  (add 4 4 8)

  (sub 1 1 0)
  (sub 1 2 -1)
  (sub 1 3 -2)
  (sub 1 4 -3)
  (sub 2 1 1)
  (sub 2 2 0)
  (sub 2 3 -1)
  (sub 2 4 -2)
  (sub 3 1 2)
  (sub 3 2 1)
  (sub 3 3 0)
  (sub 3 4 -1)
  (sub 4 1 3)
  (sub 4 2 2)
  (sub 4 3 1)
  (sub 4 4 0)
"))(NEG (EXAMPLE.SOURCEQUERY 4QUEENS "goal"))(POS (EXAMPLE.SOURCEQUERY 4QUEENS "(forall (?x1 ?y1 ?x2 ?y2 ?x3 ?y3 ?x4 ?y4) 
              (=> (and (row q1 ?x1) (col q1 ?y1) (row q2 ?x2) (col q2 ?y2) (row q3 ?x3) (col q3 ?y3) (row q4 ?x4) (col q4 ?y4))
                  (not (or (and (= ?x1 1) (= ?y1 1))
                           (and (= ?x2 1) (= ?y2 1))
                           (and (= ?x3 1) (= ?y3 1))
                           (and (= ?x4 1) (= ?y4 1))))))"))(NEG (EXAMPLE.SOURCE 4QUEENS "  (<= goal 
      (forall (?x1 ?y1 ?x2 ?y2 ?x3 ?y3 ?x4 ?y4) 
              (=> (and (row q1 ?x1) (col q1 ?y1) (row q2 ?x2) (col q2 ?y2) (row q3 ?x3) (col q3 ?y3) (row q4 ?x4) (col q4 ?y4))
                  (not (or (and (= ?x1 1) (= ?y1 1))
                           (and (= ?x2 1) (= ?y2 1))
                           (and (= ?x3 1) (= ?y3 1))
                           (and (= ?x4 1) (= ?y4 1)))))))

  ; all the queens have different rows
  (<= (not (row ?x ?c))
      (row ?y ?c)
      (not (= ?x ?y)))

  ; all the queens have different columns
  (<= (not (col ?x ?c))
      (col ?y ?c)
      (not (= ?x ?y)))

  ; given a row and column, we can compute the two diagonals it is on.
  (<= (d ?q pos ?z) (row ?q ?x) (col ?q ?y) (sub ?y ?x ?z))
  (<= (d ?q neg ?z) (row ?q ?x) (col ?q ?y) (add ?y ?x ?z))

  ; all the queens have different diagonals
  (<= (not (d ?q1 ?sign ?z))
      (d ?q2 ?sign ?z)
      (not (= ?q1 ?q2)))

  ; add and subtract
  (add 1 1 2)
  (add 1 2 3)
  (add 1 3 4)
  (add 1 4 5)
  (add 2 1 3)
  (add 2 2 4)
  (add 2 3 5)
  (add 2 4 6)
  (add 3 1 4)
  (add 3 2 5)
  (add 3 3 6)
  (add 3 4 7)
  (add 4 1 5)
  (add 4 2 6)
  (add 4 3 7)
  (add 4 4 8)

  (sub 1 1 0)
  (sub 1 2 -1)
  (sub 1 3 -2)
  (sub 1 4 -3)
  (sub 2 1 1)
  (sub 2 2 0)
  (sub 2 3 -1)
  (sub 2 4 -2)
  (sub 3 1 2)
  (sub 3 2 1)
  (sub 3 3 0)
  (sub 3 4 -1)
  (sub 4 1 3)
  (sub 4 2 2)
  (sub 4 3 1)
  (sub 4 4 0)
"))(POS (EXAMPLE.SOURCE 4QUEENS "
  ; all the queens have different rows
  (<= (not (row ?x ?c))
      (row ?y ?c)
      (not (= ?x ?y)))

  ; all the queens have different columns
  (<= (not (col ?x ?c))
      (col ?y ?c)
      (not (= ?x ?y)))

  ; given a row and column, we can compute the two diagonals it is on.
  (<= (d ?q pos ?z) (row ?q ?x) (col ?q ?y) (sub ?y ?x ?z))
  (<= (d ?q neg ?z) (row ?q ?x) (col ?q ?y) (add ?y ?x ?z))

  ; all the queens have different diagonals
  (<= (not (d ?q1 ?sign ?z))
      (d ?q2 ?sign ?z)
      (not (= ?q1 ?q2)))

  ; add and subtract
  (add 1 1 2)
  (add 1 2 3)
  (add 1 3 4)
  (add 1 4 5)
  (add 2 1 3)
  (add 2 2 4)
  (add 2 3 5)
  (add 2 4 6)
  (add 3 1 4)
  (add 3 2 5)
  (add 3 3 6)
  (add 3 4 7)
  (add 4 1 5)
  (add 4 2 6)
  (add 4 3 7)
  (add 4 4 8)

  (sub 1 1 0)
  (sub 1 2 -1)
  (sub 1 3 -2)
  (sub 1 4 -3)
  (sub 2 1 1)
  (sub 2 2 0)
  (sub 2 3 -1)
  (sub 2 4 -2)
  (sub 3 1 2)
  (sub 3 2 1)
  (sub 3 3 0)
  (sub 3 4 -1)
  (sub 4 1 3)
  (sub 4 2 2)
  (sub 4 3 1)
  (sub 4 4 0)
"))(POS (TECHNIQUE.INSTANCE SYMMETRYANALYSIS))(POS (PRETTYNAME SYMMETRYANALYSIS "Symmetry Analysis"))(POS (SHORTNAME SYMMETRYANALYSIS "Sym"))(POS (MATRIXSHOW SYMMETRYANALYSIS TRUE))(POS (TECHNIQUE.DESCRIPTION SYMMETRYANALYSIS "Take advantage of symmetry in the problem to reduce the search space."))(POS (EXAMPLE.INSTANCE 4QSDATALOG))(POS (PRETTYNAME 4QSDATALOG "4-Queens Datalog"))(POS (SHORTNAME 4QSDATALOG "4qsdatalog"))(POS (EXAMPLE.COMPLETE 4QSDATALOG COMPLETE))(POS (EXAMPLE.TECHNIQUE 4QSDATALOG SYMMETRYANALYSIS))(POS (EXAMPLE.DESCRIPTION 4QSDATALOG "Take advantage of the fact that we can order the queens so that the first one is always placed left of the second, the second left of the third, and so on.  To do this, we use less-than instead of just distinct."))(POS (EXAMPLE.EFFICIENCYGAINS 4QSDATALOG "5x"))(POS (MATRIXSHOW 4QSDATALOG TRUE))(POS (EXAMPLE.COMMENTS 4QSDATALOG "We should be able to detect the fact that the query doesn't care about what order the queens are in; determining that less-than can be used and how to do that should then be possible."))(POS (EXAMPLE.SOURCEQUERY 4QSDATALOG "ent"))(POS (EXAMPLE.SOURCE 4QSDATALOG "  (<= ent
      (not notent))
  (<= notent
      (goal17 ?X1 ?Y1 ?X2 ?Y2 ?X3 ?Y3 ?X4 ?Y4)
      (not (phi ?X1 ?Y1 ?X2 ?Y2 ?X3 ?Y3 ?X4 ?Y4)))
 
  (<= (phi ?X1 ?Y1 ?X2 ?Y2 ?X3 ?Y3 ?X4 ?Y4)
      (or (distinct ?x1 1)
          (distinct ?y1 1))
      (or (distinct ?x2 1)
          (distinct ?y2 1))
      (or (distinct ?x3 1)
          (distinct ?y3 1))
      (or (distinct ?x4 1)
          (distinct ?y4 1)))
      
  ; below ne is the not equal table
  (<= (goal17 ?X1 ?Y1 ?X2 ?Y2 ?X3 ?Y3 ?X4 ?Y4)
      
      (sub ?y1 ?x1 ?neg1)
      (add ?y1 ?x1 ?pos1)
      (sub ?y2 ?x2 ?neg2)
      (distinct ?X1 ?X2)
      (distinct ?Y1 ?Y2)
      (distinct ?neg2 ?neg1)
      (add ?y2 ?x2 ?pos2)
      (distinct ?pos2 ?pos1)
      
      
      (sub ?y3 ?x3 ?neg3)
      (distinct ?X1 ?X3) 
      (distinct ?Y1 ?Y3)
      (distinct ?X2 ?X3)
      (distinct ?Y2 ?Y3)
      (distinct ?neg3 ?neg2)
      (distinct ?neg3 ?neg1)
      (add ?y3 ?x3 ?pos3)
      (distinct ?pos3 ?pos2)
      (distinct ?pos3 ?pos1)
      
      (sub ?y4 ?x4 ?neg4)
      (distinct ?X1 ?X4)
      (distinct ?X2 ?X4)
      (distinct ?X3 ?X4)
      (distinct ?Y1 ?Y4)
      (distinct ?Y2 ?Y4)
      (distinct ?Y3 ?Y4)
      (distinct ?neg4 ?neg3)
      (distinct ?neg4 ?neg2)
      (distinct ?neg4 ?neg1)
      (add ?y4 ?x4 ?pos4)
      (distinct ?pos4 ?pos3)
      (distinct ?pos4 ?pos2)
      (distinct ?pos4 ?pos1))
  
  (add 1 1 2)
  (add 1 2 3)
  (add 1 3 4)
  (add 1 4 5)
  (add 2 1 3)
  (add 2 2 4)
  (add 2 3 5)
  (add 2 4 6)
  (add 3 1 4)
  (add 3 2 5)
  (add 3 3 6)
  (add 3 4 7)
  (add 4 1 5)
  (add 4 2 6)
  (add 4 3 7)
  (add 4 4 8)

  (sub 1 1 0)
  (sub 1 2 -1)
  (sub 1 3 -2)
  (sub 1 4 -3)
  (sub 2 1 1)
  (sub 2 2 0)
  (sub 2 3 -1)
  (sub 2 4 -2)
  (sub 3 1 2)
  (sub 3 2 1)
  (sub 3 3 0)
  (sub 3 4 -1)
  (sub 4 1 3)
  (sub 4 2 2)
  (sub 4 3 1)
  (sub 4 4 0)"))(POS (EXAMPLE.TARGETQUERY 4QSDATALOG "ent"))(POS (EXAMPLE.TARGET 4QSDATALOG "  (<= ent
      (not notent))
  (<= notent
      (goal17 ?X1 ?Y1 ?X2 ?Y2 ?X3 ?Y3 ?X4 ?Y4)
      (not (phi ?X1 ?Y1 ?X2 ?Y2 ?X3 ?Y3 ?X4 ?Y4)))
 
  (<= (phi ?X1 ?Y1 ?X2 ?Y2 ?X3 ?Y3 ?X4 ?Y4)
      (or (distinct ?x1 1)
          (distinct ?y1 1))
      (or (distinct ?x2 1)
          (distinct ?y2 1))
      (or (distinct ?x3 1)
          (distinct ?y3 1))
      (or (distinct ?x4 1)
          (distinct ?y4 1)))
      
  ; below ne is the not equal table
  (<= (goal17 ?X1 ?Y1 ?X2 ?Y2 ?X3 ?Y3 ?X4 ?Y4)
      
      (sub ?y1 ?x1 ?neg1)
      (add ?y1 ?x1 ?pos1)
      (sub ?y2 ?x2 ?neg2)
      (< ?x1 ?x2)
      (distinct ?y1 ?y2)
      (distinct ?neg2 ?neg1)
      (add ?y2 ?x2 ?pos2)
      (distinct ?pos2 ?pos1)
      
      
      (sub ?y3 ?x3 ?neg3)
      (< ?x2 ?x3)
      (distinct ?y3 ?y1)
      (distinct ?y3 ?y2)
      (distinct ?neg3 ?neg2)
      (distinct ?neg3 ?neg1)
      (add ?y3 ?x3 ?pos3)
      (distinct ?pos3 ?pos2)
      (distinct ?pos3 ?pos1)
      
      (sub ?y4 ?x4 ?neg4)
      (< ?x3 ?x4)
      (distinct ?y4 ?y1)
      (distinct ?y4 ?y2)
      (distinct ?y4 ?y3)
      (distinct ?neg4 ?neg3)
      (distinct ?neg4 ?neg2)
      (distinct ?neg4 ?neg1)
      (add ?y4 ?x4 ?pos4)
      (distinct ?pos4 ?pos3)
      (distinct ?pos4 ?pos2)
      (distinct ?pos4 ?pos1))
  
  (add 1 1 2)
  (add 1 2 3)
  (add 1 3 4)
  (add 1 4 5)
  (add 2 1 3)
  (add 2 2 4)
  (add 2 3 5)
  (add 2 4 6)
  (add 3 1 4)
  (add 3 2 5)
  (add 3 3 6)
  (add 3 4 7)
  (add 4 1 5)
  (add 4 2 6)
  (add 4 3 7)
  (add 4 4 8)

  (sub 1 1 0)
  (sub 1 2 -1)
  (sub 1 3 -2)
  (sub 1 4 -3)
  (sub 2 1 1)
  (sub 2 2 0)
  (sub 2 3 -1)
  (sub 2 4 -2)
  (sub 3 1 2)
  (sub 3 2 1)
  (sub 3 3 0)
  (sub 3 4 -1)
  (sub 4 1 3)
  (sub 4 2 2)
  (sub 4 3 1)
  (sub 4 4 0)"))(NEG (EXAMPLE.COMMENTS 4QUEENS "Add in UNA and DCA for all object constants, i.e. this is finite Herbrand logic."))(POS (EXAMPLE.COMMENTS 4QUEENS "In the source, add in UNA and DCA for all object constants, i.e. this is finite Herbrand logic."))(NEG (EXAMPLE.SOURCE 4QUEENS "
  ; all the queens have different rows
  (<= (not (row ?x ?c))
      (row ?y ?c)
      (not (= ?x ?y)))

  ; all the queens have different columns
  (<= (not (col ?x ?c))
      (col ?y ?c)
      (not (= ?x ?y)))

  ; given a row and column, we can compute the two diagonals it is on.
  (<= (d ?q pos ?z) (row ?q ?x) (col ?q ?y) (sub ?y ?x ?z))
  (<= (d ?q neg ?z) (row ?q ?x) (col ?q ?y) (add ?y ?x ?z))

  ; all the queens have different diagonals
  (<= (not (d ?q1 ?sign ?z))
      (d ?q2 ?sign ?z)
      (not (= ?q1 ?q2)))

  ; add and subtract
  (add 1 1 2)
  (add 1 2 3)
  (add 1 3 4)
  (add 1 4 5)
  (add 2 1 3)
  (add 2 2 4)
  (add 2 3 5)
  (add 2 4 6)
  (add 3 1 4)
  (add 3 2 5)
  (add 3 3 6)
  (add 3 4 7)
  (add 4 1 5)
  (add 4 2 6)
  (add 4 3 7)
  (add 4 4 8)

  (sub 1 1 0)
  (sub 1 2 -1)
  (sub 1 3 -2)
  (sub 1 4 -3)
  (sub 2 1 1)
  (sub 2 2 0)
  (sub 2 3 -1)
  (sub 2 4 -2)
  (sub 3 1 2)
  (sub 3 2 1)
  (sub 3 3 0)
  (sub 3 4 -1)
  (sub 4 1 3)
  (sub 4 2 2)
  (sub 4 3 1)
  (sub 4 4 0)
"))(POS (EXAMPLE.SOURCE 4QUEENS "  ; all the queens have different rows
  (<= (not (row ?x ?c))
      (row ?y ?c)
      (not (= ?x ?y)))

  ; all the queens have different columns
  (<= (not (col ?x ?c))
      (col ?y ?c)
      (not (= ?x ?y)))

  ; given a row and column, we can compute the two diagonals it is on.
  (<= (d ?q pos ?z) (row ?q ?x) (col ?q ?y) (sub ?y ?x ?z))
  (<= (d ?q neg ?z) (row ?q ?x) (col ?q ?y) (add ?y ?x ?z))

  ; all the queens have different diagonals
  (<= (not (d ?q1 ?sign ?z))
      (d ?q2 ?sign ?z)
      (not (= ?q1 ?q2)))

  ; add and subtract
  (add 1 1 2)
  (add 1 2 3)
  (add 1 3 4)
  (add 1 4 5)
  (add 2 1 3)
  (add 2 2 4)
  (add 2 3 5)
  (add 2 4 6)
  (add 3 1 4)
  (add 3 2 5)
  (add 3 3 6)
  (add 3 4 7)
  (add 4 1 5)
  (add 4 2 6)
  (add 4 3 7)
  (add 4 4 8)

  (sub 1 1 0)
  (sub 1 2 -1)
  (sub 1 3 -2)
  (sub 1 4 -3)
  (sub 2 1 1)
  (sub 2 2 0)
  (sub 2 3 -1)
  (sub 2 4 -2)
  (sub 3 1 2)
  (sub 3 2 1)
  (sub 3 3 0)
  (sub 3 4 -1)
  (sub 4 1 3)
  (sub 4 2 2)
  (sub 4 3 1)
  (sub 4 4 0)
"))(POS (EXAMPLE.INSTANCE NQUEENS))(POS (PRETTYNAME NQUEENS "N-Queens"))(POS (SHORTNAME NQUEENS "nqueens"))(POS (EXAMPLE.COMPLETE NQUEENS INCOMPLETE))(POS (EXAMPLE.TECHNIQUE NQUEENS BILEVEL))(POS (EXAMPLE.TECHNIQUE NQUEENS NAF))(POS (EXAMPLE.TECHNIQUE NQUEENS CONSISTENCY2DEDUCTION))(POS (EXAMPLE.TECHNIQUE NQUEENS UNNAMED))(POS (EXAMPLE.DESCRIPTION NQUEENS "Here we use (a minimal-model semantic version of) metalevel logic to describe the class of all X-queens queries, where the constraints are written as usual in FHL.  The recursive query definition is guarded by a single table that says how many queens are available (which I believe may play a crucial role in doing the translation).  The datalog version uses recursion and functions, again bounded by the single table with the number of queens.  "))(POS (MATRIXSHOW NQUEENS TRUE))(POS (EXAMPLE.COMMENTS NQUEENS "Here we can do the reformulation once and apply it to any n-queens problem by simply changing the value in that NumQueens table and the add/sub facts.  We pay a little more in interpreting the Datalog because of the added recursion.

This example illustrates just C2D: we just want to enumerate all the solutiions.  (query ?x) is true in the Datalog version if ?x is a list of queen locations, ?x satisfies the constraints of n-queens, and ?x has n locations, where n is the value in the table querylength.
"))(POS (EXAMPLE.SOURCEQUERY NQUEENS "  (query ?x)"))(POS (EXAMPLE.SOURCE NQUEENS "
 ;;;;;;;;;; metalevel query definition ;;;;;;;;;;;;
(<= (query ?x)
      (queens ?x)
      (query-length ?n)
      (length ?x ?n))

  (<= (queen \"(and (row <?q> <?x>) (col <?q> <?y>))\")
      (queen ?q)
      (var ?x)
      (var ?y)
      (not (= ?x ?y)))

  (<= (queens \"(and ?x ?y)\")
      (queen ?x)
      (queens ?y))

  (<= (length \"(?x ?y ?z)\" (s 0))
      (not (= ?x \"and\")))
  (<= (length \"(and <?x> <?y>)\" (s ?z))
      (length ?y ?z))

  ;;;;;;; then we have the normal constraints ;;;;;;;;
  ; all the queens have different rows
  (<= (not (row ?x ?c))
      (row ?y ?c)
      (not (= ?x ?y)))

  ; all the queens have different columns
  (<= (not (col ?x ?c))
      (col ?y ?c)
      (not (= ?x ?y)))

  ; given a row and column, we can compute the two diagonals it is on.
  (<= (d ?q pos ?z) (row ?q ?x) (col ?q ?y) (sub ?y ?x ?z))
  (<= (d ?q neg ?z) (row ?q ?x) (col ?q ?y) (add ?y ?x ?z))

  ; all the queens have different diagonals
  (<= (not (d ?q1 ?sign ?z))
      (d ?q2 ?sign ?z)
      (not (= ?q1 ?q2)))

  ; add and subtract
  (add 1 1 2)
  (add 1 2 3)
  (add 1 3 4)
  (add 1 4 5)
  (add 2 1 3)
  (add 2 2 4)
  (add 2 3 5)
  (add 2 4 6)
  (add 3 1 4)
  (add 3 2 5)
  (add 3 3 6)
  (add 3 4 7)
  (add 4 1 5)
  (add 4 2 6)
  (add 4 3 7)
  (add 4 4 8)

  (sub 1 1 0)
  (sub 1 2 -1)
  (sub 1 3 -2)
  (sub 1 4 -3)
  (sub 2 1 1)
  (sub 2 2 0)
  (sub 2 3 -1)
  (sub 2 4 -2)
  (sub 3 1 2)
  (sub 3 2 1)
  (sub 3 3 0)
  (sub 3 4 -1)
  (sub 4 1 3)
  (sub 4 2 2)
  (sub 4 3 1)
  (sub 4 4 0)
"))(POS (EXAMPLE.TARGETQUERY NQUEENS "(query ?x)"))(POS (EXAMPLE.TARGET NQUEENS "  (<= (query ?x)
      (querylength ?n)
      (ans ?x ?n))

  (<= (ans nil 0))
  (<= (ans (f ?x ?y) (s ?z))
      (ans ?y ?z)
      (augmentans ?x ?y))

  (<= (augmentans ?x ?y)
      (place-queen ?x)
      (not (some-queen-attacks ?x ?y)))

  (<= (place-queen (loc ?x ?y ?neg ?pos))
      (sub ?y ?x ?neg)
      (add ?y ?x ?pos))
      
  (<= (some-queen-attacks (loc ?x ?y ?neg ?pos) (f (loc ?x2 ?y2 ?neg2 ?pos2) ?rest))
      (or (= ?x ?x2)
          (= ?y ?y2)
          (= ?neg ?neg2)
          (= ?pos ?pos2)
          (some-queen-attacks (loc ?x ?y ?neg ?pos) ?rest)))
  (= ?x ?x)

  (querylength (s (s (s (s 0)))))
  (add 1 1 2)
  (add 1 2 3)
  (add 1 3 4)
  (add 1 4 5)
  (add 2 1 3)
  (add 2 2 4)
  (add 2 3 5)
  (add 2 4 6)
  (add 3 1 4)
  (add 3 2 5)
  (add 3 3 6)
  (add 3 4 7)
  (add 4 1 5)
  (add 4 2 6)
  (add 4 3 7)
  (add 4 4 8)

  (sub 1 1 0)
  (sub 1 2 -1)
  (sub 1 3 -2)
  (sub 1 4 -3)
  (sub 2 1 1)
  (sub 2 2 0)
  (sub 2 3 -1)
  (sub 2 4 -2)
  (sub 3 1 2)
  (sub 3 2 1)
  (sub 3 3 0)
  (sub 3 4 -1)
  (sub 4 1 3)
  (sub 4 2 2)
  (sub 4 3 1)
  (sub 4 4 0)
"))(POS (EXAMPLE.INSTANCE WUMPUSPERCEPTS))(POS (PRETTYNAME WUMPUSPERCEPTS "Wumpus World with Percepts"))(POS (SHORTNAME WUMPUSPERCEPTS "wumpus.per"))(POS (EXAMPLE.COMPLETE WUMPUSPERCEPTS INCOMPLETE))(POS (EXAMPLE.TECHNIQUE WUMPUSPERCEPTS BILEVEL))(POS (EXAMPLE.TECHNIQUE WUMPUSPERCEPTS CONSISTENCY2DEDUCTION))(POS (EXAMPLE.TECHNIQUE WUMPUSPERCEPTS NAF))(POS (EXAMPLE.TECHNIQUE WUMPUSPERCEPTS UNNAMED))(POS (EXAMPLE.DESCRIPTION WUMPUSPERCEPTS "A snapshot of wumpus world, after sensing a stench at one location and a shine at another.  Is the gold to the west of the wumpus in all cases?  Translate this problem stated in logic, where the data is the set of percepts, into a datalog program (with a single function for representing the structure of a grid location) that checks the entailment by cases."))(POS (MATRIXSHOW WUMPUSPERCEPTS TRUE))(POS (EXAMPLE.COMMENTS WUMPUSPERCEPTS "There is nothing mystical about introducing (cell x y) instead of sticking to opaque names for cells.  It was partly laziness and partly I believe we may be able to automatically produce this translation by analyzing the constraints on the data (which we might include as integrity constraints)."))(POS (EXAMPLE.SOURCEQUERY WUMPUSPERCEPTS "      (=> (gold ?x) (wumpus ?y) (westof ?x ?y)))
"))(POS (EXAMPLE.SOURCE WUMPUSPERCEPTS "  (north a e)
  (north e i)
  (north i m)
  (north b f)
  (north f j)
  (north j n)
  (north c g)
  (north g k)
  (north k o)
  (north d h)
  (north h l)
  (north l p)

  (east a b)
  (east b c)
  (east c d)
  (east e f)
  (east f g)
  (east g h)
  (east i j)
  (east j k)
  (east k l)
  (east m n)
  (east n o)
  (east o p)


  (<=> (west ?x ?y) (east ?y ?x))
  (<=> (south ?x ?y) (north ?y ?x))

  (<=> (westof ?x ?y)
       (or (west ?x ?y)
           (exists ?z (and (west ?x ?z) (west ?z ?y)))
           (exists (?z ?w) (and (west ?x ?z) (west ?z ?w) (west ?w ?y)))))

  (westborder e)
  (westborder i)
  (eastborder h)
  (eastborder l)
  (northborder b)
  (northborder c)
  (southborder n)
  (southborder o)

  (nwcorner a)
  (necorner d)
  (swcorner m)
  (secorner p)
  
  (notborder f)
  (notborder g)
  (notborder j)
  (notborder k)


  ; center
  (=> (stench ?cell)
      (notborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?celle)
          (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (notborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))
           (not (wumpus ?cellw))
           (not (wumpus ?cells))))

  ;;; borders

  ;west
  (=> (stench ?cell)
      (westborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (or (wumpus ?celln)
          (wumpus ?celle)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (westborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))
           (not (wumpus ?cells))))


  ; north
  (=> (stench ?cell)
      (northborder ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (or (wumpus ?celle)
          (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (northborder ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (and (not (wumpus ?celle))
           (not (wumpus ?cellw))
           (not (wumpus ?cells))))

      
  ; south
  (=> (stench ?cell)
      (southborder ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?celle)
          (wumpus ?cellw)))

  (=> (not (stench ?cell))
      (southborder ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))
           (not (wumpus ?cellw))))

  ; east
  (=> (stench ?cell)
      (eastborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (eastborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?cellw))
           (not (wumpus ?cells))))

  ;;; corners

  ; nw
  (=> (stench ?cell)
      (nwcorner ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (or (wumpus ?celle)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (nwcorner ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (and (not (wumpus ?celle))
           (not (wumpus ?cells))))

  ; ne
  (=> (stench ?cell)
      (necorner ?cell)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (or (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (necorner ?cell)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (and (not (wumpus ?cellw))
           (not (wumpus ?cells))))

  ; sw
  (=> (stench ?cell)
      (wwcorner ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (or (wumpus ?celln)
          (wumpus ?celle)))

  (=> (not (stench ?cell))
      (wwcorner ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))))

  ; se
  (=> (stench ?cell)
      (secorner ?cell)
      (north ?cell ?celln)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?cellw)))

  (=> (not (stench ?cell))
      (secorner ?cell)
      (north ?cell ?celln)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?cellw))))

  ;(or (wumpus a) (wumpus b) (wumpus c) (wumpus d) (wumpus e) (wumpus f) (wumpus g) (wumpus h) (wumpus i))

  (shiney e)
  (not (stench e))
  (stench l)
  (not (shiney l))
"))(POS (EXAMPLE.TARGETQUERY WUMPUSPERCEPTS "ent"))(POS (EXAMPLE.TARGET WUMPUSPERCEPTS "(deftheory datalog-wumpusworld2

  (<= ent
      (not notent))
  (<= notent
      (possworld ?x ?y)
      (not (westof ?x ?y)))

  (<= (westof ?x ?y)
      (or (west ?x ?y)
          (and (west ?x ?z) (west ?z ?y))
          (and (west ?x ?z) (west ?z ?w) (west ?w ?y))))

  (<= (possworld ?x ?y)
      (possgold ?x)
      (posswumpus ?y))

  ; poss gold
  (<= (possgold ?x)
      (adjacentshiney ?x)
      (not (some-adjacentnonshiney ?x))
      (not (some-nonadjacentshiney ?x)))

  (<= (adjacentshiney ?x)
      (shiney ?s)
      (adjacent ?s ?x))

  (<= (some-nonadjacentshiney ?x)
      (shiney ?s)
      (not (adjacent ?s ?x)))

  (<= (some-adjacentnonshiney ?x)
      (adjacent ?x ?y)
      (nshiney ?y))

  ; poss wumpus
  (<= (posswumpus ?x)
      (adjacentstench ?x)
      (not (some-adjacentnonstench ?x))
      (not (some-nonadjacentstench ?x)))

  (<= (adjacentstench ?x)
      (stench ?s)
      (adjacent ?s ?x))

  (<= (some-nonadjacentstench ?x)
      (stench ?s)
      (not (adjacent ?s ?x)))

  (<= (some-adjacentnonstench ?x)
      (adjacent ?x ?y)
      (nstench ?y))
      

  (adj 1 2)
  (adj 2 3)
  (adj 3 4)
  (<= (next ?x ?y)
      (or (adj ?x ?y) (adj ?y ?x)))
  
  (<= (adjacent (cell ?x ?y) (cell ?z ?y))
      (next ?x ?z))

  (<= (adjacent (cell ?x ?y) (cell ?x ?w))
      (next ?y ?w))

  (<= (adjacent (cell ?x ?y) (cell ?z ?w))
      (next ?x ?z)
      (next ?y ?w))

  (<= (west (cell ?x ?y) (cell ?x2 ?w))
      (adj ?x ?x2))

  (shiney (cell 1 3))
  (nstench (cell 1 3))
  (stench (cell 4 2))
  (nshiney (cell 4 2))
)"))(NEG (EXAMPLE.TARGET WUMPUSPERCEPTS "(deftheory datalog-wumpusworld2

  (<= ent
      (not notent))
  (<= notent
      (possworld ?x ?y)
      (not (westof ?x ?y)))

  (<= (westof ?x ?y)
      (or (west ?x ?y)
          (and (west ?x ?z) (west ?z ?y))
          (and (west ?x ?z) (west ?z ?w) (west ?w ?y))))

  (<= (possworld ?x ?y)
      (possgold ?x)
      (posswumpus ?y))

  ; poss gold
  (<= (possgold ?x)
      (adjacentshiney ?x)
      (not (some-adjacentnonshiney ?x))
      (not (some-nonadjacentshiney ?x)))

  (<= (adjacentshiney ?x)
      (shiney ?s)
      (adjacent ?s ?x))

  (<= (some-nonadjacentshiney ?x)
      (shiney ?s)
      (not (adjacent ?s ?x)))

  (<= (some-adjacentnonshiney ?x)
      (adjacent ?x ?y)
      (nshiney ?y))

  ; poss wumpus
  (<= (posswumpus ?x)
      (adjacentstench ?x)
      (not (some-adjacentnonstench ?x))
      (not (some-nonadjacentstench ?x)))

  (<= (adjacentstench ?x)
      (stench ?s)
      (adjacent ?s ?x))

  (<= (some-nonadjacentstench ?x)
      (stench ?s)
      (not (adjacent ?s ?x)))

  (<= (some-adjacentnonstench ?x)
      (adjacent ?x ?y)
      (nstench ?y))
      

  (adj 1 2)
  (adj 2 3)
  (adj 3 4)
  (<= (next ?x ?y)
      (or (adj ?x ?y) (adj ?y ?x)))
  
  (<= (adjacent (cell ?x ?y) (cell ?z ?y))
      (next ?x ?z))

  (<= (adjacent (cell ?x ?y) (cell ?x ?w))
      (next ?y ?w))

  (<= (adjacent (cell ?x ?y) (cell ?z ?w))
      (next ?x ?z)
      (next ?y ?w))

  (<= (west (cell ?x ?y) (cell ?x2 ?w))
      (adj ?x ?x2))

  (shiney (cell 1 3))
  (nstench (cell 1 3))
  (stench (cell 4 2))
  (nshiney (cell 4 2))
)"))(POS (EXAMPLE.TARGET WUMPUSPERCEPTS "  (<= ent
      (not notent))
  (<= notent
      (possworld ?x ?y)
      (not (westof ?x ?y)))

  (<= (westof ?x ?y)
      (or (west ?x ?y)
          (and (west ?x ?z) (west ?z ?y))
          (and (west ?x ?z) (west ?z ?w) (west ?w ?y))))

  (<= (possworld ?x ?y)
      (possgold ?x)
      (posswumpus ?y))

  ; poss gold
  (<= (possgold ?x)
      (adjacentshiney ?x)
      (not (some-adjacentnonshiney ?x))
      (not (some-nonadjacentshiney ?x)))

  (<= (adjacentshiney ?x)
      (shiney ?s)
      (adjacent ?s ?x))

  (<= (some-nonadjacentshiney ?x)
      (shiney ?s)
      (not (adjacent ?s ?x)))

  (<= (some-adjacentnonshiney ?x)
      (adjacent ?x ?y)
      (nshiney ?y))

  ; poss wumpus
  (<= (posswumpus ?x)
      (adjacentstench ?x)
      (not (some-adjacentnonstench ?x))
      (not (some-nonadjacentstench ?x)))

  (<= (adjacentstench ?x)
      (stench ?s)
      (adjacent ?s ?x))

  (<= (some-nonadjacentstench ?x)
      (stench ?s)
      (not (adjacent ?s ?x)))

  (<= (some-adjacentnonstench ?x)
      (adjacent ?x ?y)
      (nstench ?y))
      

  (adj 1 2)
  (adj 2 3)
  (adj 3 4)
  (<= (next ?x ?y)
      (or (adj ?x ?y) (adj ?y ?x)))
  
  (<= (adjacent (cell ?x ?y) (cell ?z ?y))
      (next ?x ?z))

  (<= (adjacent (cell ?x ?y) (cell ?x ?w))
      (next ?y ?w))

  (<= (adjacent (cell ?x ?y) (cell ?z ?w))
      (next ?x ?z)
      (next ?y ?w))

  (<= (west (cell ?x ?y) (cell ?x2 ?w))
      (adj ?x ?x2))

  (shiney (cell 1 3))
  (nstench (cell 1 3))
  (stench (cell 4 2))
  (nshiney (cell 4 2))"))(NEG (EXAMPLE.DESCRIPTION WUMPUSPERCEPTS "A snapshot of wumpus world, after sensing a stench at one location and a shine at another.  Is the gold to the west of the wumpus in all cases?  Translate this problem stated in logic, where the data is the set of percepts, into a datalog program (with a single function for representing the structure of a grid location) that checks the entailment by cases."))(POS (EXAMPLE.DESCRIPTION WUMPUSPERCEPTS "A snapshot of wumpus world, after sensing a stench at one location and a shine at another.  Is the gold to the west of the wumpus in all cases?  Translate this problem stated in logic, where the data is the set of percepts, into a datalog program that checks the entailment by cases.  The tricky part here is that the percept tables (the ones that are supposed to be left out of the transformation) are incomplete; thus, we cannot import them directly into datalog. Because the tables are incomplete but not disjunctive, we create a complete table for stench, another complete table for notstench; likewise for shine.  The stench table includes all those cells where we observed a stench; the notstench table contains all those cells without a stench.  These can both be complete, and we know the environment maintains consistency. "))(NEG (EXAMPLE.COMMENTS WUMPUSPERCEPTS "There is nothing mystical about introducing (cell x y) instead of sticking to opaque names for cells.  It was partly laziness and partly I believe we may be able to automatically produce this translation by analyzing the constraints on the data (which we might include as integrity constraints)."))(POS (EXAMPLE.COMMENTS WUMPUSPERCEPTS "Here I'm using some functions in the source, simply because the problem was easier to write down this way.  It may also be a case that demonstrates that sometimes we can deal with functions.  I'm conflating this with completing the tables stench and shine, but I couldn't bring myself to write it without functions."))(NEG (EXAMPLE.SOURCE WUMPUSPERCEPTS "  (north a e)
  (north e i)
  (north i m)
  (north b f)
  (north f j)
  (north j n)
  (north c g)
  (north g k)
  (north k o)
  (north d h)
  (north h l)
  (north l p)

  (east a b)
  (east b c)
  (east c d)
  (east e f)
  (east f g)
  (east g h)
  (east i j)
  (east j k)
  (east k l)
  (east m n)
  (east n o)
  (east o p)


  (<=> (west ?x ?y) (east ?y ?x))
  (<=> (south ?x ?y) (north ?y ?x))

  (<=> (westof ?x ?y)
       (or (west ?x ?y)
           (exists ?z (and (west ?x ?z) (west ?z ?y)))
           (exists (?z ?w) (and (west ?x ?z) (west ?z ?w) (west ?w ?y)))))

  (westborder e)
  (westborder i)
  (eastborder h)
  (eastborder l)
  (northborder b)
  (northborder c)
  (southborder n)
  (southborder o)

  (nwcorner a)
  (necorner d)
  (swcorner m)
  (secorner p)
  
  (notborder f)
  (notborder g)
  (notborder j)
  (notborder k)


  ; center
  (=> (stench ?cell)
      (notborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?celle)
          (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (notborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))
           (not (wumpus ?cellw))
           (not (wumpus ?cells))))

  ;;; borders

  ;west
  (=> (stench ?cell)
      (westborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (or (wumpus ?celln)
          (wumpus ?celle)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (westborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))
           (not (wumpus ?cells))))


  ; north
  (=> (stench ?cell)
      (northborder ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (or (wumpus ?celle)
          (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (northborder ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (and (not (wumpus ?celle))
           (not (wumpus ?cellw))
           (not (wumpus ?cells))))

      
  ; south
  (=> (stench ?cell)
      (southborder ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?celle)
          (wumpus ?cellw)))

  (=> (not (stench ?cell))
      (southborder ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))
           (not (wumpus ?cellw))))

  ; east
  (=> (stench ?cell)
      (eastborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (eastborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?cellw))
           (not (wumpus ?cells))))

  ;;; corners

  ; nw
  (=> (stench ?cell)
      (nwcorner ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (or (wumpus ?celle)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (nwcorner ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (and (not (wumpus ?celle))
           (not (wumpus ?cells))))

  ; ne
  (=> (stench ?cell)
      (necorner ?cell)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (or (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (necorner ?cell)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (and (not (wumpus ?cellw))
           (not (wumpus ?cells))))

  ; sw
  (=> (stench ?cell)
      (wwcorner ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (or (wumpus ?celln)
          (wumpus ?celle)))

  (=> (not (stench ?cell))
      (wwcorner ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))))

  ; se
  (=> (stench ?cell)
      (secorner ?cell)
      (north ?cell ?celln)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?cellw)))

  (=> (not (stench ?cell))
      (secorner ?cell)
      (north ?cell ?celln)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?cellw))))

  ;(or (wumpus a) (wumpus b) (wumpus c) (wumpus d) (wumpus e) (wumpus f) (wumpus g) (wumpus h) (wumpus i))

  (shiney e)
  (not (stench e))
  (stench l)
  (not (shiney l))
"))(POS (EXAMPLE.SOURCE WUMPUSPERCEPTS "
  (succ 1 2)
  (succ 2 3)
  (succ 3 4)

  (<=> (next ?x ?y)
       (or (succ ?x ?y)
           (succ ?y ?x)))

  (<=> (west (cell ?x ?y) (cell ?x2 ?y))
       (succ ?x2 ?x))
  (<=> (north (cell ?x ?y) (cell ?x ?y2))
       (succ ?y2 ?y))
  
  (<=> (east ?x ?y) (west ?y ?x))
  (<=> (south ?x ?y) (north ?y ?x))

  (<=> (westof (cell ?x ?y) (cell ?x2 ?y2))
       (or (adj ?x ?x2)
           (exists ?z (and (adj ?x ?z) (adj ?z ?x2)))
           (exists (?z ?w) (and (adj ?x ?z) (adj ?z ?w) (adj ?w ?x2)))))

  (<=> (westborder (cell 1 ?x))
       (not (= ?x 1))
       (not (= ?x 4)))

  (<=> (eastborder (cell 4 ?x))
       (not (= ?x 1))
       (not (= ?x 4)))

  (<=> (southborder (cell ?x 1))
       (not (= ?x 1))
       (not (= ?x 4)))

  (<=> (northborder (cell ?x 4))
       (not (= ?x 1))
       (not (= ?x 4)))

  (nwcorner (cell 1 4))
  (necorner (cell 4 4))
  (swcorner (cell 1 1))
  (secorner (cell 4 1))
  
  (<=> (notborder (cell ?x ?y))
       (and (not (= ?x 1))
            (not (= ?x 4))
            (not (= ?y 1))
            (not (= ?y 4))))

  ; center
  (=> (stench ?cell)
      (notborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?celle)
          (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (notborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))
           (not (wumpus ?cellw))
           (not (wumpus ?cells))))

  ;;; borders

  ;west
  (=> (stench ?cell)
      (westborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (or (wumpus ?celln)
          (wumpus ?celle)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (westborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))
           (not (wumpus ?cells))))


  ; north
  (=> (stench ?cell)
      (northborder ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (or (wumpus ?celle)
          (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (northborder ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (and (not (wumpus ?celle))
           (not (wumpus ?cellw))
           (not (wumpus ?cells))))

      
  ; south
  (=> (stench ?cell)
      (southborder ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?celle)
          (wumpus ?cellw)))

  (=> (not (stench ?cell))
      (southborder ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))
           (not (wumpus ?cellw))))

  ; east
  (=> (stench ?cell)
      (eastborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (eastborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?cellw))
           (not (wumpus ?cells))))

  ;;; corners

  ; nw
  (=> (stench ?cell)
      (nwcorner ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (or (wumpus ?celle)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (nwcorner ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (and (not (wumpus ?celle))
           (not (wumpus ?cells))))

  ; ne
  (=> (stench ?cell)
      (necorner ?cell)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (or (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (necorner ?cell)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (and (not (wumpus ?cellw))
           (not (wumpus ?cells))))

  ; sw
  (=> (stench ?cell)
      (wwcorner ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (or (wumpus ?celln)
          (wumpus ?celle)))

  (=> (not (stench ?cell))
      (wwcorner ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))))

  ; se
  (=> (stench ?cell)
      (secorner ?cell)
      (north ?cell ?celln)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?cellw)))

  (=> (not (stench ?cell))
      (secorner ?cell)
      (north ?cell ?celln)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?cellw))))

  (exists (?x ?y) (wumpus (cell ?x ?y)))

  (shiney (cell 1 3))
  (not (stench (cell 1 3)))
  (stench (cell 4 2))
  (not (shiney (cell 4 2)))
"))(NEG (EXAMPLE.SOURCEQUERY WUMPUSPERCEPTS "      (=> (gold ?x) (wumpus ?y) (westof ?x ?y)))
"))(POS (EXAMPLE.SOURCEQUERY WUMPUSPERCEPTS "      (=> (gold ?x) (wumpus ?y) (westof ?x ?y))
"))(NEG (EXAMPLE.SOURCE WUMPUSPERCEPTS "
  (succ 1 2)
  (succ 2 3)
  (succ 3 4)

  (<=> (next ?x ?y)
       (or (succ ?x ?y)
           (succ ?y ?x)))

  (<=> (west (cell ?x ?y) (cell ?x2 ?y))
       (succ ?x2 ?x))
  (<=> (north (cell ?x ?y) (cell ?x ?y2))
       (succ ?y2 ?y))
  
  (<=> (east ?x ?y) (west ?y ?x))
  (<=> (south ?x ?y) (north ?y ?x))

  (<=> (westof (cell ?x ?y) (cell ?x2 ?y2))
       (or (adj ?x ?x2)
           (exists ?z (and (adj ?x ?z) (adj ?z ?x2)))
           (exists (?z ?w) (and (adj ?x ?z) (adj ?z ?w) (adj ?w ?x2)))))

  (<=> (westborder (cell 1 ?x))
       (not (= ?x 1))
       (not (= ?x 4)))

  (<=> (eastborder (cell 4 ?x))
       (not (= ?x 1))
       (not (= ?x 4)))

  (<=> (southborder (cell ?x 1))
       (not (= ?x 1))
       (not (= ?x 4)))

  (<=> (northborder (cell ?x 4))
       (not (= ?x 1))
       (not (= ?x 4)))

  (nwcorner (cell 1 4))
  (necorner (cell 4 4))
  (swcorner (cell 1 1))
  (secorner (cell 4 1))
  
  (<=> (notborder (cell ?x ?y))
       (and (not (= ?x 1))
            (not (= ?x 4))
            (not (= ?y 1))
            (not (= ?y 4))))

  ; center
  (=> (stench ?cell)
      (notborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?celle)
          (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (notborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))
           (not (wumpus ?cellw))
           (not (wumpus ?cells))))

  ;;; borders

  ;west
  (=> (stench ?cell)
      (westborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (or (wumpus ?celln)
          (wumpus ?celle)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (westborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))
           (not (wumpus ?cells))))


  ; north
  (=> (stench ?cell)
      (northborder ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (or (wumpus ?celle)
          (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (northborder ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (and (not (wumpus ?celle))
           (not (wumpus ?cellw))
           (not (wumpus ?cells))))

      
  ; south
  (=> (stench ?cell)
      (southborder ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?celle)
          (wumpus ?cellw)))

  (=> (not (stench ?cell))
      (southborder ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))
           (not (wumpus ?cellw))))

  ; east
  (=> (stench ?cell)
      (eastborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (eastborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?cellw))
           (not (wumpus ?cells))))

  ;;; corners

  ; nw
  (=> (stench ?cell)
      (nwcorner ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (or (wumpus ?celle)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (nwcorner ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (and (not (wumpus ?celle))
           (not (wumpus ?cells))))

  ; ne
  (=> (stench ?cell)
      (necorner ?cell)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (or (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (necorner ?cell)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (and (not (wumpus ?cellw))
           (not (wumpus ?cells))))

  ; sw
  (=> (stench ?cell)
      (wwcorner ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (or (wumpus ?celln)
          (wumpus ?celle)))

  (=> (not (stench ?cell))
      (wwcorner ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))))

  ; se
  (=> (stench ?cell)
      (secorner ?cell)
      (north ?cell ?celln)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?cellw)))

  (=> (not (stench ?cell))
      (secorner ?cell)
      (north ?cell ?celln)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?cellw))))

  (exists (?x ?y) (wumpus (cell ?x ?y)))

  (shiney (cell 1 3))
  (not (stench (cell 1 3)))
  (stench (cell 4 2))
  (not (shiney (cell 4 2)))
"))(POS (EXAMPLE.SOURCE WUMPUSPERCEPTS "  (succ 1 2)
  (succ 2 3)
  (succ 3 4)

  (<=> (next ?x ?y)
       (or (succ ?x ?y)
           (succ ?y ?x)))

  (<=> (west (cell ?x ?y) (cell ?x2 ?y))
       (succ ?x2 ?x))
  (<=> (north (cell ?x ?y) (cell ?x ?y2))
       (succ ?y2 ?y))
  
  (<=> (east ?x ?y) (west ?y ?x))
  (<=> (south ?x ?y) (north ?y ?x))

  (<=> (westof (cell ?x ?y) (cell ?x2 ?y2))
       (or (adj ?x ?x2)
           (exists ?z (and (adj ?x ?z) (adj ?z ?x2)))
           (exists (?z ?w) (and (adj ?x ?z) (adj ?z ?w) (adj ?w ?x2)))))

  (<=> (westborder (cell 1 ?x))
       (not (= ?x 1))
       (not (= ?x 4)))

  (<=> (eastborder (cell 4 ?x))
       (not (= ?x 1))
       (not (= ?x 4)))

  (<=> (southborder (cell ?x 1))
       (not (= ?x 1))
       (not (= ?x 4)))

  (<=> (northborder (cell ?x 4))
       (not (= ?x 1))
       (not (= ?x 4)))

  (nwcorner (cell 1 4))
  (necorner (cell 4 4))
  (swcorner (cell 1 1))
  (secorner (cell 4 1))
  
  (<=> (notborder (cell ?x ?y))
       (and (not (= ?x 1))
            (not (= ?x 4))
            (not (= ?y 1))
            (not (= ?y 4))))

  ; center
  (=> (stench ?cell)
      (notborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?celle)
          (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (notborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))
           (not (wumpus ?cellw))
           (not (wumpus ?cells))))

  ;;; borders

  ;west
  (=> (stench ?cell)
      (westborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (or (wumpus ?celln)
          (wumpus ?celle)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (westborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))
           (not (wumpus ?cells))))


  ; north
  (=> (stench ?cell)
      (northborder ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (or (wumpus ?celle)
          (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (northborder ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (and (not (wumpus ?celle))
           (not (wumpus ?cellw))
           (not (wumpus ?cells))))

      
  ; south
  (=> (stench ?cell)
      (southborder ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?celle)
          (wumpus ?cellw)))

  (=> (not (stench ?cell))
      (southborder ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))
           (not (wumpus ?cellw))))

  ; east
  (=> (stench ?cell)
      (eastborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (eastborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?cellw))
           (not (wumpus ?cells))))

  ;;; corners

  ; nw
  (=> (stench ?cell)
      (nwcorner ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (or (wumpus ?celle)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (nwcorner ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (and (not (wumpus ?celle))
           (not (wumpus ?cells))))

  ; ne
  (=> (stench ?cell)
      (necorner ?cell)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (or (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (necorner ?cell)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (and (not (wumpus ?cellw))
           (not (wumpus ?cells))))

  ; sw
  (=> (stench ?cell)
      (wwcorner ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (or (wumpus ?celln)
          (wumpus ?celle)))

  (=> (not (stench ?cell))
      (wwcorner ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))))

  ; se
  (=> (stench ?cell)
      (secorner ?cell)
      (north ?cell ?celln)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?cellw)))

  (=> (not (stench ?cell))
      (secorner ?cell)
      (north ?cell ?celln)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?cellw))))

  (exists (?x ?y) (wumpus (cell ?x ?y)))

  (shiney (cell 1 3))
  (not (stench (cell 1 3)))
  (stench (cell 4 2))
  (not (shiney (cell 4 2)))
"))(NEG (EXAMPLE.SOURCE WUMPUSPERCEPTS "  (succ 1 2)
  (succ 2 3)
  (succ 3 4)

  (<=> (next ?x ?y)
       (or (succ ?x ?y)
           (succ ?y ?x)))

  (<=> (west (cell ?x ?y) (cell ?x2 ?y))
       (succ ?x2 ?x))
  (<=> (north (cell ?x ?y) (cell ?x ?y2))
       (succ ?y2 ?y))
  
  (<=> (east ?x ?y) (west ?y ?x))
  (<=> (south ?x ?y) (north ?y ?x))

  (<=> (westof (cell ?x ?y) (cell ?x2 ?y2))
       (or (adj ?x ?x2)
           (exists ?z (and (adj ?x ?z) (adj ?z ?x2)))
           (exists (?z ?w) (and (adj ?x ?z) (adj ?z ?w) (adj ?w ?x2)))))

  (<=> (westborder (cell 1 ?x))
       (not (= ?x 1))
       (not (= ?x 4)))

  (<=> (eastborder (cell 4 ?x))
       (not (= ?x 1))
       (not (= ?x 4)))

  (<=> (southborder (cell ?x 1))
       (not (= ?x 1))
       (not (= ?x 4)))

  (<=> (northborder (cell ?x 4))
       (not (= ?x 1))
       (not (= ?x 4)))

  (nwcorner (cell 1 4))
  (necorner (cell 4 4))
  (swcorner (cell 1 1))
  (secorner (cell 4 1))
  
  (<=> (notborder (cell ?x ?y))
       (and (not (= ?x 1))
            (not (= ?x 4))
            (not (= ?y 1))
            (not (= ?y 4))))

  ; center
  (=> (stench ?cell)
      (notborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?celle)
          (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (notborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))
           (not (wumpus ?cellw))
           (not (wumpus ?cells))))

  ;;; borders

  ;west
  (=> (stench ?cell)
      (westborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (or (wumpus ?celln)
          (wumpus ?celle)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (westborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))
           (not (wumpus ?cells))))


  ; north
  (=> (stench ?cell)
      (northborder ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (or (wumpus ?celle)
          (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (northborder ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (and (not (wumpus ?celle))
           (not (wumpus ?cellw))
           (not (wumpus ?cells))))

      
  ; south
  (=> (stench ?cell)
      (southborder ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?celle)
          (wumpus ?cellw)))

  (=> (not (stench ?cell))
      (southborder ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))
           (not (wumpus ?cellw))))

  ; east
  (=> (stench ?cell)
      (eastborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (eastborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?cellw))
           (not (wumpus ?cells))))

  ;;; corners

  ; nw
  (=> (stench ?cell)
      (nwcorner ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (or (wumpus ?celle)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (nwcorner ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (and (not (wumpus ?celle))
           (not (wumpus ?cells))))

  ; ne
  (=> (stench ?cell)
      (necorner ?cell)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (or (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (necorner ?cell)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (and (not (wumpus ?cellw))
           (not (wumpus ?cells))))

  ; sw
  (=> (stench ?cell)
      (wwcorner ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (or (wumpus ?celln)
          (wumpus ?celle)))

  (=> (not (stench ?cell))
      (wwcorner ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))))

  ; se
  (=> (stench ?cell)
      (secorner ?cell)
      (north ?cell ?celln)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?cellw)))

  (=> (not (stench ?cell))
      (secorner ?cell)
      (north ?cell ?celln)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?cellw))))

  (exists (?x ?y) (wumpus (cell ?x ?y)))

  (shiney (cell 1 3))
  (not (stench (cell 1 3)))
  (stench (cell 4 2))
  (not (shiney (cell 4 2)))
"))(POS (EXAMPLE.SOURCE WUMPUSPERCEPTS "
  (succ 1 2)
  (succ 2 3)
  (succ 3 4)

  (<=> (next ?x ?y)
       (or (succ ?x ?y)
           (succ ?y ?x)))

  (<=> (west (cell ?x ?y) (cell ?x2 ?y))
       (succ ?x2 ?x))
  (<=> (north (cell ?x ?y) (cell ?x ?y2))
       (succ ?y2 ?y))
  
  (<=> (east ?x ?y) (west ?y ?x))
  (<=> (south ?x ?y) (north ?y ?x))

  (<=> (westof (cell ?x ?y) (cell ?x2 ?y2))
       (or (succ ?x ?x2)
           (exists ?z (and (succ ?x ?z) (succ ?z ?x2)))
           (exists (?z ?w) (and (succ ?x ?z) (succ ?z ?w) (succ ?w ?x2)))))

  (<=> (westborder (cell 1 ?x))
       (not (= ?x 1))
       (not (= ?x 4)))

  (<=> (eastborder (cell 4 ?x))
       (not (= ?x 1))
       (not (= ?x 4)))

  (<=> (southborder (cell ?x 1))
       (not (= ?x 1))
       (not (= ?x 4)))

  (<=> (northborder (cell ?x 4))
       (not (= ?x 1))
       (not (= ?x 4)))

  (nwcorner (cell 1 4))
  (necorner (cell 4 4))
  (swcorner (cell 1 1))
  (secorner (cell 4 1))
  
  (<=> (notborder (cell ?x ?y))
       (and (not (= ?x 1))
            (not (= ?x 4))
            (not (= ?y 1))
            (not (= ?y 4))))

  ; center
  (=> (stench ?cell)
      (notborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?celle)
          (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (notborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))
           (not (wumpus ?cellw))
           (not (wumpus ?cells))))

  ;;; borders

  ;west
  (=> (stench ?cell)
      (westborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (or (wumpus ?celln)
          (wumpus ?celle)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (westborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))
           (not (wumpus ?cells))))


  ; north
  (=> (stench ?cell)
      (northborder ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (or (wumpus ?celle)
          (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (northborder ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (and (not (wumpus ?celle))
           (not (wumpus ?cellw))
           (not (wumpus ?cells))))

      
  ; south
  (=> (stench ?cell)
      (southborder ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?celle)
          (wumpus ?cellw)))

  (=> (not (stench ?cell))
      (southborder ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))
           (not (wumpus ?cellw))))

  ; east
  (=> (stench ?cell)
      (eastborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (eastborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?cellw))
           (not (wumpus ?cells))))

  ;;; corners

  ; nw
  (=> (stench ?cell)
      (nwcorner ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (or (wumpus ?celle)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (nwcorner ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (and (not (wumpus ?celle))
           (not (wumpus ?cells))))

  ; ne
  (=> (stench ?cell)
      (necorner ?cell)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (or (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (necorner ?cell)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (and (not (wumpus ?cellw))
           (not (wumpus ?cells))))

  ; sw
  (=> (stench ?cell)
      (wwcorner ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (or (wumpus ?celln)
          (wumpus ?celle)))

  (=> (not (stench ?cell))
      (wwcorner ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))))

  ; se
  (=> (stench ?cell)
      (secorner ?cell)
      (north ?cell ?celln)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?cellw)))

  (=> (not (stench ?cell))
      (secorner ?cell)
      (north ?cell ?celln)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?cellw))))

  (exists (?x ?y) (wumpus (cell ?x ?y)))

  (shiney (cell 1 3))
  (not (stench (cell 1 3)))
  (stench (cell 4 2))
  (not (shiney (cell 4 2)))
"))(POS (EXAMPLE.INSTANCE WUMPUSDISJUNCTIVE))(POS (PRETTYNAME WUMPUSDISJUNCTIVE "Disjunctive Wumpus World"))(POS (SHORTNAME WUMPUSDISJUNCTIVE "wumpus.disj"))(POS (EXAMPLE.COMPLETE WUMPUSDISJUNCTIVE INCOMPLETE))(POS (EXAMPLE.TECHNIQUE WUMPUSDISJUNCTIVE BILEVEL))(POS (EXAMPLE.TECHNIQUE WUMPUSDISJUNCTIVE CONSISTENCY2DEDUCTION))(POS (EXAMPLE.TECHNIQUE WUMPUSDISJUNCTIVE NAF))(POS (EXAMPLE.TECHNIQUE WUMPUSDISJUNCTIVE UNNAMED))(POS (EXAMPLE.DESCRIPTION WUMPUSDISJUNCTIVE "In this snapshot version of wumpus world, at each step of the game, we write down what the percepts we have received mean.  For example, if we sense a stench then we write down that the wumpus is in one of the surrounding squares.  This incomplete theory is built on top of incomplete and, more to the point, disjunctive base tables.  The reformulation must then take into account that those base tables must be completed each time new info is added.  The way we complete the tables is to introduce new object constants into the language, that is at least what we would have done had we used object constants to name each cell instead of functional terms.  This example illustrates the need to change the universe of discourse."))(POS (MATRIXSHOW WUMPUSDISJUNCTIVE TRUE))(POS (EXAMPLE.COMMENTS WUMPUSDISJUNCTIVE "This example definitely illustrates the issues of starting with DISJUNCTIVE base tables can produce.  One way to deal with that is to increase the size of the universe, as indicated in the description.  Another way is to add functional terms, as is done in the actual example below.

The only reason this example might be problematic for Otter/Vampire is that the query is a universal statement, and we have a DCA to worry about."))(POS (EXAMPLE.SOURCEQUERY WUMPUSDISJUNCTIVE "(=> (gold ?x) (wumpus ?y) (westof ?x ?y))"))(POS (EXAMPLE.SOURCE WUMPUSDISJUNCTIVE "  (succ 1 2)
  (succ 2 3)
  (succ 3 4)

  (<=> (westof (cell ?x ?y) (cell ?x2 ?y2))
       (or (succ ?x ?x2)
           (exists ?z (and (succ ?x ?z) (succ ?z ?x2)))
           (exists (?z ?w) (and (succ ?x ?z) (succ ?z ?w) (succ ?w ?x2)))))


  (or (gold (cell 1 4)) (gold (cell 1 2)) (gold (cell 2 2)) (gold (cell 2 3)) (gold (cell 2 4)))
  (not (wumpus (cell 1 4)))
  (not (wumpus (cell 1 2)))
  (not (wumpus (cell 2 2)))
  (not (wumpus (cell 2 3)))
  (not (wumpus (cell 2 4)))

  (or (wumpus (cell 3 1)) (wumpus (cell 3 2)) (wumpus (cell 3 3)) (wumpus (cell 4 1)) (wumpus (cell 4 3)))
  (not (gold (cell 3 1)))
  (not (gold (cell 3 2)))
  (not (gold (cell 3 3)))
  (not (gold (cell 4 1)))
  (not (gold (cell 4 3)))
"))(POS (EXAMPLE.TARGETQUERY WUMPUSDISJUNCTIVE "ent"))(POS (EXAMPLE.TARGET WUMPUSDISJUNCTIVE " (<= ent
      (not notent))
  (<= notent
      (possgold ?x)
      (posswumpus ?y)
      (not (westof ?x ?y)))
      
  (<= (possgold ?x)
      (gold ?y)
      (part ?y ?x)
      (not (ngold ?x))
      (not (some-goldnotin ?x)))

  (<= (some-goldnotin ?x)
      (gold ?y)
      (not (part ?y ?x)))

  (<= (posswumpus ?x)
      (wumpus ?y)
      (part ?y ?x)
      (not (nwumpus ?x))
      (not (some-wumpusnotin ?x)))
  
  (<= (some-wumpusnotin ?x)
      (wumpus ?y)
      (not (part ?y ?x)))

  (<= (part (listof ?x @y) ?x))
  (<= (part (listof ?z @y) ?x)
      (part (listof @y) ?x))

  (adj 1 2)
  (adj 2 3)
  (adj 3 4)

  (<= (west (cell ?x ?y) (cell ?x2 ?w))
      (adj ?x ?x2))

  (<= (westof ?x ?y)
      (or (west ?x ?y)
          (and (west ?x ?z) (west ?z ?y))
          (and (west ?x ?z) (west ?z ?w) (west ?w ?y))))

  (gold (listof (cell 1 4) (cell 1 2) (cell 2 2) (cell 2 3) (cell 2 4)))
  (ngold (cell 3 1))
  (ngold (cell 3 2))
  (ngold (cell 3 3))
  (ngold (cell 4 1))
  (ngold (cell 4 3))

  (wumpus (listof (cell 3 1) (cell 3 2) (cell 3 3) (cell 4 1) (cell 4 3)))
  (nwumpus (cell 1 4))
  (nwumpus (cell 1 2))
  (nwumpus (cell 2 2))
  (nwumpus (cell 2 3))
  (nwumpus (cell 2 4))
"))(NEG (EXAMPLE.DESCRIPTION WUMPUSDISJUNCTIVE "In this snapshot version of wumpus world, at each step of the game, we write down what the percepts we have received mean.  For example, if we sense a stench then we write down that the wumpus is in one of the surrounding squares.  This incomplete theory is built on top of incomplete and, more to the point, disjunctive base tables.  The reformulation must then take into account that those base tables must be completed each time new info is added.  The way we complete the tables is to introduce new object constants into the language, that is at least what we would have done had we used object constants to name each cell instead of functional terms.  This example illustrates the need to change the universe of discourse."))(POS (EXAMPLE.DESCRIPTION WUMPUSDISJUNCTIVE "In this snapshot version of wumpus world, at each step of the game, we write down what the percepts we have received mean.  For example, if we sense a stench then we write down that the wumpus is in one of the surrounding squares.  This incomplete theory is built on top of incomplete and, more to the point, disjunctive base tables.  The reformulation must then take into account that those base tables must be completed each time new info is added.  The way we complete the tables is to introduce new object constants into the language.  This example illustrates the problem of disjunctive base tables and a solution: the introduction of new object constants."))(NEG (EXAMPLE.COMMENTS WUMPUSDISJUNCTIVE "This example definitely illustrates the issues of starting with DISJUNCTIVE base tables can produce.  One way to deal with that is to increase the size of the universe, as indicated in the description.  Another way is to add functional terms, as is done in the actual example below.

The only reason this example might be problematic for Otter/Vampire is that the query is a universal statement, and we have a DCA to worry about."))(POS (EXAMPLE.COMMENTS WUMPUSDISJUNCTIVE "The only reason this example might be problematic for Otter/Vampire is that the query is a universal statement, and we have a DCA to worry about.

Add UNA/DCA to the source."))(NEG (EXAMPLE.SOURCEQUERY WUMPUSDISJUNCTIVE "(=> (gold ?x) (wumpus ?y) (westof ?x ?y))"))(POS (EXAMPLE.SOURCEQUERY WUMPUSDISJUNCTIVE "(forall (?x ?y) (=> (gold ?x) (wumpus ?y) (westof ?x ?y)))"))(NEG (EXAMPLE.SOURCE WUMPUSDISJUNCTIVE "  (succ 1 2)
  (succ 2 3)
  (succ 3 4)

  (<=> (westof (cell ?x ?y) (cell ?x2 ?y2))
       (or (succ ?x ?x2)
           (exists ?z (and (succ ?x ?z) (succ ?z ?x2)))
           (exists (?z ?w) (and (succ ?x ?z) (succ ?z ?w) (succ ?w ?x2)))))


  (or (gold (cell 1 4)) (gold (cell 1 2)) (gold (cell 2 2)) (gold (cell 2 3)) (gold (cell 2 4)))
  (not (wumpus (cell 1 4)))
  (not (wumpus (cell 1 2)))
  (not (wumpus (cell 2 2)))
  (not (wumpus (cell 2 3)))
  (not (wumpus (cell 2 4)))

  (or (wumpus (cell 3 1)) (wumpus (cell 3 2)) (wumpus (cell 3 3)) (wumpus (cell 4 1)) (wumpus (cell 4 3)))
  (not (gold (cell 3 1)))
  (not (gold (cell 3 2)))
  (not (gold (cell 3 3)))
  (not (gold (cell 4 1)))
  (not (gold (cell 4 3)))
"))(POS (EXAMPLE.SOURCE WUMPUSDISJUNCTIVE "  (or (gold a) (gold i) (gold b) (gold f) (gold j))
  (not (wumpus a))
  (not (wumpus i))
  (not (wumpus b))
  (not (wumpus f))
  (not (wumpus j))

  (or (wumpus g) (wumpus k) (wumpus o) (wumpus h) (wumpus p))
  (not (gold g))
  (not (gold k))
  (not (gold o))
  (not (gold h))
  (not (gold p))

(westof A B)
(westof A F)
(westof A J)
(westof A N)
(westof A C)
(westof A G)
(westof A K)
(westof A O)
(westof A D)
(westof A H)
(westof A L)
(westof A P)
(westof E B)
(westof E F)
(westof E J)
(westof E N)
(westof E C)
(westof E G)
(westof E K)
(westof E O)
(westof E D)
(westof E H)
(westof E L)
(westof E P)
(westof I B)
(westof I F)
(westof I J)
(westof I N)
(westof I C)
(westof I G)
(westof I K)
(westof I O)
(westof I D)
(westof I H)
(westof I L)
(westof I P)
(westof M B)
(westof M F)
(westof M J)
(westof M N)
(westof M C)
(westof M G)
(westof M K)
(westof M O)
(westof M D)
(westof M H)
(westof M L)
(westof M P)
(westof B C)
(westof B G)
(westof B K)
(westof B O)
(westof B D)
(westof B H)
(westof B L)
(westof B P)
(westof F C)
(westof F G)
(westof F K)
(westof F O)
(westof F D)
(westof F H)
(westof F L)
(westof F P)
(westof J C)
(westof J G)
(westof J K)
(westof J O)
(westof J D)
(westof J H)
(westof J L)
(westof J P)
(westof N C)
(westof N G)
(westof N K)
(westof N O)
(westof N D)
(westof N H)
(westof N L)
(westof N P)
(westof C D)
(westof C H)
(westof C L)
(westof C P)
(westof G D)
(westof G H)
(westof G L)
(westof G P)
(westof K D)
(westof K H)
(westof K L)
(westof K P)
(westof O D)
(westof O H)
(westof O L)
(westof O P)"))(NEG (EXAMPLE.TARGET WUMPUSDISJUNCTIVE " (<= ent
      (not notent))
  (<= notent
      (possgold ?x)
      (posswumpus ?y)
      (not (westof ?x ?y)))
      
  (<= (possgold ?x)
      (gold ?y)
      (part ?y ?x)
      (not (ngold ?x))
      (not (some-goldnotin ?x)))

  (<= (some-goldnotin ?x)
      (gold ?y)
      (not (part ?y ?x)))

  (<= (posswumpus ?x)
      (wumpus ?y)
      (part ?y ?x)
      (not (nwumpus ?x))
      (not (some-wumpusnotin ?x)))
  
  (<= (some-wumpusnotin ?x)
      (wumpus ?y)
      (not (part ?y ?x)))

  (<= (part (listof ?x @y) ?x))
  (<= (part (listof ?z @y) ?x)
      (part (listof @y) ?x))

  (adj 1 2)
  (adj 2 3)
  (adj 3 4)

  (<= (west (cell ?x ?y) (cell ?x2 ?w))
      (adj ?x ?x2))

  (<= (westof ?x ?y)
      (or (west ?x ?y)
          (and (west ?x ?z) (west ?z ?y))
          (and (west ?x ?z) (west ?z ?w) (west ?w ?y))))

  (gold (listof (cell 1 4) (cell 1 2) (cell 2 2) (cell 2 3) (cell 2 4)))
  (ngold (cell 3 1))
  (ngold (cell 3 2))
  (ngold (cell 3 3))
  (ngold (cell 4 1))
  (ngold (cell 4 3))

  (wumpus (listof (cell 3 1) (cell 3 2) (cell 3 3) (cell 4 1) (cell 4 3)))
  (nwumpus (cell 1 4))
  (nwumpus (cell 1 2))
  (nwumpus (cell 2 2))
  (nwumpus (cell 2 3))
  (nwumpus (cell 2 4))
"))(POS (EXAMPLE.TARGET WUMPUSDISJUNCTIVE "  (<= ent
      (not notent))
  (<= notent
      (possgold ?x)
      (posswumpus ?y)
      (not (westof ?x ?y)))
      
  (<= (possgold ?x)
      (gold ?y)
      (part ?y ?x)
      (not (ngold ?x))
      (not (some-goldnotin ?x)))

  (<= (some-goldnotin ?x)
      (gold ?y)
      (not (part ?y ?x)))

  (<= (posswumpus ?x)
      (wumpus ?y)
      (part ?y ?x)
      (not (nwumpus ?x))
      (not (some-wumpusnotin ?x)))
  
  (<= (some-wumpusnotin ?x)
      (wumpus ?y)
      (not (part ?y ?x)))

  (gold aibfj)
  (ngold g)
  (ngold k)
  (ngold o)
  (ngold h)
  (ngold p)

  (wumpus gkohp)
  (nwumpus a)
  (nwumpus i)
  (nwumpus b)
  (nwumpus f)
  (nwumpus j)

  (part aibfj a)
  (part aibfj i)
  (part aibfj b)
  (part aibfj f)
  (part aibfj j)

  (part gkohp g)
  (part gkohp k)
  (part gkohp o)
  (part gkohp h)
  (part gkohp p)

(westof A B)
(westof A F)
(westof A J)
(westof A N)
(westof A C)
(westof A G)
(westof A K)
(westof A O)
(westof A D)
(westof A H)
(westof A L)
(westof A P)
(westof E B)
(westof E F)
(westof E J)
(westof E N)
(westof E C)
(westof E G)
(westof E K)
(westof E O)
(westof E D)
(westof E H)
(westof E L)
(westof E P)
(westof I B)
(westof I F)
(westof I J)
(westof I N)
(westof I C)
(westof I G)
(westof I K)
(westof I O)
(westof I D)
(westof I H)
(westof I L)
(westof I P)
(westof M B)
(westof M F)
(westof M J)
(westof M N)
(westof M C)
(westof M G)
(westof M K)
(westof M O)
(westof M D)
(westof M H)
(westof M L)
(westof M P)
(westof B C)
(westof B G)
(westof B K)
(westof B O)
(westof B D)
(westof B H)
(westof B L)
(westof B P)
(westof F C)
(westof F G)
(westof F K)
(westof F O)
(westof F D)
(westof F H)
(westof F L)
(westof F P)
(westof J C)
(westof J G)
(westof J K)
(westof J O)
(westof J D)
(westof J H)
(westof J L)
(westof J P)
(westof N C)
(westof N G)
(westof N K)
(westof N O)
(westof N D)
(westof N H)
(westof N L)
(westof N P)
(westof C D)
(westof C H)
(westof C L)
(westof C P)
(westof G D)
(westof G H)
(westof G L)
(westof G P)
(westof K D)
(westof K H)
(westof K L)
(westof K P)
(westof O D)
(westof O H)
(westof O L)
(westof O P)
"))(NEG (EXAMPLE.COMMENTS WUMPUSPERCEPTS "Here I'm using some functions in the source, simply because the problem was easier to write down this way.  It may also be a case that demonstrates that sometimes we can deal with functions.  I'm conflating this with completing the tables stench and shine, but I couldn't bring myself to write it without functions."))(POS (EXAMPLE.COMMENTS WUMPUSPERCEPTS "There is a version using functions to name cells.  Add UNA and DCA to the source."))(NEG (EXAMPLE.SOURCEQUERY WUMPUSPERCEPTS "      (=> (gold ?x) (wumpus ?y) (westof ?x ?y))
"))(POS (EXAMPLE.SOURCEQUERY WUMPUSPERCEPTS "     (forall (?x ?y) (=> (gold ?x) (wumpus ?y) (westof ?x ?y)))
"))(NEG (EXAMPLE.SOURCE WUMPUSPERCEPTS "
  (succ 1 2)
  (succ 2 3)
  (succ 3 4)

  (<=> (next ?x ?y)
       (or (succ ?x ?y)
           (succ ?y ?x)))

  (<=> (west (cell ?x ?y) (cell ?x2 ?y))
       (succ ?x2 ?x))
  (<=> (north (cell ?x ?y) (cell ?x ?y2))
       (succ ?y2 ?y))
  
  (<=> (east ?x ?y) (west ?y ?x))
  (<=> (south ?x ?y) (north ?y ?x))

  (<=> (westof (cell ?x ?y) (cell ?x2 ?y2))
       (or (succ ?x ?x2)
           (exists ?z (and (succ ?x ?z) (succ ?z ?x2)))
           (exists (?z ?w) (and (succ ?x ?z) (succ ?z ?w) (succ ?w ?x2)))))

  (<=> (westborder (cell 1 ?x))
       (not (= ?x 1))
       (not (= ?x 4)))

  (<=> (eastborder (cell 4 ?x))
       (not (= ?x 1))
       (not (= ?x 4)))

  (<=> (southborder (cell ?x 1))
       (not (= ?x 1))
       (not (= ?x 4)))

  (<=> (northborder (cell ?x 4))
       (not (= ?x 1))
       (not (= ?x 4)))

  (nwcorner (cell 1 4))
  (necorner (cell 4 4))
  (swcorner (cell 1 1))
  (secorner (cell 4 1))
  
  (<=> (notborder (cell ?x ?y))
       (and (not (= ?x 1))
            (not (= ?x 4))
            (not (= ?y 1))
            (not (= ?y 4))))

  ; center
  (=> (stench ?cell)
      (notborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?celle)
          (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (notborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))
           (not (wumpus ?cellw))
           (not (wumpus ?cells))))

  ;;; borders

  ;west
  (=> (stench ?cell)
      (westborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (or (wumpus ?celln)
          (wumpus ?celle)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (westborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))
           (not (wumpus ?cells))))


  ; north
  (=> (stench ?cell)
      (northborder ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (or (wumpus ?celle)
          (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (northborder ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (and (not (wumpus ?celle))
           (not (wumpus ?cellw))
           (not (wumpus ?cells))))

      
  ; south
  (=> (stench ?cell)
      (southborder ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?celle)
          (wumpus ?cellw)))

  (=> (not (stench ?cell))
      (southborder ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))
           (not (wumpus ?cellw))))

  ; east
  (=> (stench ?cell)
      (eastborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (eastborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?cellw))
           (not (wumpus ?cells))))

  ;;; corners

  ; nw
  (=> (stench ?cell)
      (nwcorner ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (or (wumpus ?celle)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (nwcorner ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (and (not (wumpus ?celle))
           (not (wumpus ?cells))))

  ; ne
  (=> (stench ?cell)
      (necorner ?cell)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (or (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (necorner ?cell)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (and (not (wumpus ?cellw))
           (not (wumpus ?cells))))

  ; sw
  (=> (stench ?cell)
      (wwcorner ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (or (wumpus ?celln)
          (wumpus ?celle)))

  (=> (not (stench ?cell))
      (wwcorner ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))))

  ; se
  (=> (stench ?cell)
      (secorner ?cell)
      (north ?cell ?celln)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?cellw)))

  (=> (not (stench ?cell))
      (secorner ?cell)
      (north ?cell ?celln)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?cellw))))

  (exists (?x ?y) (wumpus (cell ?x ?y)))

  (shiney (cell 1 3))
  (not (stench (cell 1 3)))
  (stench (cell 4 2))
  (not (shiney (cell 4 2)))
"))(POS (EXAMPLE.SOURCE WUMPUSPERCEPTS "  ; complete tables
  (north a e)
  (north e i)
  (north i m)
  (north b f)
  (north f j)
  (north j n)
  (north c g)
  (north g k)
  (north k o)
  (north d h)
  (north h l)
  (north l p)

  (west a b)
  (west b c)
  (west c d)
  (west e f)
  (west f g)
  (west g h)
  (west i j)
  (west j k)
  (west k l)
  (west m n)
  (west n o)
  (west o p)
  
  (<=> (east ?x ?y) (west ?y ?x))
  (<=> (south ?x ?y) (north ?y ?x))

  ; more complete tables
  (westborder e)
  (westborder i)
  (northborder b)
  (northborder c)
  (eastborder h)
  (eastborder l)
  (southborder n)
  (southborder o)

  (nwcorner a)
  (necorner d)
  (swcorner m)
  (swcorner p)

  (notborder f)
  (notborder g)
  (notborder j)
  (notborder k)
  
  ; center
  (=> (stench ?cell)
      (notborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?celle)
          (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (notborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))
           (not (wumpus ?cellw))
           (not (wumpus ?cells))))

  ;;; borders

  ;west
  (=> (stench ?cell)
      (westborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (or (wumpus ?celln)
          (wumpus ?celle)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (westborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))
           (not (wumpus ?cells))))


  ; north
  (=> (stench ?cell)
      (northborder ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (or (wumpus ?celle)
          (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (northborder ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (and (not (wumpus ?celle))
           (not (wumpus ?cellw))
           (not (wumpus ?cells))))

      
  ; south
  (=> (stench ?cell)
      (southborder ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?celle)
          (wumpus ?cellw)))

  (=> (not (stench ?cell))
      (southborder ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))
           (not (wumpus ?cellw))))

  ; east
  (=> (stench ?cell)
      (eastborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (eastborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?cellw))
           (not (wumpus ?cells))))

  ;;; corners

  ; nw
  (=> (stench ?cell)
      (nwcorner ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (or (wumpus ?celle)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (nwcorner ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (and (not (wumpus ?celle))
           (not (wumpus ?cells))))

  ; ne
  (=> (stench ?cell)
      (necorner ?cell)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (or (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (necorner ?cell)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (and (not (wumpus ?cellw))
           (not (wumpus ?cells))))

  ; sw
  (=> (stench ?cell)
      (wwcorner ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (or (wumpus ?celln)
          (wumpus ?celle)))

  (=> (not (stench ?cell))
      (wwcorner ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))))

  ; se
  (=> (stench ?cell)
      (secorner ?cell)
      (north ?cell ?celln)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?cellw)))

  (=> (not (stench ?cell))
      (secorner ?cell)
      (north ?cell ?celln)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?cellw))))


  (exists ?x (wumpus ?x))
  (exists ?x (gold ?x))

  (shiney e)
  (not (stench e))
  (stench l)
  (not (shiney l))



; a complete table
(westof A B)
(westof A F)
(westof A J)
(westof A N)
(westof A C)
(westof A G)
(westof A K)
(westof A O)
(westof A D)
(westof A H)
(westof A L)
(westof A P)
(westof E B)
(westof E F)
(westof E J)
(westof E N)
(westof E C)
(westof E G)
(westof E K)
(westof E O)
(westof E D)
(westof E H)
(westof E L)
(westof E P)
(westof I B)
(westof I F)
(westof I J)
(westof I N)
(westof I C)
(westof I G)
(westof I K)
(westof I O)
(westof I D)
(westof I H)
(westof I L)
(westof I P)
(westof M B)
(westof M F)
(westof M J)
(westof M N)
(westof M C)
(westof M G)
(westof M K)
(westof M O)
(westof M D)
(westof M H)
(westof M L)
(westof M P)
(westof B C)
(westof B G)
(westof B K)
(westof B O)
(westof B D)
(westof B H)
(westof B L)
(westof B P)
(westof F C)
(westof F G)
(westof F K)
(westof F O)
(westof F D)
(westof F H)
(westof F L)
(westof F P)
(westof J C)
(westof J G)
(westof J K)
(westof J O)
(westof J D)
(westof J H)
(westof J L)
(westof J P)
(westof N C)
(westof N G)
(westof N K)
(westof N O)
(westof N D)
(westof N H)
(westof N L)
(westof N P)
(westof C D)
(westof C H)
(westof C L)
(westof C P)
(westof G D)
(westof G H)
(westof G L)
(westof G P)
(westof K D)
(westof K H)
(westof K L)
(westof K P)
(westof O D)
(westof O H)
(westof O L)
(westof O P)
"))(NEG (EXAMPLE.TARGET WUMPUSPERCEPTS "  (<= ent
      (not notent))
  (<= notent
      (possworld ?x ?y)
      (not (westof ?x ?y)))

  (<= (westof ?x ?y)
      (or (west ?x ?y)
          (and (west ?x ?z) (west ?z ?y))
          (and (west ?x ?z) (west ?z ?w) (west ?w ?y))))

  (<= (possworld ?x ?y)
      (possgold ?x)
      (posswumpus ?y))

  ; poss gold
  (<= (possgold ?x)
      (adjacentshiney ?x)
      (not (some-adjacentnonshiney ?x))
      (not (some-nonadjacentshiney ?x)))

  (<= (adjacentshiney ?x)
      (shiney ?s)
      (adjacent ?s ?x))

  (<= (some-nonadjacentshiney ?x)
      (shiney ?s)
      (not (adjacent ?s ?x)))

  (<= (some-adjacentnonshiney ?x)
      (adjacent ?x ?y)
      (nshiney ?y))

  ; poss wumpus
  (<= (posswumpus ?x)
      (adjacentstench ?x)
      (not (some-adjacentnonstench ?x))
      (not (some-nonadjacentstench ?x)))

  (<= (adjacentstench ?x)
      (stench ?s)
      (adjacent ?s ?x))

  (<= (some-nonadjacentstench ?x)
      (stench ?s)
      (not (adjacent ?s ?x)))

  (<= (some-adjacentnonstench ?x)
      (adjacent ?x ?y)
      (nstench ?y))
      

  (adj 1 2)
  (adj 2 3)
  (adj 3 4)
  (<= (next ?x ?y)
      (or (adj ?x ?y) (adj ?y ?x)))
  
  (<= (adjacent (cell ?x ?y) (cell ?z ?y))
      (next ?x ?z))

  (<= (adjacent (cell ?x ?y) (cell ?x ?w))
      (next ?y ?w))

  (<= (adjacent (cell ?x ?y) (cell ?z ?w))
      (next ?x ?z)
      (next ?y ?w))

  (<= (west (cell ?x ?y) (cell ?x2 ?w))
      (adj ?x ?x2))

  (shiney (cell 1 3))
  (nstench (cell 1 3))
  (stench (cell 4 2))
  (nshiney (cell 4 2))"))(POS (EXAMPLE.TARGET WUMPUSPERCEPTS "  (<= ent
      (not notent))
  (<= notent
      (possworld ?x ?y)
      (not (westof ?x ?y)))


  (<= (possworld ?x ?y)
      (possgold ?x)
      (posswumpus ?y))

  ; poss gold
  (<= (possgold ?x)
      (adjacentshiney ?x)
      (not (some-adjacentnonshiney ?x))
      (not (some-nonadjacentshiney ?x)))

  (<= (adjacentshiney ?x)
      (shiney ?s)
      (adjacent ?s ?x))

  (<= (some-nonadjacentshiney ?x)
      (shiney ?s)
      (not (adjacent ?s ?x)))

  (<= (some-adjacentnonshiney ?x)
      (adjacent ?x ?y)
      (nshiney ?y))

  ; poss wumpus
  (<= (posswumpus ?x)
      (adjacentstench ?x)
      (not (some-adjacentnonstench ?x))
      (not (some-nonadjacentstench ?x)))

  (<= (adjacentstench ?x)
      (stench ?s)
      (adjacent ?s ?x))

  (<= (some-nonadjacentstench ?x)
      (stench ?s)
      (not (adjacent ?s ?x)))

  (<= (some-adjacentnonstench ?x)
      (adjacent ?x ?y)
      (nstench ?y))
      
#|
 --- --- --- ---
| a | b | c | d |
 --- --- --- ---
| e | f | g | h |
 --- --- --- ---
| i | j | k | l |
 --- --- --- ---
| m | n | o | p |
 --- --- --- ---
Shine: e
Stench: l

|#

  (<= (adjacent ?x ?y)
      (or (north ?x ?y)
          (north ?y ?x)
          (west ?x ?y)
          (west ?y ?x)
          (and (west ?z ?x) (north ?y ?z))
          (and (west ?z ?x) (north ?z ?y))
          (and (west ?x ?z) (north ?y ?z))
          (and (west ?x ?z) (north ?z ?y))))

  (north a e)
  (north e i)
  (north i m)
  (north b f)
  (north f j)
  (north j n)
  (north c g)
  (north g k)
  (north k o)
  (north d h)
  (north h l)
  (north l p)

  (west a b)
  (west b c)
  (west c d)
  (west e f)
  (west f g)
  (west g h)
  (west i j)
  (west j k)
  (west k l)
  (west m n)
  (west n o)
  (west o p)
  
  (<= (east ?x ?y) (west ?y ?x))
  (<= (south ?x ?y) (north ?y ?x))


  (shiney e)
  (nstench e)
  (stench l)
  (nshiney l)

(westof A B)
(westof A F)
(westof A J)
(westof A N)
(westof A C)
(westof A G)
(westof A K)
(westof A O)
(westof A D)
(westof A H)
(westof A L)
(westof A P)
(westof E B)
(westof E F)
(westof E J)
(westof E N)
(westof E C)
(westof E G)
(westof E K)
(westof E O)
(westof E D)
(westof E H)
(westof E L)
(westof E P)
(westof I B)
(westof I F)
(westof I J)
(westof I N)
(westof I C)
(westof I G)
(westof I K)
(westof I O)
(westof I D)
(westof I H)
(westof I L)
(westof I P)
(westof M B)
(westof M F)
(westof M J)
(westof M N)
(westof M C)
(westof M G)
(westof M K)
(westof M O)
(westof M D)
(westof M H)
(westof M L)
(westof M P)
(westof B C)
(westof B G)
(westof B K)
(westof B O)
(westof B D)
(westof B H)
(westof B L)
(westof B P)
(westof F C)
(westof F G)
(westof F K)
(westof F O)
(westof F D)
(westof F H)
(westof F L)
(westof F P)
(westof J C)
(westof J G)
(westof J K)
(westof J O)
(westof J D)
(westof J H)
(westof J L)
(westof J P)
(westof N C)
(westof N G)
(westof N K)
(westof N O)
(westof N D)
(westof N H)
(westof N L)
(westof N P)
(westof C D)
(westof C H)
(westof C L)
(westof C P)
(westof G D)
(westof G H)
(westof G L)
(westof G P)
(westof K D)
(westof K H)
(westof K L)
(westof K P)
(westof O D)
(westof O H)
(westof O L)
(westof O P)"))(POS (LANGUAGE.INSTANCE IKIF))(POS (LANGUAGE.INSTANCE KIF))(POS (LANGUAGE.INSTANCE XML))(POS (TECHNIQUE.INSTANCE CONSISTENCY2DEDUCTION))(POS (TECHNIQUE.DESCRIPTION CONSISTENCY2DEDUCTION "Consistency2Deduction[Delta,phi(xbar)] computes an expression that represents for all the query instances tbar such that Delta U {phi(tbar)} is consistent."))(POS (TECHNIQUE.INSTANCE REIFICATION))(POS (TECHNIQUE.DESCRIPTION REIFICATION "Reification is an umbrella technique that encompasses all kinds of vocabulary and conceptualization shifts."))(POS (TECHNIQUE.INSTANCE UNNAMED))(POS (TECHNIQUE.DESCRIPTION UNNAMED "Encompasses all unnamed techniques."))(POS (TECHNIQUE.INSTANCE RELATIONALIZING))(POS (TECHNIQUE.DESCRIPTION RELATIONALIZING "Form of reification where object/function constants are turned into relation constants."))(POS (TECHNIQUE.INSTANCE OBJECTIFYING))(POS (TECHNIQUE.DESCRIPTION OBJECTIFYING "Form of reification where relation constants become function or object constants."))(POS (TECHNIQUE.INSTANCE GENERATEOVERGUESS))(POS (TECHNIQUE.DESCRIPTION GENERATEOVERGUESS "Technique that changes a guess-and-check problem formulation reformulation into a formulation that generates the answer constructively."))(POS (TECHNIQUE.INSTANCE DATAEXTRACTION))(POS (TECHNIQUE.DESCRIPTION DATAEXTRACTION "Pulls data out of a rule or set of rules, places that data into tables, and appropriately adjusts the rule so that semantically the original and the new versions are identical.  Inverse of dataInfusion."))(POS (TECHNIQUE.INSTANCE DATAINFUSION))(POS (TECHNIQUE.DESCRIPTION DATAINFUSION "Pushes data from a table into rules, a special form of partial deduction from the logic programming literature.  Inverse of dataExtraction."))(POS (TECHNIQUE.INSTANCE CHIRKOVAREFORMULATION))(POS (TECHNIQUE.DESCRIPTION CHIRKOVAREFORMULATION "Computes the optimal viewset for transforming an unknown (but fixed-size) database into a new database that more efficiently answers a given query set."))(POS (PERSON.INSTANCE NATLOVE))(POS (PERSON.FIRSTNAME NATLOVE "Nat"))(POS (PERSON.LASTNAME NATLOVE "Love"))(POS (PERSON.TEAM NATLOVE NATLOVE))(POS (PERSON.EMAIL NATLOVE "natlove@stanford.edu"))(POS (PERSON.INSTANCE JDUCHI))(POS (PERSON.FIRSTNAME JDUCHI "John"))(POS (PERSON.LASTNAME JDUCHI "Duchi"))(POS (PERSON.TEAM JDUCHI JDUCHI))(POS (PERSON.EMAIL JDUCHI "jduchi@stanford.edu"))(POS (PERSON.INSTANCE DTARLOW))(POS (PERSON.FIRSTNAME DTARLOW "Danny"))(POS (PERSON.LASTNAME DTARLOW "Tarlow"))(POS (PERSON.TEAM DTARLOW DTARLOW))(POS (PERSON.EMAIL DTARLOW "dtarlow@stanford.edu"))(POS (PERSON.INSTANCE THINRICH))(POS (PERSON.FIRSTNAME THINRICH "Tim"))(POS (PERSON.LASTNAME THINRICH "Hinrichs"))(POS (PERSON.TEAM THINRICH THINRICH))(POS (PERSON.EMAIL THINRICH "thinrich@stanford.edu"))(POS (PAPER.INSTANCE ABITEBOUL))(POS (PAPER.BIBTEX ABITEBOUL BOOK))(POS (PAPER.AUTHOR ABITEBOUL "Serge Abiteboul and Richard Hull and Victor Vianu"))(POS (PAPER.TITLE ABITEBOUL "Foundations of Databases"))(POS (PAPER.PUBLISHER ABITEBOUL "Addison-Wesley Publishing Company"))(POS (PAPER.LINK ABITEBOUL "http://www.amazon.com/Foundations-Databases-Logical-Serge-Abiteboul/dp/0201537710"))(POS (PAPER.YEAR ABITEBOUL 1995))(POS (PAPER.DESCRIPTION ABITEBOUL "
The definitive guide for comparing various database query languages.
"))(POS (PAPER.TOPIC ABITEBOUL ""))(POS (PAPER.INSTANCE AGRAWAL2000))(POS (PAPER.BIBTEX AGRAWAL2000 INPROCEEDINGS))(POS (PAPER.AUTHOR AGRAWAL2000 "Agrawal and Chaudrhuri and Narasavya"))(POS (PAPER.TITLE AGRAWAL2000 "Automatic selection of materialized views and indexes in Microsoft SQL Server"))(POS (PAPER.PUBLICATION AGRAWAL2000 "In proceedings of Very Large Databases (VLDB)"))(POS (PAPER.STARTPAGE AGRAWAL2000 496))(POS (PAPER.ENDPAGE AGRAWAL2000 505))(POS (PAPER.YEAR AGRAWAL2000 2000))(POS (PAPER.DESCRIPTION AGRAWAL2000 "
Another paper on view selection problem in databases.
"))(POS (PAPER.TOPIC AGRAWAL2000 "Databases"))(POS (PAPER.INSTANCE AIELLO80))(POS (PAPER.BIBTEX AIELLO80 INPROCEEDINGS))(POS (PAPER.AUTHOR AIELLO80 "Luigia Aiello"))(POS (PAPER.TITLE AIELLO80 "Automatic Generation of Semantic Attachments in FOL"))(POS (PAPER.PUBLICATION AIELLO80 "AAAI"))(POS (PAPER.YEAR AIELLO80 1980))(POS (PAPER.RANK AIELLO80 "[**]"))(POS (PAPER.DESCRIPTION AIELLO80 "
Aiello describes a process of generating new semantic attachments from old
ones by compiling FOL into Lisp.
"))(POS (PAPER.TOPIC AIELLO80 "Theorem Proving with Attachments"))(POS (PAPER.INSTANCE ALFERES94))(POS (PAPER.AUTHOR ALFERES94 "J.J. Alferes, R. Li and L.M. Pereira"))(POS (PAPER.TITLE ALFERES94 "Concurrent Actions and Changes in the Situation Calculus"))(POS (PAPER.PUBLICATION ALFERES94 "Proceedings of IBERAMIA 94"))(POS (PAPER.STARTPAGE ALFERES94 93))(POS (PAPER.ENDPAGE ALFERES94 104))(POS (PAPER.LINK ALFERES94 "http://centria.fct.unl.pt/~lmp/publications/Biblio.html"))(POS (PAPER.YEAR ALFERES94 1994))(POS (PAPER.DESCRIPTION ALFERES94 "
Alferes shows that Situation Calculus extended with concurrent actions (e.g. buytoothpaste||buyshampoo) is no more expressive than standard Situation Calculus.  Intuitively, give names to every subset of actions since there are only 2^n such subsets of n actions.  Use those names as the actions in situation calculus.  The trouble here is how do we produce the effect axioms of a concurrent action set given the effect axioms of the individual actions?  Some of these axioms simply must be given by the user, e.g. buying toothpaste and shampoo at the same time might result in a free bar of soap, though neither effect axiom for buying toothpaste or shampoo would mention soap.  For those actions whose composition (in Alferes terms) can be determined automatically, the authors offer a solution using nonmonotonic logic: if Holds(p, Result(a, Result(b,s))) and Holds(p, Result(b, Result(a,s))) and there is no definition for Holds(p, Result(a||b),s), then conclude Holds(p, Result(a||b,s)).  Alferes elaborates the rule to include preconditions and subsets of size other than 2 (though some technical details arise in doing the latter).
"))(POS (PAPER.TOPIC ALFERES94 "Fundamentals"))(POS (PAPER.INSTANCE ALLEN90))(POS (PAPER.AUTHOR ALLEN90 "J. Allen, J. Hendler and A. Tate"))(POS (PAPER.TITLE ALLEN90 "Readings in Planning"))(POS (PAPER.LINK ALLEN90 "http://www.amazon.com/exec/obidos/ASIN/1558601309/qid%3D954347291/sr%3D1-13/002-1714614-2412067"))(POS (PAPER.YEAR ALLEN90 1990))(POS (PAPER.DESCRIPTION ALLEN90 "
Survey book on planning through 1990.
"))(POS (PAPER.TOPIC ALLEN90 "Historical"))(POS (PAPER.INSTANCE ALLWEIN96))(POS (PAPER.BIBTEX ALLWEIN96 BOOK))(POS (PAPER.AUTHOR ALLWEIN96 "Gerard Allwein and Jon Barwise"))(POS (PAPER.TITLE ALLWEIN96 "Logical Reasoning with Diagrams"))(POS (PAPER.PUBLISHER ALLWEIN96 "Oxford University Press"))(POS (PAPER.LINK ALLWEIN96 "http://www.amazon.com/exec/obidos/tg/detail/-/0195104277/104-6992918-7685512?vi=glance"))(POS (PAPER.YEAR ALLWEIN96 1996))(POS (PAPER.RANK ALLWEIN96 "[***]"))(POS (PAPER.DESCRIPTION ALLWEIN96 "
This book advocates the appropriate use of diagrams in formal, rigorous
proofs.  It formalizes the notions of entailment from a diagram and 
adjustments to a diagram.  The formalization is pretty complex, but
it is not obvious how to simplify it.  The book also looks at various
logics that can incorporate diagramatic methods.  The last two sections
are non-theoretical: a series of case studies and a series of heterogeneous
systems.  The bibiliography looks helpful.
"))(POS (PAPER.TOPIC ALLWEIN96 "Graphical Reasoning Techniques"))(POS (PAPER.INSTANCE ALSAC2002))(POS (PAPER.AUTHOR ALSAC2002 "Guray Alsac and Chitta Baral "))(POS (PAPER.TITLE ALSAC2002 "Reasoning in description logics using declarative logic programming"))(POS (PAPER.LINK ALSAC2002 "http://citeseer.ist.psu.edu/context/2398354/0"))(POS (PAPER.YEAR ALSAC2002 2002))(POS (PAPER.DESCRIPTION ALSAC2002 "
The authors discuss a nontrivial translation of a particular 
description logic into logic programming.
"))(POS (PAPER.TOPIC ALSAC2002 "Logic Programming"))(POS (PAPER.INSTANCE AMIR2001))(POS (PAPER.BIBTEX AMIR2001 PHDTHESIS))(POS (PAPER.AUTHOR AMIR2001 "Eyal Amir"))(POS (PAPER.TITLE AMIR2001 "Dividing and Conquering Logic"))(POS (PAPER.PUBLISHER AMIR2001 "Stanford University"))(POS (PAPER.LINK AMIR2001 ""))(POS (PAPER.YEAR AMIR2001 2001))(POS (PAPER.DESCRIPTION AMIR2001 "
Amir's thesis considers several problems related to the construction and
reasoning about large knowledge bases.  First he discusses object-oriented
first-order logic, a synthesis of the object oriented paradigm and
FOL.  Second he applies this logic to theories of action, most notably
situation calculus.  Third he shows how to parallelize automated
theorem proving where a theory has been partitioned into pieces.  Fourth
he gives algorithms for automatically decomposing theories, based on
the syntactic character of the axioms.  Last he describes a logic-based
subsumption architecture for automated robot control, similar in spirit
to Golog.  An appendix on logic, one on reactive control systems, and
30 pages of references round out the thesis.  It should be noted
that while he does augment various resolution procedures to work
in this parallel setting, the rest of the results are independent of
a particular calculus.
"))(POS (PAPER.TOPIC AMIR2001 "Logical Knowledge Representation"))(POS (PAPER.INSTANCE ARENAS98))(POS (PAPER.AUTHOR ARENAS98 "Marcello Arenas and Leopoldo Bertossi"))(POS (PAPER.TITLE ARENAS98 "Hypothetical Temporal Reasoning with History Encoding"))(POS (PAPER.PUBLICATION ARENAS98 "Knowledge Representation Meets Database"))(POS (PAPER.VOLUME ARENAS98 "4.1-4.8"))(POS (PAPER.LINK ARENAS98 "http://citeseer.ist.psu.edu/529093.html"))(POS (PAPER.YEAR ARENAS98 1998))(POS (PAPER.RANK ARENAS98 "[***]"))(POS (PAPER.DESCRIPTION ARENAS98 "
Arenas and Bertossi build on J. Chomicki's work of progressing a history of a database transaction's effects through the execution of a transaction to save on the costs of doing temporal constraint checking.  They also use Reiter's work on evaluating a query in the state that results after executing a sequence of actions.  The authors meld these two approaches to answer queries about the evolution of a database that contain quantification over states (for two specific types of queries).  This work also leads to a process for transforming dynamic integrity constraints into static ones and transforming history dependent action preconditions into local preconditions. 
"))(POS (PAPER.TOPIC ARENAS98 "Hypothetical Temporal DB Queries"))(POS (PAPER.RELATED ARENAS98 CHOMICKI95))(POS (PAPER.INSTANCE ARENAS98B))(POS (PAPER.AUTHOR ARENAS98B "Marcelo Arenas, Leopoldo Bertossi and Javier Pinto"))(POS (PAPER.TITLE ARENAS98B "Representation of Temporal Knowledge in the Situation Calculus"))(POS (PAPER.LINK ARENAS98B "http://citeseer.ist.psu.edu/527517.html"))(POS (PAPER.YEAR ARENAS98B 1998))(POS (PAPER.RANK ARENAS98B "[***]"))(POS (PAPER.DESCRIPTION ARENAS98B "
This incomplete paper describes translating a first-order modal temporal logic, Metric Time Temporal Logic, into situation calculus in the context of database updates.  The key insight is the creation of new relations that summarize information about the past.  Doing this gives us the power to write non-Markovian axioms (those that depend on a history of states instead of a just the last state).  
"))(POS (PAPER.TOPIC ARENAS98B "Hypothetical Temporal DB Queries"))(POS (PAPER.INSTANCE ARMANDO93))(POS (PAPER.BIBTEX ARMANDO93 ARTICLE))(POS (PAPER.AUTHOR ARMANDO93 "A. Armando and E. Giunchiglia"))(POS (PAPER.TITLE ARMANDO93 "Embedding complex decision procedures inside an interative theorem prover"))(POS (PAPER.PUBLICATION ARMANDO93 "Annals of Mathematics and Artificial Intelligence"))(POS (PAPER.VOLUME ARMANDO93 "8(3-4)"))(POS (PAPER.STARTPAGE ARMANDO93 475))(POS (PAPER.ENDPAGE ARMANDO93 502))(POS (PAPER.LINK ARMANDO93 "http://citeseer.ist.psu.edu/context/552111/0"))(POS (PAPER.YEAR ARMANDO93 1993))(POS (PAPER.DESCRIPTION ARMANDO93 "
Building a Non-CNF SAT solver out of a CNF SAT-solver.  
"))(POS (PAPER.TOPIC ARMANDO93 "SAT Solving"))(POS (PAPER.INSTANCE ARMANDO97))(POS (PAPER.BIBTEX ARMANDO97 TECHREPORT))(POS (PAPER.AUTHOR ARMANDO97 "A. Armando and S. Ranise"))(POS (PAPER.TITLE ARMANDO97 "From Integrated Reasoning Specialists to Plug-and-Play Reasoning Components"))(POS (PAPER.PUBLICATION ARMANDO97 "Technical Report
           "))(POS (PAPER.LINK ARMANDO97 "http://citeseer.ist.psu.edu/armando98from.html"))(POS (PAPER.YEAR ARMANDO97 1997))(POS (PAPER.RANK ARMANDO97 "[***]"))(POS (PAPER.DESCRIPTION ARMANDO97 "
Armando and Ranise investigate breaking apart a reasoner into its
constituent pieces.  This investigation aims at learning how to
describe reasoners in an effort to promote the heterogeneous integration
of reasoners.  Their case study is NQTHM, Boyer and Moore's linear
arithmetic decision procedure.
"))(POS (PAPER.TOPIC ARMANDO97 "Architectures"))(POS (PAPER.INSTANCE ASTRACHAN92))(POS (PAPER.BIBTEX ASTRACHAN92 INPROCEEDINGS))(POS (PAPER.AUTHOR ASTRACHAN92 "Owen Astrachan and Mark Stickel"))(POS (PAPER.TITLE ASTRACHAN92 "Caching and Lemmaizing in Model Elimination Theorem Provers"))(POS (PAPER.PUBLICATION ASTRACHAN92 "Proceedings of CADE"))(POS (PAPER.LINK ASTRACHAN92 "http://citeseer.ist.psu.edu/astrachan92caching.html"))(POS (PAPER.YEAR ASTRACHAN92 1992))(POS (PAPER.RANK ASTRACHAN92 "[***]"))(POS (PAPER.DESCRIPTION ASTRACHAN92 "
Caching essentially saves intermediate results of a proof in a lookup table and
checks that table to avoid repeating the search for a result already computed.
It keeps track of the depth at which solutions are found to ensure
the same solutions are found given the appropriate depth cutoff using
iterative deepening.  Lemmaizing adds a derived result to the set of input 
clauses, which hopefully will decrease the depth of the proof by more 
than it increases the branching factor. This seminal paper deals with the 
Horn case.
"))(POS (PAPER.TOPIC ASTRACHAN92 "Theorem Proving with Attachments"))(POS (PAPER.INSTANCE AUDEMARD2000))(POS (PAPER.BIBTEX AUDEMARD2000 INPROCEEDINGS))(POS (PAPER.AUTHOR AUDEMARD2000 "Gilles Audemard and Belaid Benhamou and Laurent Henocque"))(POS (PAPER.TITLE AUDEMARD2000 "Two techniques to improve Finite Model Search"))(POS (PAPER.PUBLICATION AUDEMARD2000 "Proceedings of the 17th International Conference on Automated Deduction"))(POS (PAPER.LINK AUDEMARD2000 "http://citeseer.ist.psu.edu/386981.html"))(POS (PAPER.YEAR AUDEMARD2000 2000))(POS (PAPER.DESCRIPTION AUDEMARD2000 "
Two techniques are introduced to speed up SEM-style model finding.
"))(POS (PAPER.TOPIC AUDEMARD2000 "Model Building"))(POS (PAPER.INSTANCE BACHMAIR97))(POS (PAPER.AUTHOR BACHMAIR97 "Leo Bachmair and Harald Ganzinger and Andrei Voronkov"))(POS (PAPER.TITLE BACHMAIR97 "Elimination of Equality via Transformation with Ordering Constraints"))(POS (PAPER.PUBLICATION BACHMAIR97 "CADE"))(POS (PAPER.LINK BACHMAIR97 "http://portal.acm.org/citation.cfm?id=648234.753446"))(POS (PAPER.YEAR BACHMAIR97 1997))(POS (PAPER.DESCRIPTION BACHMAIR97 "
This paper  builds on Brand's method for eliminating the substitution,
reflexivity, symmetry, and transitivity axioms of equality by rewriting
the rules.  It adds ordering constraints in the process of transformation,
which seems to be one of the big benefits.
"))(POS (PAPER.TOPIC BACHMAIR97 "Transformations"))(POS (PAPER.INSTANCE BARALIS97))(POS (PAPER.BIBTEX BARALIS97 INPROCEEDINGS))(POS (PAPER.AUTHOR BARALIS97 "Baralis and Paraboschi and Teniente"))(POS (PAPER.TITLE BARALIS97 "Materialized view selection in a multidimensional database"))(POS (PAPER.PUBLICATION BARALIS97 "In proceedings of Very Large Databases (VLDB)"))(POS (PAPER.STARTPAGE BARALIS97 155))(POS (PAPER.ENDPAGE BARALIS97 165))(POS (PAPER.YEAR BARALIS97 1997))(POS (PAPER.DESCRIPTION BARALIS97 "
Paper on view selection problem in databases
"))(POS (PAPER.TOPIC BARALIS97 "Databases"))(POS (PAPER.INSTANCE BARRETT2000))(POS (PAPER.BIBTEX BARRETT2000 INPROCEEDINGS))(POS (PAPER.AUTHOR BARRETT2000 "Clark Barrett and David Dill and Aaron Stump"))(POS (PAPER.TITLE BARRETT2000 "A Framework for Cooperating Decision Procedures"))(POS (PAPER.PUBLICATION BARRETT2000 "17th International Conference on Automated Deduction
           "))(POS (PAPER.LINK BARRETT2000 "http://citeseer.ist.psu.edu/barrett00framework.html"))(POS (PAPER.YEAR BARRETT2000 2000))(POS (PAPER.RANK BARRETT2000 "[**]"))(POS (PAPER.DESCRIPTION BARRETT2000 "
Barrett et. al. describe a framework approach for building reasoners
that combine decision procedures.  This work is a precurser to janicic2002.
They introduce half a dozen operations that can be used to interrelate
these decision procedures; they further show how Nelson Oppen and
Shostak procedures can be built in their framework.
"))(POS (PAPER.TOPIC BARRETT2000 "Architectures"))(POS (PAPER.RELATED BARRETT2000 JANICIC2002))(POS (PAPER.INSTANCE BAUMGARTNER2003))(POS (PAPER.BIBTEX BAUMGARTNER2003 ARTICLE))(POS (PAPER.AUTHOR BAUMGARTNER2003 "Peter Baumgartner and Cesare Tinelli"))(POS (PAPER.TITLE BAUMGARTNER2003 "The Model Evolution Calculus"))(POS (PAPER.PUBLICATION BAUMGARTNER2003 "19th International Conference on Automated
    Deduction"))(POS (PAPER.STARTPAGE BAUMGARTNER2003 350))(POS (PAPER.ENDPAGE BAUMGARTNER2003 364))(POS (PAPER.LINK BAUMGARTNER2003 "http://sherry.ifi.unizh.ch/577584.html"))(POS (PAPER.YEAR BAUMGARTNER2003 2003))(POS (PAPER.RANK BAUMGARTNER2003 "[****]"))(POS (PAPER.DESCRIPTION BAUMGARTNER2003 "
Baumgartner and Tinelli describe a first-order version of the DPLL 
(Davis-Putnam-Logemann-Loveland) SAT solver.  In the case of
propositional logic, ME reduces to DPLL.  It differs in the first-order
case because of additional inference rules and skolemization.  The procedure
works by exaustively trying to build a first-order model.  If the search 
fails, the sentences are unsatisfiable.  But if the sentences are satisfiable,
the procedure may run forever trying to construct one.  (Obviously if there
are only infinite models this technique may have issues.) 
"))(POS (PAPER.TOPIC BAUMGARTNER2003 "The Model Evolution Calculus"))(POS (PAPER.INSTANCE BAUMGARTNER2007))(POS (PAPER.BIBTEX BAUMGARTNER2007 ARTICLE))(POS (PAPER.AUTHOR BAUMGARTNER2007 "Peter Baumgartner and Alexander Fuchs and Hans Nivelle and Cesare Tinelli"))(POS (PAPER.TITLE BAUMGARTNER2007 "Computing Finite Models by Reduction to Function-Free Clause Logic"))(POS (PAPER.PUBLICATION BAUMGARTNER2007 "Journal of Applied Logic"))(POS (PAPER.LINK BAUMGARTNER2007 "http://goedel.cs.uiowa.edu/Darwin/"))(POS (PAPER.YEAR BAUMGARTNER2007 2007))(POS (PAPER.DESCRIPTION BAUMGARTNER2007 "
Paper on FMDarwin for building finite models of clause sets.  Unlike
techniques for finding a model directly and techniques that ground out
sentences and invoke a SAT solver, FMDarwin reduces a set of clauses
to function-free clause logic in a way that preserves satisfiability
for a particular size domain.  Then it uses Darwin, an implementation
of the model evolution calculus, to check the satisfiability of
the function-free clauses, iterating through domain sizes.  
"))(POS (PAPER.TOPIC BAUMGARTNER2007 "Model Building"))(POS (PAPER.INSTANCE BAUMGARTNER94))(POS (PAPER.AUTHOR BAUMGARTNER94 "Peter Baumgartner and Ulrich Furbach"))(POS (PAPER.TITLE BAUMGARTNER94 "Model Elimination Without Contrapositives"))(POS (PAPER.PUBLICATION BAUMGARTNER94 "Proceedings of Conference on Automated Deduction"))(POS (PAPER.VOLUME BAUMGARTNER94 "814"))(POS (PAPER.STARTPAGE BAUMGARTNER94 87))(POS (PAPER.ENDPAGE BAUMGARTNER94 101))(POS (PAPER.LINK BAUMGARTNER94 "http://portal.acm.org/citation.cfm?id=752966"))(POS (PAPER.YEAR BAUMGARTNER94 1994))(POS (PAPER.DESCRIPTION BAUMGARTNER94 "
Baumgartner and Furbach introduce Restart Model Elimination and a couple of refinements.
RME obviates the need for contrapositives; all the rules are written in the form
A1 | ... | An <= B1 ^ ... ^ Bm, i.e. the only extension steps that can be performed
are on one of the Ai.  The price we pay is that whenever the literal on the top of the 
stack is positive, we put the goal literal onto the top of the stack (forcibly in
strict RME), hence the name Restart ME.  Also, this means that ancestry pruning cannot
be used with RME if completeness is to be preserved.  Soundness and refutational 
completeness results.  Some experimental results and fairly lengthy comparison
to other calculi.
"))(POS (PAPER.TOPIC BAUMGARTNER94 "Calculi"))(POS (PAPER.INSTANCE BAUMGARTNER95))(POS (PAPER.BIBTEX BAUMGARTNER95 ARTICLE))(POS (PAPER.AUTHOR BAUMGARTNER95 "Peter Baumgartner and Ulrich Furbach and Frieder Stolzenburg"))(POS (PAPER.TITLE BAUMGARTNER95 "Model Elimination, Logic Programming and Computing Answers"))(POS (PAPER.PUBLICATION BAUMGARTNER95 "Technical Report"))(POS (PAPER.LINK BAUMGARTNER95 "http://citeseer.ist.psu.edu/144755.html"))(POS (PAPER.YEAR BAUMGARTNER95 1995))(POS (PAPER.DESCRIPTION BAUMGARTNER95 "
The authors demonstrate that restart model elimination can be used as a complete
interpreter for positive disjunctive logic programming.  That is, they show how
to adjust RME so that it is complete for (definite) answer extraction.  With proofs.
Also, they introduce a limited form of ancestry pruning.  More experiments.
"))(POS (PAPER.TOPIC BAUMGARTNER95 "Calculi"))(POS (PAPER.INSTANCE BELL95))(POS (PAPER.BIBTEX BELL95 ARTICLE))(POS (PAPER.AUTHOR BELL95 "John Bell"))(POS (PAPER.TITLE BELL95 "Pragmatic Reasoning: A model-based theory"))(POS (PAPER.PUBLISHER BELL95 "Kluwer Academic Publishers"))(POS (PAPER.PUBLICATION BELL95 "Applied Logic: How, What and Why"))(POS (PAPER.LINK BELL95 "http://citeseer.ist.psu.edu/bell92pragmatic.html"))(POS (PAPER.YEAR BELL95 1995))(POS (PAPER.RANK BELL95 "[****]"))(POS (PAPER.DESCRIPTION BELL95 "
Bell defines pragmatic reasoning as context-dependent reasoning, in
contrast to deduction which is context-free.  He mathematizes
the two model-theoretically and discusses different versions
of pragmatic entailment.  He compares it to mental models, and
looks at different techniques that have been developed for
expressing pragmatic reasoning tasks.
"))(POS (PAPER.TOPIC BELL95 "Logical Knowledge Representation"))(POS (PAPER.INSTANCE BEREZIN2002))(POS (PAPER.BIBTEX BEREZIN2002 PHDTHESIS))(POS (PAPER.AUTHOR BEREZIN2002 "Sergey Berezin"))(POS (PAPER.TITLE BEREZIN2002 "Model Checking and Theorem Proving: A Unified Framework"))(POS (PAPER.PUBLICATION BEREZIN2002 "CMU Ph.D. Thesis"))(POS (PAPER.LINK BEREZIN2002 "http://chicory.stanford.edu/~berezin/thesis/"))(POS (PAPER.YEAR BEREZIN2002 2002))(POS (PAPER.RANK BEREZIN2002 "[**]"))(POS (PAPER.DESCRIPTION BEREZIN2002 "
This thesis builds a framework for integrating model checking and 
theorem proving, focusing on formal verification applications.  
The basic framework proves first-order branching time mu-calculus
properties of Kripke models, but the inference rules can be easily
changed to facilitate the fast development of new proof systems
(called model provers).  Related work is not so thorough. 
"))(POS (PAPER.TOPIC BEREZIN2002 "Model Checking"))(POS (PAPER.INSTANCE BLACKBURN))(POS (PAPER.BIBTEX BLACKBURN BOOK))(POS (PAPER.AUTHOR BLACKBURN "Patrick Blackburn and Johan van Benthem and Frank Wolter"))(POS (PAPER.TITLE BLACKBURN "Handbook of Modal Logic"))(POS (PAPER.PUBLISHER BLACKBURN "Elsevier Science"))(POS (PAPER.LINK BLACKBURN "http://www.elsevier.com/wps/find/bookdescription.cws_home/708884/description#description"))(POS (PAPER.YEAR BLACKBURN 2006))(POS (PAPER.RANK BLACKBURN "[*****]"))(POS (PAPER.DESCRIPTION BLACKBURN "
A handbook for modal logic, covering basic and advanced theory, variations and extensions, and applications.
"))(POS (PAPER.TOPIC BLACKBURN ""))(POS (PAPER.INSTANCE BODIRSKY2004))(POS (PAPER.BIBTEX BODIRSKY2004 PHDTHESIS))(POS (PAPER.AUTHOR BODIRSKY2004 "Manuel Bodirsky"))(POS (PAPER.TITLE BODIRSKY2004 "Constraint Satisfaction with Infinite Domains"))(POS (PAPER.LINK BODIRSKY2004 "http://www.informatik.hu-berlin.de/~bodirsky/publications/diss.html"))(POS (PAPER.YEAR BODIRSKY2004 2004))(POS (PAPER.DESCRIPTION BODIRSKY2004 "
Bodirsky examines the problem of the homomorphic CSP: given one structure,
is it homomorphic to the target structure?  He for the first time
considers target structures that are countably large; more precisely,
those that are countably large but are omega categorical, i.e. 
all countable models of the first-order theory of that model are isomorphic.
In this work, he produces an algorithm for constructing a tree that
satisfies a given set of constraints, where those constraints require
the existence of nodes that meet certain conditions.  Three possible conditions:
x is an ancestor of y, x and y are equal, and x occurs in a subtree to
the left of the subtree that includes y.  While these constraints force
nodes to exist that satisfy particular relationships, OOCSPs force 
particular nodes to have a particular relationship.
"))(POS (PAPER.TOPIC BODIRSKY2004 "Miscellaneous"))(POS (PAPER.INSTANCE BONACINA97))(POS (PAPER.BIBTEX BONACINA97 INPROCEEDINGS))(POS (PAPER.AUTHOR BONACINA97 "Maria Bonacina"))(POS (PAPER.TITLE BONACINA97 "Machine-independent evaluation of theorem-proving strategies"))(POS (PAPER.PUBLICATION BONACINA97 "Workshop on Theorem Proving Strategies"))(POS (PAPER.STARTPAGE BONACINA97 37))(POS (PAPER.ENDPAGE BONACINA97 39))(POS (PAPER.LINK BONACINA97 "http://citeseer.ist.psu.edu/bonacina97machineindependent.html"))(POS (PAPER.YEAR BONACINA97 1997))(POS (PAPER.RANK BONACINA97 "[***]"))(POS (PAPER.DESCRIPTION BONACINA97 "
Bonacina's position piece explains the need for 'strategy analysis' of
theorem proving techniques.  'Strategy analysis' focuses on theorem-proving
complexity as in plaisted94, but also incorporates indexing, data-structures,
unification complexity, etc.   Bonacina gives a summary of another paper 
that confronts the problem representing deletion strategies in a search
space.  Cites kowalski69 as handling the case where results are never
deleted.  She also explains how a sizable body of related work 
concentrates on the complexity of a logical formalism without reference
to any automated proof-finding system, e.g. goubault94.  
"))(POS (PAPER.TOPIC BONACINA97 "Comparative Analysis"))(POS (PAPER.RELATED BONACINA97 KOWALSKI69))(POS (PAPER.RELATED BONACINA97 GOUBAULT94))(POS (PAPER.INSTANCE BONACINA98))(POS (PAPER.BIBTEX BONACINA98 MISC))(POS (PAPER.AUTHOR BONACINA98 "Maria Bonacina"))(POS (PAPER.TITLE BONACINA98 "Strategy analysis: from Sequential to parallel strategies"))(POS (PAPER.STARTPAGE BONACINA98 21))(POS (PAPER.ENDPAGE BONACINA98 23))(POS (PAPER.LINK BONACINA98 "http://citeseer.ist.psu.edu/36838.html"))(POS (PAPER.YEAR BONACINA98 1998))(POS (PAPER.RANK BONACINA98 "[*]"))(POS (PAPER.DESCRIPTION BONACINA98 "
Bonacina's position paper describes the formalization of the
search space for parallelized theorem proving with contraction
operations.  This paper covers the main ideas, but the meat looks
to be cited in two technical reports.
"))(POS (PAPER.TOPIC BONACINA98 "Comparative Analysis"))(POS (PAPER.INSTANCE BORGER))(POS (PAPER.BIBTEX BORGER BOOK))(POS (PAPER.AUTHOR BORGER "Egon Borger and Erich Gradel and Yuri Gurevich"))(POS (PAPER.TITLE BORGER "The Classical Decision Problem"))(POS (PAPER.PUBLISHER BORGER "Springer-Verlag"))(POS (PAPER.LINK BORGER "http://books.google.com/books?id=3po2Tv_UVcMC&dq=&pg=PP1&ots=FMOqyLGt4N&sig=7pB4XtFUSbGbiUuF4XlKGattRts&prev=http://www.google.com/search%3Fclient%3Dsafari%26rls%3Den%26q%3Dthe%2Bclassical%2Bdecision%2Bproblem%26ie%3DUTF-8%26oe%3DUTF-8&sa=X&oi=print&ct=title#PPP1,M1"))(POS (PAPER.YEAR BORGER 1997))(POS (PAPER.DESCRIPTION BORGER "
The book detailing decidability results for entailment in various prefix
classes of first-order logic, along with complexity results for the 
decidable classes.
"))(POS (PAPER.TOPIC BORGER ""))(POS (PAPER.INSTANCE BORNING92))(POS (PAPER.BIBTEX BORNING92 ARTICLE))(POS (PAPER.AUTHOR BORNING92 "A. Borning and B.N. Freeman-Benson and M. Wilson"))(POS (PAPER.TITLE BORNING92 "Constraint hierarchies"))(POS (PAPER.PUBLICATION BORNING92 "Lisp and Symbolic Computation"))(POS (PAPER.VOLUME BORNING92 "5"))(POS (PAPER.STARTPAGE BORNING92 223))(POS (PAPER.ENDPAGE BORNING92 270))(POS (PAPER.LINK BORNING92 "http://citeseer.ist.psu.edu/borning92constraint.html"))(POS (PAPER.YEAR BORNING92 1992))(POS (PAPER.RANK BORNING92 "[*]"))(POS (PAPER.DESCRIPTION BORNING92 "
Constraint hierarchies, aka Hierarchical Constraint Satisfaction Problems,
impose a precedence hierarchy on constraints.  Only the highest 
precedence constraints must be satisfied; the others constraints
form an ordered set of preferences on the solutions.
"))(POS (PAPER.TOPIC BORNING92 "Object Oriented Constraint Satisfaction"))(POS (PAPER.INSTANCE BORRETT2001))(POS (PAPER.AUTHOR BORRETT2001 "James Borrett and Edward Tsang"))(POS (PAPER.TITLE BORRETT2001 "A Context for Constraint Satisfaction Problem Formulation Selection"))(POS (PAPER.PUBLICATION BORRETT2001 "Constraints"))(POS (PAPER.VOLUME BORRETT2001 "6"))(POS (PAPER.STARTPAGE BORRETT2001 299))(POS (PAPER.ENDPAGE BORRETT2001 327))(POS (PAPER.LINK BORRETT2001 "http://citeseer.ist.psu.edu/borret99context.html"))(POS (PAPER.YEAR BORRETT2001 2001))(POS (PAPER.RANK BORRETT2001 "[***]"))(POS (PAPER.DESCRIPTION BORRETT2001 "
Borrett and Tsang construct a framework for searching through various constraint satisfaction problem formulations and selecting one.  They only consider
formulations of the form <V,D,C>, i.e. typical CSP formulations.  They break the problem into 4 parts: generating an initial formulation, constructing operators to change that formulation, constructing heuristics for choosing which operator to apply, and constructing an evaluation function to that determines the cost of a given formulation.  They go on to demonstrate a particular type of operator: the introduction of redundant constraints and show how searching through CSP formulations with this type of operator works in their framework.
"))(POS (PAPER.TOPIC BORRETT2001 "Reformulation"))(POS (PAPER.INSTANCE BOWEN91))(POS (PAPER.BIBTEX BOWEN91 ARTICLE))(POS (PAPER.AUTHOR BOWEN91 "J. Bowen and D. Bahler"))(POS (PAPER.TITLE BOWEN91 "Conditional Existence of Variables in Generalized Constraint Networks
"))(POS (PAPER.PUBLICATION BOWEN91 "AAAI "))(POS (PAPER.LINK BOWEN91 "http://www.csc.ncsu.edu/faculty/bahler/aaai91/aaai91.pdf"))(POS (PAPER.YEAR BOWEN91 1991))(POS (PAPER.DESCRIPTION BOWEN91 "
Bowen and Bahler employ Free Logic to construct a constraint network
where not all variables must be assigned values.  A constraint network
is defined as a set of logical sentences with a DCA; 
a solution is an interpretation
of the vocabulary in a model so that the sentences are satisfied.  
Free logic differs from FOL in that not every element in the vocabulary
needs to be mapped into the model.
"))(POS (PAPER.TOPIC BOWEN91 "Miscellaneous"))(POS (PAPER.INSTANCE BRY2007))(POS (PAPER.BIBTEX BRY2007 ARTICLE))(POS (PAPER.AUTHOR BRY2007 "Francois Bry and Norbert Eisinger and Thomas Eiter and Tim Furche and Georg Gottlob and Clemens Ley and Benedikt Linse and Reinhard Pichler and Fang Wei"))(POS (PAPER.TITLE BRY2007 "Foundations of Rule-Based Query Answering"))(POS (PAPER.PUBLICATION BRY2007 "Reasoning Web, Third International Summer School 2007, Grigoris Antoniou, Uwe Assmann, Cristina Baroglio, Stefan Decker, Nicola Henze, Paula-Lavinia Patranjan, Robert Tolksdorf (editors)"))(POS (PAPER.VOLUME BRY2007 "LNCS 4636"))(POS (PAPER.LINK BRY2007 "http://www.pms.ifi.lmu.de/publikationen/index.html#PMS-FB-2007-7"))(POS (PAPER.YEAR BRY2007 2007))(POS (PAPER.DESCRIPTION BRY2007 "
The mathematical foundations of logical query languages.
"))(POS (PAPER.TOPIC BRY2007 "Logical Knowledge Representation"))(POS (PAPER.INSTANCE BUNDY73))(POS (PAPER.BIBTEX BUNDY73 INPROCEEDINGS))(POS (PAPER.AUTHOR BUNDY73 "Alan Bundy"))(POS (PAPER.TITLE BUNDY73 "Doing Arithmetic With Diagrams"))(POS (PAPER.PUBLICATION BUNDY73 "IJCAI"))(POS (PAPER.YEAR BUNDY73 1973))(POS (PAPER.RANK BUNDY73 "[**]"))(POS (PAPER.DESCRIPTION BUNDY73 "
Bundy describes SUMS (System which Understands Mathematical
Symbols), a theorem prover for theorems over natural numbers.
The SUMS proof process represents the natural numbers in
a diagram, and by manipulating the diagram, determines the
truth of a conjecture.  Bundy makes an interesting point at the 
end of the paper: mathematicians do not usually manipulate
logic to prove theorems.  Rather, they convince themselves
of the correctness of a conjecture through diagrams or other
semantic insights and then use logic as a language for
communicating to others the proof of the theorem.  SUMS
is an attempt at building a machine that simply 
convinces itself of the truth of a conjecture.
"))(POS (PAPER.TOPIC BUNDY73 "Graphical Reasoning Techniques"))(POS (PAPER.INSTANCE BUNDY99))(POS (PAPER.AUTHOR BUNDY99 "Alan Bundy"))(POS (PAPER.TITLE BUNDY99 "A Survey of Automated Deduction"))(POS (PAPER.LINK BUNDY99 "http://citeseer.ist.psu.edu/bundy99survey.html"))(POS (PAPER.YEAR BUNDY99 1999))(POS (PAPER.RANK BUNDY99 ""))(POS (PAPER.DESCRIPTION BUNDY99 "
Bundy surveys research in automated deduction.  He focuses on resolution,
term rewriting, built-in unification, higher-order logics and type-theory,
induction, interactive theorem-proving, meta-reasoning, common sense
reasoning, and logic programming.
"))(POS (PAPER.TOPIC BUNDY99 "Theorem Proving"))(POS (PAPER.INSTANCE BYLANDER94))(POS (PAPER.AUTHOR BYLANDER94 "Tom Bylander"))(POS (PAPER.TITLE BYLANDER94 "The Computational Complexity of Propositional STRIPS Planning"))(POS (PAPER.PUBLICATION BYLANDER94 "Artificial Intelligence"))(POS (PAPER.VOLUME BYLANDER94 "69(1-2)"))(POS (PAPER.STARTPAGE BYLANDER94 165))(POS (PAPER.ENDPAGE BYLANDER94 204))(POS (PAPER.LINK BYLANDER94 "http://citeseer.ist.psu.edu/bylander94computational.html"))(POS (PAPER.YEAR BYLANDER94 1994))(POS (PAPER.DESCRIPTION BYLANDER94 "
Bylander discusses complexity results for propositional STRIPS; he also mentions that a class of first-order STRIPS can be reduced in polynomial time to propositional STRIPS, making these results widely applicable.  PLANSAT (decision problem for determining whether an instance of prop STRIPS planning is satisfiable) is PSPACE-complete.  PLANSAT[2+,2] (PLANSAT where all operators have at least 2 positive preconditions and 2 postconditions) is also PSPACE-complete.  Results are shown for a variety of restrictions, concluding that without severe restrictions, PLANSAT is NP-complete or PSPACE-complete.
These results carry over to PLANMIN (the decision problem of determining whether an instance has a solution of k or fewer operators.  The new results here show a variety of PLANMIN are NP-complete, and a couple, very restricted versions are polynomial.  He also shows results for Propositional Strips with formulas (Extended Propositional STRIPS).  EPLANSAT, EPLANSAT[0,1+] restricted to define Horn clauses are PSPACE-complete.  More results are shown for EPLANSAT and EPLANSATMIN.  See paper for details.
"))(POS (PAPER.TOPIC BYLANDER94 "Historical"))(POS (PAPER.INSTANCE BYRNE2000))(POS (PAPER.BIBTEX BYRNE2000 MISC))(POS (PAPER.AUTHOR BYRNE2000 "Ruth Byrne and Lisa Gilroy"))(POS (PAPER.TITLE BYRNE2000 "Mental Models Website"))(POS (PAPER.LINK BYRNE2000 "http://www.tcd.ie/Psychology/Ruth_Byrne/mental_models/index.html"))(POS (PAPER.YEAR BYRNE2000 2000))(POS (PAPER.DESCRIPTION BYRNE2000 "
Mental Models website--the Psychology version of model-based reasoning.
"))(POS (PAPER.TOPIC BYRNE2000 "Model-Based Reasoning"))(POS (PAPER.INSTANCE CADOLI2000))(POS (PAPER.BIBTEX CADOLI2000 MISC))(POS (PAPER.AUTHOR CADOLI2000 "Marco Cadoli and Francesco M. Donini and Paolo Liberatore and Marco Schaerf"))(POS (PAPER.TITLE CADOLI2000 "Preprocessing of Intractable Problems"))(POS (PAPER.PUBLICATION CADOLI2000 "Information and Computation"))(POS (PAPER.VOLUME CADOLI2000 "176(2)"))(POS (PAPER.STARTPAGE CADOLI2000 89))(POS (PAPER.ENDPAGE CADOLI2000 120))(POS (PAPER.LINK CADOLI2000 "http://citeseer.ist.psu.edu/cadoli00preprocessing.html"))(POS (PAPER.YEAR CADOLI2000 2000))(POS (PAPER.RANK CADOLI2000 "[**]"))(POS (PAPER.DESCRIPTION CADOLI2000 "
This paper describes complexity classes for algorithms after they
have been preprocessed, or compiled.  The problems targeted have two
parts, one that is fixed, and one that changes frequently.  For
example, determining whether Delta entails a sentence phi has a
fixed part (Delta) and a changing part (phi).  If we could compile
Delta into a more vivid representation, computing entailment might
be easier.  This paper formalizes that idea, gives a complexity class
hierarchy, and a method for reductions.  Cool ideas, but very
theoretical (and only with propositional KB examples).
"))(POS (PAPER.TOPIC CADOLI2000 "Knowledge Base Compilation"))(POS (PAPER.INSTANCE CADOLI2000B))(POS (PAPER.BIBTEX CADOLI2000B MISC))(POS (PAPER.AUTHOR CADOLI2000B "Marco Cadoli and Francesco Donini and Paolo Liberatore and Marco Schaerf"))(POS (PAPER.TITLE CADOLI2000B "Space Efficiency of Propositional Knowledge Representation Formalisms"))(POS (PAPER.PUBLICATION CADOLI2000B "Journal of Artificial Intelligence Research"))(POS (PAPER.VOLUME CADOLI2000B "13"))(POS (PAPER.STARTPAGE CADOLI2000B 1))(POS (PAPER.ENDPAGE CADOLI2000B 31))(POS (PAPER.LINK CADOLI2000B "http://citeseer.ist.psu.edu/cadoli00space.html"))(POS (PAPER.YEAR CADOLI2000B 2000))(POS (PAPER.RANK CADOLI2000B "[*****]"))(POS (PAPER.DESCRIPTION CADOLI2000B "
The authors leverage previous work on compilation complexity classes to compare
various propositional knowledge formalisms.  They introduce two axes for comparing
such formalisms under translation: theorem-preservation and model-preservation.
That is, given a set of sentences in one formalism, translate those sentences
into another formalism so that (1) the theorems are preserved across the translation
after a translation of their own or (2) the models are preserved across the
translation after a translation of their own.  The translation of premise sets
is assumed to be polynomial in size; the requirement on the translation of
theorems/models is that the representation of the translation process itself
must be polynomial in size.  

The authors then introduce the notion of 
model-C and thm-C classes.  A formalism belongs to the model-C class iff 
model checking in that formalism is in the compilability class C, where the KB is 
the fixed part and the model is the varying part.  A formalism belongs to
the thm-C class iff inference in that formalism is in the compilability class C,
where the KB is the fixed part and the query is the varying part.

Next the authors prove that two formalisms in the same model-C/thm-C class then
there must be a poly-size reduction between the two formalisms that 
preserves models/theorems.  They also show that if two problems are in different
classes there is no polynomial size reduction satisfying models/theorems.

Finally, the propositional formalisms stable model semantics, circumscription, 
generalized closed world, skeptical default logic, credulous default logic, 
WIDTIO belief revision, and skeptical belief revision are analyzed in this 
framework, giving fairly complete coverage of inference/model space complexity.
"))(POS (PAPER.TOPIC CADOLI2000B "Knowledge Base Compilation"))(POS (PAPER.INSTANCE CADOLI2001))(POS (PAPER.AUTHOR CADOLI2001 "Marco Cadoli and Andrea Schaerf"))(POS (PAPER.TITLE CADOLI2001 "Compiling Problem Specifications into SAT"))(POS (PAPER.PUBLICATION CADOLI2001 "Lecture Notes in Computer Science"))(POS (PAPER.VOLUME CADOLI2001 "2028"))(POS (PAPER.LINK CADOLI2001 "http://citeseer.ist.psu.edu/cadoli01compiling.html"))(POS (PAPER.RANK CADOLI2001 "[***]"))(POS (PAPER.DESCRIPTION CADOLI2001 "
Cadoli and Schaerf describe a language, NP-Spec, for specifying problems
in NP, and a technique for translating that language into SAT.  They
mention a previous translation into Prolog.  With SAT, results were
far better than with Prolog; that is, they could solve what they called
medium-sized problems instead of just small problems.  NP-Spec is based
on Prolog without negation (except on some predefined predicates) with
a fixed database. It includes a mix of metalevel constraints and object-level
constraints.
"))(POS (PAPER.TOPIC CADOLI2001 "Knowledge Base Compilation"))(POS (PAPER.INSTANCE CADOLI2002))(POS (PAPER.AUTHOR CADOLI2002 "Marco Cadoli and Toni Mancini"))(POS (PAPER.TITLE CADOLI2002 "Knowledge compilation = Query rewriting + View synthesis"))(POS (PAPER.PUBLICATION CADOLI2002 "Symposium on Principles of Database Systems"))(POS (PAPER.STARTPAGE CADOLI2002 199))(POS (PAPER.ENDPAGE CADOLI2002 208))(POS (PAPER.LINK CADOLI2002 "http://citeseer.ist.psu.edu/641562.html"))(POS (PAPER.RANK CADOLI2002 "[***]"))(POS (PAPER.DESCRIPTION CADOLI2002 "
Cadoli describes a class of propositional knowledge compilation  where
the problem is transformed into a database and a second-order
query over that database.  The database is a straight-forward representation
of the clausal form of the input.  The authors give syntactic conditions
under which the problem can be compiled into P using this technique.
"))(POS (PAPER.TOPIC CADOLI2002 "Knowledge Base Compilation"))(POS (PAPER.INSTANCE CADOLI97))(POS (PAPER.BIBTEX CADOLI97 ARTICLE))(POS (PAPER.AUTHOR CADOLI97 "Marco Cadoli and Francesco M. Donini"))(POS (PAPER.TITLE CADOLI97 "A Survey on Knowledge Compilation"))(POS (PAPER.PUBLICATION CADOLI97 "AI Communications"))(POS (PAPER.VOLUME CADOLI97 "10(3-4)"))(POS (PAPER.STARTPAGE CADOLI97 137))(POS (PAPER.ENDPAGE CADOLI97 150))(POS (PAPER.LINK CADOLI97 "http://citeseer.ist.psu.edu/cadoli98survey.html"))(POS (PAPER.YEAR CADOLI97 1997))(POS (PAPER.RANK CADOLI97 "[***]"))(POS (PAPER.DESCRIPTION CADOLI97 "
Cadoli and Donini review techniques for propositional knowledge base compilation.  
The goal
is to rewrite a KB in a form that will answer queries more quickly.  They survey
exact compilation: prime implicates and implicants, unit-resolution-complete 
methods, and theory prime implicates.  They look at approximate compilation:
anytime versions of exact methods, horn approximations (can result in unsound
inference).  They consider compiling non-monotonic knowledge bases with
circumscription, default logic, and belief revision.  All those techniques aim
to reduce intractable query answering to tractable query answering.  Lastly,
Cadoli and Donini mention compilations of _polynomial-time_ query answering,
compilations into something other than a KB, and compare compilation to 
fixed-parameter tractability.
"))(POS (PAPER.TOPIC CADOLI97 "Knowledge Base Compilation"))(POS (PAPER.INSTANCE CASEAU94))(POS (PAPER.AUTHOR CASEAU94 "Yves Caseau"))(POS (PAPER.TITLE CASEAU94 "Constraint Satisfaction with an Object-Oriented Knowledge
Representation Language"))(POS (PAPER.PUBLICATION CASEAU94 "Applied Intelligence "))(POS (PAPER.VOLUME CASEAU94 "4(2)"))(POS (PAPER.STARTPAGE CASEAU94 157))(POS (PAPER.ENDPAGE CASEAU94 184))(POS (PAPER.LINK CASEAU94 "http://citeseer.ist.psu.edu/caseau94constraint.html"))(POS (PAPER.YEAR CASEAU94 1994))(POS (PAPER.RANK CASEAU94 "[***]"))(POS (PAPER.DESCRIPTION CASEAU94 "
Caseau describes how one might solve constraint satisfaction problems
using Laure, an object-oriented language that combines declarative
and procedural knowledge.  In Laure, a Database is used to model
the world; solving a problem amounts to finding objects to fill
goals and satisfy constraints.  Those objects are completions of
the database.  CSPs can be represented by attaching constraints
to objects; a finite number of these objects allows standard 
CSP techniques, e.g. arc consistency, to find solutions.
"))(POS (PAPER.TOPIC CASEAU94 "OO Languages with Native Constraint Satisfaction"))(POS (PAPER.INSTANCE CASEAU96))(POS (PAPER.BIBTEX CASEAU96 ARTICLE))(POS (PAPER.AUTHOR CASEAU96 "Yves Caseau, Francois Laburthe"))(POS (PAPER.TITLE CASEAU96 "CLAIRE: a brief overview"))(POS (PAPER.PUBLICATION CASEAU96 ""))(POS (PAPER.LINK CASEAU96 "http://citeseer.ist.psu.edu/caseau96claire.html"))(POS (PAPER.YEAR CASEAU96 1996))(POS (PAPER.RANK CASEAU96 "[**]"))(POS (PAPER.DESCRIPTION CASEAU96 "
CLAIRE is a programming language designed to be C++ compliant that  
can compute using constraints natively.
"))(POS (PAPER.TOPIC CASEAU96 "OO Languages with Native Constraint Satisfaction"))(POS (PAPER.INSTANCE CHANGLEE))(POS (PAPER.BIBTEX CHANGLEE BOOK))(POS (PAPER.AUTHOR CHANGLEE "Chin-Liang Chang and Richard Lee"))(POS (PAPER.TITLE CHANGLEE "Symbolic Logic and Mechanical Theorem Proving"))(POS (PAPER.PUBLISHER CHANGLEE "Academic Press"))(POS (PAPER.LINK CHANGLEE "http://www.amazon.com/exec/obidos/ASIN/0121703509/qid%3D965533387/sr%3D1-1/102-6107129-2481765"))(POS (PAPER.YEAR CHANGLEE 1973))(POS (PAPER.RANK CHANGLEE ""))(POS (PAPER.DESCRIPTION CHANGLEE "
A classic text for automated reasoning.  Chang and Lee cover propositional and
first-order logic, Herbrand's theorem, resolution (standard, semantic, lock,
and linear) and equality.  They discuss an alternative to resolution, 
Prawitz's procedure and V-resolution.  A chapter on program analysis
leads to query answering and program synthesis in the final chapter.
"))(POS (PAPER.TOPIC CHANGLEE ""))(POS (PAPER.INSTANCE CHEN2000))(POS (PAPER.AUTHOR CHEN2000 "Hubie Chen"))(POS (PAPER.TITLE CHEN2000 "A Theory of Average-Case Compilability in Knowledge Representation"))(POS (PAPER.LINK CHEN2000 "http://citeseer.ist.psu.edu/590465.html"))(POS (PAPER.RANK CHEN2000 "[***]"))(POS (PAPER.DESCRIPTION CHEN2000 "Chen gives an overview of the Compilability hierarchy given
by Cadoli2000.  Then Chen gives theorems concerning average-case
compilability, i.e. analogs of the Cadoli hierarchy when there is a 
distribution over the space of knowledge representations within a class.
The results are pretty densely presented.  
"))(POS (PAPER.TOPIC CHEN2000 "Knowledge Base Compilation"))(POS (PAPER.INSTANCE CHIRKOVA2002))(POS (PAPER.BIBTEX CHIRKOVA2002 PHDTHESIS))(POS (PAPER.AUTHOR CHIRKOVA2002 "Rada Chirkova"))(POS (PAPER.TITLE CHIRKOVA2002 "Automated Database Restructuring"))(POS (PAPER.PUBLISHER CHIRKOVA2002 "Stanford University"))(POS (PAPER.LINK CHIRKOVA2002 ""))(POS (PAPER.YEAR CHIRKOVA2002 2002))(POS (PAPER.RANK CHIRKOVA2002 "[****]"))(POS (PAPER.DESCRIPTION CHIRKOVA2002 "
Chirkova's thesis presents algorithms for computing the set of views
that if materialized would allow queries to be answered optimally.  That is
there is no set of views that if materialized would answer those queries
any more efficiently.  Three results: the problem is decidable, it
has a triply exponential upper bound in the queries, and it has an
exponential lower bound.  Only conjunctions, i.e. SPJ,
are considered, both for view definitions and the queries.
"))(POS (PAPER.TOPIC CHIRKOVA2002 "Databases"))(POS (PAPER.INSTANCE CHOI2000))(POS (PAPER.BIBTEX CHOI2000 MISC))(POS (PAPER.AUTHOR CHOI2000 "Seungyeob Choi"))(POS (PAPER.TITLE CHOI2000 "Semantically Guided Proof Planning"))(POS (PAPER.LINK CHOI2000 "http://citeseer.ist.psu.edu/464153.html"))(POS (PAPER.YEAR CHOI2000 2000))(POS (PAPER.RANK CHOI2000 "[***]"))(POS (PAPER.DESCRIPTION CHOI2000 "
This thesis proposal focuses on adding semantic guidance to
automated theorem proving in two ways: 1) by incorporating
the use of models with a clause graph procedure and 2) by
incorporating the use of models with a proof planning
procedure.  This gives a good overview of various theorem
proving techniques and semantic techniques.
"))(POS (PAPER.TOPIC CHOI2000 "Model-Guided Proof Techniques"))(POS (PAPER.INSTANCE CHOMICKI95))(POS (PAPER.AUTHOR CHOMICKI95 "Jan Chomicki"))(POS (PAPER.TITLE CHOMICKI95 "Efficient Checking of Temporal Integrity Constraints Using Bounded History Encoding"))(POS (PAPER.PUBLICATION CHOMICKI95 "ACM Transactions on Database Systems"))(POS (PAPER.VOLUME CHOMICKI95 "20(2)"))(POS (PAPER.STARTPAGE CHOMICKI95 149))(POS (PAPER.ENDPAGE CHOMICKI95 186))(POS (PAPER.LINK CHOMICKI95 "http://citeseer.ist.psu.edu/chomicki95efficient.html"))(POS (PAPER.YEAR CHOMICKI95 1995))(POS (PAPER.RANK CHOMICKI95 "[**]"))(POS (PAPER.DESCRIPTION CHOMICKI95 "
Chomicki describes an algorithm for maintaining temporal constraints on a database, which are written in past first order temporal logic.  Instead of storing the entire history of the database, Chomicki describes a way to roll up the history (in a lossy way) into auxiliary relations in the database.  She assumes the set of constraints is fixed, which means a single auxiliary relation can be stored for each sentence in the constraints.  She proves this encoding to be polynomially-bounded in the number of domain values that appear in the database over time.  Chomicki extends this work to include real-time constraints, which refer to a clock.
"))(POS (PAPER.TOPIC CHOMICKI95 "Hypothetical Temporal DB Queries"))(POS (PAPER.INSTANCE CHRISTIAN93))(POS (PAPER.BIBTEX CHRISTIAN93 ARTICLE))(POS (PAPER.AUTHOR CHRISTIAN93 "Jim Christian"))(POS (PAPER.TITLE CHRISTIAN93 "Flatterms, Discrimination Nets, and Fast Term Rewriting"))(POS (PAPER.PUBLICATION CHRISTIAN93 "Journal of Automated Reasoning
"))(POS (PAPER.VOLUME CHRISTIAN93 "10"))(POS (PAPER.STARTPAGE CHRISTIAN93 95))(POS (PAPER.ENDPAGE CHRISTIAN93 113))(POS (PAPER.LINK CHRISTIAN93 ""))(POS (PAPER.YEAR CHRISTIAN93 1993))(POS (PAPER.RANK CHRISTIAN93 ""))(POS (PAPER.DESCRIPTION CHRISTIAN93 "
One of the early papers on Discrimination Nets, which is argued as
a reason for representing terms as flat terms.
"))(POS (PAPER.TOPIC CHRISTIAN93 "Indexing"))(POS (PAPER.INSTANCE CLAESSEN2003))(POS (PAPER.BIBTEX CLAESSEN2003 INPROCEEDINGS))(POS (PAPER.AUTHOR CLAESSEN2003 "K. Claessen and N. Sorensson"))(POS (PAPER.TITLE CLAESSEN2003 "New Techniues that Improve MACE-style Finite Model Finding"))(POS (PAPER.PUBLICATION CLAESSEN2003 "CADE-19 Workshop on Model Computation"))(POS (PAPER.LINK CLAESSEN2003 "http://citeseer.ist.psu.edu/claessen03new.html"))(POS (PAPER.YEAR CLAESSEN2003 2003))(POS (PAPER.DESCRIPTION CLAESSEN2003 "
A serieis of techniques are introduced for constructing a finite model
by conversion to SAT, aka the MACE-style model building.  A/the paradox paper.
"))(POS (PAPER.TOPIC CLAESSEN2003 "Model Building"))(POS (PAPER.INSTANCE CLARKE))(POS (PAPER.BIBTEX CLARKE BOOK))(POS (PAPER.AUTHOR CLARKE "Edmund M. Clarke Jr. and Orna Grumberg and Doron Peled"))(POS (PAPER.TITLE CLARKE "Model Checking"))(POS (PAPER.PUBLISHER CLARKE "The MIT Press"))(POS (PAPER.LINK CLARKE "http://mitpress.mit.edu/catalog/item/default.asp?ttype=2&tid=3730"))(POS (PAPER.YEAR CLARKE 1999))(POS (PAPER.RANK CLARKE "[*****]"))(POS (PAPER.DESCRIPTION CLARKE "
An introduction to model checking as performed by the formal methods community.
"))(POS (PAPER.TOPIC CLARKE ""))(POS (PAPER.INSTANCE COHEN90))(POS (PAPER.AUTHOR COHEN90 "P.R. Cohen and H.J. Levesque"))(POS (PAPER.TITLE COHEN90 "Intention is choice with commitment"))(POS (PAPER.PUBLICATION COHEN90 "Artificial Intelligence"))(POS (PAPER.VOLUME COHEN90 "42(3)"))(POS (PAPER.YEAR COHEN90 1990))(POS (PAPER.RANK COHEN90 "[*]"))(POS (PAPER.DESCRIPTION COHEN90 "
Cohen and Levesque use modal operators without explicit mention of time to describe an agent's persistent goals.  These goals will be worked upon until 1) they are achieved or 2) they are deemed impossible.  No work was done here on planning to achieve these goals. 
"))(POS (PAPER.TOPIC COHEN90 "Behavioral Goals"))(POS (PAPER.INSTANCE COMON99))(POS (PAPER.BIBTEX COMON99 ARTICLE))(POS (PAPER.AUTHOR COMON99 "Hubert Comon and Mehmet Dincbas and Jean-pierre Jouannaud and Claude Kirchner"))(POS (PAPER.TITLE COMON99 "A Methodological View of Constraint Solving"))(POS (PAPER.PUBLICATION COMON99 "Constraints"))(POS (PAPER.VOLUME COMON99 "4"))(POS (PAPER.STARTPAGE COMON99 337))(POS (PAPER.ENDPAGE COMON99 361))(POS (PAPER.LINK COMON99 "http://citeseer.ist.psu.edu/13836.html"))(POS (PAPER.YEAR COMON99 1999))(POS (PAPER.DESCRIPTION COMON99 "
The authors motivate why sets are described using constraints and go on to survey the various techniques that have been used for processing those constraints, i.e. (1) determining whether an element belongs to a set or (2) determining whether one set is included entirely in another set (entailment).  They discuss 3 types of techniques: syntactic, semantic, and hybrid.  Syntactic techniques translate a formula into another formula.  Semantic techniques translate formulas into automata or another such formalism.  Hybrid techniques use both.  For more info on automata, try http://www.grappa.univ-lille3.fr/tata/.
"))(POS (PAPER.TOPIC COMON99 "General"))(POS (PAPER.INSTANCE COOK71))(POS (PAPER.BIBTEX COOK71 ARTICLE))(POS (PAPER.AUTHOR COOK71 "Stephen Cook"))(POS (PAPER.TITLE COOK71 "The Complexity of Theorem-Proving Procedures"))(POS (PAPER.PUBLICATION COOK71 "Symposium on the Theory of Computing (STOC)"))(POS (PAPER.STARTPAGE COOK71 151))(POS (PAPER.ENDPAGE COOK71 158))(POS (PAPER.LINK COOK71 "http://citeseer.ist.psu.edu/context/5446/0"))(POS (PAPER.YEAR COOK71 1971))(POS (PAPER.RANK COOK71 "[*]"))(POS (PAPER.DESCRIPTION COOK71 "
This is Cook's paper which introduces the theory of NP completeness
and polynomial reductions.  He gives complexity bounds on theorem-
proving procedures relative to the minimum number of copies of 
axioms required for propositional unsatisfiability.
"))(POS (PAPER.TOPIC COOK71 "Comparative Analysis"))(POS (PAPER.INSTANCE CRAIG2004))(POS (PAPER.BIBTEX CRAIG2004 ARTICLE))(POS (PAPER.AUTHOR CRAIG2004 "S. Craig and J. Gallagher and M. Leuschel and K. Henriksen"))(POS (PAPER.TITLE CRAIG2004 "Fully Automatic Binding-Time Analysis for Prolog"))(POS (PAPER.PUBLICATION CRAIG2004 "14th International Symposium, Logic Based Program Synthesis and Trnasformation (LOPSTR)"))(POS (PAPER.STARTPAGE CRAIG2004 53))(POS (PAPER.ENDPAGE CRAIG2004 68))(POS (PAPER.LINK CRAIG2004 "http://wotan.liu.edu/docis/dbl/lopstr/index.html"))(POS (PAPER.YEAR CRAIG2004 2004))(POS (PAPER.DESCRIPTION CRAIG2004 "
The authors consider the problem of computing modes, i.e. binding
patterns, for prolog relations, and whether to unroll or inline
such relations.  The first computes a set of disjoint types 
from regular types and then propagates them.  The second 
uses binary clause semantics and convex hull abstraction
to determine which relations will not terminate.  Apparently,
very similar work was done in 2001 by Vanhoof and Bruynooghe
in 2001.
"))(POS (PAPER.TOPIC CRAIG2004 "Reformulation"))(POS (PAPER.INSTANCE CYRLUK96SHOSTAKS))(POS (PAPER.BIBTEX CYRLUK96SHOSTAKS INPROCEEDINGS))(POS (PAPER.AUTHOR CYRLUK96SHOSTAKS "David Cyrluk, Patrick Lincoln, and Natarajan Shankar"))(POS (PAPER.TITLE CYRLUK96SHOSTAKS "On Shostak's Decision Procedure for Combinations of Theories"))(POS (PAPER.PUBLICATION CYRLUK96SHOSTAKS "13th International Conference on Automated Deduction
           "))(POS (PAPER.LINK CYRLUK96SHOSTAKS "http://citeseer.ist.psu.edu/cyrluk96shostaks.html"))(POS (PAPER.YEAR CYRLUK96SHOSTAKS 1996))(POS (PAPER.RANK CYRLUK96SHOSTAKS "[****]"))(POS (PAPER.DESCRIPTION CYRLUK96SHOSTAKS "
Cyrluk, Lincoln, and Shankar give a crisp description of the Shostak
procedure and sketch proofs of its properties.  It breaks the algorithm
down into 1) a congruence closure computation and 2) the interpretation
of functions through canonization.  This version of Shostak and all its
counterparts were later shown incomplete.
"))(POS (PAPER.TOPIC CYRLUK96SHOSTAKS "Nelson-Oppen and Shostak"))(POS (PAPER.RELATED CYRLUK96SHOSTAKS SHOSTAK84))(POS (PAPER.RELATED CYRLUK96SHOSTAKS RUEB2000DECONSTRUCTING))(POS (PAPER.INSTANCE DANTSIN2001))(POS (PAPER.AUTHOR DANTSIN2001 "Evgeny Dantsin and Thomas Eiter and Georg Gottlob and Andrei Voronkov"))(POS (PAPER.TITLE DANTSIN2001 "Complexity and Expressive Power of Logic Programming"))(POS (PAPER.PUBLICATION DANTSIN2001 "ACM Computing Surveys"))(POS (PAPER.VOLUME DANTSIN2001 "33(3)"))(POS (PAPER.STARTPAGE DANTSIN2001 374))(POS (PAPER.ENDPAGE DANTSIN2001 425))(POS (PAPER.LINK DANTSIN2001 "http://portal.acm.org/citation.cfm?id=502810&dl=ACM&coll=GUIDE"))(POS (PAPER.YEAR DANTSIN2001 2001))(POS (PAPER.DESCRIPTION DANTSIN2001 "
Complexity results for logic programming.
"))(POS (PAPER.TOPIC DANTSIN2001 "Logic Programming"))(POS (PAPER.INSTANCE DARWICHE2002))(POS (PAPER.BIBTEX DARWICHE2002 ARTICLE))(POS (PAPER.AUTHOR DARWICHE2002 "Adnan Darwiche and Pierre Marquis"))(POS (PAPER.TITLE DARWICHE2002 "A Knowledge Compilation Map"))(POS (PAPER.PUBLICATION DARWICHE2002 "Journal of Artificial Intelligence Research"))(POS (PAPER.VOLUME DARWICHE2002 "17"))(POS (PAPER.STARTPAGE DARWICHE2002 229))(POS (PAPER.ENDPAGE DARWICHE2002 264))(POS (PAPER.LINK DARWICHE2002 "http://citeseer.ist.psu.edu/497263.html"))(POS (PAPER.YEAR DARWICHE2002 2002))(POS (PAPER.DESCRIPTION DARWICHE2002 "
The authors analyze knowledge compilation on two axes: the succinctness of
the target language and the class of queries and transformations that the
language supports in polytime.  They analyze a large number of existing
approaches.
"))(POS (PAPER.TOPIC DARWICHE2002 "Knowledge Base Compilation"))(POS (PAPER.INSTANCE DAVIS60))(POS (PAPER.BIBTEX DAVIS60 ARTICLE))(POS (PAPER.AUTHOR DAVIS60 "M. Davis and H. Putnam"))(POS (PAPER.TITLE DAVIS60 "A Machine Program for Theorem Proving"))(POS (PAPER.PUBLICATION DAVIS60 "Journal of the ACM"))(POS (PAPER.VOLUME DAVIS60 "7"))(POS (PAPER.STARTPAGE DAVIS60 201))(POS (PAPER.ENDPAGE DAVIS60 215))(POS (PAPER.YEAR DAVIS60 1960))(POS (PAPER.DESCRIPTION DAVIS60 "
One of the DPLL papers.
"))(POS (PAPER.TOPIC DAVIS60 "Calculi"))(POS (PAPER.INSTANCE DAVIS62))(POS (PAPER.BIBTEX DAVIS62 ARTICLE))(POS (PAPER.AUTHOR DAVIS62 "M. Davis and G. Logemann an D. Loveland"))(POS (PAPER.TITLE DAVIS62 "A Computing Procedure for Quantification Theory"))(POS (PAPER.PUBLICATION DAVIS62 "Communications of the ACM"))(POS (PAPER.VOLUME DAVIS62 "5"))(POS (PAPER.STARTPAGE DAVIS62 394))(POS (PAPER.ENDPAGE DAVIS62 397))(POS (PAPER.YEAR DAVIS62 1962))(POS (PAPER.DESCRIPTION DAVIS62 "
One of the DPLL papers.
"))(POS (PAPER.TOPIC DAVIS62 "Calculi"))(POS (PAPER.INSTANCE DAVIS94))(POS (PAPER.BIBTEX DAVIS94 TECHREPORT))(POS (PAPER.AUTHOR DAVIS94 "Ernest Davis"))(POS (PAPER.TITLE DAVIS94 "Lucid Representations"))(POS (PAPER.PUBLISHER DAVIS94 "New York University"))(POS (PAPER.LINK DAVIS94 "http://citeseer.ist.psu.edu/davis94lucid.html"))(POS (PAPER.YEAR DAVIS94 1994))(POS (PAPER.RANK DAVIS94 "[****]"))(POS (PAPER.DESCRIPTION DAVIS94 "
Davis writes Lucid Representations in part to argue Levesque's
Making Believers Out of Computers paper.  Davis claims Levesque argues
that the only representations one should allow are complete ones,
in the database sense to ensure reasoning is fast.  Davis argues
that no AI system could get by with only complete information.
Incomplete information is imperative.  Davis attempts to propose
a technique for achieving the benefits of complete information
from starting from incomplete information by first instantiating
to complete the theory, then reasoning quickly, and finally 
ignoring those results which were artificially  introduced by
the process of instantiation.  This is a position piece trying to
refute Levesque's vision of the future and replacing
it with a vision of its own.
"))(POS (PAPER.TOPIC DAVIS94 "Logical Knowledge Representation"))(POS (PAPER.INSTANCE DEBRAY93))(POS (PAPER.BIBTEX DEBRAY93 ARTICLE))(POS (PAPER.AUTHOR DEBRAY93 "Saumya Debray and Nai-Wei Lin"))(POS (PAPER.TITLE DEBRAY93 "Cost Analysis of Logic Programs"))(POS (PAPER.PUBLICATION DEBRAY93 "ACM Transactions on Programming Languages and Systems>"))(POS (PAPER.VOLUME DEBRAY93 "15(5)"))(POS (PAPER.STARTPAGE DEBRAY93 826))(POS (PAPER.ENDPAGE DEBRAY93 875))(POS (PAPER.YEAR DEBRAY93 1993))(POS (PAPER.DESCRIPTION DEBRAY93 "
Debray and Lin outline techniques for computing upper bounds on the cost
of a logic program, taking in account multiple solutions and nondeterminism.
Based on relationship between argument size, moded relations, and typed 
relations.
"))(POS (PAPER.TOPIC DEBRAY93 "Logic Programming"))(POS (PAPER.INSTANCE DECHTER92))(POS (PAPER.BIBTEX DECHTER92 ARTICLE))(POS (PAPER.AUTHOR DECHTER92 "Rina Dechter and Judea Pearl"))(POS (PAPER.TITLE DECHTER92 "Structure Identificatioin in Relational Data"))(POS (PAPER.PUBLICATION DECHTER92 "Artificial Intelligence"))(POS (PAPER.VOLUME DECHTER92 "58(1-3)"))(POS (PAPER.STARTPAGE DECHTER92 237))(POS (PAPER.ENDPAGE DECHTER92 270))(POS (PAPER.LINK DECHTER92 "http://citeseer.ist.psu.edu/dechter97structure.html"))(POS (PAPER.YEAR DECHTER92 1992))(POS (PAPER.RANK DECHTER92 "[**]"))(POS (PAPER.DESCRIPTION DECHTER92 "
Dechter and Pearl describe building a propositional Horn representation
of a given set of models.  Identifying whether such a representation 
exists turns out to be polynomial in the size of the models.  Building
such a representation is polynomial in the size of the models and
the number of variables.  For k-Horn theories, a tightest approximation
can also be calculated in polynomial time.  
"))(POS (PAPER.TOPIC DECHTER92 "Knowledge Base Compilation"))(POS (PAPER.INSTANCE DELVAL96))(POS (PAPER.BIBTEX DELVAL96 INPROCEEDINGS))(POS (PAPER.AUTHOR DELVAL96 "Alvaro del Val"))(POS (PAPER.TITLE DELVAL96 "Approximate Knowledge Compilation: The First Order Case"))(POS (PAPER.PUBLICATION DELVAL96 "AAAI"))(POS (PAPER.STARTPAGE DELVAL96 498))(POS (PAPER.ENDPAGE DELVAL96 503))(POS (PAPER.LINK DELVAL96 "http://citeseer.ist.psu.edu/delval96approximate.html"))(POS (PAPER.YEAR DELVAL96 1996))(POS (PAPER.RANK DELVAL96 "[****]"))(POS (PAPER.DESCRIPTION DELVAL96 "
This seems to be the seminal work on Knowledge Compilation for FOL.  
del Val introduces a new algorithm for computing the Least Upper
Bound approximation for a propositional knowledge base, at times
exponentially better than the previously known algorithm.  He then
lifts both algorithms to first order logic under some restrictions.
"))(POS (PAPER.TOPIC DELVAL96 "Knowledge Base Compilation"))(POS (PAPER.RELATED DELVAL96 SELMAN91))(POS (PAPER.INSTANCE DERSHOWITZ82))(POS (PAPER.AUTHOR DERSHOWITZ82 "Nachum Dershowitz"))(POS (PAPER.TITLE DERSHOWITZ82 "Orderings for Term-rewriting Systems"))(POS (PAPER.PUBLICATION DERSHOWITZ82 "Theoretical Computer Science"))(POS (PAPER.VOLUME DERSHOWITZ82 "17"))(POS (PAPER.STARTPAGE DERSHOWITZ82 279))(POS (PAPER.ENDPAGE DERSHOWITZ82 301))(POS (PAPER.LINK DERSHOWITZ82 "http://citeseer.ist.psu.edu/context/20249/0"))(POS (PAPER.YEAR DERSHOWITZ82 1982))(POS (PAPER.DESCRIPTION DERSHOWITZ82 "
This paper confronts termination in term-rewriting systems.  
Dershowitz first defines the notion of a non-terminating rewrite system,
i.e. one with an infinite homeomorphic self-embedding derivation.  Then
he defines a simplification ordering as a partial ordering with
the replacement (monotonicity), subterm, and deletion properties.  If there
is a simplification ordering for a term rewriting system such that l > r for
every rewrite rule l -> r then the rewrite system terminates.  Dershowitz
goes on to define a quasi-simplification ordering, which is weaker than
a simplification ordering, making it easier to prove rewrite systems
terminate.  The reason this paper is located in this section is that
the notion of a recursive path ordering is then defined.  RPO and
variants thereof are used in modern theorem provers when ordering
is necessary.  The last section goes through a series of examples
that demonstrate how to prove rewrite systems terminate.
"))(POS (PAPER.TOPIC DERSHOWITZ82 "Orderings"))(POS (PAPER.INSTANCE DERSHOWITZ93))(POS (PAPER.BIBTEX DERSHOWITZ93 INBOOK))(POS (PAPER.AUTHOR DERSHOWITZ93 "Nachum Dershowitz"))(POS (PAPER.TITLE DERSHOWITZ93 "A Taste of Rewrite Systems"))(POS (PAPER.PUBLICATION DERSHOWITZ93 "Functional Programming, Concurrency, Simulation, and
Automated Reasoning"))(POS (PAPER.STARTPAGE DERSHOWITZ93 199))(POS (PAPER.ENDPAGE DERSHOWITZ93 228))(POS (PAPER.LINK DERSHOWITZ93 "http://citeseer.ist.psu.edu/dershowitz93taste.html"))(POS (PAPER.YEAR DERSHOWITZ93 1993))(POS (PAPER.RANK DERSHOWITZ93 ""))(POS (PAPER.DESCRIPTION DERSHOWITZ93 "
Dershowitz gives a whirlwind tour of rewrite systems, covering the
basic properties termination (existence of normal forms), 
confluence (the uniqueness of those forms), completion (how to construct 
confluent systems), checking entailment and solving equations via 
basically abduction.  He also discusses special techniques for dealing
with associative and commutative systems and conditional rewriting rules.
Applications include theorem proving and programming
"))(POS (PAPER.TOPIC DERSHOWITZ93 "Theorem Proving"))(POS (PAPER.INSTANCE DOYLE91))(POS (PAPER.BIBTEX DOYLE91 ARTICLE))(POS (PAPER.AUTHOR DOYLE91 "Jon Doyle and Ramesh Patil"))(POS (PAPER.TITLE DOYLE91 "Two Theses of Knowledge Representation: Language Restrictions, Taxonomic Classification, and the Utility of Representation Services"))(POS (PAPER.PUBLICATION DOYLE91 "Artificial Intelligence"))(POS (PAPER.VOLUME DOYLE91 "48(3)"))(POS (PAPER.STARTPAGE DOYLE91 261))(POS (PAPER.ENDPAGE DOYLE91 298))(POS (PAPER.LINK DOYLE91 "http://citeseer.ist.psu.edu/doyle91two.html"))(POS (PAPER.YEAR DOYLE91 1991))(POS (PAPER.RANK DOYLE91 "[****]"))(POS (PAPER.DESCRIPTION DOYLE91 "
Doyle and Patil argue against Levesque and Brachman's position that a
general purpose KB system must be able to answer all questions 
in a bounded amount of time.  In particular, they examine KL-ONE
and its variants, enumerating classes of problems that a restricted
language cannot express but that would be natural for use in a KB
system.  They argue that worst-case complexity is the right measure for
just a small fraction of all potential applications of a Knowledge-based
system.  
"))(POS (PAPER.TOPIC DOYLE91 "Logical Knowledge Representation"))(POS (PAPER.INSTANCE DYMETMAN91))(POS (PAPER.BIBTEX DYMETMAN91 ARTICLE))(POS (PAPER.AUTHOR DYMETMAN91 "M. Dymetman"))(POS (PAPER.TITLE DYMETMAN91 "Inherently Reversible Grammars, Logic Programming and Computability"))(POS (PAPER.LINK DYMETMAN91 "http://acl.ldc.upenn.edu/W/W91/W91-0104.pdf"))(POS (PAPER.YEAR DYMETMAN91 1991))(POS (PAPER.RANK DYMETMAN91 "[***]"))(POS (PAPER.DESCRIPTION DYMETMAN91 "
Dymetman offers a decoupling of the term reversible grammar into (1)
uniformity of implementation for parsers and generators and (2) 
reversibility as an inherent property of a grammar.  He formalizes
the second idea, which includes various notions about the completeness
and termination of answer extraction for logic programming.
"))(POS (PAPER.TOPIC DYMETMAN91 "Natural Language Processing"))(POS (PAPER.INSTANCE EBBINGHAUS))(POS (PAPER.BIBTEX EBBINGHAUS BOOK))(POS (PAPER.AUTHOR EBBINGHAUS "Heinz-Dieter Ebbinghaus and Jorg Flum"))(POS (PAPER.TITLE EBBINGHAUS "Finite Model Theory"))(POS (PAPER.PUBLISHER EBBINGHAUS "Springer-Verlag"))(POS (PAPER.LINK EBBINGHAUS "http://www.amazon.com/Finite-Theory-Springer-Monographs-Mathematics/dp/3540287876"))(POS (PAPER.YEAR EBBINGHAUS 1999))(POS (PAPER.RANK EBBINGHAUS "[*****]"))(POS (PAPER.DESCRIPTION EBBINGHAUS "
The authors introduce Finite Model Theory, a logic that is identical to first-order
logic but where a model is defined as having a finite universe.  Topics covered
include Ehrenfeucht-Fraisse Method, 01 laws, finite automata, descriptive
complexity theory, fixed-point operators, logic programs, logics for PTIME, 
and logical reductions.
"))(POS (PAPER.TOPIC EBBINGHAUS ""))(POS (PAPER.INSTANCE EITER2001))(POS (PAPER.BIBTEX EITER2001 INPROCEEDINGS))(POS (PAPER.AUTHOR EITER2001 "Thomas Eiter and Toshihide Ibaraki and Kazuhisa Makino"))(POS (PAPER.TITLE EITER2001 "Disjunctions of Horn Theories and their Cores"))(POS (PAPER.PUBLICATION EITER2001 "ISAAC"))(POS (PAPER.LINK EITER2001 "http://citeseer.ist.psu.edu/eiter01disjunctions.html"))(POS (PAPER.YEAR EITER2001 2001))(POS (PAPER.RANK EITER2001 "[*]"))(POS (PAPER.DESCRIPTION EITER2001 "
This paper studies the problem of determining whether a disjunction of 
Horn theories is Horn and if not computing a Horn core and envelope.
Eiter et. al. investigate both the characteristic model representation
of Horn theories and the CNF representation.  For both representations 
the problem is intractable.
"))(POS (PAPER.TOPIC EITER2001 "Characteristic Models"))(POS (PAPER.INSTANCE EITER2004))(POS (PAPER.BIBTEX EITER2004 INPROCEEDINGS))(POS (PAPER.AUTHOR EITER2004 "Thomas Eiter and Thomas Lukasiewicz and Roman Schindlauer and Hans Tompits"))(POS (PAPER.TITLE EITER2004 "Combining Answer Set Programming with Description Logics for the Semantic Web"))(POS (PAPER.PUBLICATION EITER2004 "Proceedings of Knowledge Representation and Reasoning"))(POS (PAPER.LINK EITER2004 "http://citeseer.ist.psu.edu/727609.html"))(POS (PAPER.YEAR EITER2004 2004))(POS (PAPER.DESCRIPTION EITER2004 "
A language that integrates SHIF(D) and SHOIN(D) with answer set programming
"))(POS (PAPER.TOPIC EITER2004 "Semantic Web"))(POS (PAPER.INSTANCE EITER98))(POS (PAPER.BIBTEX EITER98 INPROCEEDINGS))(POS (PAPER.AUTHOR EITER98 "Thomas Eiter and Thoshihide Ibaraki and Kazuhisa Makino"))(POS (PAPER.TITLE EITER98 "Computing Intersections of Horn Theories for Reasoning with Models"))(POS (PAPER.PUBLICATION EITER98 "AAAI"))(POS (PAPER.LINK EITER98 "http://citeseer.ist.psu.edu/537461.html"))(POS (PAPER.YEAR EITER98 1998))(POS (PAPER.RANK EITER98 "[****]"))(POS (PAPER.DESCRIPTION EITER98 "
The authors examine complexity issues that arise when intersecting several
propositional horn knowledge bases, which are represented with 
characteristic models.  Finding
the unique minimal model (which is a characteristic model) can be done
in linear time in the number of KBs.  Finding all-models can be solved
with polynomial delay (a polynomial amount of time between outputting
models).  In a sense, that means the procedure is polynomial, but the 
number of outputs could be exponential.  Finding all characteristic
models of the intersection has no polynomial time algorithm (even if
P = NP).  Answering deductive queries can still be accomplished in
polynomial time by looking at each KB independently.  Finally, abduction
is shown to be intractable, which differs from the result of a single
KB (where it is polynomial).
"))(POS (PAPER.TOPIC EITER98 "Characteristic Models"))(POS (PAPER.INSTANCE ENDERTON))(POS (PAPER.BIBTEX ENDERTON BOOK))(POS (PAPER.AUTHOR ENDERTON "Herbert Enderton"))(POS (PAPER.TITLE ENDERTON "A Mathematical Introduction to Logic"))(POS (PAPER.PUBLISHER ENDERTON "Academic Press"))(POS (PAPER.LINK ENDERTON "http://www.amazon.com/exec/obidos/tg/detail/-/0122384520/qid=1062605496/sr=1-6/ref=sr_1_6/102-6107129-2481765?v=glance&s=books"))(POS (PAPER.YEAR ENDERTON 2000))(POS (PAPER.RANK ENDERTON "[*****]"))(POS (PAPER.DESCRIPTION ENDERTON "
The definitive text on introductory mathematical logic.  Enderton covers both 
propositional (sentential),  and first-order logic including compactness, completeness,
and soundness proofs.  The third chapter covers undecidability, Godel's 
incompleteness proof, and Church's and Tarski's theorems.  The last chapter
covers second-order logic. 
"))(POS (PAPER.TOPIC ENDERTON ""))(POS (PAPER.INSTANCE ETHERINGTON89))(POS (PAPER.BIBTEX ETHERINGTON89 ARTICLE))(POS (PAPER.AUTHOR ETHERINGTON89 "David Etherington and Alex Borgida and Ronald Brachman and Henry Kautz"))(POS (PAPER.TITLE ETHERINGTON89 "Vivid Knowledge and Tractable Reasoning"))(POS (PAPER.PUBLICATION ETHERINGTON89 "IJCAI"))(POS (PAPER.STARTPAGE ETHERINGTON89 1146))(POS (PAPER.ENDPAGE ETHERINGTON89 1152))(POS (PAPER.LINK ETHERINGTON89 "http://citeseer.ist.psu.edu/etherington89vivid.html"))(POS (PAPER.YEAR ETHERINGTON89 1989))(POS (PAPER.RANK ETHERINGTON89 "[****]"))(POS (PAPER.DESCRIPTION ETHERINGTON89 "
Etherington, et.al. give a preliminary description of representing a KB with a set of atoms.  They try to motivate the work by appealing to the speed of humans' commonsense reasoning facilities as evidence that much such reasoning is done via lookup.   A set of atoms is not very expressive, so the first extension is to allow definite clauses: a(x)=>b(x).  To deal with this they use a closed world assumption.  Second extension tries to deal with disjunction: age(joe,53) | age(joe,55) is replaced by age(joe,x)^in50s(x).  Third extension uses skolems to remove disjunction: p(a) | p(b) becomes p(k). 
"))(POS (PAPER.TOPIC ETHERINGTON89 "Logical Knowledge Representation"))(POS (PAPER.INSTANCE FAGIN82))(POS (PAPER.BIBTEX FAGIN82 ARTICLE))(POS (PAPER.AUTHOR FAGIN82 "Ronald Fagin"))(POS (PAPER.TITLE FAGIN82 "Horn Clauses and Database Dependencies"))(POS (PAPER.PUBLICATION FAGIN82 "Journal of the ACM"))(POS (PAPER.VOLUME FAGIN82 "29(4)"))(POS (PAPER.STARTPAGE FAGIN82 952))(POS (PAPER.ENDPAGE FAGIN82 985))(POS (PAPER.LINK FAGIN82 "http://citeseer.ist.psu.edu/context/62052/0"))(POS (PAPER.YEAR FAGIN82 1982))(POS (PAPER.RANK FAGIN82 "[****]"))(POS (PAPER.DESCRIPTION FAGIN82 "
Fagin generalizes dependencies in the database literature and
shows the following are all equivalent for a given set of sentences
S.  1) There is an operator O that maps nonempty families of models
into models such that if sigma is a sentence in S and R_i is a
nonempty family of models, then sigma holds for O(R_i) iff sigma
holds for each R_i.  2) Whenever Sigma is a consistent subset of S
and Sigma* is the set of sentences in S that are logical consequences
of Sigma, there is an Armstrong model--it obeys Sigma* and no other
sentences in S.  3) Whenever Sigma is a subset of S and phi_i is a 
nonempty subset of S then Sigma |= V phi_i iff there is some i for
which Sigma |= phi_i.  For FOL in general, there is no Armstrong relation for 
first-order axiom sets.  Take the empty set of axioms, and assume
there is an Armstrong relation R.  R will either entail or not
entail any non-tautology sigma, which means R is not an Armstrong
relation for the axiom set.  A corollary to this theorem shows
that any axiom set Delta in a Horn-related subset of FOL can be
represented with a single, infinite model.
"))(POS (PAPER.TOPIC FAGIN82 "Characteristic Models"))(POS (PAPER.INSTANCE FIKES71))(POS (PAPER.AUTHOR FIKES71 "R.E. Fikes and N.J. Nilsson"))(POS (PAPER.TITLE FIKES71 "STRIPS: a new approach to the application of theorem proving to problem solving"))(POS (PAPER.PUBLICATION FIKES71 "Artificial Intelligence"))(POS (PAPER.VOLUME FIKES71 "2(3-4)"))(POS (PAPER.STARTPAGE FIKES71 189))(POS (PAPER.ENDPAGE FIKES71 208))(POS (PAPER.YEAR FIKES71 1971))(POS (PAPER.DESCRIPTION FIKES71 "
The STRIPS paper.  Fikes and Nilsson allow first-order formulas to describe the action preconditions and effects (add/delete lists) but maintain that each operator instanatiation must be ground.  They note that the case of non-ground instantiations needs more study.  Interestingly, they generate successor states in the search tree using a form of residue from a proof that a given world state achieves a given subgoal.  They implement a world state as being a set of changes from the initial state.
"))(POS (PAPER.TOPIC FIKES71 "Historical"))(POS (PAPER.INSTANCE FIKES72))(POS (PAPER.AUTHOR FIKES72 "Richard Fikes, Peter Hart and Nils Nilsson"))(POS (PAPER.TITLE FIKES72 "Learning and Executing Generalized Robot Plans"))(POS (PAPER.PUBLICATION FIKES72 "Artificial Intelligence"))(POS (PAPER.VOLUME FIKES72 "3(4)"))(POS (PAPER.STARTPAGE FIKES72 251))(POS (PAPER.ENDPAGE FIKES72 288))(POS (PAPER.YEAR FIKES72 1972))(POS (PAPER.DESCRIPTION FIKES72 "
Fikes, Hart, and Nillson take a STRIPS planner, 1) describe a concise
representation for plans (triangle tables), 2) develop a method for
generalizing plans to make new primitive actions (MACROPs), 3) describe
an execution engine (PLANEX) that uses these Macrops that does replanning and
handles coincidental goal achievement.  They go on to describe needed future
improvements: 1) creating a set of abstractions for the new primitives actions
to avoid dealing with large numbers of preconditions and 2) discarding
subsumed or otherwise unused primitive operators to avoid an ever-growing
operator set.
"))(POS (PAPER.TOPIC FIKES72 "Historical"))(POS (PAPER.INSTANCE FIKES93))(POS (PAPER.AUTHOR FIKES93 "R.E. Fikes and N.J. Nilsson"))(POS (PAPER.TITLE FIKES93 "STRIPS, a retrospective"))(POS (PAPER.PUBLICATION FIKES93 "Artificial Intelligence"))(POS (PAPER.VOLUME FIKES93 "59(1-2)"))(POS (PAPER.STARTPAGE FIKES93 227))(POS (PAPER.ENDPAGE FIKES93 232))(POS (PAPER.YEAR FIKES93 1993))(POS (PAPER.DESCRIPTION FIKES93 "
This short paper puts the STRIPS work in a historical context, examining both the plan generator and execution monitor.  Green's work on deductive plan synthesis was the first real planner, but most researchers didn't explore monitoring execution (they were assuming computational environments).  Fikes and Nilsson used 'kernels' to represent the sentences that must be true at each stage of the plan for the rest of the plan to succeed.  They also used the notion of a 'triangle table' to represent plans so that serendipitous acts and action-failure-but-that's-all-you-can-do-so-just-try-again events would not require replanning.
"))(POS (PAPER.TOPIC FIKES93 "Historical"))(POS (PAPER.INSTANCE FITTING2007))(POS (PAPER.BIBTEX FITTING2007 ARTICLE))(POS (PAPER.AUTHOR FITTING2007 "Melvin Fitting"))(POS (PAPER.TITLE FITTING2007 "Intensional Logic"))(POS (PAPER.PUBLICATION FITTING2007 "The Stanford Encyclopedia of Philosophy (Spring 2007 Edition), Edward N. Zalta (ed.)"))(POS (PAPER.LINK FITTING2007 "http://plato.stanford.edu/archives/spr2007/entries/logic-intensional/"))(POS (PAPER.YEAR FITTING2007 2007))(POS (PAPER.DESCRIPTION FITTING2007 "
The mathematical foundations of logical query languages.
"))(POS (PAPER.TOPIC FITTING2007 "Logical Knowledge Representation"))(POS (PAPER.INSTANCE FOLLETT80))(POS (PAPER.BIBTEX FOLLETT80 ARTICLE))(POS (PAPER.AUTHOR FOLLETT80 "Ria Follett"))(POS (PAPER.TITLE FOLLETT80 "Synthesising Recursive Functions with Side Effects"))(POS (PAPER.PUBLICATION FOLLETT80 "Artificial Intelligence"))(POS (PAPER.VOLUME FOLLETT80 "13:3"))(POS (PAPER.STARTPAGE FOLLETT80 175))(POS (PAPER.ENDPAGE FOLLETT80 200))(POS (PAPER.YEAR FOLLETT80 1980))(POS (PAPER.RANK FOLLETT80 "[*]"))(POS (PAPER.DESCRIPTION FOLLETT80 "
"))(POS (PAPER.TOPIC FOLLETT80 "Theorem Proving with Attachments"))(POS (PAPER.INSTANCE FRANCONI2004))(POS (PAPER.BIBTEX FRANCONI2004 INPROCEEDINGS))(POS (PAPER.AUTHOR FRANCONI2004 "Enrico Franconi and Sergio Tessaris"))(POS (PAPER.TITLE FRANCONI2004 "Rules and Queries with Ontologies: A Unified Logical Framework"))(POS (PAPER.PUBLICATION FRANCONI2004 "Proceedings of Principles and Practice of Semantic Web Reasoning"))(POS (PAPER.LINK FRANCONI2004 "http://www.springerlink.com/content/1hnwcggw510elp4y/"))(POS (PAPER.YEAR FRANCONI2004 2004))(POS (PAPER.DESCRIPTION FRANCONI2004 "
A comparison of various techniques for integrating logic programming with 
description logics.
"))(POS (PAPER.TOPIC FRANCONI2004 "Semantic Web"))(POS (PAPER.INSTANCE GAMMER2007))(POS (PAPER.BIBTEX GAMMER2007 INPROCEEDINGS))(POS (PAPER.AUTHOR GAMMER2007 "Igor Gammer and Eyal Amir"))(POS (PAPER.TITLE GAMMER2007 "Solving Satisfiability in Ground Logic with Equality by Efficient Conversion to Propositional Logic"))(POS (PAPER.PUBLICATION GAMMER2007 "Proc. 7th Symposium on Abstraction, Reformulation, and Approximation"))(POS (PAPER.LINK GAMMER2007 "http://reason.cs.uiuc.edu/eyal/paper.html"))(POS (PAPER.YEAR GAMMER2007 2007))(POS (PAPER.DESCRIPTION GAMMER2007 "
The authors consider ground first-order logic with equality and show
how one can employ Craig's Interpolation theorem to reduce the cost
of grounding out the usual axiomatization of equality.
"))(POS (PAPER.TOPIC GAMMER2007 "Reformulation"))(POS (PAPER.INSTANCE GEDDIS95))(POS (PAPER.BIBTEX GEDDIS95 PHDTHESIS))(POS (PAPER.AUTHOR GEDDIS95 "Don Geddis"))(POS (PAPER.TITLE GEDDIS95 "Caching and Non-Horn Inference in Model Elimination Theorem Provers"))(POS (PAPER.PUBLISHER GEDDIS95 "Stanford University"))(POS (PAPER.LINK GEDDIS95 "http://library.stanford.edu/depts/mathcs/mathcscoll/techreports.html"))(POS (PAPER.YEAR GEDDIS95 1995))(POS (PAPER.RANK GEDDIS95 "[***]"))(POS (PAPER.DESCRIPTION GEDDIS95 "
Geddis investigates Nonhorn caching for model elimination.  Astrachan and
Stickel did the seminal work on caching for the Horn case.  Nonhorn
caching is made difficult by the reduction operation, i.e. proofs of
subgoals are context dependent.  Previous work stored the context and
the proven subgoal.  Geddis shows that if a literal has a completion in
one context, it has a completion in every context.  Thus, if a subgoal
cannot be completed, it can be added to a failure cache.  A completion is
not the same as a proof, however, and there are no results for success
caching.  If a depth-limited search-strategy is used, incompleteness can
result; Geddis found no solution for this problem.  Also discussed is an
extension to David Smith's work: postponement caching.  It basically avoids
infinite recursions if possible by 'enslaving' a subgoal to an ancestor
if the two unify.  It is complete for Horn and incomplete for nonHorn.
"))(POS (PAPER.TOPIC GEDDIS95 "Theorem Proving with Attachments"))(POS (PAPER.INSTANCE GELERNTER63))(POS (PAPER.BIBTEX GELERNTER63 ARTICLE))(POS (PAPER.AUTHOR GELERNTER63 "H. Gelernter"))(POS (PAPER.TITLE GELERNTER63 "Realization of a Geometry-Theorem Proving Machine"))(POS (PAPER.PUBLICATION GELERNTER63 "Computers and Thought"))(POS (PAPER.STARTPAGE GELERNTER63 134))(POS (PAPER.ENDPAGE GELERNTER63 152))(POS (PAPER.YEAR GELERNTER63 1963))(POS (PAPER.RANK GELERNTER63 "[*]"))(POS (PAPER.DESCRIPTION GELERNTER63 "
Gelernter describes the Geometry Machine, an ad hoc theorem prover
for Euclidian geometry.  It uses a diagram as a heuristic to guide
the theorem prover's search, eliminating subgoals when not 
satisfied by the diagram.  Sometimes that diagram prunes too much,
in which case multiple diagrams need to be generated to achieve
completeness.  The system is also unique in the fact that it does
not give the theorem prover a complete axiomitization of geometry,
but rather allows it to add axioms that are 'obvious' from the 
diagram, much as a human might do.
"))(POS (PAPER.TOPIC GELERNTER63 "Graphical Reasoning Techniques"))(POS (PAPER.INSTANCE GELFOND88))(POS (PAPER.BIBTEX GELFOND88 ARTICLE))(POS (PAPER.AUTHOR GELFOND88 "Michael Gelfond and Vladimir Lifschitz"))(POS (PAPER.TITLE GELFOND88 "The Stable Model Semantics for Logic Programming"))(POS (PAPER.PUBLICATION GELFOND88 "Proceedings of the Fifth International Conference on Logic Programming"))(POS (PAPER.STARTPAGE GELFOND88 1070))(POS (PAPER.ENDPAGE GELFOND88 1080))(POS (PAPER.LINK GELFOND88 "http://citeseer.ist.psu.edu/gelfond88stable.html"))(POS (PAPER.YEAR GELFOND88 1988))(POS (PAPER.DESCRIPTION GELFOND88 "
Stable model semantics for logic programming.
"))(POS (PAPER.TOPIC GELFOND88 "Logic Programming"))(POS (PAPER.INSTANCE GENESERETH87))(POS (PAPER.BIBTEX GENESERETH87 BOOK))(POS (PAPER.AUTHOR GENESERETH87 "Michael Genesereth and Nils Nilsson"))(POS (PAPER.TITLE GENESERETH87 "Logical Foundations of Artificial Intelligence"))(POS (PAPER.PUBLISHER GENESERETH87 "Morgan Kaufmann Publishers"))(POS (PAPER.LINK GENESERETH87 "http://www.amazon.com/Foundations-Artificial-Intelligence-Michael-Genesereth/dp/0934613311"))(POS (PAPER.YEAR GENESERETH87 1987))(POS (PAPER.RANK GENESERETH87 "[*****]"))(POS (PAPER.DESCRIPTION GENESERETH87 "
Genesereth and Nilsson construct the foundations of AI using logic.  Covers logic, resolution and various strategies, nonmonotonic reasoning, induction, uncertainty, belief,
metaknowledge and metareasoning, a changing environment, and agent architectures.
"))(POS (PAPER.TOPIC GENESERETH87 ""))(POS (PAPER.INSTANCE GIACOMO2000))(POS (PAPER.AUTHOR GIACOMO2000 "G. De Giacomo, Y. Lesperance, and H.J. Levesque"))(POS (PAPER.TITLE GIACOMO2000 "ConGolog, a concurrent prrogramming language based on the situation calculus"))(POS (PAPER.PUBLICATION GIACOMO2000 "Artificial Intelligence"))(POS (PAPER.VOLUME GIACOMO2000 "121"))(POS (PAPER.STARTPAGE GIACOMO2000 109))(POS (PAPER.ENDPAGE GIACOMO2000 169))(POS (PAPER.LINK GIACOMO2000 "http://www.cs.yorku.ca/~lesperan/publications.html"))(POS (PAPER.YEAR GIACOMO2000 2000))(POS (PAPER.DESCRIPTION GIACOMO2000 "
ConGolog extends Golog (both implementations being in Prolog) to include concurrent actions (conceptualized as interleaving actions of different processes that can block, in the OS sense).  The constructs introduced here include synchronized conditionals (test-and-set), synchronized loops, concurrent execution, concurrency with different priorities (the lower priority process can only execute if the higher priority one is blocked or finished), concurrent iteration, and interrupts.  Nondeterminstic iteration can be useful when an unspecified number of programs need to be run concurrently, e.g. an FTP server.  Some more work is required to handle procedures.  The semantics given in the original Golog paper were evaluation semantics.  Here the authors switch to transition semantics and require all the macros of Golog to become embedded in the language.
Exogenous events are handled by allowing the user to specify which primitive actions may occurs outside the control of the program.  A predefined program for choosing a possible exogenous action, checking its preconditions, and executing it if possible is run concurrently with the user-defined program. To handle truly overlapping actions such as filling-bath-tub and singing-do-re-mi, the authors suggest thinking of filling-bath-tub as not an action, but rather as a state, which requires the start-filling action to enter the state and the stop-filling action to exit the state.  This way, interleaving filling-bath-tub and singing-do-re-mi can happen at the same time.
"))(POS (PAPER.TOPIC GIACOMO2000 "Logic Programming"))(POS (PAPER.INSTANCE GIUNCHIGLIA92))(POS (PAPER.BIBTEX GIUNCHIGLIA92 ARTICLE))(POS (PAPER.AUTHOR GIUNCHIGLIA92 "Fausto Giunchiglia and Toby Walsh"))(POS (PAPER.TITLE GIUNCHIGLIA92 "A theory of abstraction"))(POS (PAPER.PUBLICATION GIUNCHIGLIA92 "Artificial Intelligence"))(POS (PAPER.VOLUME GIUNCHIGLIA92 "57"))(POS (PAPER.STARTPAGE GIUNCHIGLIA92 323))(POS (PAPER.ENDPAGE GIUNCHIGLIA92 389))(POS (PAPER.LINK GIUNCHIGLIA92 "http://citeseer.ist.psu.edu/27696.html"))(POS (PAPER.YEAR GIUNCHIGLIA92 1992))(POS (PAPER.RANK GIUNCHIGLIA92 "[****]"))(POS (PAPER.DESCRIPTION GIUNCHIGLIA92 "
Giunchiglia and Walsh describe a theory of abstraction in very general terms,
which is intended to be independent of proof system.  Most generally,
an abstraction is a mapping between a pair of formal systems, where a
formal system consists of a language and a subset of that language defining
the axioms.  Axiomatic formal systems include an extra element: the
proof system.  Abstractions are categorized by whether they increase, decrease, or
leave constant the set of consequences of the theory: TI, TD, TC.  The authors
claim the TI abstractions is the true meaning of abstraction.  TD abstractions
can be used to prove entailment, i.e. if TD(Delta) |= phi then Delta |= phi.
TI abstractions can be used to prove negative entailment, i.e. if
TI(Delta) |/= phi then Delta |/= phi.  Refutation systems are concerned
not with provability but with inconsistency.  Abstractions in this setting
are characterized as NTI, NTD, and NTC.  If the formal system includes
negation and the abstraction f is negation preserving, i.e. f(-phi) = -f(phi)
then NT* and T* are equivalent.  Further classifications are made of abstractions,
depending on how independently an abstraction translates axioms, inference rules, etc.
A large section explaining how various peoples' work fits into this framework follows.
Then sections follow on inconsistent abstract spaces, operations performed
on abstractions, ordering abstractions, hierarchies of abstraction spaces, and building
abstractions.
"))(POS (PAPER.TOPIC GIUNCHIGLIA92 "Abstraction"))(POS (PAPER.INSTANCE GIUNCHIGLIA96REASONING))(POS (PAPER.BIBTEX GIUNCHIGLIA96REASONING INPROCEEDINGS))(POS (PAPER.AUTHOR GIUNCHIGLIA96REASONING "Fausto Giunchiglia and Paolo Pecchiari and Carolyn Talcott"))(POS (PAPER.TITLE GIUNCHIGLIA96REASONING "Reasoning Theories - Towards an Architecture for Open Mechanized Reasoning Systems"))(POS (PAPER.PUBLICATION GIUNCHIGLIA96REASONING "1st International Workshop: Frontiers of Combining Systems
           "))(POS (PAPER.STARTPAGE GIUNCHIGLIA96REASONING 157))(POS (PAPER.ENDPAGE GIUNCHIGLIA96REASONING 174))(POS (PAPER.LINK GIUNCHIGLIA96REASONING "http://citeseer.ist.psu.edu/354680.html"))(POS (PAPER.YEAR GIUNCHIGLIA96REASONING 1996))(POS (PAPER.RANK GIUNCHIGLIA96REASONING "[***]"))(POS (PAPER.DESCRIPTION GIUNCHIGLIA96REASONING "Giunchiglia et al. describe a formalization of logical reasoners.  Such
reasoners (quoting) might be based on different logics; have different domain models;
use different vocabularies and data structures; use different reasoning
strategies; and have different interaction capabilities.  The authors
put forth a general architecture called Open Mechanized Reasoning Systems
(OMRS) for integrating reasoners described by what they call a
Reasoning Theory.  They use NQTHM as an example to illustrate the construction
of a Reasoning Theory.
"))(POS (PAPER.TOPIC GIUNCHIGLIA96REASONING "Architectures"))(POS (PAPER.INSTANCE GIUNCHIGLIA99APPLYING))(POS (PAPER.BIBTEX GIUNCHIGLIA99APPLYING INPROCEEDINGS))(POS (PAPER.AUTHOR GIUNCHIGLIA99APPLYING "Enrico Giunchiglia and Roberto Sebastiani"))(POS (PAPER.TITLE GIUNCHIGLIA99APPLYING "Applying the Davis-Putnam Procedure to Non-clausal Formulas"))(POS (PAPER.PUBLICATION GIUNCHIGLIA99APPLYING "Proceedings of the 6th Congress of the Italian Association for Artificial Intelligence on Advances in Artificial Intelligence"))(POS (PAPER.STARTPAGE GIUNCHIGLIA99APPLYING 84))(POS (PAPER.ENDPAGE GIUNCHIGLIA99APPLYING 94))(POS (PAPER.LINK GIUNCHIGLIA99APPLYING "http://citeseer.ist.psu.edu/giunchiglia99applying.html"))(POS (PAPER.YEAR GIUNCHIGLIA99APPLYING 1999))(POS (PAPER.DESCRIPTION GIUNCHIGLIA99APPLYING "
Continuation of their earlier work on building a SAT solver that handles
non-clausal form by translating the problem into CNF in such a way that 
the search space of the non-CNF problem is preserved in some way.
"))(POS (PAPER.TOPIC GIUNCHIGLIA99APPLYING "SAT Solving"))(POS (PAPER.INSTANCE GIUNCHIGLIA99PLANNING))(POS (PAPER.BIBTEX GIUNCHIGLIA99PLANNING INPROCEEDINGS))(POS (PAPER.AUTHOR GIUNCHIGLIA99PLANNING "Fausto Giunchiglia and Paolo Traverso"))(POS (PAPER.TITLE GIUNCHIGLIA99PLANNING "Planning as Model Checking"))(POS (PAPER.LINK GIUNCHIGLIA99PLANNING "http://citeseer.ist.psu.edu/giunchiglia99planning.html"))(POS (PAPER.YEAR GIUNCHIGLIA99PLANNING 1999))(POS (PAPER.RANK GIUNCHIGLIA99PLANNING "[*]"))(POS (PAPER.DESCRIPTION GIUNCHIGLIA99PLANNING "
This paper gives an introduction to Planning as Model Checking for
both deterministic and nondeterministic domains.  It explains
the model checking problem, planning as model checking, 
planning in nondeterministic domains, an implementation, and
related work.  They look at problems formalized in Computation
Tree Logic (CTL).
"))(POS (PAPER.TOPIC GIUNCHIGLIA99PLANNING "Model Checking"))(POS (PAPER.INSTANCE GRAMLICH2005))(POS (PAPER.BIBTEX GRAMLICH2005 ARTICLE))(POS (PAPER.AUTHOR GRAMLICH2005 "Bernhard Gramlich"))(POS (PAPER.TITLE GRAMLICH2005 "Strategic issues, Problems and Challenges in Inductive Theorem Proving"))(POS (PAPER.LINK GRAMLICH2005 "http://www.logic.at/staff/gramlich/ papers/strategies04-entcs05.pdf.gz"))(POS (PAPER.YEAR GRAMLICH2005 2005))(POS (PAPER.RANK GRAMLICH2005 "[***]"))(POS (PAPER.DESCRIPTION GRAMLICH2005 "
Gramlich outlines the inductive theorem proving, how it differs from
first-order theorem proving, and some of the obstacles that must be
overcome to make automated inductive theorem proving a reality.
"))(POS (PAPER.TOPIC GRAMLICH2005 "Herbrand Logic"))(POS (PAPER.INSTANCE GREEN69))(POS (PAPER.AUTHOR GREEN69 "C. Green"))(POS (PAPER.TITLE GREEN69 "Theorem-proving by resolution as a basis for question-answering systems."))(POS (PAPER.PUBLICATION GREEN69 "Machine Intelligence 4"))(POS (PAPER.STARTPAGE GREEN69 183))(POS (PAPER.ENDPAGE GREEN69 205))(POS (PAPER.YEAR GREEN69 1969))(POS (PAPER.DESCRIPTION GREEN69 "
Green describes using a theorem prover, QA3, to build a question-answering system.  Both statements and questions are written in FOL.  Questions can be True/False or Constructive (i.e. ask for an x such that ...).  Constructive answers are produced by adding the rule question-of-user(x) => Answer(x).  Green goes on to describe what we now call deductive plan synthesis, i.e. answer extraction of situation calculus axioms.  QA3 uses subsumption, duplicate literal elimination, unit preference, a variant on set of support, and no equality (yet).
"))(POS (PAPER.TOPIC GREEN69 "Fundamentals"))(POS (PAPER.INSTANCE GREINER91))(POS (PAPER.BIBTEX GREINER91 ARTICLE))(POS (PAPER.AUTHOR GREINER91 "Russell Greiner and Charles Elkan"))(POS (PAPER.TITLE GREINER91 "Measuring and Improving the Effectiveness of Representations"))(POS (PAPER.PUBLICATION GREINER91 "IJCAI"))(POS (PAPER.STARTPAGE GREINER91 518))(POS (PAPER.ENDPAGE GREINER91 524))(POS (PAPER.LINK GREINER91 "http://citeseer.ist.psu.edu/114212.html"))(POS (PAPER.YEAR GREINER91 1991))(POS (PAPER.RANK GREINER91 "[****]"))(POS (PAPER.DESCRIPTION GREINER91 "
Greiner and Elkan give axes upon which a representation, i.e. black box
for answering questions, can be evaluated: accuracy (how often the answer
given is correct), categoricity (how often the answer is I don't know), and
efficiency. A representation is thus evaluated wrt a query stream.  This 
external form of evaluation captures what any system using a representation
system actually cares about -- how well that representation works.  The
internal representation might also be evaluated by, for example, its
conciseness or elegance, but that is not covered here.  They also formalize
all bounded, linearly separable utility measures, i.e. ways of combining
evaluations wrt the 3 axes above.  Finally the authors confront statistical
approaches for performing evaluation, comparing representations, and improving
existing representations.   Well written.
"))(POS (PAPER.TOPIC GREINER91 "Logical Knowledge Representation"))(POS (PAPER.INSTANCE GREINER98))(POS (PAPER.BIBTEX GREINER98 ARTICLE))(POS (PAPER.AUTHOR GREINER98 "Russell Greiner and Christian Darken and N. Santoso"))(POS (PAPER.TITLE GREINER98 "Efficient Reasoning"))(POS (PAPER.PUBLICATION GREINER98 "ACM Computing Surveys"))(POS (PAPER.VOLUME GREINER98 "33(1)"))(POS (PAPER.STARTPAGE GREINER98 1))(POS (PAPER.ENDPAGE GREINER98 30))(POS (PAPER.LINK GREINER98 "http://citeseer.ist.psu.edu/greiner98efficient.html"))(POS (PAPER.YEAR GREINER98 1998))(POS (PAPER.RANK GREINER98 "[*]"))(POS (PAPER.DESCRIPTION GREINER98 "
Greiner gives a survey of techniques for efficient reasoning: both deductive 
and probabilistic.  He talks about the various techniques available for
dealing with exponential run times: unsound inference, incompleteness, etc.
"))(POS (PAPER.TOPIC GREINER98 "Logical Knowledge Representation"))(POS (PAPER.INSTANCE GROHE2001))(POS (PAPER.BIBTEX GROHE2001 INPROCEEDINGS))(POS (PAPER.AUTHOR GROHE2001 "Martin Grohe"))(POS (PAPER.TITLE GROHE2001 "Generalized Model-Checking Problems for First-Order Logic"))(POS (PAPER.PUBLICATION GROHE2001 "Symposium on Theoretical Aspects of Computer Science"))(POS (PAPER.STARTPAGE GROHE2001 12))(POS (PAPER.ENDPAGE GROHE2001 26))(POS (PAPER.LINK GROHE2001 "http://www.dcs.ed.ac.uk/home/grohe/pub.html"))(POS (PAPER.YEAR GROHE2001 2001))(POS (PAPER.RANK GROHE2001 "[****]"))(POS (PAPER.DESCRIPTION GROHE2001 "
Grohe investigates the parameterized complexity of various model-checking
problems in first-order logic.  In general, the problem is PSPACE-complete
for the combined size of the query and the model.  Under the assumption
of a small query, the parameterized complexity is still AW[*].  However,
some types of formulas and models lend themselves to tractable algorithms:
those with an underlying tree structure.  This paper gives a survey
of various model-checking complexity results for first-order logic.
"))(POS (PAPER.TOPIC GROHE2001 "Model Checking"))(POS (PAPER.RELATED GROHE2001 GROHE2002))(POS (PAPER.INSTANCE GROHE2002))(POS (PAPER.BIBTEX GROHE2002 ARTICLE))(POS (PAPER.AUTHOR GROHE2002 "Martin Grohe"))(POS (PAPER.TITLE GROHE2002 "Parameterized Complexity for the Database Theorist"))(POS (PAPER.PUBLICATION GROHE2002 "SIGMOD"))(POS (PAPER.VOLUME GROHE2002 "31(4)"))(POS (PAPER.LINK GROHE2002 "http://www.dcs.ed.ac.uk/home/grohe/pub.html"))(POS (PAPER.YEAR GROHE2002 2002))(POS (PAPER.RANK GROHE2002 "[*]"))(POS (PAPER.DESCRIPTION GROHE2002 "
Grohe gives a gentle introduction to Parameterized Complexity Theory for
database theorists.  The theory defines a complexity hierarchy for
problems with nonstandard constraints and reductions for proofs
of problem locations within the hierarchy.
These parameterized problems include more information than their standard
counterparts, and thus, can have better solutions.
"))(POS (PAPER.TOPIC GROHE2002 "Knowledge Base Compilation"))(POS (PAPER.INSTANCE GROSOF2003))(POS (PAPER.BIBTEX GROSOF2003 INPROCEEDINGS))(POS (PAPER.AUTHOR GROSOF2003 "Benjamin Grosof and Ian Horrocks and Raphael Volz and Stefan Decker"))(POS (PAPER.TITLE GROSOF2003 "Description Logic Programs: Combining Logic Programs with Description Logic"))(POS (PAPER.PUBLICATION GROSOF2003 "Proceedings of the 12th International Conference on the World Wide Web"))(POS (PAPER.LINK GROSOF2003 "http://citeseer.ist.psu.edu/grosof03description.html"))(POS (PAPER.YEAR GROSOF2003 2003))(POS (PAPER.DESCRIPTION GROSOF2003 "
Description Logic Programs are introduced, which lie in the intersection 
of logic programming and OWL DL.  In addition, mechanisms for reasoning
about this fragment with either description logic or logic programming
tools are introduced.
"))(POS (PAPER.TOPIC GROSOF2003 "Semantic Web"))(POS (PAPER.INSTANCE GUREVICH90))(POS (PAPER.BIBTEX GUREVICH90 ARTICLE))(POS (PAPER.AUTHOR GUREVICH90 "Yuri Gurevich"))(POS (PAPER.TITLE GUREVICH90 "On the Classical Decision Problem"))(POS (PAPER.PUBLICATION GUREVICH90 "Bulletin of the European Association for Theoretical Computer Science"))(POS (PAPER.VOLUME GUREVICH90 "42"))(POS (PAPER.STARTPAGE GUREVICH90 140))(POS (PAPER.ENDPAGE GUREVICH90 150))(POS (PAPER.LINK GUREVICH90 "http://citeseer.ist.psu.edu/gurevich93classical.html"))(POS (PAPER.YEAR GUREVICH90 1990))(POS (PAPER.RANK GUREVICH90 "[*]"))(POS (PAPER.DESCRIPTION GUREVICH90 "
This paper takes the form of a dialogue between the Author and Quisani.
It gives an introduction to the problem of determining whether a first-
order formula is satisfiable (or valid).  The classic decision problem
is whether this problem is decidable.  Church and Turing showed
it to be undecidable.  Then the question becomes, for which
formulas is this decidable?  Classes are given based on the 
quantifier prefixes that are decidable.  More interestingly, 
a certain set of 4 prefixes are enough to completely solve the
decision problem for prefix classes.
"))(POS (PAPER.TOPIC GUREVICH90 "Decidable Fragments of First-Order Logic"))(POS (PAPER.INSTANCE HAAS86))(POS (PAPER.AUTHOR HAAS86 "Andrew R. Haas"))(POS (PAPER.TITLE HAAS86 "A Syntactic Theory of Belief and Action"))(POS (PAPER.PUBLICATION HAAS86 "Artificial Intelligence"))(POS (PAPER.VOLUME HAAS86 "28(3)"))(POS (PAPER.STARTPAGE HAAS86 245))(POS (PAPER.ENDPAGE HAAS86 292))(POS (PAPER.LINK HAAS86 "http://www.reviews.com/Review/Review_review.cfm?media_id=778843&reviewer=110938&pos=3&page=4"))(POS (PAPER.YEAR HAAS86 1986))(POS (PAPER.DESCRIPTION HAAS86 "
Haas describes an approach for reasoning about belief, both an agent's own
beliefs and another agent's belief's.  First, we represent an agent's belief's
with Believes(agent, sentence), where sentence names a sentence of FOL.  Haas
names sentences of FOL by quoting each component, i.e. p(a) is named 'p('a)
(it looks cleaner in prefix notation).  He also gives names for intervals of
time so he can state how long it will take for an agent to believe a certain
sentence; afterall inference is not instantaneous.   In order to give an agent
the ability to determine what another agent will infer, Haas borrows
Konolige's suggestion of implanting an agent's inference rules into the
Believes statements.  Then, Haas introduces The Reflection Schema to do
inference.  Specifically,
Ax1,..,xn. (ClosedTerm x1)^...^(ClosedTerm xn) => IsProof(s)
s is a proof quoted appropriately.  He shows this schema sound and complete.
Haas goes on to define 'Knowing What' in terms of the context of what was asked.
'Knowing How' means a robot has a program to execute.  Finally, Haas connnects
belief and truth using the truth predicate: 'true(quote p) 'iff 'p.  The
Liar's paradox shows up here, but Haas avoids it by proving if p is ground,
true produces no contradictions.
"))(POS (PAPER.TOPIC HAAS86 "Metalevel Reasoning"))(POS (PAPER.INSTANCE HAHNLE2002))(POS (PAPER.AUTHOR HAHNLE2002 "Reiner Hahnle and Neil Murray and Erik Rosenthal"))(POS (PAPER.TITLE HAHNLE2002 "Ordered Resolution vs. Connection Graph Resolution"))(POS (PAPER.LINK HAHNLE2002 "http://citeseer.ist.psu.edu/446349.html"))(POS (PAPER.YEAR HAHNLE2002 2002))(POS (PAPER.DESCRIPTION HAHNLE2002 "
Hahnle et. al. first describe connection graph resolution for
propositional logic, introduced by Kowalski in 1975.  
CGR begins with a graph of clauses with
edges between complementary literals.  Activating an edge
means performing a step of resolution, producing a new 
clause graph.  Then they show that ordered resolution
is a special case of cg-resolution (for prop logic) and then
that ordered cg-resolution will always terminate.  Ordered
cg-resolution enforces a total ordering on literals so
that resolution is applied only to the maximally ordered
literal in a clause.  It is a little unclear to what extent
the results are new, but apparently
the proofs are simpler than those given in the past.  At the end,
the authors discuss issues for lifting this to first-order and
give Eisinger's example that shows unrestricted cg-resolution
is non-terminal.  
"))(POS (PAPER.TOPIC HAHNLE2002 "Calculi"))(POS (PAPER.INSTANCE HALEVY2001))(POS (PAPER.BIBTEX HALEVY2001 ARTICLE))(POS (PAPER.AUTHOR HALEVY2001 "Alon Halevy"))(POS (PAPER.TITLE HALEVY2001 "Answering Queries Using Views: A Survey"))(POS (PAPER.PUBLICATION HALEVY2001 "VLDB Journal: Very Large Data Bases"))(POS (PAPER.VOLUME HALEVY2001 "10(4)"))(POS (PAPER.STARTPAGE HALEVY2001 270))(POS (PAPER.ENDPAGE HALEVY2001 294))(POS (PAPER.LINK HALEVY2001 "http://citeseer.ist.psu.edu/halevy00answering.html"))(POS (PAPER.YEAR HALEVY2001 2001))(POS (PAPER.RANK HALEVY2001 "[****]"))(POS (PAPER.DESCRIPTION HALEVY2001 "
Halevy's survey splits the work that answers queries using views into two
cateogires: using materialized views to speed up query answering and
data integration.  In the former setting, materialized views have the potential
to speed up query answering because some portion of the query may have already
been computed and stored in the db as a materialized view.  The goal here is
to produce an efficient execution plan that uses base tables and materialized views.
In the latter setting, data integration techniques provide a schema, sometimes
called the mediated schema, for a user to query a large number of separate
databases.  To define how each individual schema relates to the mediated schema,
the tables in the individual schemas are expressed as views of the mediated schema.
Here the work focuses on rewriting the query in terms of the views of the mediated
schema, i.e. in terms of the database schema that actually exist.  This case is
particularly interesting because it requires the views to be treated as
incomplete, e.g. both the database of american cars and the database of foreign
cars contribute to the car table.
"))(POS (PAPER.TOPIC HALEVY2001 "Databases"))(POS (PAPER.INSTANCE HALMOS))(POS (PAPER.BIBTEX HALMOS BOOK))(POS (PAPER.AUTHOR HALMOS "Paul Halmos"))(POS (PAPER.TITLE HALMOS "Naive Set Theory"))(POS (PAPER.PUBLISHER HALMOS "Van Nostrand Reinhold Company"))(POS (PAPER.LINK HALMOS "http://www.amazon.com/Naive-Theory-Undergraduate-Texts-Mathematics/dp/0387900926"))(POS (PAPER.YEAR HALMOS 1960))(POS (PAPER.RANK HALMOS ""))(POS (PAPER.DESCRIPTION HALMOS "
A 100-page book on naive set theory.
"))(POS (PAPER.TOPIC HALMOS ""))(POS (PAPER.INSTANCE HALPERN91))(POS (PAPER.AUTHOR HALPERN91 "Joseph Halpern and Moshe Vardi"))(POS (PAPER.TITLE HALPERN91 "Model Checking vs. Theorem Proving: A Manifesto"))(POS (PAPER.PUBLICATION HALPERN91 "Artificial and mathematical Theory of Computation
       (Papers in Honor of John McCarthy)"))(POS (PAPER.LINK HALPERN91 "http://www.cs.cornell.edu/home/halpern/abstract.html#bookart4"))(POS (PAPER.YEAR HALPERN91 1991))(POS (PAPER.RANK HALPERN91 "[****]"))(POS (PAPER.DESCRIPTION HALPERN91 "
Halpern and Vardi prescribe using a semantic model to represent an agent's
knowledge and use model checking to determine logical entailment.  This differs
greatly from the standard approach of using logical sentences to represent
knowledge and then doing theorem proving to check entailment.  The authors
outline constructing such models in a few contexts and consider problems with
the model checking.
"))(POS (PAPER.TOPIC HALPERN91 "Model Checking"))(POS (PAPER.INSTANCE HAMMER93))(POS (PAPER.BIBTEX HAMMER93 ARTICLE))(POS (PAPER.AUTHOR HAMMER93 "Peter Hammer and Alexander Kogan"))(POS (PAPER.TITLE HAMMER93 "Optimal Compression of Propositional Horn Knowledge Bases: Complexity and Approximation"))(POS (PAPER.PUBLICATION HAMMER93 "Artificial Intelligence"))(POS (PAPER.VOLUME HAMMER93 "64(1)"))(POS (PAPER.STARTPAGE HAMMER93 131))(POS (PAPER.ENDPAGE HAMMER93 145))(POS (PAPER.LINK HAMMER93 "http://citeseer.ist.psu.edu/hammer93optimal.html"))(POS (PAPER.YEAR HAMMER93 1993))(POS (PAPER.RANK HAMMER93 "[*]"))(POS (PAPER.DESCRIPTION HAMMER93 "
Hammer and Kogan show that finding the minimum propositional Horn
KB of a given Horn KB is NP-Complete.  They also show a previous
O(n^2) approximation algorithm to be a good one since it allows
no more than a linear factor more rules.
"))(POS (PAPER.TOPIC HAMMER93 "Knowledge Base Compilation"))(POS (PAPER.INSTANCE HAYES75))(POS (PAPER.AUTHOR HAYES75 "Philip J. Hayes"))(POS (PAPER.TITLE HAYES75 "A Representation for Robot Plans"))(POS (PAPER.PUBLICATION HAYES75 "IJCAI"))(POS (PAPER.STARTPAGE HAYES75 181))(POS (PAPER.ENDPAGE HAYES75 188))(POS (PAPER.YEAR HAYES75 1975))(POS (PAPER.DESCRIPTION HAYES75 "
Due to the need for replanning, Hayes advocates producing plans that consist
of two data structures: a subgoal tree and a decision graph.  The subgoal tree represents the plan in a hierarchical-type planner, i.e. root is the overall
goal; each internal node is a reduction of its parent; each leaf is a
primitive action.  The decision graph records the decisions made by the planner while producing the plan.  Links exist between the decision graph and the
subgoal tree so that when a failure occurs during plan execution, the
appropriate parts of both data structures can be removed.
"))(POS (PAPER.TOPIC HAYES75 "Historical"))(POS (PAPER.INSTANCE HENTENRYCK89))(POS (PAPER.BIBTEX HENTENRYCK89 BOOK))(POS (PAPER.AUTHOR HENTENRYCK89 "Pascal Van Hentenryck"))(POS (PAPER.TITLE HENTENRYCK89 "Constraint Satisfaction in Logic Programming"))(POS (PAPER.PUBLISHER HENTENRYCK89 "MIT Press"))(POS (PAPER.YEAR HENTENRYCK89 1989))(POS (PAPER.DESCRIPTION HENTENRYCK89 "
This is an extended form of Hentenryck's thesis.  It concerns the integration
of two standard CSP techniques (forward checking and arc consistency) into
Prolog.  First, there is a thorough introduction to Prolog--syntax,
semantics, proof theory.  Then he formally shows how to do the
integration.  Next he explains an implementation of the integration
that allows users the ability to specify when to apply the
new techniques.  
"))(POS (PAPER.TOPIC HENTENRYCK89 "Logic Programming"))(POS (PAPER.INSTANCE HEYMANS2003))(POS (PAPER.BIBTEX HEYMANS2003 INPROCEEDINGS))(POS (PAPER.AUTHOR HEYMANS2003 "S. Heymans and D. Vermeir"))(POS (PAPER.TITLE HEYMANS2003 "Integrating Semantic Web Reasoning and Answer Set Programming"))(POS (PAPER.PUBLICATION HEYMANS2003 "Proceedings of the 2nd International ASP Workshop"))(POS (PAPER.LINK HEYMANS2003 "http://citeseer.ist.psu.edu/727609.html"))(POS (PAPER.YEAR HEYMANS2003 2003))(POS (PAPER.DESCRIPTION HEYMANS2003 "
Translating another description logic into logic programming, this time
using stable model semantics.
"))(POS (PAPER.TOPIC HEYMANS2003 "Semantic Web"))(POS (PAPER.INSTANCE HINRICHS2004))(POS (PAPER.BIBTEX HINRICHS2004 ARTICLE))(POS (PAPER.BIBTEX HINRICHS2004 PROCEEDINGS))(POS (PAPER.AUTHOR HINRICHS2004 "T. Hinrichs and N. Love and C. Petrie and L. Ramshaw and A. Sahai and S. Singhal."))(POS (PAPER.AUTHOR HINRICHS2004 "Tim Hinrichs, Nathaniel Love, Charles Petrie, Lyle Ramshaw, Akhil Sahai and Sharad Singhal"))(POS (PAPER.TITLE HINRICHS2004 "Using Object-Oriented Constraint Satisfaction for Automated Configuration Generation"))(POS (PAPER.TITLE HINRICHS2004 "Using Object-Oriented Constraint Satisfaction for Automated Configuration Generation"))(POS (PAPER.PUBLICATION HINRICHS2004 "DSOM"))(POS (PAPER.PUBLICATION HINRICHS2004 "Utility Computing: 15th IFIP/IEEE International Workshop on Distributed Systems: Operations and Management, DSOM 2004"))(POS (PAPER.LINK HINRICHS2004 "http://logic.stanford.edu/~thinrich/publications.htm"))(POS (PAPER.LINK HINRICHS2004 "papers/hinrichs2004using.pdf"))(POS (PAPER.YEAR HINRICHS2004 2004))(POS (PAPER.YEAR HINRICHS2004 2004))(POS (PAPER.RANK HINRICHS2004 ""))(POS (PAPER.DESCRIPTION HINRICHS2004 "
Hinrichs, et. al. describe an application of Object-Oriented Constraint 
Satisfaction to configuration management.
"))(POS (PAPER.DESCRIPTION HINRICHS2004 "
In this paper, we describe an approach for automatically generating configurations for complex applications. Automated generation of system configurations is required to allow large-scale deployment of custom applications within utility computing environments. Our approach models the configuration management problem as an Object-Oriented Constraint Satisfaction Problem (OOCSP) that can be solved efficiently using a resolution-based theorem-prover. We outline the approach and discuss both the benefits of the approach as well as its limitations, and highlight certain unresolved issues that require further work. We demonstrate the viability of this approach using an e-Commerce site as an example, and provide results on the complexity and time required to solve for the configuration of such an application.
"))(POS (PAPER.TOPIC HINRICHS2004 "Object Oriented Constraint Satisfaction"))(POS (PAPER.TOPIC HINRICHS2004 "References"))(POS (PAPER.INSTANCE HINRICHS2005AXIOM))(POS (PAPER.BIBTEX HINRICHS2005AXIOM INPROCEEDINGS))(POS (PAPER.AUTHOR HINRICHS2005AXIOM "Timothy Hinrichs and Michael Genesereth"))(POS (PAPER.TITLE HINRICHS2005AXIOM "Axiom Schemata as Metalevel Axioms: Model Theory"))(POS (PAPER.PUBLICATION HINRICHS2005AXIOM "In proceedings of American Association for Aritificial Intelligence"))(POS (PAPER.LINK HINRICHS2005AXIOM "http://logic.stanford.edu/~thinrich/papers/hinrichs2005axiom.pdf"))(POS (PAPER.YEAR HINRICHS2005AXIOM 2005))(POS (PAPER.DESCRIPTION HINRICHS2005AXIOM "
Logicians frequently use axiom schemata to encode (potentially infinite) sets of sentences with particular syntactic form. In this paper we examine a first-order language in which it is possible to write expressions that both describe sentences and assert the truth of the sentences so described. The effect of adding such expressions to a knowledge base is the same as directly including the set of described sentences. 
"))(POS (PAPER.TOPIC HINRICHS2005AXIOM "References"))(POS (PAPER.INSTANCE HINRICHS2006HERBRAND))(POS (PAPER.BIBTEX HINRICHS2006HERBRAND TECHREPORT))(POS (PAPER.AUTHOR HINRICHS2006HERBRAND "Timothy Hinrichs and Michael Genesereth"))(POS (PAPER.TITLE HINRICHS2006HERBRAND "Herbrand Logic"))(POS (PAPER.PUBLISHER HINRICHS2006HERBRAND "Stanford University"))(POS (PAPER.LINK HINRICHS2006HERBRAND "http://logic.stanford.edu/reports/LG-2006-02.pdf"))(POS (PAPER.YEAR HINRICHS2006HERBRAND 2006))(POS (PAPER.DESCRIPTION HINRICHS2006HERBRAND "
Herbrand logic has the same syntax as first-order logic but has Herbrand semantics. That is, the only models that exist in Herbrand logic are the Herbrand models. This logic is easier to learn than first-order logic and is often better suited for modeling and manipulating today's computer systems, the central concerns of computer science. In Herbrand logic, arithmetic using the natural numbers if finitely axiomatizable; however, neither entailment nor satisfiability are semi-decidable. Nevertheless, four of the most industrially successful applications of logic in computer science have been built within fragments of Herbrand logic: deductive databases, logic programming, constraint satisfaction, and formal verification. In this paper, we define Herbrand logic formally, prove several of its properties, discuss Goedel's incompleteness result with respect to Herbrand logic, and demonstrate how each of the four applications mentioned above can be formalized within Herbrand logic. 
"))(POS (PAPER.TOPIC HINRICHS2006HERBRAND "References"))(POS (PAPER.INSTANCE HINRICHS2007EXTENSIONAL))(POS (PAPER.BIBTEX HINRICHS2007EXTENSIONAL INPROCEEDINGS))(POS (PAPER.AUTHOR HINRICHS2007EXTENSIONAL "Timothy Hinrichs and Michael Genesereth"))(POS (PAPER.TITLE HINRICHS2007EXTENSIONAL "Extensional Reasoning"))(POS (PAPER.PUBLICATION HINRICHS2007EXTENSIONAL "In proceedings of CADE Workshop on Empirically Successful Automated Reasoning in Large Theories (ESARLT)"))(POS (PAPER.LINK HINRICHS2007EXTENSIONAL "http://logic.stanford.edu/~thinrich/papers/hinrichs2007extensional.pdf"))(POS (PAPER.YEAR HINRICHS2007EXTENSIONAL 2007))(POS (PAPER.DESCRIPTION HINRICHS2007EXTENSIONAL "
Relational databases are one of the most industrially successful applications of logic in computer science, built for handling massive amounts of data. The power of the paradigm is clear both because of its widespread adoption and theoretical analysis. Today, automated theorem provers are not able to take advantage of database query engines and therefore do not routinely leverage that source of power. Extensional Reasoning is an approach to automated theorem proving where the machine automatically translates a logical entailment query into a database, a set of view definitions, and a database query such that the entailment query can be answered by answering the database query. This paper discusses the framework for Extensional Reasoning, describes algorithms that enable a theorem prover to leverage the power of the database in the case of axiomatically complete theories, and discusses theory resolution for handling incomplete theories. 
"))(POS (PAPER.TOPIC HINRICHS2007EXTENSIONAL "References"))(POS (PAPER.INSTANCE HINRICHS2007REFORMULATION))(POS (PAPER.BIBTEX HINRICHS2007REFORMULATION INPROCEEDINGS))(POS (PAPER.AUTHOR HINRICHS2007REFORMULATION "Timothy Hinrichs and Michael Genesereth"))(POS (PAPER.TITLE HINRICHS2007REFORMULATION "Reformulation for Extensional Reasoning"))(POS (PAPER.PUBLICATION HINRICHS2007REFORMULATION "In proceedings of the Symposium of Abstraction, Reformulation, and Approximation (SARA)"))(POS (PAPER.LINK HINRICHS2007REFORMULATION "http://logic.stanford.edu/~thinrich/papers/hinrichs2007reformulation.pdf"))(POS (PAPER.YEAR HINRICHS2007REFORMULATION 2007))(POS (PAPER.DESCRIPTION HINRICHS2007REFORMULATION "
Relational databases have had great industrial success in computer science. The power of the paradigm is made clear both by its widespread adoption and by theoretical analysis. Today, automated theorem provers are not able to take advantage of database query engines and therefore do not routinely leverage that source of power. Extensional Reasoning (ER) is an approach to automated theorem proving where the machine automatically translates a logical entailment query into a database, a set of view definitions, and a database query such that the entailment query can be answered by answering the database query. The techniques developed for ER to date are applicable only when the logical theory is axiomatically complete. This paper discusses techniques for reformulating an incomplete theory into a complete theory so that Extensional Reasoning techniques can be applied. 

"))(POS (PAPER.TOPIC HINRICHS2007REFORMULATION "References"))(POS (PAPER.INSTANCE HITZLER2005))(POS (PAPER.BIBTEX HITZLER2005 INPROCEEDINGS))(POS (PAPER.AUTHOR HITZLER2005 "Pascal Hitzler and Peter Haase and Markus Krotzsch and York Sure and Rudi Studer"))(POS (PAPER.TITLE HITZLER2005 "DLP isn't so bad after all"))(POS (PAPER.PUBLICATION HITZLER2005 "Proceedings of the WS OWL -- Experiences and Directions"))(POS (PAPER.LINK HITZLER2005 "http://citeseer.ist.psu.edu/733286.html"))(POS (PAPER.YEAR HITZLER2005 2005))(POS (PAPER.DESCRIPTION HITZLER2005 "
The authors try to clarify the controversy surrounding Description Logic
Programs, which is a fragment of OWL DL that can be reasoned about effectively
with logic programming engines.  
"))(POS (PAPER.TOPIC HITZLER2005 "Semantic Web"))(POS (PAPER.INSTANCE HODGSON2002))(POS (PAPER.BIBTEX HODGSON2002 ARTICLE))(POS (PAPER.AUTHOR HODGSON2002 "Kahlil Hodgson and John Slaney"))(POS (PAPER.TITLE HODGSON2002 "TPTP, CASC and the development of a semantically guided 
theorem prover"))(POS (PAPER.PUBLICATION HODGSON2002 "AI Communications"))(POS (PAPER.VOLUME HODGSON2002 "15"))(POS (PAPER.STARTPAGE HODGSON2002 135))(POS (PAPER.ENDPAGE HODGSON2002 146))(POS (PAPER.LINK HODGSON2002 "http://citeseer.ist.psu.edu/558093.html"))(POS (PAPER.YEAR HODGSON2002 2002))(POS (PAPER.RANK HODGSON2002 ""))(POS (PAPER.DESCRIPTION HODGSON2002 "
Hodgson and Slaney describe SCOTT 5, the fifth generation of
semantically constrained otter.  The authors give a quick
description of the differences between the five versions
and explain the algorithm for the newest.  Instead of
maintaining a single model that satisfies some of the
constraints, they maintain several models.  Moreover,
sometimes they use these models to implement the semantic
queue strategy.  Pick the largest set of clauses known
to be satisfiable and if the number of clauses complementary
to a clause in S in the passive list is small, into the
active list. If none of these so called co-NMCSs are small
enough, cycle through them and add clauses to the active
queue.  SCOTT keeps separate the model builder and the theorem
prover from semantic guidance routines to allow, in principle,
a plug and play architecture.
"))(POS (PAPER.TOPIC HODGSON2002 "System Designs"))(POS (PAPER.INSTANCE HOHFELD88))(POS (PAPER.BIBTEX HOHFELD88 ARTICLE))(POS (PAPER.AUTHOR HOHFELD88 "M. Hohfeld and Gert Smolka"))(POS (PAPER.TITLE HOHFELD88 "Definite Relations over Constraint Languages"))(POS (PAPER.LINK HOHFELD88 "http://citeseer.ist.psu.edu/hohfeld88definite.html"))(POS (PAPER.YEAR HOHFELD88 1988))(POS (PAPER.RANK HOHFELD88 "[****]"))(POS (PAPER.DESCRIPTION HOHFELD88 "
Hohfeld and Smolka generalize the previous formal foundations of Constraint
Logic Programming by allowing arbitrary constraints placed on definite
logic programming clauses.  Their definition for constraint states  that
it is simply a restriction on variables; predicate logic is simply a special
case.  They give a generalization of SLD resolution that is sound and 
complete for this broader definition of CLP.  The authors go on to give a 'semantic type discipline' for these CLP clause sets.
"))(POS (PAPER.TOPIC HOHFELD88 "Constraint Logic Programming"))(POS (PAPER.INSTANCE HORIYAMA99))(POS (PAPER.BIBTEX HORIYAMA99 INPROCEEDINGS))(POS (PAPER.AUTHOR HORIYAMA99 "Takashi Horiyama and Toshihide ibaraki"))(POS (PAPER.TITLE HORIYAMA99 "Ordered Binary Decision Diagrams as Knowledge-Bases"))(POS (PAPER.PUBLICATION HORIYAMA99 "International Symposium on Algorithms and Computation"))(POS (PAPER.LINK HORIYAMA99 "http://citeseer.ist.psu.edu/horiyama99ordered.html"))(POS (PAPER.YEAR HORIYAMA99 1999))(POS (PAPER.RANK HORIYAMA99 "[*]"))(POS (PAPER.DESCRIPTION HORIYAMA99 "
Ordered binary decision diagrams can be used to represent propositional 
knowledge bases.  Deduction can be done from such a representation in 
polynomial time; not surprisingly, some knowledge bases require exponential
space while others require only polynomial space.  On the up-side, the
space requirements are not correlated with either characteristic models
(see kautz and khardon) or standard CNF representations.
"))(POS (PAPER.TOPIC HORIYAMA99 "Model-Based Reasoning"))(POS (PAPER.RELATED HORIYAMA99 KAUTZ93))(POS (PAPER.RELATED HORIYAMA99 KHARDON94))(POS (PAPER.INSTANCE HOWER96))(POS (PAPER.BIBTEX HOWER96 ARTICLE))(POS (PAPER.AUTHOR HOWER96 "Walter Hower and Winfried Graf"))(POS (PAPER.TITLE HOWER96 "A bibliographical survey of constraint-based approaches to CAD,
graphics, layout, visualization, and related topics"))(POS (PAPER.PUBLICATION HOWER96 "Knowledge-Based Systems
"))(POS (PAPER.VOLUME HOWER96 "9(7)"))(POS (PAPER.STARTPAGE HOWER96 449))(POS (PAPER.ENDPAGE HOWER96 464))(POS (PAPER.LINK HOWER96 "http://citeseer.ist.psu.edu/hower96bibliographical.html"))(POS (PAPER.YEAR HOWER96 1996))(POS (PAPER.RANK HOWER96 "[**]"))(POS (PAPER.DESCRIPTION HOWER96 "
Survey paper on just what the title indicates.  There are a few paragraphs
on object-oriented approaches most of which is orthogonal.
"))(POS (PAPER.TOPIC HOWER96 "Miscellaneous"))(POS (PAPER.INSTANCE JACKSON98))(POS (PAPER.BIBTEX JACKSON98 ARTICLE))(POS (PAPER.AUTHOR JACKSON98 "Daniel Jackson and Somesh Jha and Craig Damon"))(POS (PAPER.TITLE JACKSON98 "Isomorph-free model enumeration: a new method for checking relational specifications"))(POS (PAPER.PUBLICATION JACKSON98 "ACM Transactions on Programming Languages and Systems"))(POS (PAPER.LINK JACKSON98 "http://portal.acm.org/citation.cfm?id=276396&dl=ACM&coll=portal"))(POS (PAPER.YEAR JACKSON98 1998))(POS (PAPER.DESCRIPTION JACKSON98 "
Methods for building models while avoiding the enumeration of isomorphic candidates for the language Nitpick.
"))(POS (PAPER.TOPIC JACKSON98 "Model Building"))(POS (PAPER.INSTANCE JAFFAR87))(POS (PAPER.BIBTEX JAFFAR87 ARTICLE))(POS (PAPER.AUTHOR JAFFAR87 "J. Jaffar and J.L. Lassez"))(POS (PAPER.TITLE JAFFAR87 "Constraint Logic Programming"))(POS (PAPER.PUBLICATION JAFFAR87 "ACM Symposium on Principles of Programming Languages"))(POS (PAPER.STARTPAGE JAFFAR87 111))(POS (PAPER.ENDPAGE JAFFAR87 119))(POS (PAPER.LINK JAFFAR87 "http://portal.acm.org/citation.cfm?id=41635&dl=GUIDE&coll=GUIDE"))(POS (PAPER.YEAR JAFFAR87 1987))(POS (PAPER.RANK JAFFAR87 "[****]"))(POS (PAPER.DESCRIPTION JAFFAR87 "
Jaffar and Lassez introduce constraint logic programming as a class
of logic programming languages, one for each domain of discourse.  
Every rule has associated with it a set of constraints 
over that domain.  Hohfeld and Smolka in '88 generalize this 
framework, but this is the seminal paper.  Solution to a CLP problem
is a set of constraints; thus, logic programming is a special form
of CLP where those constraints must be equality constraints.
"))(POS (PAPER.TOPIC JAFFAR87 "Constraint Logic Programming"))(POS (PAPER.INSTANCE JANICIC2002))(POS (PAPER.BIBTEX JANICIC2002 ARTICLE))(POS (PAPER.AUTHOR JANICIC2002 "Predrag Janicic and Alan Bundy"))(POS (PAPER.TITLE JANICIC2002 "A General Setting for Flexibly Combining and Augmenting Decision Procedures"))(POS (PAPER.PUBLICATION JANICIC2002 "Journal of Automated Reasoning
           "))(POS (PAPER.VOLUME JANICIC2002 "28(3)"))(POS (PAPER.STARTPAGE JANICIC2002 257))(POS (PAPER.ENDPAGE JANICIC2002 305))(POS (PAPER.LINK JANICIC2002 "http://www.inf.ed.ac.uk/publications/report/0095.html"))(POS (PAPER.YEAR JANICIC2002 2002))(POS (PAPER.RANK JANICIC2002 "[***]"))(POS (PAPER.DESCRIPTION JANICIC2002 "
Janicic and Bundy invent a set of macro rewrite rules that can be used
to build a reasoner out of a set of decision procedures.  They provide
a good overview of the main influences in the field of combining
and augmenting decision procedures.  They build a prototype system
and report comparison results for Nelson-Oppen, Shostak, etc.
"))(POS (PAPER.TOPIC JANICIC2002 "Architectures"))(POS (PAPER.INSTANCE JEAVONS99))(POS (PAPER.BIBTEX JEAVONS99 ARTICLE))(POS (PAPER.AUTHOR JEAVONS99 "Peter Jeavons and David Cohen and Marc Gyssens"))(POS (PAPER.TITLE JEAVONS99 "How to Determine the Expressive Power of Constraints"))(POS (PAPER.PUBLICATION JEAVONS99 "Constraints"))(POS (PAPER.VOLUME JEAVONS99 "4"))(POS (PAPER.STARTPAGE JEAVONS99 113))(POS (PAPER.ENDPAGE JEAVONS99 131))(POS (PAPER.LINK JEAVONS99 "http://citeseer.ist.psu.edu/jeavons98how.html"))(POS (PAPER.YEAR JEAVONS99 1999))(POS (PAPER.DESCRIPTION JEAVONS99 "
The authors define expresssive power as the set of relations definable
from another set of relations.  They show how to compute which algebraic 
operators are closed for a given set of relations by solving a particular
kind of CSP for the given relations.  Then they show that the set of
relations definable from a given set is equal to the set of relations
that are closed under the same operations as that given set.  If some set
R is closed under the set of operations O and every operation in O is 
what they call essentially unary, the problem is NP-complete.  Moreover,
if O includes an operation that is not essentially unary, it includes
an operation that has arity at most max(3, the size of the domain).
Thus, this paper details sufficient conditions for checking whether
a particular CSP is NP-complete: (1) compute the set of operations
that are closed over the permissible tables in the constraints of the CSP.
(2) If that set includes just essentially-unary operations (which can
be deduced by checking for operations of arity up to max(3, size of domain), 
we are assured the problem is NP-complete.
"))(POS (PAPER.TOPIC JEAVONS99 "General"))(POS (PAPER.INSTANCE KAUTZ91))(POS (PAPER.BIBTEX KAUTZ91 INPROCEEDINGS))(POS (PAPER.AUTHOR KAUTZ91 "Henry Kautz and Bart Selman"))(POS (PAPER.TITLE KAUTZ91 "A General Framework for Knowledge Compilation"))(POS (PAPER.PUBLICATION KAUTZ91 "International Workshop on Processing Declarative Knowledge"))(POS (PAPER.LINK KAUTZ91 "http://citeseer.ist.psu.edu/kautz91general.html"))(POS (PAPER.YEAR KAUTZ91 1991))(POS (PAPER.RANK KAUTZ91 "[****]"))(POS (PAPER.DESCRIPTION KAUTZ91 "
This follows up on selman91 and generalizes the Knowledge Compilation 
idea into a framework.  It says that it lifts the algorithms for
Least Upper Bound and Greatest Lower Bound Horn approximations to first-
order, but the proofs of computability are nonexistent.  
"))(POS (PAPER.TOPIC KAUTZ91 "Knowledge Base Compilation"))(POS (PAPER.RELATED KAUTZ91 SELMAN91))(POS (PAPER.INSTANCE KAUTZ92))(POS (PAPER.BIBTEX KAUTZ92 INPROCEEDINGS))(POS (PAPER.AUTHOR KAUTZ92 "Henry Kautz and Bart Selman"))(POS (PAPER.TITLE KAUTZ92 "Forming Concepts for Fast Inference"))(POS (PAPER.PUBLICATION KAUTZ92 "ECAI-Workshop on Knowledge Representation and Reasoning
      "))(POS (PAPER.STARTPAGE KAUTZ92 200))(POS (PAPER.ENDPAGE KAUTZ92 215))(POS (PAPER.LINK KAUTZ92 "http://citeseer.ist.psu.edu/kautz92forming.html"))(POS (PAPER.YEAR KAUTZ92 1992))(POS (PAPER.RANK KAUTZ92 "[**]"))(POS (PAPER.DESCRIPTION KAUTZ92 "
Kautz and Selman show the Least Upper Bound Horn approximation to a 
propositional knowledge base can be exponential in size.  In general,
there do exist knowledge bases (quoting) whose LUBs cannot be represented 
in a form that is both small and tractable.  This paper mainly
considers the utility of learning new concepts to reduce the size
of the LUB.  
"))(POS (PAPER.TOPIC KAUTZ92 "Knowledge Base Compilation"))(POS (PAPER.RELATED KAUTZ92 SELMAN91))(POS (PAPER.INSTANCE KAUTZ93))(POS (PAPER.BIBTEX KAUTZ93 INPROCEEDINGS))(POS (PAPER.AUTHOR KAUTZ93 "Henry Kautz and Michael Kearns and Bart Selman"))(POS (PAPER.TITLE KAUTZ93 "Reasoning with Characteristic Models"))(POS (PAPER.PUBLICATION KAUTZ93 "AAAI"))(POS (PAPER.LINK KAUTZ93 "http://citeseer.ist.psu.edu/kautz93reasoning.html"))(POS (PAPER.YEAR KAUTZ93 1993))(POS (PAPER.RANK KAUTZ93 "[*****]"))(POS (PAPER.DESCRIPTION KAUTZ93 "
This is the seminal work on characteristic models.  The authors
define the characteristic models of a set M of models as those that cannot 
be derived by intersecting other models of M.  For propositional Horn
theories, these characteristic models are sufficient for computing 
entailment in time linear in the size of the characteristic models and
the conjecture.  In some cases the clausal representation requires 
exponentially more space than the characteristic representation, but
in others just the reverse is true.  Abduction using characteristic
models can be done in time polynomial in the size of the assumption set 
and the size of the characteristic set.  Very clean paper overall.
"))(POS (PAPER.TOPIC KAUTZ93 "Characteristic Models"))(POS (PAPER.INSTANCE KAUTZ95))(POS (PAPER.BIBTEX KAUTZ95 ARTICLE))(POS (PAPER.AUTHOR KAUTZ95 "Henry Kautz and Michael Kearns and Bart Selman"))(POS (PAPER.TITLE KAUTZ95 "Horn Approximations of Empirical Data"))(POS (PAPER.PUBLICATION KAUTZ95 "Artificial Intelligence"))(POS (PAPER.VOLUME KAUTZ95 "74(1)"))(POS (PAPER.STARTPAGE KAUTZ95 129))(POS (PAPER.ENDPAGE KAUTZ95 145))(POS (PAPER.LINK KAUTZ95 "http://citeseer.ist.psu.edu/kautz95horn.html"))(POS (PAPER.YEAR KAUTZ95 1995))(POS (PAPER.RANK KAUTZ95 "[****]"))(POS (PAPER.DESCRIPTION KAUTZ95 "
This paper essentially rehashes that of kautz93, except it also looks
at the problem of converting a given set of models into either clausal
form or characteristic model form.  This idea of extracting structure
from 'empirical data' was first addressed in dechter92.
"))(POS (PAPER.TOPIC KAUTZ95 "Characteristic Models"))(POS (PAPER.RELATED KAUTZ95 KAUTZ93))(POS (PAPER.RELATED KAUTZ95 DECHTER92))(POS (PAPER.INSTANCE KAVVADIAS93))(POS (PAPER.BIBTEX KAVVADIAS93 INPROCEEDINGS))(POS (PAPER.AUTHOR KAVVADIAS93 "D. Kavvadias and C. Papadimitriou and M. Sideri"))(POS (PAPER.TITLE KAVVADIAS93 "On Horn Envelopes and Hypergraph Transversals"))(POS (PAPER.PUBLICATION KAVVADIAS93 "ISAAC"))(POS (PAPER.LINK KAVVADIAS93 "http://www.aueb.gr/Users/sideri/publicat.htm"))(POS (PAPER.YEAR KAVVADIAS93 1993))(POS (PAPER.RANK KAVVADIAS93 "[**]"))(POS (PAPER.DESCRIPTION KAVVADIAS93 "
This is the seminal work relating hypergraph transversals to
characteristic models.  Kavvadias et. al. look into the complexity
of computing the Horn envelope of a set of boolean models (the minimal
set of clauses that entail all the models) and the Horn core
(the maximal set of clauses that entail a subset of the models).
"))(POS (PAPER.TOPIC KAVVADIAS93 "Characteristic Models"))(POS (PAPER.INSTANCE KHARDON94))(POS (PAPER.BIBTEX KHARDON94 INPROCEEDINGS))(POS (PAPER.AUTHOR KHARDON94 "Roni Khardon and Dan Roth"))(POS (PAPER.TITLE KHARDON94 "Reasoning with Models"))(POS (PAPER.PUBLICATION KHARDON94 "AAAI"))(POS (PAPER.LINK KHARDON94 "http://citeseer.ist.psu.edu/khardon96reasoning.html"))(POS (PAPER.YEAR KHARDON94 1994))(POS (PAPER.RANK KHARDON94 "[****]"))(POS (PAPER.DESCRIPTION KHARDON94 "
This paper describes a method for determining entailment and abduction
through model-
checking for a KB of full propositional logic over a restricted set of 
queries.   It extends the work of Kautz, et. al. who wrote the seminal
work for propositional Horn KBs.  The definition for characteristic
models relies on Monotone Theory, which describes properties of 
Boolean functions.  It is important to note that these characteristic
models are defined with respect to a class of queries; that is, given
a class of queries, one can compute the characteristic models for
a propositional KB.  That set of models is then the optimal set, 
meaning all models are needed for correct entailment and abduction.
This paper does a thorough treatment of the issues it
brings up, but it is hard to penetrate.  Section 4 is a list of definitions
of Monotone theory, with little motivation or intuition as to the
utility of each definition.  Of course, the rest of the paper relies
on these definitions.  Reread! 
"))(POS (PAPER.TOPIC KHARDON94 "Characteristic Models"))(POS (PAPER.RELATED KHARDON94 KAUTZ93))(POS (PAPER.INSTANCE KHARDON94A))(POS (PAPER.BIBTEX KHARDON94A INPROCEEDINGS))(POS (PAPER.AUTHOR KHARDON94A "Roni Khardon and Dan Roth"))(POS (PAPER.TITLE KHARDON94A "Exploiting Relevance through Model-Based Reasoning"))(POS (PAPER.PUBLICATION KHARDON94A "AAAI"))(POS (PAPER.LINK KHARDON94A "http://citeseer.ist.psu.edu/40071.html"))(POS (PAPER.YEAR KHARDON94A 1994))(POS (PAPER.RANK KHARDON94A "[*****]"))(POS (PAPER.DESCRIPTION KHARDON94A "
Khardon and Roth outline three cases when the relevance can be exploited
to reason more efficiently.  The first deals with context.  Instead of using
all models for logical entailment, use just those that are relevant to 
the current context.  The second use of relevance is in using the Least
Upper Bound approximation of a theory to determine entailment when all 
queries will be answered correctly by the LUB.  Lastly, machine learning
is used to make reasoning easier as it gains experience in the world.
"))(POS (PAPER.TOPIC KHARDON94A "Model-Based Reasoning"))(POS (PAPER.INSTANCE KHARDON95))(POS (PAPER.BIBTEX KHARDON95 ARTICLE))(POS (PAPER.AUTHOR KHARDON95 "Roni Khardon"))(POS (PAPER.TITLE KHARDON95 "Translating between Horn Representations and their Characteristic Models"))(POS (PAPER.PUBLICATION KHARDON95 "Journal of Artificial Intelligence Research"))(POS (PAPER.VOLUME KHARDON95 "3"))(POS (PAPER.STARTPAGE KHARDON95 349))(POS (PAPER.ENDPAGE KHARDON95 372))(POS (PAPER.LINK KHARDON95 "http://citeseer.ist.psu.edu/khardon95translating.html"))(POS (PAPER.YEAR KHARDON95 1995))(POS (PAPER.RANK KHARDON95 "[***]"))(POS (PAPER.DESCRIPTION KHARDON95 "
Khardon builds on the previous work in kautz93 and khardon94 and investigates
the complexity of translating between propositional 
characteristic models and their
horn representations.  He shows that translating either way is polynomial-
reducible to the other, and that both are equivalent to deciding whether
a given set of models is the set of characteristic models of a given
set of horn clauses.  All these problems are at least as hard as converting
a monotone (no negations) CNF formula into a monotone DNF formula.  This
problem has a sub-exponential time solution of n^O(log n).
This paper also gives references to equivalent work in the database 
community under the name Armstrong relations.
"))(POS (PAPER.TOPIC KHARDON95 "Characteristic Models"))(POS (PAPER.RELATED KHARDON95 KAUTZ93))(POS (PAPER.RELATED KHARDON95 KHARDON95))(POS (PAPER.INSTANCE KHARDON95B))(POS (PAPER.BIBTEX KHARDON95B ARTICLE))(POS (PAPER.AUTHOR KHARDON95B "Roni Khardon and Heikki Mannila and Dan Roth"))(POS (PAPER.TITLE KHARDON95B "Reasoning with Examples: Propositional Formulae and Database Dependencies"))(POS (PAPER.PUBLICATION KHARDON95B "Techical Report: Harvard University"))(POS (PAPER.LINK KHARDON95B "http://citeseer.ist.psu.edu/170480.html"))(POS (PAPER.YEAR KHARDON95B 1995))(POS (PAPER.RANK KHARDON95B "[***]"))(POS (PAPER.DESCRIPTION KHARDON95B "
The authors show the connection between characteristic models and Armstrong
relations, i.e. relations that are sufficient for determining logical
entailment of functional dependencies.  They strengthen some of the
results on Armstrong relations and demonstrate a connection between
finding keys and abduction.
"))(POS (PAPER.TOPIC KHARDON95B "Characteristic Models"))(POS (PAPER.RELATED KHARDON95B KAUTZ93))(POS (PAPER.RELATED KHARDON95B KHARDON95))(POS (PAPER.INSTANCE KHARDON97))(POS (PAPER.BIBTEX KHARDON97 ARTICLE))(POS (PAPER.AUTHOR KHARDON97 "Roni Khardon and Dan Roth"))(POS (PAPER.TITLE KHARDON97 "Defaults and Relevance in Model Based Reasoning"))(POS (PAPER.PUBLICATION KHARDON97 "Artificial Intelligence"))(POS (PAPER.VOLUME KHARDON97 "97(1-2)"))(POS (PAPER.STARTPAGE KHARDON97 169))(POS (PAPER.ENDPAGE KHARDON97 193))(POS (PAPER.LINK KHARDON97 "http://citeseer.ist.psu.edu/khardon97defaults.html"))(POS (PAPER.YEAR KHARDON97 1997))(POS (PAPER.RANK KHARDON97 "[****]"))(POS (PAPER.DESCRIPTION KHARDON97 "
This paper explains how model-based reasoning can be used to model reasoning
with context.  Suppose the KB is represented by a set of models M.  As the agent's
context changes, new sentences appear that define that context.  Entailment in
the context then means that the sentence holds in the subset of models M that
satisfy those new sentences.  By representing the theory as a set of models,
as context changes, that set can be reduced online.  In this paper, context
change is represented using default logic.  Algorithms are given for both
skeptical and credulous default reasoning where the knowledge base is represented
as a set of models.  Conditions are given under which these algorithms work
correctly.  Finally, the learning to reason paradigm is brought up as a third
argument for representing a KB as the set of models that satisfy it.  All three,
context, defaults, and learning to reason, sometimes produce computational
benefits because models are used to represent knowledge.
"))(POS (PAPER.TOPIC KHARDON97 "Characteristic Models"))(POS (PAPER.INSTANCE KHARDON98))(POS (PAPER.BIBTEX KHARDON98 ARTICLE))(POS (PAPER.AUTHOR KHARDON98 "Roni Khardon and Heikki Manilla and Dan Roth"))(POS (PAPER.TITLE KHARDON98 "Reasoning with Examples: Propositional Formulae and Database Dependencies"))(POS (PAPER.PUBLICATION KHARDON98 "Acta Informatica"))(POS (PAPER.VOLUME KHARDON98 "36(4)"))(POS (PAPER.STARTPAGE KHARDON98 267))(POS (PAPER.ENDPAGE KHARDON98 286))(POS (PAPER.LINK KHARDON98 "http://citeseer.ist.psu.edu/170480.html"))(POS (PAPER.YEAR KHARDON98 1998))(POS (PAPER.RANK KHARDON98 "[***]"))(POS (PAPER.DESCRIPTION KHARDON98 "
Reasoning with Examples means reasoning with enough models to correctly
determine entailment.  This technique shows up both in the database
literature under the name 'Armstrong Relations' and in the automated
reasoning literature under the name 'Characteristic Models'.  While
the latter refers to a set of examples, the former refers to a single
example.  The number of models needed in Characteristic Models for
propositional logic is bounded by |B|*|DNF(kb)|, where B is the 
basis for the knowledge base kb.  The bulk of this paper shows how the 
two concepts are closely intertwined; it goes on to show that finding 
the keys of a DB is akin to finding abductive explanations in a propositional
knowledge base. 
"))(POS (PAPER.TOPIC KHARDON98 "Characteristic Models"))(POS (PAPER.RELATED KHARDON98 FAGIN82))(POS (PAPER.RELATED KHARDON98 KHARDON95))(POS (PAPER.INSTANCE KIM87))(POS (PAPER.BIBTEX KIM87 ARTICLE))(POS (PAPER.AUTHOR KIM87 "Myung Won Kim"))(POS (PAPER.TITLE KIM87 "On Automatically Generating and Using Examples in a Computational Logic System"))(POS (PAPER.PUBLICATION KIM87 "Technical Report"))(POS (PAPER.LINK KIM87 "http://citeseer.ist.psu.edu/342499.html"))(POS (PAPER.YEAR KIM87 1987))(POS (PAPER.RANK KIM87 "[*]"))(POS (PAPER.DESCRIPTION KIM87 "
Kim's dissertation explores an algorithm for automatically generating 
examples that satisfy a particular constraint given other such examples.
He also explores how such an algorithm can be used to help prune
a theorem-proving search space.  The logic is the Boyer-Moore theory,
and the theorem prover is the Boyer Moore theorem prover.
"))(POS (PAPER.TOPIC KIM87 "Reasoning with Examples"))(POS (PAPER.INSTANCE KIM94))(POS (PAPER.BIBTEX KIM94 INPROCEEDINGS))(POS (PAPER.AUTHOR KIM94 "Sun Kim and Hantao Zhang"))(POS (PAPER.TITLE KIM94 "ModGen: Theorem Proving by Model Generation"))(POS (PAPER.PUBLICATION KIM94 "AAAI"))(POS (PAPER.LINK KIM94 "http://citeseer.ist.psu.edu/kim94modgen.html"))(POS (PAPER.YEAR KIM94 1994))(POS (PAPER.RANK KIM94 "[**]"))(POS (PAPER.DESCRIPTION KIM94 "
The authors describe a system that propositionalizes Otter sentences and then
applies model-checking.  The limitation here is the requirement of a 
finite Herbrand universe.
"))(POS (PAPER.TOPIC KIM94 "Model-Based Reasoning"))(POS (PAPER.INSTANCE KLEER84))(POS (PAPER.BIBTEX KLEER84 INPROCEEDINGS))(POS (PAPER.AUTHOR KLEER84 "Johan de Kleer"))(POS (PAPER.TITLE KLEER84 "Choices without Backtracking"))(POS (PAPER.PUBLICATION KLEER84 "AAAI"))(POS (PAPER.YEAR KLEER84 1984))(POS (PAPER.RANK KLEER84 "[**]"))(POS (PAPER.DESCRIPTION KLEER84 "
Kleer describes a method for increasing the efficiency of problem solving
by storing the assumptions of a derived fact along with that fact.  Doing
this limits the amount of backtracking necessary.  This might be applicable
when backtracking with data structures.  Here it is situated within a truth
maintenance system.
"))(POS (PAPER.TOPIC KLEER84 "Theorem Proving with Attachments"))(POS (PAPER.INSTANCE KOWALSKI69))(POS (PAPER.BIBTEX KOWALSKI69 INBOOK))(POS (PAPER.AUTHOR KOWALSKI69 "Robert Kowalski"))(POS (PAPER.TITLE KOWALSKI69 "Search Strategies for Theorem-Proving"))(POS (PAPER.PUBLICATION KOWALSKI69 "Machine Intelligence"))(POS (PAPER.VOLUME KOWALSKI69 "5"))(POS (PAPER.STARTPAGE KOWALSKI69 181))(POS (PAPER.ENDPAGE KOWALSKI69 201))(POS (PAPER.YEAR KOWALSKI69 1969))(POS (PAPER.RANK KOWALSKI69 "[***]"))(POS (PAPER.DESCRIPTION KOWALSKI69 "
Kowalski abstractly defines the theorem-proving problem in terms of an 
'abstract theorem-proving graph'.  He defines the search space by giving
a specification for each state, the operators that act on those 
states, and a termination condition.  In this case, the tp graph initially
consists of a set of nodes, one for each input axiom.  Further nodes 
(states) are reached (generated) by applying an inference rule to a set
of already reached (generated) nodes.   A search strategy is a mapping
from sets of nodes to other sets of nodes.  Kowalski gives sufficient
(abstract) conditions under which a search strategy is complete.  The
last few sections cover heuristics, their optimality and their 
admissibility.
"))(POS (PAPER.TOPIC KOWALSKI69 "Comparative Analysis"))(POS (PAPER.INSTANCE KOWALSKI79))(POS (PAPER.AUTHOR KOWALSKI79 "Robert Kowalski"))(POS (PAPER.TITLE KOWALSKI79 "Algorithm = Logic + Control"))(POS (PAPER.PUBLICATION KOWALSKI79 "Communications of the ACM"))(POS (PAPER.VOLUME KOWALSKI79 "22(7)"))(POS (PAPER.STARTPAGE KOWALSKI79 424))(POS (PAPER.ENDPAGE KOWALSKI79 436))(POS (PAPER.LINK KOWALSKI79 "http://portal.acm.org/citation.cfm?id=359136&dl=ACM&coll=portal&CFID=6287538&CFTOKEN=93143078"))(POS (PAPER.YEAR KOWALSKI79 1979))(POS (PAPER.RANK KOWALSKI79 "[*****]"))(POS (PAPER.DESCRIPTION KOWALSKI79 "
Kowalski defines an algorithm as Logic and Control.  Logic specifies what the
algorithm does or the knowledge used in
solving a problem.  Control determines the problem-solving strategies, namely
top-down, bottom -up, a combination of the two, and
orthogonally parallelization.  Ideally, the bulk of efficiency concerns
should fall under Control; however, we can improve the efficiency of an
algorithm by adjusting either the Logic or the Control.  
Quote: Computer programs
will be more often correct, more easily improved, and more readily adapted to
new problems when programming languages separate logic and control.
"))(POS (PAPER.TOPIC KOWALSKI79 "Logical Knowledge Representation"))(POS (PAPER.INSTANCE KROTZSCH2005))(POS (PAPER.BIBTEX KROTZSCH2005 TECHREPORT))(POS (PAPER.AUTHOR KROTZSCH2005 "Markus Krotzsch and Pascal Hitzler and Michael Sintek and Denny Vrandecic"))(POS (PAPER.TITLE KROTZSCH2005 "Expressive OWL Reasoning"))(POS (PAPER.PUBLISHER KROTZSCH2005 "University of Kalrsruhe"))(POS (PAPER.LINK KROTZSCH2005 "http://citeseer.ist.psu.edu/733293.html"))(POS (PAPER.YEAR KROTZSCH2005 2005))(POS (PAPER.DESCRIPTION KROTZSCH2005 "
The authors enlarge the class of formulas in OWL DL that can be reasoned
about with a logic programming engine; in addition they present
an alternative characterization of Description Logic Programming.
"))(POS (PAPER.TOPIC KROTZSCH2005 "Semantic Web"))(POS (PAPER.INSTANCE LENAT90))(POS (PAPER.BIBTEX LENAT90 BOOK))(POS (PAPER.AUTHOR LENAT90 "D.B. Lenat and R.V. Guha"))(POS (PAPER.TITLE LENAT90 "Building Large Knowledge-Based Systems: Representation and Inference in the CYC Project"))(POS (PAPER.PUBLISHER LENAT90 "Addison-Wesley"))(POS (PAPER.YEAR LENAT90 1990))(POS (PAPER.DESCRIPTION LENAT90 "
Book on Cyc, the large common-sense knowledge base in Texas.
"))(POS (PAPER.TOPIC LENAT90 "Logical Knowledge Representation"))(POS (PAPER.INSTANCE LENZ98))(POS (PAPER.BIBTEX LENZ98 BOOK))(POS (PAPER.AUTHOR LENZ98 "(ed.) Mario Lenz, et. al."))(POS (PAPER.TITLE LENZ98 "Case-Based Reasoning Technology:From Foundations to Applications (Lecture Notes in Artificial Intelligence)"))(POS (PAPER.LINK LENZ98 "http://www.amazon.com/exec/obidos/tg/detail/-/3540645721/104-6992918-7685512?vi=glance"))(POS (PAPER.YEAR LENZ98 1998))(POS (PAPER.RANK LENZ98 "[***]"))(POS (PAPER.DESCRIPTION LENZ98 "
Case-based reasoning analogically produces solutions to problems through
the use of a case library.  Chapter 1 tries to situate it in the field of
knowledge representation, explain the fundamental process, and describe
the problems to be solved.
"))(POS (PAPER.TOPIC LENZ98 "Case-Based Reasoning"))(POS (PAPER.INSTANCE LESPERANCE95))(POS (PAPER.AUTHOR LESPERANCE95 "Yves Lesperance, Hector J. Levesque, Fangzhen Lin, and Richard B.
Scherl"))(POS (PAPER.TITLE LESPERANCE95 "Ability and Knowing How in the Situation Calculus"))(POS (PAPER.LINK LESPERANCE95 "http://citeseer.ist.psu.edu/lesperance95ability.html"))(POS (PAPER.YEAR LESPERANCE95 1995))(POS (PAPER.DESCRIPTION LESPERANCE95 "
Lesperance et. al. describe 1) a formalism for showing that a given goal can or cannot be accomplished
without simply producing a plan to accomplish it.  This involves discovering whether there is a path of
actions that will lead to the goal at the metalevel.  2) In the plan space that includes sensing actions, nondeterministic
branching, nondeterministic argument-passing, and nondeterministic primitive action choice, the authors formalize the notion that a dumb execution
engine cannot execute all the same plans as an intelligent execution engine.  Building on (1), they
define DumbKnowHow (DKH) and SmartKnowHow (SKH) predicates.  Cool ideas here.  There is also a nice summary
of a formalization of these sensing actions.
"))(POS (PAPER.TOPIC LESPERANCE95 "Fundamentals"))(POS (PAPER.INSTANCE LEUSCHEL2002))(POS (PAPER.BIBTEX LEUSCHEL2002 ARTICLE))(POS (PAPER.AUTHOR LEUSCHEL2002 "Michael Leuschel and Maurice Bruynooghe"))(POS (PAPER.TITLE LEUSCHEL2002 "Logic Program Specialisation Through Partial Deduction: Control Issues"))(POS (PAPER.PUBLICATION LEUSCHEL2002 "Theory and Practice of Logic Programming"))(POS (PAPER.VOLUME LEUSCHEL2002 "2(4-5)"))(POS (PAPER.STARTPAGE LEUSCHEL2002 461))(POS (PAPER.ENDPAGE LEUSCHEL2002 515))(POS (PAPER.LINK LEUSCHEL2002 ""))(POS (PAPER.YEAR LEUSCHEL2002 2002))(POS (PAPER.DESCRIPTION LEUSCHEL2002 "
The authors go through some of the work on partial evaluation in the case
of pure logic programming, which is called partial deduction.  (It differs
from partial evaluation in LP because axioms can be partially partially 
evaluated in the case of non-ground static arguments.)  Partial deduction
means constructing a partial SLDNF tree for a query, and using the fringe
to imply the goal as the output.  Interestingly, with negation, most work 
focuses on preserving operational semantics, as the well-founded semantics
are preserved for all groundings of the goal(s).  This paper focuses on
control issues surrounding the constructing of these SLDNF trees: (1)
given a goal atom A, how do we construct a tree, the local control
problem, and (2) what is the set of all goal atoms, the global control. 
The second problem only occurs because of the desire to preserve
procedural semantics.  The process of unfolding, i.e. constructing
the tree, is difficult because applying too many resolutions can 
result in local code explosion, work duplication, and non
termination.  If the unfold function is guaranteed to produce a tree 
with at most one non-failing
branch, it is said to be determinate; determine unfolding will not
produce code explosion or work duplication.  It is undecidable to determine
whether a tree with at most one non-failing branch can be constructed.
Approximations are usually used.   To deal with termination, binding-time
analysis is used (sometimes computed using abstract interpretation), which
creates annotations that have decided whether to unfold or not.  Instead of
handling termination offline, another approach handles it online--during
specialisation.  Well-founded and well-quasi orders are popular here.  
There is also a discussion of global control issues.  Interestingly,
tabling with partial deduction can turn a terminating program into
a nonterminating program.  Long reference list.
"))(POS (PAPER.TOPIC LEUSCHEL2002 "Reformulation"))(POS (PAPER.INSTANCE LEVESQUE84))(POS (PAPER.BIBTEX LEVESQUE84 CHAPTER))(POS (PAPER.AUTHOR LEVESQUE84 "Hector J. Levesque"))(POS (PAPER.TITLE LEVESQUE84 "The Logic of Incomplete Knowledge Bases"))(POS (PAPER.PUBLISHER LEVESQUE84 "Springer-Verlag"))(POS (PAPER.PUBLICATION LEVESQUE84 "On Conceptual Modelling"))(POS (PAPER.STARTPAGE LEVESQUE84 165))(POS (PAPER.ENDPAGE LEVESQUE84 189))(POS (PAPER.LINK LEVESQUE84 ""))(POS (PAPER.YEAR LEVESQUE84 1984))(POS (PAPER.RANK LEVESQUE84 "[**]"))(POS (PAPER.DESCRIPTION LEVESQUE84 "
Levesque attacks the problem of querying an incomplete knowledge base about its
incompleteness.  How else does one know how accurately the KB represents the domain
it is modeling?  If a query is not entailed, without being able to ask whether the
query itself is known to the KB, we do not know if the query is false or whether
the KB simply doesn't know.  Levesque introduces a language, KL, based on the operator
K for dealing with this problem.  In the end, he claims the interaction of a KB
with a user should be done using this  language, but that any such query can be
translated into straight-up FOL without K.
"))(POS (PAPER.TOPIC LEVESQUE84 "Logical Knowledge Representation"))(POS (PAPER.INSTANCE LEVESQUE85))(POS (PAPER.BIBTEX LEVESQUE85 INBOOK))(POS (PAPER.AUTHOR LEVESQUE85 "Hector J. Levesque and Ronald J. Brachman"))(POS (PAPER.TITLE LEVESQUE85 "A Fundamental Tradeoff in Knowledge Representation and Reasoning"))(POS (PAPER.PUBLISHER LEVESQUE85 "Morgan Kaufmann Publishers"))(POS (PAPER.PUBLICATION LEVESQUE85 "Readings in Knowledge Representation and Reasoning
           "))(POS (PAPER.LINK LEVESQUE85 "http://citeseer.ist.psu.edu/context/54197/0"))(POS (PAPER.YEAR LEVESQUE85 1985))(POS (PAPER.RANK LEVESQUE85 "[***]"))(POS (PAPER.DESCRIPTION LEVESQUE85 "
Levesque and Brachman argue that a perfect representation language does not
exist.  Rather, languages vary in expressiveness and tractability, and some
are only more interesting than others for certain uses.  The authors examine
first-order logic, databases, semantic nets, and frame systems as examples.
"))(POS (PAPER.TOPIC LEVESQUE85 "Logical Knowledge Representation"))(POS (PAPER.INSTANCE LEVESQUE86))(POS (PAPER.AUTHOR LEVESQUE86 "Hector J. Levesque"))(POS (PAPER.TITLE LEVESQUE86 "Making Believers Out of Computers"))(POS (PAPER.PUBLICATION LEVESQUE86 "Artificial Intelligence"))(POS (PAPER.VOLUME LEVESQUE86 "30(1)"))(POS (PAPER.STARTPAGE LEVESQUE86 81))(POS (PAPER.ENDPAGE LEVESQUE86 108))(POS (PAPER.YEAR LEVESQUE86 1986))(POS (PAPER.RANK LEVESQUE86 "[***]"))(POS (PAPER.DESCRIPTION LEVESQUE86 "
Levesque argues that the combinatorial explosion of exponential-time
algorithms cannot be tolerated for AI systems, except for a 'puzzle-mode'.  
To that end, he advises building knowledge bases using languages that
only allow complete ('vivid') information and using 
reasoning methods that may at times be unsound and/or incomplete.  His
examples invoke the reader's imagination to invent a pictures that model
the example descriptions.  Such descriptions can then be considered vivid.
"))(POS (PAPER.TOPIC LEVESQUE86 "Logical Knowledge Representation"))(POS (PAPER.INSTANCE LEVESQUE96))(POS (PAPER.AUTHOR LEVESQUE96 "Hector J. Levesque"))(POS (PAPER.TITLE LEVESQUE96 "What is Planning in the presence of sensing?"))(POS (PAPER.LINK LEVESQUE96 "http://www.cs.toronto.edu/cogrobo/Papers/sensing.pdf"))(POS (PAPER.YEAR LEVESQUE96 1996))(POS (PAPER.DESCRIPTION LEVESQUE96 "

Intro: Classical planning doesn't deal with the problem of sensing or looping, e.g. it cannot produce plans that will successfully achieve the Airport or the Omlette examples.  Sensing is necessary iff there are properties of the world that cannot be deduced at plan time but that are required for achieving the goal.

<br><br>Classical Planning: Use sit calc to formally define the classical planning problem.  It is unclear to me whether the sit calc he is using would somehow allow there to be partial order plans, e.g. return something like (do (parallel a b c) (do (parallel e f) (do h s0))).  For now let's say it can't and sitcalc plans must be total orders.  We might argue that because his definition is tied to sitcalc, which produces only totally ordered plans, his 'definition' of the classical planning problem is wrong.  But it doesn't really matter for the rest of what he is going to say.

Incorporating sensing actions: gives an overview of another one of his papers which introduces sensing actions into sitcalc, and reviews some related work.

<br><br>Robot programs: introduces a language for describing plans that is more expressive than the standard sitcalc (do a (do b (do .... s0)))) and partial order languages.  Includes loops and branches.  He defines the semantics of the language in situation calculus, relying on a new second order construct for defining the semantics of a loop.  Finally, he states the first theorem, which amounts to a set of rewrite rules for each of the new constructs in the robot language, where the rewrite rules allow one to construct an interpreter for the language.  That is, the obvious interpreter for the language does the right thing, and the theorem proves that.

The revised planning task: formalize, using the machinery built up above, the planning problem as it includes loops, branches, and sensing.  Remember this is all sitcalc in first-order logic + a couple second-order constructs.  The rest of the section works through the Airport example.

<br><br>Note: Importantly, all the examples thusfar, as well as the definition of the planning task requires a _deductive_ solution.  That is, the airport example includes the axiom AtGate(a) | AtGate(b).  At plan-time we can prove that the plan (seq goto-airport (if check-gate(a) then goto-gate-a else goto-gate-b)) will work.  This is unlike our room reservation example since there may be no room to reserve, but we won't know that until plan execution time.  At plan-time, there is no plan we can prove will work.

<br><br>Are robot programs enough?: They claim the original plan language is not sufficient for expressing plans for every solvable planning problem.  The reason is that there is no memory available for the program to use.  Asking for a plan that returns the number of eggs it is given at runtime cannot be achieved without (infinite) memory.  Levesque adds 5 actions (left, right, mark, erase, read_mark) that can be used to expand the plans expressible by his robot language to include (he claims) everything that is computable.  That is, his planning language with these additional actions would force a planner to construct a Turing Machine that achieves the given goal.  Of course, that problem is undecidable.  

<br><br>A two sentence summary.  Levesque introduces a plan description language that includes branching and loops (with an extension that he claims makes the language Turing complete), for the simple reason that solving some real world planning problems requires sensing and looping.  He formalizes the planning problem as one of deduction, which has the benefit that deductive solutions will always be right but has the drawback that it eliminates plans that we might expect a machine to produce, e.g. room reservation.


"))(POS (PAPER.TOPIC LEVESQUE96 "Planning with Sensing Actions"))(POS (PAPER.INSTANCE LEVESQUE97))(POS (PAPER.AUTHOR LEVESQUE97 "Levesque, et al."))(POS (PAPER.TITLE LEVESQUE97 "Golog: A Logic Programming Language for Dynamic Domains"))(POS (PAPER.LINK LEVESQUE97 "http://citeseer.ist.psu.edu/27198.html"))(POS (PAPER.YEAR LEVESQUE97 1997))(POS (PAPER.DESCRIPTION LEVESQUE97 "
Golog does macro-replacement into situation calculus from nondeterministic parameter choice, nondeterministic action choice, nondeterministic iteration, test actions, and procedures.  This macro-replacement means answer extraction cannot be used to extract a complex plan using the above constructs.  Instead, given a complex plan, the Golog interpreter produces an equivalent situation calculus plan(I think--still fuzzy here).
"))(POS (PAPER.TOPIC LEVESQUE97 "Logic Programming"))(POS (PAPER.INSTANCE LEVESQUE98))(POS (PAPER.AUTHOR LEVESQUE98 "Hector Levesque, Fiora Pirri, and Ray Reiter"))(POS (PAPER.TITLE LEVESQUE98 "Foundations for the Situation Calculus"))(POS (PAPER.PUBLICATION LEVESQUE98 "Linkoping Electronic Articles in Computer and Information Science"))(POS (PAPER.VOLUME LEVESQUE98 "3"))(POS (PAPER.LINK LEVESQUE98 "http://citeseer.ist.psu.edu/levesque98foundations.html"))(POS (PAPER.YEAR LEVESQUE98 1998))(POS (PAPER.RANK LEVESQUE98 "[***]"))(POS (PAPER.DESCRIPTION LEVESQUE98 "
This is a rehash of Pirri99, except they add in a
section describing sensing and knowledge in Situation Calculus.  They extend
their definition of a basic action theory to include knowledge-producing
actions.  Namely, a knowledge-action theory D_e = Sigma_e U D_ss U D_ap U D_una
U D_S0 U D_sf U D_k0.  Sigma_e is an expanded set of foundational axioms; D_ss
are the successor state axioms; D_ap are the action precondition axioms;
D_una are the unique name axioms for actions; D_s0 is the initial situation;
D_k0 is an initial knowldge axiom (what the agent knows in S0).  This stuff
gets pretty messy, but eventually they provide a solution to the knowledge
frame problem, i.e. "))(POS (PAPER.TOPIC LEVESQUE98 "Fundamentals"))(POS (PAPER.INSTANCE LIFSCHITZ2002))(POS (PAPER.BIBTEX LIFSCHITZ2002 ARTICLE))(POS (PAPER.AUTHOR LIFSCHITZ2002 "V. Lifschitz"))(POS (PAPER.TITLE LIFSCHITZ2002 "Answer set programming and plan generation"))(POS (PAPER.PUBLICATION LIFSCHITZ2002 "Artificial Intelligence"))(POS (PAPER.VOLUME LIFSCHITZ2002 "138(1-2)"))(POS (PAPER.STARTPAGE LIFSCHITZ2002 39))(POS (PAPER.ENDPAGE LIFSCHITZ2002 54))(POS (PAPER.LINK LIFSCHITZ2002 "http://citeseer.ist.psu.edu/301403.html"))(POS (PAPER.YEAR LIFSCHITZ2002 2002))(POS (PAPER.DESCRIPTION LIFSCHITZ2002 "
Answer set programming paper by Lifschitz.
"))(POS (PAPER.TOPIC LIFSCHITZ2002 "Logic Programming"))(POS (PAPER.INSTANCE LIFSCHITZ85))(POS (PAPER.BIBTEX LIFSCHITZ85 ARTICLE))(POS (PAPER.AUTHOR LIFSCHITZ85 "Vladimir Lifschitz"))(POS (PAPER.TITLE LIFSCHITZ85 "Closed World Databases and Circumscription"))(POS (PAPER.PUBLICATION LIFSCHITZ85 "Artificial Intelligence"))(POS (PAPER.VOLUME LIFSCHITZ85 "27(2)"))(POS (PAPER.STARTPAGE LIFSCHITZ85 229))(POS (PAPER.ENDPAGE LIFSCHITZ85 235))(POS (PAPER.YEAR LIFSCHITZ85 1985))(POS (PAPER.DESCRIPTION LIFSCHITZ85 "
Lifschitz proves the following theorem.  If CWA is consistent,
then CWA and Circumscription produce 
equivalent theories when applied to universal, closed sentences in a
function-free, equality-free vocabulary with finitely many relation and
object constants whenever the domain closure assumption and unique
names assumption are in play.
"))(POS (PAPER.TOPIC LIFSCHITZ85 "Non-monotonic Reasoning"))(POS (PAPER.INSTANCE LIFSCHITZ87))(POS (PAPER.AUTHOR LIFSCHITZ87 "V. Lifschitz"))(POS (PAPER.TITLE LIFSCHITZ87 "On the semantics of STRIPS"))(POS (PAPER.PUBLICATION LIFSCHITZ87 "Reasoning About Actions and Plans"))(POS (PAPER.STARTPAGE LIFSCHITZ87 1))(POS (PAPER.ENDPAGE LIFSCHITZ87 9))(POS (PAPER.LINK LIFSCHITZ87 "http://www.cs.utexas.edu/users/vl/papers-old.html"))(POS (PAPER.YEAR LIFSCHITZ87 1987))(POS (PAPER.DESCRIPTION LIFSCHITZ87 "
Lifschitz gives semantics to Fike's and Nilsson's STRIPS.  He gives one definition of a STRIPS system's soundness that relies on atomic sentences for both the add and delete lists (effectively).  All non-atomic sentences must be true in all worlds.  The preconditions can still be full FOL.  Lifschitz goes on to explain how to deal with peculiarities to improve efficiency, e.g. only including nextTo(a,b) when nextTo(x,y) is symmetric.
"))(POS (PAPER.TOPIC LIFSCHITZ87 "Historical"))(POS (PAPER.INSTANCE LIFSCHITZ96))(POS (PAPER.BIBTEX LIFSCHITZ96 CHAPTER))(POS (PAPER.AUTHOR LIFSCHITZ96 "Vladimir Lifschitz"))(POS (PAPER.TITLE LIFSCHITZ96 "Foundations of Logic Programming"))(POS (PAPER.PUBLICATION LIFSCHITZ96 "Principles of Knowledge Representation"))(POS (PAPER.STARTPAGE LIFSCHITZ96 69))(POS (PAPER.ENDPAGE LIFSCHITZ96 127))(POS (PAPER.LINK LIFSCHITZ96 "http://citeseer.ist.psu.edu/lifschitz96foundations.html"))(POS (PAPER.YEAR LIFSCHITZ96 1996))(POS (PAPER.DESCRIPTION LIFSCHITZ96 "
Survey of logic programming theory.
"))(POS (PAPER.TOPIC LIFSCHITZ96 "Logic Programming"))(POS (PAPER.INSTANCE LIN94))(POS (PAPER.AUTHOR LIN94 "Fangzhen Lin and Ray Reiter"))(POS (PAPER.TITLE LIN94 "How to Progress a Database (and Why) I. Logical Foundations"))(POS (PAPER.PUBLICATION LIN94 "Principles of Knowledge Representation and Reasoning "))(POS (PAPER.STARTPAGE LIN94 425))(POS (PAPER.ENDPAGE LIN94 436))(POS (PAPER.LINK LIN94 "http://citeseer.ist.psu.edu/11152.html"))(POS (PAPER.YEAR LIN94 1994))(POS (PAPER.RANK LIN94 "[****]"))(POS (PAPER.DESCRIPTION LIN94 "
Lin and Reiter argue that STRIPS (planning) can be thought of as progressing an initial database S0 with an action sequence A to a final database SA.  They prove the general problem cannot be solved using only FOL, but in fact properly needs induction.  The special cases of 'relatively complete' initial databases and 'context-free' action theories (with certain restrictions on the initial database) yield first-order theories.
"))(POS (PAPER.TOPIC LIN94 "Theories of Action"))(POS (PAPER.INSTANCE LIN95A))(POS (PAPER.AUTHOR LIN95A "Fangzhen Lin and Ray Reiter"))(POS (PAPER.TITLE LIN95A "How to Progress a Database II: The STRIPS Connection"))(POS (PAPER.PUBLICATION LIN95A "IJCAI"))(POS (PAPER.STARTPAGE LIN95A 2001))(POS (PAPER.ENDPAGE LIN95A 2009))(POS (PAPER.LINK LIN95A "http://citeseer.ist.psu.edu/lin94how.html"))(POS (PAPER.YEAR LIN95A 1995))(POS (PAPER.RANK LIN95A "[*]"))(POS (PAPER.DESCRIPTION LIN95A "
Lin and Reiter build on the first part of this paper and give certain varieties of STRIPS semantics based on progressing a database.  
"))(POS (PAPER.TOPIC LIN95A "Theories of Action"))(POS (PAPER.RELATED LIN95A LIN94))(POS (PAPER.INSTANCE LIN95B))(POS (PAPER.AUTHOR LIN95B "Fangzhen Lin and Yoav Shoham"))(POS (PAPER.TITLE LIN95B "Provably Correct Theories of Action"))(POS (PAPER.PUBLICATION LIN95B "Journal of the ACM"))(POS (PAPER.VOLUME LIN95B "42(2)"))(POS (PAPER.STARTPAGE LIN95B 293))(POS (PAPER.ENDPAGE LIN95B 320))(POS (PAPER.LINK LIN95B "http://citeseer.ist.psu.edu/lin91provably.html"))(POS (PAPER.YEAR LIN95B 1995))(POS (PAPER.RANK LIN95B "[****]"))(POS (PAPER.DESCRIPTION LIN95B "
Lin and Shoham give a formal definition for epistemologically complete theories of action.  They explain monotonic and nonmonotonic completions of action theories; the former requires frame axioms and the latter circumscription.   They go on to extend situation calculus to handle concurrent actions by bundling primitive actions together into 'global actions'.  They extend their definition for epistemological completeness to encompass this variation of sitcalc.
"))(POS (PAPER.TOPIC LIN95B "Theories of Action"))(POS (PAPER.INSTANCE LLOYD))(POS (PAPER.BIBTEX LLOYD BOOK))(POS (PAPER.AUTHOR LLOYD "John Lloyd"))(POS (PAPER.TITLE LLOYD "Foundations of Logic Programming"))(POS (PAPER.PUBLISHER LLOYD "Springer Verlag"))(POS (PAPER.LINK LLOYD "http://www.amazon.com/Foundations-Logic-Programming-Symbolic-Computation/dp/0387181997"))(POS (PAPER.YEAR LLOYD 1984))(POS (PAPER.RANK LLOYD "[*****]"))(POS (PAPER.DESCRIPTION LLOYD "
Lloyd covers the declarative and procedural semantics of logic programming without
negation and then considers the case of an acyclic logic program with negation,
and proves soundness and completeness via predicate completion.  The classic text.
"))(POS (PAPER.TOPIC LLOYD ""))(POS (PAPER.INSTANCE LLOYD84))(POS (PAPER.BIBTEX LLOYD84 ARTICLE))(POS (PAPER.AUTHOR LLOYD84 "J. Lloyd and R. Topor"))(POS (PAPER.TITLE LLOYD84 "Making Prolog more expressive"))(POS (PAPER.PUBLICATION LLOYD84 "Journal of Logic Programming"))(POS (PAPER.VOLUME LLOYD84 "1(3)"))(POS (PAPER.STARTPAGE LLOYD84 225))(POS (PAPER.ENDPAGE LLOYD84 240))(POS (PAPER.YEAR LLOYD84 1984))(POS (PAPER.DESCRIPTION LLOYD84 "
Includes the Lloyd-Topor transformation.
"))(POS (PAPER.TOPIC LLOYD84 "Logic Programming"))(POS (PAPER.INSTANCE LOBO))(POS (PAPER.BIBTEX LOBO BOOK))(POS (PAPER.AUTHOR LOBO "Jorge Lobo and Jack Minker and Arcot Rajasekar"))(POS (PAPER.TITLE LOBO "Foundations of Disjunctive Logic Programming"))(POS (PAPER.PUBLISHER LOBO "The MIT Press"))(POS (PAPER.LINK LOBO "http://mitpress.mit.edu/catalog/item/default.asp?ttype=2&tid=5834"))(POS (PAPER.YEAR LOBO 1992))(POS (PAPER.DESCRIPTION LOBO "
Book laying the foundations of disjunctive logic programming.
"))(POS (PAPER.TOPIC LOBO ""))(POS (PAPER.INSTANCE LOCHNER02))(POS (PAPER.BIBTEX LOCHNER02 ARTICLE))(POS (PAPER.AUTHOR LOCHNER02 "Bernd Loechner and Thomas Hillenbrand"))(POS (PAPER.TITLE LOCHNER02 "A phytography of Waldmeister"))(POS (PAPER.PUBLICATION LOCHNER02 "AI Communications"))(POS (PAPER.VOLUME LOCHNER02 "15"))(POS (PAPER.STARTPAGE LOCHNER02 127))(POS (PAPER.ENDPAGE LOCHNER02 133))(POS (PAPER.LINK LOCHNER02 "http://citeseer.ist.psu.edu/558093.html"))(POS (PAPER.YEAR LOCHNER02 2002))(POS (PAPER.RANK LOCHNER02 ""))(POS (PAPER.DESCRIPTION LOCHNER02 "
Waldmeister is a unit equation theorem prover based on
unfailing completion.  Its architecture is the same
Discount algorithm found in Vampire and E.  Written in C,
it uses perfect discrimination trees (a variation on the trie)
to index terms.  It also includes automated tuning of 
its parameters, based on TPTP experience.
"))(POS (PAPER.TOPIC LOCHNER02 "System Designs"))(POS (PAPER.INSTANCE LOECHNER2004))(POS (PAPER.AUTHOR LOECHNER2004 "Bernd Loechner"))(POS (PAPER.TITLE LOECHNER2004 "Things to know when implementing LPO"))(POS (PAPER.PUBLICATION LOECHNER2004 "Workshop on Empirically Successful First Ordering Reasoning"))(POS (PAPER.LINK LOECHNER2004 ""))(POS (PAPER.YEAR LOECHNER2004 2004))(POS (PAPER.DESCRIPTION LOECHNER2004 "
Loechner explains that the naive implementation of Lexicographic Path
Ordering is exponential but then goes on to show how to make it
multiplicative in the size of the two terms.  
"))(POS (PAPER.TOPIC LOECHNER2004 "Orderings"))(POS (PAPER.INSTANCE LOPEZGARCIA2004))(POS (PAPER.BIBTEX LOPEZGARCIA2004 ARTICLE))(POS (PAPER.AUTHOR LOPEZGARCIA2004 "P. Lopez-Garcia and F. Bueno and M. Hermenegildo"))(POS (PAPER.TITLE LOPEZGARCIA2004 "Determinacy Analysis for Logic Programs Using Mode and Type Information"))(POS (PAPER.PUBLICATION LOPEZGARCIA2004 "14th International Symposium, Logic Based Program Synthesis and Trnasformation (LOPSTR)"))(POS (PAPER.STARTPAGE LOPEZGARCIA2004 19))(POS (PAPER.ENDPAGE LOPEZGARCIA2004 35))(POS (PAPER.LINK LOPEZGARCIA2004 "http://wotan.liu.edu/docis/dbl/lopstr/index.html"))(POS (PAPER.YEAR LOPEZGARCIA2004 2004))(POS (PAPER.DESCRIPTION LOPEZGARCIA2004 "
In the context of Logic programming, the authors consider two problems:
(1) detecting whether a relation will ever return more than one answer
through all control paths, i.e. whether the relation is determinate,
 and (2) determining whether more than one
rule with for a relation will ever be satisfied for
the same query, i.e. whether the rules defining that relation
are mutually exclusive.  Addressing these questions relies on type
information, i.e. all the possible queries asked for a relation, and
mode information, i.e. whether a variable is used for validation or
for generation.  For r to be determinate, it is sufficient
that every relation that is a subgoal of r be mutually exclusive.
Thus an approximation of (1) can be accomplished by computing (2).  The test
for mutual exclusion offered here will return true only when all the 
rules for a relation contain procedural attachments that can be shown
to be mutually exclusive for all the types of the relation.  Experimental
results are shown for the case where the procedural attachments are
equality/distinction/inequality.
"))(POS (PAPER.TOPIC LOPEZGARCIA2004 "Reformulation"))(POS (PAPER.INSTANCE MANNA86))(POS (PAPER.AUTHOR MANNA86 "Zohar Manna"))(POS (PAPER.TITLE MANNA86 "How to Clear a Block: A Theory of Plans"))(POS (PAPER.LINK MANNA86 "http://library.stanford.edu/depts/mathcs/mathcscoll/techreports.html"))(POS (PAPER.YEAR MANNA86 1986))(POS (PAPER.DESCRIPTION MANNA86 "
This is the recursive plan paper everyone cites; not surprisingly, it shows up in the context of
program synthesis.  Manna uses Deductive Tableaux to produce programs that contain conditionals
(via a special inference rule) and recursion (using a well-founded mathematical
induction axiom).  The problem with Manna's recursion lies in the need for what he calls
Generalization, i.e. automatically strengthening the stated goal.  Manna also deals
with equality by building it into the unification algorithm.
"))(POS (PAPER.TOPIC MANNA86 "Recursive Plan Generation"))(POS (PAPER.INSTANCE MANNA94))(POS (PAPER.BIBTEX MANNA94 INBOOK))(POS (PAPER.AUTHOR MANNA94 "Zohar Manna et. al."))(POS (PAPER.TITLE MANNA94 "STeP: the Stanford Temporal Prover"))(POS (PAPER.PUBLICATION MANNA94 "TAPSOFT"))(POS (PAPER.LINK MANNA94 "http://citeseer.ist.psu.edu/manna94step.html"))(POS (PAPER.YEAR MANNA94 1994))(POS (PAPER.RANK MANNA94 "[*]"))(POS (PAPER.DESCRIPTION MANNA94 "
STeP is a verification system that proves first order temporal 
formulas valid in concurrent, reactive systems described in SPL.  
It combines equational and arithmetic simplification, model 
checking, interactive first-order theorem proving, and automatic
invariant generation.  The model checking is done through 
Streett automaton and behavior automaton.  The first-order
theorem proving is automated with non-clausal resolution
and paramodulation and utilizes lemmas.  The interactive
theorem proving is handled with a Gentzen-style prover:
both first-order and temporal first-order.  Propositional
temporal formulas can be automatically verified.
This paper is well-written and clear, but assumes knowledge
of temporal logic and transition systems.
"))(POS (PAPER.TOPIC MANNA94 "Model Checking"))(POS (PAPER.INSTANCE MANTHEY88))(POS (PAPER.BIBTEX MANTHEY88 INPROCEEDINGS))(POS (PAPER.AUTHOR MANTHEY88 "Rainer Manthey and Francois Bry"))(POS (PAPER.TITLE MANTHEY88 "SATCHMO: A Theorem Prover Implemented in Prolog"))(POS (PAPER.PUBLICATION MANTHEY88 "Proceedings of the Conference on Automated Deduction"))(POS (PAPER.STARTPAGE MANTHEY88 415))(POS (PAPER.ENDPAGE MANTHEY88 434))(POS (PAPER.YEAR MANTHEY88 1988))(POS (PAPER.DESCRIPTION MANTHEY88 "
Tableaux-style prover implemented in Prolog, using assert and retract.
"))(POS (PAPER.TOPIC MANTHEY88 "Calculi"))(POS (PAPER.INSTANCE MARRAFA91))(POS (PAPER.BIBTEX MARRAFA91 ARTICLE))(POS (PAPER.AUTHOR MARRAFA91 "Palmira Marrafa and Patrick Saint-Dizier"))(POS (PAPER.TITLE MARRAFA91 "Reversibility in a Constraint and Type based Logic Grammar"))(POS (PAPER.LINK MARRAFA91 "http://acl.ldc.upenn.edu/W/W91/W91-0102.pdf"))(POS (PAPER.YEAR MARRAFA91 1991))(POS (PAPER.RANK MARRAFA91 "[***]"))(POS (PAPER.DESCRIPTION MARRAFA91 "
In the topic of reversible grammars.
Marrafa and Saint-Dizier introduce a mathematical language for 
describing natural languages.  The mathematical language includes certain
object-oriented concepts. In addition, abstract machines for parsing and
generating languages so described are given.
"))(POS (PAPER.TOPIC MARRAFA91 "Natural Language Processing"))(POS (PAPER.INSTANCE MASTERS2003))(POS (PAPER.BIBTEX MASTERS2003 ARTICLE))(POS (PAPER.AUTHOR MASTERS2003 "James Masters and Zelai Gungordu"))(POS (PAPER.TITLE MASTERS2003 "Semantic Knowledge Source Integration: A Progress Report"))(POS (PAPER.PUBLICATION MASTERS2003 "Integration of Knowledge Intensive Multi-Agent Systems"))(POS (PAPER.YEAR MASTERS2003 2003))(POS (PAPER.RANK MASTERS2003 ""))(POS (PAPER.DESCRIPTION MASTERS2003 "
Paper on using a database to speed up theorem proving.  Here they want togive a TP access to the information contained in several databases.
"))(POS (PAPER.TOPIC MASTERS2003 "Theorem Proving with Attachments"))(POS (PAPER.INSTANCE MATZINGER97))(POS (PAPER.BIBTEX MATZINGER97 TECHREPORT))(POS (PAPER.AUTHOR MATZINGER97 "Robert Matzinger"))(POS (PAPER.TITLE MATZINGER97 "Comparing Computational Representations of Herbrand Models"))(POS (PAPER.LINK MATZINGER97 "http://www.kr.tuwien.ac.at/guests/matzi/publications.html"))(POS (PAPER.YEAR MATZINGER97 1997))(POS (PAPER.RANK MATZINGER97 "[*****]"))(POS (PAPER.DESCRIPTION MATZINGER97 "
Matzinger investigates various representations of models and
answers three complexity questions for each representation:
ground atom entailment, clause entailment, model equivalence.
The two representations of finite models examined are
context-free grammers and atom representations.  Both CFGs
and ground atoms plus ground equations are equivalent
to finite models, i.e. both representations have an associated
finite model and every finite model has a submodel that
is equivalent to both representations.
Different subsets of all infinite models can be represented by 
term schematizations and constrained atoms.  They seem to be
incomparable.  This paper is pretty dense, but also very important.
"))(POS (PAPER.TOPIC MATZINGER97 "Model-Based Reasoning"))(POS (PAPER.INSTANCE MCCARTHY59))(POS (PAPER.AUTHOR MCCARTHY59 "John McCarthy"))(POS (PAPER.TITLE MCCARTHY59 "Programs with Common Sense"))(POS (PAPER.PUBLICATION MCCARTHY59 "Proceedings of the Teddington Conference on the
                Mechanization of Thought Processes"))(POS (PAPER.STARTPAGE MCCARTHY59 77))(POS (PAPER.ENDPAGE MCCARTHY59 81))(POS (PAPER.LINK MCCARTHY59 "http://www-formal.stanford.edu/jmc/mcc59.html"))(POS (PAPER.YEAR MCCARTHY59 1958))(POS (PAPER.RANK MCCARTHY59 "[*****]"))(POS (PAPER.DESCRIPTION MCCARTHY59 "
Most likely the first paper on logical AI, i.e. the advice taker paper.
It describes a system(the advice taker) that can be told sentences in logic
and can draw conclusions about the world from its knowledge base.
"))(POS (PAPER.TOPIC MCCARTHY59 "Logical Knowledge Representation"))(POS (PAPER.INSTANCE MCCARTHY80))(POS (PAPER.BIBTEX MCCARTHY80 ARTICLE))(POS (PAPER.AUTHOR MCCARTHY80 "John McCarthy"))(POS (PAPER.TITLE MCCARTHY80 "Circumscription -- a form of non-monotonic reasoning"))(POS (PAPER.PUBLICATION MCCARTHY80 "Artificial Intelligence"))(POS (PAPER.VOLUME MCCARTHY80 "13"))(POS (PAPER.STARTPAGE MCCARTHY80 27))(POS (PAPER.ENDPAGE MCCARTHY80 39))(POS (PAPER.YEAR MCCARTHY80 1988))(POS (PAPER.DESCRIPTION MCCARTHY80 "
Circumscription.
"))(POS (PAPER.TOPIC MCCARTHY80 "Non-monotonic Reasoning"))(POS (PAPER.INSTANCE MCCARTHY82))(POS (PAPER.BIBTEX MCCARTHY82 TECHREPORT))(POS (PAPER.AUTHOR MCCARTHY82 "John McCarthy"))(POS (PAPER.TITLE MCCARTHY82 "Coloring Maps and the Kowalski Doctrine"))(POS (PAPER.PUBLISHER MCCARTHY82 "Stanford University"))(POS (PAPER.YEAR MCCARTHY82 1982))(POS (PAPER.DESCRIPTION MCCARTHY82 "
Paper that analyzes various formulations of the map coloring problem
written in Prolog.  Looks at various reorderings of subgoals.
"))(POS (PAPER.TOPIC MCCARTHY82 "Logic Programming"))(POS (PAPER.INSTANCE MCCHAY69))(POS (PAPER.AUTHOR MCCHAY69 "John McCarthy and Patrick J. Hayes"))(POS (PAPER.TITLE MCCHAY69 "Some Philosophical Problems from the Standpoint of Artificial Intelligence"))(POS (PAPER.PUBLICATION MCCHAY69 "Machine Intelligence 4"))(POS (PAPER.STARTPAGE MCCHAY69 463))(POS (PAPER.ENDPAGE MCCHAY69 502))(POS (PAPER.LINK MCCHAY69 "http://www-formal.stanford.edu/jmc/mcchay69.html"))(POS (PAPER.YEAR MCCHAY69 1969))(POS (PAPER.DESCRIPTION MCCHAY69 "
The basic situation calculus paper.  McCarthy and Hayes consider not only the classic planning environment (fully-observable), but also a partially-observable one, introducing what are now referred to as 'sensing actions'.  They attempt a self-proclaimed ad-hoc approach to handling these sensing actions.  They also point out the frame problem, alluding to a state vector as a possible solution.  The qualification problem (though they don't name it that) shows up here, along with the introduction of the modal operators consistent(phi), probably(phi), and normally(phi) as a tentative solution avenue.  Finally, McCarthy and Hayes look into embedding Modal Logic, Logic of Knowledge (Hintikka), Tense Logics, and a couple of others into situation calculus.
"))(POS (PAPER.TOPIC MCCHAY69 "Historical"))(POS (PAPER.INSTANCE MCCUNE2001))(POS (PAPER.BIBTEX MCCUNE2001 MISC))(POS (PAPER.AUTHOR MCCUNE2001 "William McCune"))(POS (PAPER.TITLE MCCUNE2001 "Mace 2.0 Reference Manual and Guide"))(POS (PAPER.LINK MCCUNE2001 "http://citeseer.ist.psu.edu/464179.html"))(POS (PAPER.YEAR MCCUNE2001 2001))(POS (PAPER.DESCRIPTION MCCUNE2001 "
Manual for Mace 2.0, a finite model builder that grounds out formulas
and relies on a SAT solver.
"))(POS (PAPER.TOPIC MCCUNE2001 "Model Building"))(POS (PAPER.INSTANCE MCCUNE2003))(POS (PAPER.BIBTEX MCCUNE2003 TECHREPORT))(POS (PAPER.AUTHOR MCCUNE2003 "William McCune"))(POS (PAPER.TITLE MCCUNE2003 "Mace4 Reference Manual and Guide"))(POS (PAPER.PUBLISHER MCCUNE2003 "Argonne National Laboratory"))(POS (PAPER.LINK MCCUNE2003 "http://www-unix.mcs.anl.gov/AR/mace4/July-2005/doc/mace4.pdf"))(POS (PAPER.YEAR MCCUNE2003 2003))(POS (PAPER.DESCRIPTION MCCUNE2003 "
The reference manual for Mace4.  Unlike its predecessors, which flattened
formulas, ground them, and used a SAT solver, Mace4 incrementally constructs
a model and after each instantiation computes the consequences of the
instantiation wrt the sentences of interest.
"))(POS (PAPER.TOPIC MCCUNE2003 "Model Building"))(POS (PAPER.INSTANCE MCDONALD91))(POS (PAPER.BIBTEX MCDONALD91 ARTICLE))(POS (PAPER.AUTHOR MCDONALD91 "D. McDonald"))(POS (PAPER.TITLE MCDONALD91 "Reversible NLP by Deriving the Grammars from the Knowledge Base"))(POS (PAPER.LINK MCDONALD91 "http://acl.ldc.upenn.edu/W/W91/W91-0106.pdf"))(POS (PAPER.YEAR MCDONALD91 1991))(POS (PAPER.RANK MCDONALD91 "[***]"))(POS (PAPER.DESCRIPTION MCDONALD91 "
Reversible grammars.
McDonald presents an architecture for constructing a parsing grammar and
an acceptance grammar from a single knowledge base and semantic model.  Thus
the strongest techniques for both parsing and generation can be used without
losing the simplicity of maintenance derived from  using a single, 
reversible grammar.
"))(POS (PAPER.TOPIC MCDONALD91 "Natural Language Processing"))(POS (PAPER.INSTANCE MCILRAITH98))(POS (PAPER.BIBTEX MCILRAITH98 ARTICLE))(POS (PAPER.AUTHOR MCILRAITH98 "Sheila McIlraith"))(POS (PAPER.TITLE MCILRAITH98 "Logic-based Abductive Inference"))(POS (PAPER.PUBLICATION MCILRAITH98 "Knowledge Systems Lab Technical Report KSL98-19"))(POS (PAPER.LINK MCILRAITH98 "http://citeseer.ist.psu.edu/mcilraith98logicbased.html"))(POS (PAPER.YEAR MCILRAITH98 1998))(POS (PAPER.DESCRIPTION MCILRAITH98 "
McIlraith covers various ways to operationalize abduction, i.e. finding
an augmentation to a logical knowledge base such that a given query
is entailed. 
"))(POS (PAPER.TOPIC MCILRAITH98 "Abduction"))(POS (PAPER.INSTANCE MCKENZIE97))(POS (PAPER.BIBTEX MCKENZIE97 TECHREPORT))(POS (PAPER.AUTHOR MCKENZIE97 "Bruce McKenzie"))(POS (PAPER.TITLE MCKENZIE97 "Generating Strings at Random from a Context Free Grammar"))(POS (PAPER.LINK MCKENZIE97 "http://coscweb2.cosc.canterbury.ac.nz/research/reports/TechReps/#year1997"))(POS (PAPER.YEAR MCKENZIE97 1997))(POS (PAPER.RANK MCKENZIE97 "[***]"))(POS (PAPER.DESCRIPTION MCKENZIE97 "
McKenzie gives an algorithm for generating strings of length n from a CFG 
so that all strings of length n are equally likely.  The preprocessing
portion of the algorithm requires O(n^2) time and O(n^2) space.  The
generation portion requires O(n) time and space.
"))(POS (PAPER.TOPIC MCKENZIE97 "Context Free Grammars"))(POS (PAPER.INSTANCE MENG20067))(POS (PAPER.AUTHOR MENG20067 "Jia Meng and L.C. Paulson"))(POS (PAPER.TITLE MENG20067 "Lightweight Relevance Filtering for Machine-Generated Resolution Problems"))(POS (PAPER.PUBLICATION MENG20067 "ESCoR: Empirically Successful Computerized Reasoning"))(POS (PAPER.LINK MENG20067 "http://www.cl.cam.ac.uk/~lp15/papers/frameset.html"))(POS (PAPER.YEAR MENG20067 2006))(POS (PAPER.DESCRIPTION MENG20067 "
The authors argue for the case that large axiom sets are the norm when
an entailment query is constructed by a machine; moreover, it is often the
case that only a small fraction of those axioms are relevant to the query
at hand, and thus determining which clauses are relevant is a good first
step toward solving the problem.  The criteria for relevance they use
is based on the presence of function symbols in the clauses.
"))(POS (PAPER.TOPIC MENG20067 "Transformations"))(POS (PAPER.INSTANCE MERZ2001))(POS (PAPER.BIBTEX MERZ2001 INBOOK))(POS (PAPER.AUTHOR MERZ2001 "Stephan Merz"))(POS (PAPER.TITLE MERZ2001 "Model Checking: A Tutorial Overview"))(POS (PAPER.PUBLISHER MERZ2001 "Springer-Verlag"))(POS (PAPER.PUBLICATION MERZ2001 "Modeling and Verification of Parallel Processes"))(POS (PAPER.VOLUME MERZ2001 "2067"))(POS (PAPER.STARTPAGE MERZ2001 3))(POS (PAPER.ENDPAGE MERZ2001 38))(POS (PAPER.LINK MERZ2001 "http://www.loria.fr/~merz/papers/mc-tutorial.html"))(POS (PAPER.YEAR MERZ2001 2001))(POS (PAPER.RANK MERZ2001 "[****]"))(POS (PAPER.DESCRIPTION MERZ2001 "
The model checking problem is to determine if a sentence s is entailed
by a model M.  It is mainly used to analyze reactive systems, i.e. systems
that continually interact with their environment.  These systems are usually
modelled with a Kripke structure or an omega(Buchi)-Automaton.  The sentence s 
is usually written in Propositional Temporal Logic (PTL) (which allows only
universal statements), Computation Tree Logic (CTL) (which allows 
universal and existential statements), CTL*, or propositional mu-calculus.
PTL and CTL are not comparable (neither is more expressive than the other).
CTL* is strictly more expressive than CTL and PTL, and propositional
mu-calculus subsumes CTL*.  Model checking algorithms can either be local
(PTL), global (CTL), or symbolic.  Symbolic formulas can be represented
with ordered binary decision diagrams.
"))(POS (PAPER.TOPIC MERZ2001 "Model Checking"))(POS (PAPER.INSTANCE MILLER94))(POS (PAPER.AUTHOR MILLER94 "Rob Miller and Muray Shanahan"))(POS (PAPER.TITLE MILLER94 "Narratives in the Situation Calculus"))(POS (PAPER.PUBLICATION MILLER94 "Journal of Logic and Computation"))(POS (PAPER.VOLUME MILLER94 "4(5)"))(POS (PAPER.STARTPAGE MILLER94 513))(POS (PAPER.ENDPAGE MILLER94 530))(POS (PAPER.LINK MILLER94 "http://citeseer.ist.psu.edu/miller94narratives.html"))(POS (PAPER.YEAR MILLER94 1994))(POS (PAPER.RANK MILLER94 "[*]"))(POS (PAPER.DESCRIPTION MILLER94 "
Miller and Shanahan take a first crack at embedding narratives in the Situation calculus.  They use a new sort for times, define Happens(action, time), and define Duration(action).  Using these, they can represent narratives, noninstantaneous actions, and overlapping actions.   Miller and Shanahan rely heavily on circumscription.  
"))(POS (PAPER.TOPIC MILLER94 "Behavioral Goals"))(POS (PAPER.INSTANCE MITTAL90))(POS (PAPER.BIBTEX MITTAL90 ARTICLE))(POS (PAPER.AUTHOR MITTAL90 "Sanjay Mittal and Brian Falkenhainer"))(POS (PAPER.TITLE MITTAL90 "Dynamic Constraint Satisfaction Problems "))(POS (PAPER.PUBLICATION MITTAL90 "AAAI 90 "))(POS (PAPER.STARTPAGE MITTAL90 25))(POS (PAPER.ENDPAGE MITTAL90 32))(POS (PAPER.YEAR MITTAL90 1990))(POS (PAPER.RANK MITTAL90 "[****]"))(POS (PAPER.DESCRIPTION MITTAL90 "
Mittal and Falkenhainer describe a version of CSPs where the 
number of variables is partially determined by the values of other
variables.  To accomplish this they provide a constraint language that
can express conditions under which variables must be assigned values
and conditions under which variables need not be assigned values.  For 
every variable vi there is a propositional constant active:vi.  If 
active:vi must hold given the values of other variables, vi must
be assigned a value.  If ~active:vi must hold, vi need not be assigned
a value.  It is unclear what happens if neither active:vi nor ~active:vi 
holds.  They use an assumption-based truth maintenance system to build
a Dynamic CSP solver. 
"))(POS (PAPER.TOPIC MITTAL90 "Various Forms of Constraint Satisfaction"))(POS (PAPER.INSTANCE MOORE77))(POS (PAPER.AUTHOR MOORE77 "Robert C. Moore"))(POS (PAPER.TITLE MOORE77 "Reasoning about knowledge and action"))(POS (PAPER.PUBLICATION MOORE77 "Proceedings of the 5th International Joint
Conference on Artificial Intelligence (IJCAI-77, MIT)"))(POS (PAPER.STARTPAGE MOORE77 223))(POS (PAPER.ENDPAGE MOORE77 227))(POS (PAPER.YEAR MOORE77 1977))(POS (PAPER.DESCRIPTION MOORE77 "
Moore contributes the following formalization (after a little tweaking):
1. T(p, s): p is true in world s.
2. K(Agent, s, s'): Given what Agent knows in s, s' would be another possible world.
3. As,a,p.(True(Know(a, p), s) =def= As'.(K(a, s, s') => T(p, s')): "))(POS (PAPER.TOPIC MOORE77 "Planning with Sensing Actions"))(POS (PAPER.INSTANCE MOORE82))(POS (PAPER.BIBTEX MOORE82 ARTICLE))(POS (PAPER.AUTHOR MOORE82 "Robert C. Moore"))(POS (PAPER.TITLE MOORE82 "The Role of Logic in Knowledge Representation and Commonsense Reasoning"))(POS (PAPER.PUBLICATION MOORE82 "AAAI 82"))(POS (PAPER.LINK MOORE82 ""))(POS (PAPER.YEAR MOORE82 1982))(POS (PAPER.RANK MOORE82 "[**]"))(POS (PAPER.DESCRIPTION MOORE82 "
Moore tries to convince AI researchers that logic can be a useful method for reasoning and not just the analysis of systems.  He points out that some of the early experiments that supposedly showed logical reasoning too inefficient only showed that a particular method of inference and control were too inefficient to be used for every reasoning task.
"))(POS (PAPER.TOPIC MOORE82 "Logical Knowledge Representation"))(POS (PAPER.INSTANCE MOSES96))(POS (PAPER.BIBTEX MOSES96 ARTICLE))(POS (PAPER.AUTHOR MOSES96 "Yoram Moses and Moshe Tennenholtz"))(POS (PAPER.TITLE MOSES96 "Off-line reasoning for on-line efficiency: knowledge bases"))(POS (PAPER.PUBLICATION MOSES96 "Artificial Intelligence"))(POS (PAPER.VOLUME MOSES96 "83(2)"))(POS (PAPER.STARTPAGE MOSES96 229))(POS (PAPER.ENDPAGE MOSES96 239))(POS (PAPER.LINK MOSES96 "http://citeseer.ist.psu.edu/moses96offline.html"))(POS (PAPER.YEAR MOSES96 1996))(POS (PAPER.RANK MOSES96 "[***]"))(POS (PAPER.DESCRIPTION MOSES96 "
Moses and Tennenholtz give conditions under which compiling a KB is
worthwhile.  The results given focus almost entirely on propositional
logic.  If a KB has a basis under which all queries
can be computed via conjunctions of the basis, compilation is a good
idea if the basis can be computed in polynomial time.  The process
of compilation essentially stores all the elements of the basis
in a binary tree.  Thus, any query can be answered in (log n)*|query|.
"))(POS (PAPER.TOPIC MOSES96 "Knowledge Base Compilation"))(POS (PAPER.INSTANCE MOSKEWICZ2001))(POS (PAPER.BIBTEX MOSKEWICZ2001 ARTICLE))(POS (PAPER.AUTHOR MOSKEWICZ2001 "Matthew Moskewicz and Conor Madigan and Ying Zhao and Lintao Zhang and Sharad Malik"))(POS (PAPER.TITLE MOSKEWICZ2001 "Chaff: Engineering an Efficient SAT Solver"))(POS (PAPER.PUBLICATION MOSKEWICZ2001 "39th Design Automation Conference"))(POS (PAPER.LINK MOSKEWICZ2001 "http://citeseer.csail.mit.edu/moskewicz01chaff.html"))(POS (PAPER.YEAR MOSKEWICZ2001 2001))(POS (PAPER.DESCRIPTION MOSKEWICZ2001 "
The authors give an overview of DPLL and how it is implemented in Chaff.
Nice read.
"))(POS (PAPER.TOPIC MOSKEWICZ2001 "Solvers"))(POS (PAPER.INSTANCE MOTIK2007BRIDGING))(POS (PAPER.BIBTEX MOTIK2007BRIDGING INPROCEEDINGS))(POS (PAPER.AUTHOR MOTIK2007BRIDGING "Boris Motik and Ian Horrocks and Ulrike Sattler"))(POS (PAPER.TITLE MOTIK2007BRIDGING "Bridging the Gap Between OWL and Relational Databases"))(POS (PAPER.PUBLICATION MOTIK2007BRIDGING "Proceedings of the 16th Conference on the World Wide Web "))(POS (PAPER.LINK MOTIK2007BRIDGING ""))(POS (PAPER.YEAR MOTIK2007BRIDGING 2007))(POS (PAPER.DESCRIPTION MOTIK2007BRIDGING "
The paper attempts to implement integrity constraints as defined in the 
database literature into OWL.
"))(POS (PAPER.TOPIC MOTIK2007BRIDGING "Semantic Web"))(POS (PAPER.INSTANCE MOTIK2007FAITHFUL))(POS (PAPER.BIBTEX MOTIK2007FAITHFUL INPROCEEDINGS))(POS (PAPER.AUTHOR MOTIK2007FAITHFUL "Boris Motik and Riccardo Rosati"))(POS (PAPER.TITLE MOTIK2007FAITHFUL "A Faithful Integration of Description Logics with Logic Programming"))(POS (PAPER.PUBLICATION MOTIK2007FAITHFUL "Proceedings of International Joint Conference on Artificial Intelligence"))(POS (PAPER.LINK MOTIK2007FAITHFUL ""))(POS (PAPER.YEAR MOTIK2007FAITHFUL 2007))(POS (PAPER.DESCRIPTION MOTIK2007FAITHFUL "
The paper introduces hybrid MKNF knowledge bases, a formalism that integrates
logic programming and description logics, which reduces to LP semantics
when the DL portion is empty and to DL semantics when the LP portion is empty.
Also gives complexity results for certain classes of the logic.
"))(POS (PAPER.TOPIC MOTIK2007FAITHFUL "Semantic Web"))(POS (PAPER.INSTANCE MOTTA91))(POS (PAPER.BIBTEX MOTTA91 ARTICLE))(POS (PAPER.AUTHOR MOTTA91 "Enrico Motta and Arthur Stutt"))(POS (PAPER.TITLE MOTTA91 "An Architecture for the Integration of Heterogenous Inference Systems"))(POS (PAPER.PUBLICATION MOTTA91 "Open University Technical Report"))(POS (PAPER.LINK MOTTA91 "http://citeseer.ist.psu.edu/motta91architecture.html"))(POS (PAPER.YEAR MOTTA91 1991))(POS (PAPER.RANK MOTTA91 "[*]"))(POS (PAPER.DESCRIPTION MOTTA91 "
The authors describe an architecture for integrating specialized reasoners
where each reasoner is known to handle a particular vocabulary.
"))(POS (PAPER.TOPIC MOTTA91 "Architectures"))(POS (PAPER.INSTANCE MUHAMMED2006))(POS (PAPER.BIBTEX MUHAMMED2006 INPROCEEDINGS))(POS (PAPER.AUTHOR MUHAMMED2006 "R. Muhammed and P.J. Stuckey"))(POS (PAPER.TITLE MUHAMMED2006 "A stochastic Non-CNF SAT Solver"))(POS (PAPER.PUBLICATION MUHAMMED2006 "In Proceedings 9th Biennial Pacific Rim International Conference on Artificial Intelligence"))(POS (PAPER.STARTPAGE MUHAMMED2006 120))(POS (PAPER.ENDPAGE MUHAMMED2006 129))(POS (PAPER.LINK MUHAMMED2006 "http://www.cs.mu.oz.au/~pjs/papers.html"))(POS (PAPER.YEAR MUHAMMED2006 2006))(POS (PAPER.DESCRIPTION MUHAMMED2006 "
Paper on a stochastic SAT solver whose input is allowed to be 
in something other than CNF.
"))(POS (PAPER.TOPIC MUHAMMED2006 "SAT Solving"))(POS (PAPER.INSTANCE MYERS90))(POS (PAPER.BIBTEX MYERS90 INPROCEEDINGS))(POS (PAPER.AUTHOR MYERS90 "Karen Myers"))(POS (PAPER.TITLE MYERS90 "Automatically Generating Universal Attachments through Compilation"))(POS (PAPER.PUBLICATION MYERS90 "AAAI"))(POS (PAPER.LINK MYERS90 "http://www.ai.sri.com/~myers/"))(POS (PAPER.YEAR MYERS90 1990))(POS (PAPER.RANK MYERS90 "[**]"))(POS (PAPER.DESCRIPTION MYERS90 "
Myers describes a method for generating new universal attachments.
"))(POS (PAPER.TOPIC MYERS90 "Theorem Proving with Attachments"))(POS (PAPER.INSTANCE MYERS90T))(POS (PAPER.BIBTEX MYERS90T PHDTHESIS))(POS (PAPER.AUTHOR MYERS90T "Karen Myers"))(POS (PAPER.TITLE MYERS90T "Universal Attachments: A Logical Framework for Hybrid Reasoning"))(POS (PAPER.PUBLISHER MYERS90T "Stanford University"))(POS (PAPER.LINK MYERS90T "http://library.stanford.edu/depts/mathcs/mathcscoll/techreports.html"))(POS (PAPER.YEAR MYERS90T 1990))(POS (PAPER.RANK MYERS90T "[***]"))(POS (PAPER.DESCRIPTION MYERS90T "
"))(POS (PAPER.TOPIC MYERS90T "Theorem Proving with Attachments"))(POS (PAPER.INSTANCE NAREYEK99))(POS (PAPER.BIBTEX NAREYEK99 ARTICLE))(POS (PAPER.AUTHOR NAREYEK99 "Alexander Nareyek"))(POS (PAPER.TITLE NAREYEK99 "Structural Constraint Satisfaction"))(POS (PAPER.PUBLICATION NAREYEK99 "AAAI Workshop on Configurations"))(POS (PAPER.STARTPAGE NAREYEK99 76))(POS (PAPER.ENDPAGE NAREYEK99 82))(POS (PAPER.LINK NAREYEK99 "http://citeseer.ist.psu.edu/nareyek99structural.html"))(POS (PAPER.YEAR NAREYEK99 1999))(POS (PAPER.RANK NAREYEK99 "[***]"))(POS (PAPER.DESCRIPTION NAREYEK99 "
It is a little hard to follow what's happening here.  Nareyek seems
to be introducing generalization of CSPs where in addition to constraints
on tuples of variables, there are constraints on the structure of those
constraints.  These meta constraints are implemented via Graph Grammars.
Narayek states that solving these problems is undecidable, but gives
no proof.
"))(POS (PAPER.TOPIC NAREYEK99 "Various Forms of Constraint Satisfaction"))(POS (PAPER.INSTANCE NAYAK95))(POS (PAPER.BIBTEX NAYAK95 PROCEEDINGS))(POS (PAPER.AUTHOR NAYAK95 "P. Nayak and Alon Levy"))(POS (PAPER.TITLE NAYAK95 "A Semantic Theory of Abstractions"))(POS (PAPER.PUBLICATION NAYAK95 "IJCAI"))(POS (PAPER.LINK NAYAK95 "http://citeseer.ist.psu.edu/nayak94semantic.html"))(POS (PAPER.YEAR NAYAK95 1995))(POS (PAPER.RANK NAYAK95 "[***]"))(POS (PAPER.DESCRIPTION NAYAK95 "
Nayak and Levy explain a new approach to producing abstractions of
axioms.  Instead of simply mapping axioms to axioms as is done in
previous work, first abstract the axioms to an intended domain
model, and then find sentences that capture that model.  The
theoretical component of this paper, which accounts for the
majority of it, is very clean.  It gives model-theoretic
explainations for good (allowing no 'false proofs') and bad
(allowing 'false proofs') abstractions.
"))(POS (PAPER.TOPIC NAYAK95 "Abstraction"))(POS (PAPER.INSTANCE NELSON79))(POS (PAPER.BIBTEX NELSON79 INPROCEEDINGS))(POS (PAPER.AUTHOR NELSON79 "Greg Nelson and Derek Oppen"))(POS (PAPER.TITLE NELSON79 "Simplification by Cooperating Decision Procedures"))(POS (PAPER.PUBLICATION NELSON79 "ACM Transactions on Programming Languages and Systems
           "))(POS (PAPER.VOLUME NELSON79 "1(2)"))(POS (PAPER.STARTPAGE NELSON79 245))(POS (PAPER.ENDPAGE NELSON79 257))(POS (PAPER.LINK NELSON79 ""))(POS (PAPER.YEAR NELSON79 1979))(POS (PAPER.RANK NELSON79 "[****]"))(POS (PAPER.DESCRIPTION NELSON79 "
Nelson and Oppen describe a method for combining decision procedures
for disjoint equational theories.
To determine the satisfiability of a set of quantifier-free formulas,
partition based on the theory to which the vocabulary belongs.  If 
a term from one theory is embedded in a relation from another theory,
introduce a new variable, replace the term with that variable, and include
the sentence where that variable is set to the term in the appropriate
partition.  If any of the partitions are unsatisfiable, the entire thing
is unsatisfiable.  Otherwise, compute all the strongest equality theorems
including only variables for each of the partitions and pass to all the 
other partitions.  If the theory is nonconvex, case analysis is
necessary.
Check for unsatisfiability and repeat.  Nelson and Oppen prove correctness
and termination.
"))(POS (PAPER.TOPIC NELSON79 "Nelson-Oppen and Shostak"))(POS (PAPER.INSTANCE NEWELL63))(POS (PAPER.AUTHOR NEWELL63 "Allen Newell and H.A. Simon"))(POS (PAPER.TITLE NEWELL63 "GPS, A Program that Simulates Human Thought"))(POS (PAPER.PUBLICATION NEWELL63 "Computers and Thought, Feigenbaum and Feldman (eds.)"))(POS (PAPER.STARTPAGE NEWELL63 279))(POS (PAPER.ENDPAGE NEWELL63 293))(POS (PAPER.YEAR NEWELL63 1963))(POS (PAPER.DESCRIPTION NEWELL63 "
Description of probably the first planner. Newell et. al. compare an inexperienced student doing a logic proof to how GPS solves the same problem.  GPS takes a goal and can perform any of four operations: transform object A into object B (unification?), reduce the difference D between object A and object B (satisfaction of a subgoal of A?), and apply operator Q to object A (reduction of A to subgoals?).
"))(POS (PAPER.TOPIC NEWELL63 "Historical"))(POS (PAPER.INSTANCE NIEUWENHUIS2003))(POS (PAPER.AUTHOR NIEUWENHUIS2003 "Robert Nieuwenhuis and Thomas Hillenbrand and Alexandre Riazanov and Andrei Voronkov"))(POS (PAPER.TITLE NIEUWENHUIS2003 "On the Evaluation of Indexing Techniques for Theorem Proving"))(POS (PAPER.LINK NIEUWENHUIS2003 "http://citeseer.ist.psu.edu/nieuwenhuis03evaluation.html"))(POS (PAPER.YEAR NIEUWENHUIS2003 2003))(POS (PAPER.DESCRIPTION NIEUWENHUIS2003 "
Nieuwenhuis, et. al. describe a methodology for comparing indexing schemes.
To demonstrate it, they compare Waldmeister's discrimination trees,
Context trees, and Vampire's code trees for term indexing.  The scenario tested
involved both additions and deletions from the index and queries where
only one answer need be reported (e.g. for forward subsumption).  They
reported both space and time results.
"))(POS (PAPER.TOPIC NIEUWENHUIS2003 "Indexing"))(POS (PAPER.INSTANCE NILES2001))(POS (PAPER.BIBTEX NILES2001 INPROCEEDINGS))(POS (PAPER.AUTHOR NILES2001 "Ian Niles and Adam Pease"))(POS (PAPER.TITLE NILES2001 "Formal Ontology in Information Systems"))(POS (PAPER.PUBLICATION NILES2001 "Proceedings of the International Conference on Formal Ontology in Information Systems"))(POS (PAPER.STARTPAGE NILES2001 2))(POS (PAPER.ENDPAGE NILES2001 9))(POS (PAPER.LINK NILES2001 "http://portal.acm.org/citation.cfm?id=505170"))(POS (PAPER.YEAR NILES2001 2001))(POS (PAPER.DESCRIPTION NILES2001 "
Primary paper on SUMO, the Suggested Upper Merged Ontology.
"))(POS (PAPER.TOPIC NILES2001 "Logical Knowledge Representation"))(POS (PAPER.INSTANCE ORMAN98))(POS (PAPER.BIBTEX ORMAN98 ARTICLE))(POS (PAPER.AUTHOR ORMAN98 "Levent Orman"))(POS (PAPER.TITLE ORMAN98 "Differential Relational Calculus for Integrity Maintenance"))(POS (PAPER.PUBLICATION ORMAN98 "IEEE Transactions of Knowledge and Data Engineering"))(POS (PAPER.VOLUME ORMAN98 "10(2)"))(POS (PAPER.STARTPAGE ORMAN98 328))(POS (PAPER.ENDPAGE ORMAN98 341))(POS (PAPER.LINK ORMAN98 "http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=683760&isnumber=15039"))(POS (PAPER.YEAR ORMAN98 1998))(POS (PAPER.RANK ORMAN98 "[****]"))(POS (PAPER.DESCRIPTION ORMAN98 "
Orman defines differential relational calculus.  Given a 
database constraint V such that V is true if and only if there is an integrity
constraint violation and a transaction T, what are the necessary and
sufficient conditions for computing whether there is would be an integrity
violation after execution T, assuming there was no violation to start with?
"))(POS (PAPER.TOPIC ORMAN98 "Databases"))(POS (PAPER.INSTANCE OWRE96))(POS (PAPER.BIBTEX OWRE96 INPROCEEDINGS))(POS (PAPER.AUTHOR OWRE96 "S. Owre et. al."))(POS (PAPER.TITLE OWRE96 "PVS: Combining Specification, Proof Checking, and Model Checking"))(POS (PAPER.PUBLICATION OWRE96 "Computer Aided Verification"))(POS (PAPER.STARTPAGE OWRE96 411))(POS (PAPER.ENDPAGE OWRE96 414))(POS (PAPER.LINK OWRE96 "http://citeseer.ist.psu.edu/246180.html"))(POS (PAPER.YEAR OWRE96 1996))(POS (PAPER.RANK OWRE96 "[*]"))(POS (PAPER.DESCRIPTION OWRE96 "
PVS (Prototype Verification System) allows a user to construct a
machine-verified proof.  It combines interactive theorem
proving, typechecking, a set of decision procedures including
a model checker, and strategies to avoid tedious proof step 
repetitions for the user.   The strategies can be extended
if necessary.
"))(POS (PAPER.TOPIC OWRE96 "Model Checking"))(POS (PAPER.INSTANCE PALTRINIERI94))(POS (PAPER.BIBTEX PALTRINIERI94 ARTICLE))(POS (PAPER.AUTHOR PALTRINIERI94 "Massimo Paltrinieri"))(POS (PAPER.TITLE PALTRINIERI94 "Some Remarks on the Design of Constraint Satisfaction
Problems"))(POS (PAPER.PUBLICATION PALTRINIERI94 "Second International Workshop on the Principles
and Practice of Constraint Programming"))(POS (PAPER.STARTPAGE PALTRINIERI94 299))(POS (PAPER.ENDPAGE PALTRINIERI94 311))(POS (PAPER.LINK PALTRINIERI94 "http://citeseer.ist.psu.edu/paltrinieri94some.html"))(POS (PAPER.YEAR PALTRINIERI94 1994))(POS (PAPER.RANK PALTRINIERI94 "[****]"))(POS (PAPER.DESCRIPTION PALTRINIERI94 "
Paltrinieri gives a loose definition for an object-oriented constraint
satisfaction problem and goes on to show its utility for modelling
some CSPs.  His formulation of an OOCSP is no more expressive than
a standard CSP; solving an OOCSP then amounts to translating it into
a CSP.  To do this, find all the instances of objects needed to solve
the OOCSP and replicate the class constraints for each instance.
"))(POS (PAPER.TOPIC PALTRINIERI94 "Object Oriented Constraint Satisfaction"))(POS (PAPER.INSTANCE PALTRINIERI95))(POS (PAPER.BIBTEX PALTRINIERI95 ARTICLE))(POS (PAPER.AUTHOR PALTRINIERI95 "Massimo Paltrinieri"))(POS (PAPER.TITLE PALTRINIERI95 "A Visual Environment for Constraint Programming"))(POS (PAPER.PUBLICATION PALTRINIERI95 "Proceedings 11th International IEEE Symposium on Visual
Langauges"))(POS (PAPER.STARTPAGE PALTRINIERI95 118))(POS (PAPER.ENDPAGE PALTRINIERI95 119))(POS (PAPER.LINK PALTRINIERI95 "
http://citeseer.ist.psu.edu/paltrinieri95visual.html"))(POS (PAPER.YEAR PALTRINIERI95 1995))(POS (PAPER.RANK PALTRINIERI95 "[****]"))(POS (PAPER.DESCRIPTION PALTRINIERI95 "
Paltrinieri gives a 2-page description of a generalization of CSPs to
object-oriented CSPs.  He also describes a visual environment for 
dealing with OOCSPs.
"))(POS (PAPER.TOPIC PALTRINIERI95 "Object Oriented Constraint Satisfaction"))(POS (PAPER.INSTANCE PASTRE78))(POS (PAPER.BIBTEX PASTRE78 ARTICLE))(POS (PAPER.AUTHOR PASTRE78 "D. Pastre"))(POS (PAPER.TITLE PASTRE78 "Automatic Theorem Proving in Set Theory"))(POS (PAPER.PUBLICATION PASTRE78 "Artificial Intelligence"))(POS (PAPER.VOLUME PASTRE78 "10(1)"))(POS (PAPER.STARTPAGE PASTRE78 1))(POS (PAPER.ENDPAGE PASTRE78 27))(POS (PAPER.LINK PASTRE78 ""))(POS (PAPER.YEAR PASTRE78 1978))(POS (PAPER.RANK PASTRE78 "[**]"))(POS (PAPER.DESCRIPTION PASTRE78 "
Pastre describes PROVER, a theorem prover for set theory that builds
diagrams from axioms in order to prune the search space of theorem proving.
Pastre admits the methods to be incomplete, but claims an incomplete
method may prove more theorems than a complete one in practice.
"))(POS (PAPER.TOPIC PASTRE78 "Graphical Reasoning Techniques"))(POS (PAPER.INSTANCE PELTIER2000))(POS (PAPER.BIBTEX PELTIER2000 ARTICLE))(POS (PAPER.AUTHOR PELTIER2000 "Nicolas Peltier"))(POS (PAPER.TITLE PELTIER2000 "Model Building with Ordered Resolution"))(POS (PAPER.PUBLICATION PELTIER2000 "International Workshop on First Order Theorem Proving (FTP)"))(POS (PAPER.LINK PELTIER2000 "http://citeseer.ist.psu.edu/peltier00model.html"))(POS (PAPER.YEAR PELTIER2000 2000))(POS (PAPER.RANK PELTIER2000 "[****]"))(POS (PAPER.DESCRIPTION PELTIER2000 "
Peltier describes two algorithms that can be used after an ordered
resolution proof has failed: (1) to extract from the resolution closure
a set of formulas that have a single Herbrand model where that model
satisfies the original clauseset and (2) to turn those formulas into
a set of clauses.  Peltier's Herbrand model is represented by a clauseset,
and since the clauseset is guaranteed to have exactly one Herbrand model,
proof by consistency can be used to check whether that model satisfies
a particular sentence; moreover, for ground literals, satisfaction is decidable
since either the literal or its negation must be consistent and the 
clauseset is satisfiable, exactly one is consistent, which ensures one
is inconsistent.  Any off-the- shelf first-order entailment algorithm will 
find an inconsistency.  The technique is based on predicate completion,
which only works when there is a strict ordering among the clauses. 
"))(POS (PAPER.TOPIC PELTIER2000 "Model Building"))(POS (PAPER.INSTANCE PEREIRA80))(POS (PAPER.BIBTEX PEREIRA80 INPROCEEDINGS))(POS (PAPER.AUTHOR PEREIRA80 "Pereira and Porto"))(POS (PAPER.TITLE PEREIRA80 "Selective Backtracking for Logic Programs"))(POS (PAPER.PUBLICATION PEREIRA80 "In Proceedings of the Conference on Automated Deduction"))(POS (PAPER.YEAR PEREIRA80 1980))(POS (PAPER.DESCRIPTION PEREIRA80 "
One of the papers that uses the Logic Programming formulation of map coloring.
"))(POS (PAPER.TOPIC PEREIRA80 "Logic Programming"))(POS (PAPER.INSTANCE PETERSON98))(POS (PAPER.BIBTEX PETERSON98 INPROCEEDINGS))(POS (PAPER.AUTHOR PETERSON98 "Brian Peterson and William Anderson and Joshua Engel"))(POS (PAPER.TITLE PETERSON98 "Knowledge Bus: Generating Application-focused Databases from Large Ontologies"))(POS (PAPER.PUBLICATION PETERSON98 "Knowledge Representation Meets Databases"))(POS (PAPER.LINK PETERSON98 "http://citeseer.ist.psu.edu/peterson98knowledge.html"))(POS (PAPER.YEAR PETERSON98 1998))(POS (PAPER.DESCRIPTION PETERSON98 "
The authors attempt to construct a logic program from Cyc for answering a
given set of queries.  Their transformation is lossy, and it is unclear
to what extent the logical consequences are preserved.
"))(POS (PAPER.TOPIC PETERSON98 "Reformulation"))(POS (PAPER.INSTANCE PETRIE2004))(POS (PAPER.BIBTEX PETRIE2004 ARTICLE))(POS (PAPER.AUTHOR PETRIE2004 "Charles J. Petrie, Michael R. Genesereth, Hans Bjornsson, Rada Chirkova, Martin Ekstrom, Hidehito Gomi, Tim Hinrichs, Rob Hoskins, Michael Kassoff, Daishi Kato, Kyohei Kawazoe, Jung Ung Min, and Waqar Mohsin"))(POS (PAPER.TITLE PETRIE2004 "Adding AI to Web Services"))(POS (PAPER.PUBLICATION PETRIE2004 "Lecture Notes in Artificial Intelligence"))(POS (PAPER.VOLUME PETRIE2004 "2926"))(POS (PAPER.STARTPAGE PETRIE2004 322))(POS (PAPER.ENDPAGE PETRIE2004 338))(POS (PAPER.LINK PETRIE2004 "papers/petrie2004adding.pdf"))(POS (PAPER.YEAR PETRIE2004 2004))(POS (PAPER.DESCRIPTION PETRIE2004 "
The FX-Agents project consisted of members of the Stanford Logic Group 
and industrial visitors from NEC and Intec Web and Genome working together 
to develop new technologies based upon the combination of Web services and 
techniques from artificial intelligence, using our experience in AI-based 
software agents. This two-year project ran from April 2001 until March 2002 
and explored the then emerging functionality of Web services. This paper is 
a result of our findings. In particular, this paper discusses the shortcomings 
of current Web service standards like WSDL and how logical AI techniques 
like declarative commands, agents, and planning can be used to address some 
of these shortcomings. The primary problems that we address are automated 
Web service discovery and composition of Web services. 
"))(POS (PAPER.TOPIC PETRIE2004 "References"))(POS (PAPER.INSTANCE PICHLER2000))(POS (PAPER.BIBTEX PICHLER2000 ARTICLE))(POS (PAPER.AUTHOR PICHLER2000 "Reinhard Pichler"))(POS (PAPER.TITLE PICHLER2000 "On the Complexity of Equational Problems in CNF over a Finite Domain"))(POS (PAPER.LINK PICHLER2000 "http://citeseer.ist.psu.edu/478741.html"))(POS (PAPER.YEAR PICHLER2000 2000))(POS (PAPER.RANK PICHLER2000 "[**]"))(POS (PAPER.DESCRIPTION PICHLER2000 "
Pichler shows that the complexity of satisfiability of a purely equational 
Herbrand logic sentence E*A*.M, where M is in CNF, is Sigma_2^p-complete.
"))(POS (PAPER.TOPIC PICHLER2000 "Herbrand Logic"))(POS (PAPER.INSTANCE PINTO94))(POS (PAPER.AUTHOR PINTO94 "Javier Pinto"))(POS (PAPER.TITLE PINTO94 "Temporal Reasoning in the Situation Calculus"))(POS (PAPER.LINK PINTO94 "http://citeseer.ist.psu.edu/pinto94temporal.html"))(POS (PAPER.YEAR PINTO94 1994))(POS (PAPER.RANK PINTO94 "[**]"))(POS (PAPER.DESCRIPTION PINTO94 "
Pinto's thesis extends situation calculus to cover temporal reasoning.  He includes ACTUAL PATHS (narratives), concurrent actions, and continuous time with natural events.  He goes on to compare his situation calculus with interval temporal logic, the calculus of events, and modal temporal logics.  He later reworked his approach to narratives in [pinto98], which does not call for circumscription.  Reiter published a paper on 'Natural Actions, Concurrency, and Continuous Time' [reiter96] after Pinto--should probably read that one instead.
"))(POS (PAPER.TOPIC PINTO94 "Behavioral Goals"))(POS (PAPER.RELATED PINTO94 REITER96))(POS (PAPER.RELATED PINTO94 PINTO98))(POS (PAPER.INSTANCE PINTO98))(POS (PAPER.AUTHOR PINTO98 "Javier Pinto"))(POS (PAPER.TITLE PINTO98 "Occurrences and Narratives as Constraints in the Branching Structure of the Situation Calculus"))(POS (PAPER.PUBLICATION PINTO98 "Journal of Logic and Computation"))(POS (PAPER.VOLUME PINTO98 "8(6)"))(POS (PAPER.STARTPAGE PINTO98 777))(POS (PAPER.ENDPAGE PINTO98 808))(POS (PAPER.LINK PINTO98 "http://citeseer.ist.psu.edu/pinto96occurrences.html"))(POS (PAPER.YEAR PINTO98 1998))(POS (PAPER.RANK PINTO98 "[*****]"))(POS (PAPER.DESCRIPTION PINTO98 "
Pinto tackles the problem of expressing occurrences in situation calculus.  Occurrences are sequences of events that really do happen in every hypothetical branch of the situation tree.  In deductive plan synthesis via the Green method, we want all plans returned to include all the occurrences given.  Pinto names two specific types of occurrences: narratives (a partial specification of a sequence of events known to happen) and triggers (as in the database sense).  His formulation assigns time values to situations, a second order induction axiom, along with an extension to the sitcalc ontology to define 'nonpreventable occurrences', 'conditional occurrences', and 'simple occurrences'.  He defines 'legal(s)' in terms of these 3 occurrence types to mean that a situation s includes all the mentioned occurrences and is a valid sitcalc situation.  Pinto goes on to define when one situation is preferred to another: s preferred-to s' iff s' has the same actions as s with extra actions appended to the end.  For planning, Pinto shows that instead of finding an s s.t. goal(s) is true, we can find an s s.t. goal(s) ^ legal(s) is true. 
"))(POS (PAPER.TOPIC PINTO98 "Behavioral Goals"))(POS (PAPER.INSTANCE PIRRI99))(POS (PAPER.AUTHOR PIRRI99 "Fiora Pirri and Ray Reiter"))(POS (PAPER.TITLE PIRRI99 "Some Contributions to the Metatheory of the Situation Calculus"))(POS (PAPER.PUBLICATION PIRRI99 "Journal of the ACM"))(POS (PAPER.VOLUME PIRRI99 "46(3)"))(POS (PAPER.STARTPAGE PIRRI99 325))(POS (PAPER.ENDPAGE PIRRI99 361))(POS (PAPER.LINK PIRRI99 "http://citeseer.ist.psu.edu/pirri99some.html"))(POS (PAPER.YEAR PIRRI99 1999))(POS (PAPER.RANK PIRRI99 "[****]"))(POS (PAPER.DESCRIPTION PIRRI99 "
Pirri and Reiter formalize the theory of situation calculus and define basic
action theories as D = Sigma U D_ss U D_ap U D_una U D_s0.  Sigma are the
foundational axioms (induction, situation ordering, equality, unique names
for situations); D_ss are
successor state axioms; D_ap are action precondition axioms; D_una are unique
name axioms for actions; D_s0 are initial state axioms.  This definition
appears throughout later work on the situation calculus.  Well written.
They also define Regression (in a clearer way than reiter91--the
Frame problem...), which means rewriting a regressable formula so that the only
situations referenced are S0.  Entailment of a regressed formula requires
only knowledge
of D_s0 and D_una.  Pirri and Reiter also give conditions when induction is
not needed for entailment, as well as when other components of Sigma are
unnecessary.  They go on to show that Sigma is unnecessary for GOLOG programs.
"))(POS (PAPER.TOPIC PIRRI99 "Fundamentals"))(POS (PAPER.INSTANCE PLAISTED81))(POS (PAPER.BIBTEX PLAISTED81 ARTICLE))(POS (PAPER.AUTHOR PLAISTED81 "David Plaisted"))(POS (PAPER.TITLE PLAISTED81 "Theorem Proving with Abstraction"))(POS (PAPER.PUBLICATION PLAISTED81 "Artificial Intelligence"))(POS (PAPER.VOLUME PLAISTED81 "16(1)"))(POS (PAPER.STARTPAGE PLAISTED81 47))(POS (PAPER.ENDPAGE PLAISTED81 107))(POS (PAPER.LINK PLAISTED81 ""))(POS (PAPER.YEAR PLAISTED81 1981))(POS (PAPER.DESCRIPTION PLAISTED81 "
Plaisted defines the notion of an abstraction of a literal and a clause and
shows that under this definition, the union and composition of two
abstractions is another abstraction.  He also gives local conditions
under which a mapping is an abstraction, which can be practically used.
He goes on to discuss abstract resolution proofs and multi-clauses (which
admit simpler proof procedures than regular clauses).  He discusses
using more than one abstraction at a time.  Using these abstractions admits
a complete proof procedure.  Finally, he introduces a variant
of the multi-clause notion and considers a version of completeness for it.
"))(POS (PAPER.TOPIC PLAISTED81 "Abstraction"))(POS (PAPER.INSTANCE PLAISTED94))(POS (PAPER.BIBTEX PLAISTED94 INPROCEEDINGS))(POS (PAPER.AUTHOR PLAISTED94 "David Plaisted"))(POS (PAPER.TITLE PLAISTED94 "The Search Efficiency of Theorem Proving Strategies: An Analytical Comparison"))(POS (PAPER.PUBLICATION PLAISTED94 "CADE"))(POS (PAPER.STARTPAGE PLAISTED94 1))(POS (PAPER.ENDPAGE PLAISTED94 40))(POS (PAPER.LINK PLAISTED94 "http://citeseer.ist.psu.edu/plaisted94search.html"))(POS (PAPER.YEAR PLAISTED94 1994))(POS (PAPER.RANK PLAISTED94 "[***]"))(POS (PAPER.DESCRIPTION PLAISTED94 "
Plaisted does a comparison of a slew of clausal, refutation 
theorem-proving strategies for
propositional Horn clauses.  He gives three measures for the search
spaces generated by each strategy: iterated duplication, case-analysis
duplication, and combination duplication, the produce of which bounds
the total size of the search space.  The first measures the longest path,
the second measures the number of paths, and the third measures the
maximum size of clauses generated in any state. 
"))(POS (PAPER.TOPIC PLAISTED94 "Comparative Analysis"))(POS (PAPER.INSTANCE PLAISTED97))(POS (PAPER.BIBTEX PLAISTED97 INPROCEEDINGS))(POS (PAPER.AUTHOR PLAISTED97 "David Plaisted and Yunshan Zhu"))(POS (PAPER.TITLE PLAISTED97 "Ordered Semantic Hyper Linking"))(POS (PAPER.PUBLICATION PLAISTED97 "AAAI"))(POS (PAPER.LINK PLAISTED97 "http://citeseer.ist.psu.edu/218207.html"))(POS (PAPER.YEAR PLAISTED97 1997))(POS (PAPER.RANK PLAISTED97 "[***]"))(POS (PAPER.DESCRIPTION PLAISTED97 "
Ordered Semantic Hyper Linking is a proof procedure based on
model-building.  In includes a total ordering on
formulae to remove redundant interpretations.  OSHL allows the user
to give an initial interpretation to guide the search.
It propositionalizes first order theories to build its models.  
The paper claims soundness and completeness, but no proofs are
supplied (probably due to lack of space).
"))(POS (PAPER.TOPIC PLAISTED97 "Resolution Variants"))(POS (PAPER.INSTANCE PLUMMER95))(POS (PAPER.BIBTEX PLUMMER95 MISC))(POS (PAPER.AUTHOR PLUMMER95 "Dave Barker-Plummer and Sidney Bailin"))(POS (PAPER.TITLE PLUMMER95 "Proofs and Pictures: Proving the Diamond lemma with the GROVER Theorem Proving System"))(POS (PAPER.LINK PLUMMER95 "http://citeseer.ist.psu.edu/193199.html"))(POS (PAPER.YEAR PLUMMER95 1995))(POS (PAPER.RANK PLUMMER95 "[*]"))(POS (PAPER.DESCRIPTION PLUMMER95 "
The authors describe a theorem proving system that takes a set of axioms, Delta,
a diagram, D, and a conjecture phi.  It proves Delta |= phi by 1) examining D and 
determining that D |= phi, and 2) proving Delta |= D.  The method seems to be 
ad hoc with no guarantees of soundness or completeness; however, given enough
hints, GROVER was able to prove the Diamond Lemma.
"))(POS (PAPER.TOPIC PLUMMER95 "Graphical Reasoning Techniques"))(POS (PAPER.INSTANCE PRASAD2005))(POS (PAPER.BIBTEX PRASAD2005 ARTICLE))(POS (PAPER.AUTHOR PRASAD2005 "Mukul Prasad and Armin Biere and Aarti Gupta"))(POS (PAPER.TITLE PRASAD2005 "A Survey of Recent Advances in SAT-Based Formal Verification"))(POS (PAPER.PUBLICATION PRASAD2005 "Software Tools for Technology Transfer"))(POS (PAPER.VOLUME PRASAD2005 "7(2)"))(POS (PAPER.STARTPAGE PRASAD2005 156))(POS (PAPER.ENDPAGE PRASAD2005 173))(POS (PAPER.LINK PRASAD2005 "http://www.cerc.utexas.edu/~jay/fv_surveys/"))(POS (PAPER.YEAR PRASAD2005 2005))(POS (PAPER.DESCRIPTION PRASAD2005 "
A survey paper discussing how boolean SAT solvers are being used
for formal verification.
"))(POS (PAPER.TOPIC PRASAD2005 "Formal Verification"))(POS (PAPER.INSTANCE PUEBLA2004))(POS (PAPER.BIBTEX PUEBLA2004 ARTICLE))(POS (PAPER.AUTHOR PUEBLA2004 "G. Puebla and E. Albert and M. Hermenegildo"))(POS (PAPER.TITLE PUEBLA2004 "Efficient Local Unfolding with Ancestor Stacks for Full Prolog"))(POS (PAPER.PUBLICATION PUEBLA2004 "14th International Symposium, Logic Based Program Synthesis and Transformation (LOPSTR)"))(POS (PAPER.STARTPAGE PUEBLA2004 1))(POS (PAPER.ENDPAGE PUEBLA2004 18))(POS (PAPER.LINK PUEBLA2004 "http://wotan.liu.edu/docis/dbl/lopstr/index.html"))(POS (PAPER.YEAR PUEBLA2004 2004))(POS (PAPER.DESCRIPTION PUEBLA2004 "
In the context of Horn prolog with built-ins, the authors address the
problem of efficiently unfolding of recursive relations.  That is,
one implementation of partial evaluation/partial deduction is to produce
a partial SLD tree and using the fringe as the body of a rule for proving
the goal.  The problem with this approach is that the recursive relations 
produce infinite SLD trees, unless the recursion is cut off.  To determine
when the recursion should be cut off, a common practice is to apply a
recursive rule only when the subgoal is smaller, according to some
ordering, e.g. well-founded, well-quasi, than all its ancestors.  To
implement that, all the ancestors of each goal have in the past 
been stored, which is expensive both in time to check and in space
to store.  This paper tackles this problem by expanding the tree in a 
variant of depth-first search so that only the current call stack need
be stored.  They also consider the case of built-in predicates.
"))(POS (PAPER.TOPIC PUEBLA2004 "Reformulation"))(POS (PAPER.INSTANCE RAMACHANDRAN2005))(POS (PAPER.BIBTEX RAMACHANDRAN2005 ARTICLE))(POS (PAPER.AUTHOR RAMACHANDRAN2005 "D. Ramachandran and E. Amir"))(POS (PAPER.TITLE RAMACHANDRAN2005 "Compact Propositional Encodings of First-Order Theories"))(POS (PAPER.PUBLICATION RAMACHANDRAN2005 "20th National Conference on Artificial Intelligence"))(POS (PAPER.LINK RAMACHANDRAN2005 "http://reason.cs.uiuc.edu/eyal/paper.html"))(POS (PAPER.YEAR RAMACHANDRAN2005 2005))(POS (PAPER.DESCRIPTION RAMACHANDRAN2005 "
The authors introduce polynomial-time algorithms for converting
first-order logic (sometimes with a DCA) into propositional logic,
where the goal is a small output size.  Relies on a certain
structure within the FOL theory.
"))(POS (PAPER.TOPIC RAMACHANDRAN2005 "Reformulation"))(POS (PAPER.INSTANCE RAO2004))(POS (PAPER.BIBTEX RAO2004 ARTICLE))(POS (PAPER.AUTHOR RAO2004 "M.R.K. Krishna Rao"))(POS (PAPER.TITLE RAO2004 "Input-Termination of Logic Programs"))(POS (PAPER.PUBLICATION RAO2004 "14th International Symposium, Logic Based Program Synthesis and Transformation (LOPSTR)"))(POS (PAPER.STARTPAGE RAO2004 215))(POS (PAPER.ENDPAGE RAO2004 230))(POS (PAPER.LINK RAO2004 "http://wotan.liu.edu/docis/dbl/lopstr/index.html"))(POS (PAPER.YEAR RAO2004 2004))(POS (PAPER.DESCRIPTION RAO2004 "
Rao defines a class of logic programs, linear bounded programs,
and show that such programs are input-terminating under Prolog's 
selection rule.  Rao also shows that all simply-moded linear bounded
programs are input-terminating.  Importantly, determining whether
a program is linearly bounded is decidable, unlike previous work
which gave necessary and sufficient conditions for a class of 
decidable programs, but checking those conditions is undecidable.  Input-
consuming derivations do not instantiate variables that only occur
in the input positions of the initial query, and input-termination is the
property that all input-consuming derivations are finite.
"))(POS (PAPER.TOPIC RAO2004 "Reformulation"))(POS (PAPER.INSTANCE REITER2000))(POS (PAPER.AUTHOR REITER2000 "Ray Reiter"))(POS (PAPER.TITLE REITER2000 "Narratives as Programs"))(POS (PAPER.PUBLICATION REITER2000 "Principles of Knowledge Representation and Reasoning"))(POS (PAPER.STARTPAGE REITER2000 99))(POS (PAPER.ENDPAGE REITER2000 108))(POS (PAPER.LINK REITER2000 "http://citeseer.ist.psu.edu/reiter00narratives.html"))(POS (PAPER.YEAR REITER2000 2000))(POS (PAPER.RANK REITER2000 "[*]"))(POS (PAPER.DESCRIPTION REITER2000 "
Reiter argues that narratives (a sequence of events known to occur) are actually programs.  He uses GOLOG to represent narratives and shows that making a query Q(s) over a narrative is identical to proving a property about a program, as in program verification.  In GOLOG terms, we want to ask whether Q holds on a program v; we simply show that SitcalcAxioms |= As.(Do(v,S0,s)=>Q(s)).
"))(POS (PAPER.TOPIC REITER2000 "Behavioral Goals"))(POS (PAPER.INSTANCE REITER73))(POS (PAPER.BIBTEX REITER73 INPROCEEDINGS))(POS (PAPER.AUTHOR REITER73 "Ray Reiter"))(POS (PAPER.TITLE REITER73 "A Semantically Guided Deductive System for Automatic Theorem-Proving"))(POS (PAPER.PUBLICATION REITER73 "IJCAI"))(POS (PAPER.YEAR REITER73 1973))(POS (PAPER.RANK REITER73 "[**]"))(POS (PAPER.DESCRIPTION REITER73 "
Reiter describes a system for natural deduction that intertwines model-
building and deduction, where each affects the other.  The system itself
is composed of 12 inference rules which manipulate both axioms and 
models.  This may have been the seminal work on using an explicit 
model to aid theorem-proving; previous work used heuristics, which
Reiter characterized as implicit semantics. 
"))(POS (PAPER.TOPIC REITER73 "Model-Guided Proof Techniques"))(POS (PAPER.INSTANCE REITER78))(POS (PAPER.BIBTEX REITER78 INPROCEEDINGS))(POS (PAPER.AUTHOR REITER78 "Ray Reiter"))(POS (PAPER.TITLE REITER78 "On Closed World Databases"))(POS (PAPER.PUBLICATION REITER78 "In proceedings of 1978 ACM SIGMOD International Conference on Management of Data"))(POS (PAPER.YEAR REITER78 1978))(POS (PAPER.DESCRIPTION REITER78 "
The closed world assumption (CWA).
"))(POS (PAPER.TOPIC REITER78 "Logical Knowledge Representation"))(POS (PAPER.INSTANCE REITER80))(POS (PAPER.BIBTEX REITER80 ARTICLE))(POS (PAPER.AUTHOR REITER80 "Raymond Reiter"))(POS (PAPER.TITLE REITER80 "Equality and Domain Closure in First-Order Databases"))(POS (PAPER.PUBLICATION REITER80 "Journal of the ACM"))(POS (PAPER.VOLUME REITER80 "27(2)"))(POS (PAPER.STARTPAGE REITER80 235))(POS (PAPER.ENDPAGE REITER80 249))(POS (PAPER.LINK REITER80 "http://portal.acm.org/citation.cfm?id=322189"))(POS (PAPER.YEAR REITER80 1980))(POS (PAPER.RANK REITER80 "[**]"))(POS (PAPER.DESCRIPTION REITER80 "
Reiter explores techniques for doing first-order reasoning with 
a Domain Closure Axiom
(x=a1 | x=a2 | ... | x=an).  He focuses on axiom sets for which there
are a finite number of object constants, no function constants, and when
written in prenex form include no existential quantifiers.
To do so he (1) shows that existential queries will never require
the DCA, for algorithms exploiting Herbrand's theorem, and 
(2) how to build on this fact 
to answer any kind of query by peeling away quantifiers to build an 
existential query.  The second step uses a generalization of the 
relational database division operator for universal quantifiers and a 
generalization of the projection operator for existential quantifiers. 
Next it is shown that Horn databases and positive existential queries never 
require computing disjunctive answers. 
Then conditions are given for the removal of all but the x=x equality axiom: 
E-saturation, i.e.
unique names over all the constants.  Lastly it is
shown that extending DCA to include infinitely many constants can result in
an infinite disjunction as an answer to a query.  Very thorough, as always.
"))(POS (PAPER.TOPIC REITER80 "Logical Knowledge Representation"))(POS (PAPER.INSTANCE REITER84))(POS (PAPER.BIBTEX REITER84 CHAPTER))(POS (PAPER.AUTHOR REITER84 "Raymond Reiter"))(POS (PAPER.TITLE REITER84 "Towards a Logical Reconstruction of Relational Database Theory"))(POS (PAPER.PUBLISHER REITER84 "Springer-Verlag"))(POS (PAPER.PUBLICATION REITER84 "On Conceptual Modelling"))(POS (PAPER.STARTPAGE REITER84 191))(POS (PAPER.ENDPAGE REITER84 238))(POS (PAPER.LINK REITER84 ""))(POS (PAPER.YEAR REITER84 1984))(POS (PAPER.RANK REITER84 "[***]"))(POS (PAPER.DESCRIPTION REITER84 "
Reiter formalizes Database theory from a logical perspective.  Databases in this view are first-order models, and integrity constraints are sentences that such a model satisfies.  A relational theory (the set of sentences entailed by a relational database) can be defined as the set of ground atoms in the DB, a completion axiom for each table ensuring that those ground atoms not in the table are false, unique-names axioms, a domain closure axiom, and equality/substitution axioms.   Proof is provided.  Next Reiter goes on to generalize this definition to handle positive disjunction, which requires altering the completion axioms.  Lastly he shows how to deal with null values by changing the DCA and the completion axioms. 
"))(POS (PAPER.TOPIC REITER84 "Logical Knowledge Representation"))(POS (PAPER.INSTANCE REITER91))(POS (PAPER.AUTHOR REITER91 "Raymond Reiter"))(POS (PAPER.TITLE REITER91 "The Frame Problem in the Situation Calculus: A Simple Solution (Sometimes) and a Completeness Result for Goal Regression"))(POS (PAPER.PUBLICATION REITER91 "Artificial Intelligence and Mathematical Theory of Computation: Papers in Honor of John McCarthy"))(POS (PAPER.LINK REITER91 "http://ftp.cs.toronto.edu/pub/cogrob/README.html"))(POS (PAPER.YEAR REITER91 1991))(POS (PAPER.RANK REITER91 "[**]"))(POS (PAPER.DESCRIPTION REITER91 "
Reiter describes his solution to the frame problem, namely successor state
axioms of the form
Poss(a,s)=>[R(do(a,s)) =def= r_pos(a,s) V R(s) ^ ~r_neg(a,s)].  Poss(a,s) is
the action precondition axiom; R(do(a,s)) is the fluent, r_pos(a,s) is the
positive effect axiom for R; r_neg(a,s) is the negative effect axiom for R.
This works when also given a single definition for Poss(A,s) for each action A,
unique naming axioms for actions and states.  This technique requires F+A
axioms instead of 2*A*F axioms to describe frame and effect axioms for a
domain, where F is the number of fluents and A the number of actions.
Reiter also discusses a regression operator, which does deductive plan synthesis by taking a normal situation calculus axiomitization (using successor state axioms) and rewrites it so that every fluent only mentions S0.  Under certain conditions, Reiter shows that the rewriting can be done iff Es.G(s).
"))(POS (PAPER.TOPIC REITER91 "Fundamentals"))(POS (PAPER.INSTANCE REITER93))(POS (PAPER.AUTHOR REITER93 "Raymond Reiter"))(POS (PAPER.TITLE REITER93 "Proving Properties of States in the Situation Calculus"))(POS (PAPER.PUBLICATION REITER93 "Artificial Intelligence"))(POS (PAPER.VOLUME REITER93 "64(2)"))(POS (PAPER.STARTPAGE REITER93 337))(POS (PAPER.ENDPAGE REITER93 351))(POS (PAPER.LINK REITER93 "http://citeseer.ist.psu.edu/reiter93proving.html"))(POS (PAPER.YEAR REITER93 1993))(POS (PAPER.RANK REITER93 "[****]"))(POS (PAPER.DESCRIPTION REITER93 "
Reiter motivates the need to prove properties about states by citing the examples in the physical world (once broken, an object stays that way), planning (showing there is no plan to achieve a goal), and integrity constraints on a database.  He formulates an induction axiom sufficient for proving P(s) for all states s>=S0.  He relies on explanation closure axioms, proposed by Schubert and Haas, which are logically equivalent to frame axioms.
"))(POS (PAPER.TOPIC REITER93 "Theories of Action"))(POS (PAPER.INSTANCE REITER95))(POS (PAPER.AUTHOR REITER95 "Ray Reiter"))(POS (PAPER.TITLE REITER95 "On Specifying Database Updates"))(POS (PAPER.PUBLICATION REITER95 "Journal of Logic Programming"))(POS (PAPER.VOLUME REITER95 "25(1)"))(POS (PAPER.STARTPAGE REITER95 53))(POS (PAPER.ENDPAGE REITER95 91))(POS (PAPER.LINK REITER95 "http://citeseer.ist.psu.edu/reiter92specifying.html"))(POS (PAPER.YEAR REITER95 1995))(POS (PAPER.RANK REITER95 "[*]"))(POS (PAPER.DESCRIPTION REITER95 "
Reiter summarizes several previous pieces of work including proving properties of states in Situation Calculus and formalizing the querying of a database transaction.  He also compares this approach to other database query techniques.
"))(POS (PAPER.TOPIC REITER95 "Hypothetical Temporal DB Queries"))(POS (PAPER.INSTANCE REITER96))(POS (PAPER.AUTHOR REITER96 "Ray Reiter"))(POS (PAPER.TITLE REITER96 "Natural Actions, Concurrency and Continuous Time in the Situation Calculus"))(POS (PAPER.PUBLICATION REITER96 "Principles of Knowledge Representation and Reasoning: Proceedings of the Fifth International Conference"))(POS (PAPER.STARTPAGE REITER96 2))(POS (PAPER.ENDPAGE REITER96 13))(POS (PAPER.LINK REITER96 "http://ftp.cs.toronto.edu/pub/cogrob/README.html"))(POS (PAPER.YEAR REITER96 1996))(POS (PAPER.RANK REITER96 "[*****]"))(POS (PAPER.DESCRIPTION REITER96 "
Reiter gives an axiomitization for Concurrent, Temporal Situation Calculus.  He mentions any solution to the Precondition Interaction Problem (where two actions preconditions may both be satisfied yet the 2 actions are mutually exclusive) works within the given framework.  The axiomitization allows actions following the laws of physics to occur at the same time an agent is acting in the world.  Plans can consequently be produced that take these laws into account.
"))(POS (PAPER.TOPIC REITER96 "Behavioral Goals"))(POS (PAPER.INSTANCE RIAZANOV02))(POS (PAPER.BIBTEX RIAZANOV02 ARTICLE))(POS (PAPER.AUTHOR RIAZANOV02 "Alexandre Riazanov and Andrei Voronkov"))(POS (PAPER.TITLE RIAZANOV02 "The design and implementation of Vampire"))(POS (PAPER.PUBLICATION RIAZANOV02 "AI Communications"))(POS (PAPER.VOLUME RIAZANOV02 "15"))(POS (PAPER.STARTPAGE RIAZANOV02 91))(POS (PAPER.ENDPAGE RIAZANOV02 110))(POS (PAPER.LINK RIAZANOV02 ""))(POS (PAPER.YEAR RIAZANOV02 2002))(POS (PAPER.RANK RIAZANOV02 ""))(POS (PAPER.DESCRIPTION RIAZANOV02 "
Riazanov and Voronkov describe Vampire v2.0.  They first give an overview
of the high-level functionality, then give a more detailed discussion
of the architecture based on DISCOUNT, talk about term-indexing, 
and delve into representational
issues (e.g. shared terms) along with memory management.  
"))(POS (PAPER.TOPIC RIAZANOV02 "System Designs"))(POS (PAPER.INSTANCE RIAZANOV2001))(POS (PAPER.AUTHOR RIAZANOV2001 "Alexandre Riazanov and Andrei Voronkov"))(POS (PAPER.TITLE RIAZANOV2001 "Splitting without Backtracking"))(POS (PAPER.PUBLICATION RIAZANOV2001 "IJCAI"))(POS (PAPER.STARTPAGE RIAZANOV2001 611))(POS (PAPER.ENDPAGE RIAZANOV2001 617))(POS (PAPER.LINK RIAZANOV2001 "http://rpc25.cs.man.ac.uk/voronkov/all_publications.html"))(POS (PAPER.YEAR RIAZANOV2001 2001))(POS (PAPER.DESCRIPTION RIAZANOV2001 "
The authors describe a technique for resolution that allows resolution
to break a clause apart when variables are not shared between pieces.
Suppose the clause C can be partitioned into 2 parts D and E, where each
part shares no variables with any other part.  Splitting replaces
C with the clauses D | p and E | -p.  This only makes sense when there
is an ordering imposed on the literals so that p and -p are not immediately
resolved together undoing the work of splitting.  The authors investigate
two orders: blocking and parallel.  In blocking, the -p literals 
are ranked highest; the non p literals are ranked next with negative
bigger than positive; the p atoms are ranked lowest.  In parallel,
the p literals (positive or negative) are ranked last.  Also, 
these p literals are considered names.  If there is another clause 
C' with partition D and F, then C' is split into F | -p.  Some
experimental results from TPTP show that splitting is a bad idea
with equality but that Parallel ordering with Naming is a good idea
without equaity. 
"))(POS (PAPER.TOPIC RIAZANOV2001 "Calculi"))(POS (PAPER.INSTANCE RIAZANOV2003))(POS (PAPER.AUTHOR RIAZANOV2003 "Alexandre Riazanov and Andrei Voronkov"))(POS (PAPER.TITLE RIAZANOV2003 "Efficient Instance Retrieval with Standard and Relational Path Indexing
"))(POS (PAPER.LINK RIAZANOV2003 "http://citeseer.ist.psu.edu/594779.html"))(POS (PAPER.YEAR RIAZANOV2003 2003))(POS (PAPER.DESCRIPTION RIAZANOV2003 "
Riazanov and Voronkov follow on their first indexing paper with this one.
They compare discrimination trees and path indexing for the case of instance
retrieval.  Given a term t, find all terms u and substitutions sigma such that 
t.sigma = u.  Discrimination trees represent terms as strings; path
indexing represents terms as trees.  The authors show that with the
standard implementation of path indexing is slower than DT.  Then
they augment PI with skip lists, early cleaning to more closely
approximate perfect filtering, and a couple of other improvements.  Then
they argue for relational path indexing, utilizing database theory
to conceptualize the integration of cleaning after imperfect filtering
into the imperfect filtering.  They show how this idea makes
commutative indexing and backward subsumption on multiliteral
clauses.
"))(POS (PAPER.TOPIC RIAZANOV2003 "Indexing"))(POS (PAPER.INSTANCE ROBINSON))(POS (PAPER.BIBTEX ROBINSON BOOK))(POS (PAPER.AUTHOR ROBINSON "Alan Robinson and Andrei Voronkov"))(POS (PAPER.TITLE ROBINSON "Handbook of Automated Reasoning"))(POS (PAPER.PUBLISHER ROBINSON "MIT Press and Elsevier Science"))(POS (PAPER.LINK ROBINSON "http://www.amazon.com/Handbook-Automated-Reasoning-Alan-Robinson/dp/0262182238"))(POS (PAPER.YEAR ROBINSON 2001))(POS (PAPER.RANK ROBINSON "[*****]"))(POS (PAPER.DESCRIPTION ROBINSON "
Robinson and Voronkov edit this two volume handbook.  The first volume covers
a history of the field, methods for first-order logic, methods for equality and
other built-in theories, and induction.  The second volume covers higher-order
logics, nonclassical logics, decidable classes and model building, and implementational
details.
"))(POS (PAPER.TOPIC ROBINSON ""))(POS (PAPER.INSTANCE ROBINSON65MACHINE))(POS (PAPER.BIBTEX ROBINSON65MACHINE ARTICLE))(POS (PAPER.AUTHOR ROBINSON65MACHINE "J.A. Robinson"))(POS (PAPER.TITLE ROBINSON65MACHINE "A Machine-Oriented Logic Based on the Resolution Principle"))(POS (PAPER.PUBLICATION ROBINSON65MACHINE "Journal of the ACM"))(POS (PAPER.VOLUME ROBINSON65MACHINE "12(1)"))(POS (PAPER.STARTPAGE ROBINSON65MACHINE 23))(POS (PAPER.ENDPAGE ROBINSON65MACHINE 41))(POS (PAPER.YEAR ROBINSON65MACHINE 1965))(POS (PAPER.RANK ROBINSON65MACHINE ""))(POS (PAPER.DESCRIPTION ROBINSON65MACHINE "
The resolution paper.
"))(POS (PAPER.TOPIC ROBINSON65MACHINE "Theorem Proving"))(POS (PAPER.INSTANCE ROY2000))(POS (PAPER.BIBTEX ROY2000 ARTICLE))(POS (PAPER.AUTHOR ROY2000 "Pierre Roy, Anne Liret, Francois Pachet"))(POS (PAPER.TITLE ROY2000 "The Framework Approach for Constraint Satisfaction"))(POS (PAPER.PUBLICATION ROY2000 "ACM Computing Surveys"))(POS (PAPER.VOLUME ROY2000 "32"))(POS (PAPER.STARTPAGE ROY2000 13))(POS (PAPER.ENDPAGE ROY2000 16))(POS (PAPER.LINK ROY2000 "http://citeseer.ist.psu.edu/roy00framework.html"))(POS (PAPER.YEAR ROY2000 2000))(POS (PAPER.RANK ROY2000 "[**]"))(POS (PAPER.DESCRIPTION ROY2000 "
The authors argue that a Framework is a better paradigm for
allowing a user to solve CSPs than either a Library of generic
constraints or a Language built for writing solvers of CSPs. 
The former approach is too coarsely-grained, and the latter is
too finely-grained.  The framework approach sits nicely in the
middle. 
"))(POS (PAPER.TOPIC ROY2000 "OO Languages with Native Constraint Satisfaction"))(POS (PAPER.INSTANCE ROY97))(POS (PAPER.AUTHOR ROY97 "Pierre Roy, Francois Pachet"))(POS (PAPER.TITLE ROY97 "Reifying Constraint Satisfaction in Smalltalk"))(POS (PAPER.PUBLICATION ROY97 "Journal of Object-Oriented Programming"))(POS (PAPER.VOLUME ROY97 "10(4)"))(POS (PAPER.STARTPAGE ROY97 43))(POS (PAPER.ENDPAGE ROY97 51))(POS (PAPER.LINK ROY97 "http://citeseer.ist.psu.edu/roy97reifying.html"))(POS (PAPER.YEAR ROY97 1997))(POS (PAPER.RANK ROY97 "[**]"))(POS (PAPER.DESCRIPTION ROY97 "
Roy describes Backtalk, a system that allows a library of
generic CSP algorithms to be written.
Doing so requires reifying
the notion of a constraint, a CSP problem, a solution, etc..
"))(POS (PAPER.TOPIC ROY97 "OO Languages with Native Constraint Satisfaction"))(POS (PAPER.INSTANCE RUEB2000DECONSTRUCTING))(POS (PAPER.BIBTEX RUEB2000DECONSTRUCTING INPROCEEDINGS))(POS (PAPER.AUTHOR RUEB2000DECONSTRUCTING "Harald Rueb and Nataranjan Shankar"))(POS (PAPER.TITLE RUEB2000DECONSTRUCTING "Deconstructing Shostak"))(POS (PAPER.PUBLICATION RUEB2000DECONSTRUCTING "17th International Conference on Automated Deduction
           "))(POS (PAPER.LINK RUEB2000DECONSTRUCTING "http://citeseer.ist.psu.edu/290082.html"))(POS (PAPER.YEAR RUEB2000DECONSTRUCTING 2000))(POS (PAPER.RANK RUEB2000DECONSTRUCTING "[****]"))(POS (PAPER.DESCRIPTION RUEB2000DECONSTRUCTING "
Rueb and Shankar show the crisply outlined Shostak procedure outlined
in cyrluk96shostaks and all its variants to date are incomplete.  They
go further and give a complete version of the Shostak procedure and
finally give soundness and completeness proofs.
"))(POS (PAPER.TOPIC RUEB2000DECONSTRUCTING "Nelson-Oppen and Shostak"))(POS (PAPER.RELATED RUEB2000DECONSTRUCTING CYRLUK96SHOSTAKS))(POS (PAPER.RELATED RUEB2000DECONSTRUCTING SHOSTAK84))(POS (PAPER.INSTANCE SABIN96))(POS (PAPER.BIBTEX SABIN96 ARTICLE))(POS (PAPER.AUTHOR SABIN96 "D. Sabin and E. Freuder"))(POS (PAPER.TITLE SABIN96 "Configuration as Composite Constraint Satisfaction"))(POS (PAPER.PUBLICATION SABIN96 " AAAI Configuration Workshop"))(POS (PAPER.STARTPAGE SABIN96 28))(POS (PAPER.ENDPAGE SABIN96 36))(POS (PAPER.LINK SABIN96 "http://citeseer.ist.psu.edu/sabin96configuration.html"))(POS (PAPER.YEAR SABIN96 1996))(POS (PAPER.RANK SABIN96 "[****]"))(POS (PAPER.DESCRIPTION SABIN96 "
Sabin and Freuder define a new form of CSP which generalizes 
Meta CSPs, conditional CSPs, and hierarchical domain CSPs.
Composite CSP domain values are the set of solutions to an
entire subproblem.
"))(POS (PAPER.TOPIC SABIN96 "Various Forms of Constraint Satisfaction"))(POS (PAPER.INSTANCE SACERDOTI74))(POS (PAPER.AUTHOR SACERDOTI74 "Earl D. Sacerdoti"))(POS (PAPER.TITLE SACERDOTI74 "Planning in a Hierarchy of Abstraction Spaces"))(POS (PAPER.PUBLICATION SACERDOTI74 "Artificial Intelligence"))(POS (PAPER.VOLUME SACERDOTI74 "5"))(POS (PAPER.STARTPAGE SACERDOTI74 115))(POS (PAPER.ENDPAGE SACERDOTI74 135))(POS (PAPER.YEAR SACERDOTI74 1974))(POS (PAPER.DESCRIPTION SACERDOTI74 "
The ABSTRIPS (Abstraction-based STRIPS) paper.  In 1969, McCarthy and Hayes' asserted that knowledge representation should be epistemologically adequate and also define heuristic adequacy.  Sufficiently complex problems contain too many details to be epistemologically adequate and have adequeate heuristics.  To that end, Sacerdoti first plans through an abstract plan space and then refines a solution in that space to ensure the details support the abstraction.  To implement this idea, Sacerdoti extends STRIPS by assigning 'criticality' measures to each precondition of an action.  These measures define a hierarchy of abstraction spaces.  The planner finds a solution at the highest level of abstraction, and proceeds recursively to the next highest level.  Control of the search (i.e. the cost assigned to nodes in the search space) changes based on the level of abstraction.
"))(POS (PAPER.TOPIC SACERDOTI74 "Historical"))(POS (PAPER.INSTANCE SACERDOTI75))(POS (PAPER.AUTHOR SACERDOTI75 "Earl D. Sacerdoti"))(POS (PAPER.TITLE SACERDOTI75 "The Nonlinear Nature of Plans"))(POS (PAPER.PUBLICATION SACERDOTI75 "Aritificial Intelligence"))(POS (PAPER.VOLUME SACERDOTI75 "32"))(POS (PAPER.STARTPAGE SACERDOTI75 333))(POS (PAPER.ENDPAGE SACERDOTI75 377))(POS (PAPER.YEAR SACERDOTI75 1975))(POS (PAPER.DESCRIPTION SACERDOTI75 "
Sacerdoti describes NOAH (Nets Of Action Hierarchies), the first partial order
planner that relies heavily on the concept of a procedural net.  A 'procedural
net' is the data structure that maintains the
partially-ordered plan.  Much like his earlier work on
Hierarchical Planning, NOAH begins with an abstract
plan and continually refines it, alleviating conflicts through the use of
critics, until the plan consists of primitive actions.
"))(POS (PAPER.TOPIC SACERDOTI75 "Historical"))(POS (PAPER.INSTANCE SAGONAS94))(POS (PAPER.BIBTEX SAGONAS94 INPROCEEDINGS))(POS (PAPER.AUTHOR SAGONAS94 "K. Sagonas and T. Swift and D. S. Warren"))(POS (PAPER.TITLE SAGONAS94 "XSB as an Efficient Deductive Database Engine"))(POS (PAPER.PUBLICATION SAGONAS94 "Proceedings of the ACM SIGMOD International Conference on the Management of Data>"))(POS (PAPER.STARTPAGE SAGONAS94 442))(POS (PAPER.ENDPAGE SAGONAS94 453))(POS (PAPER.YEAR SAGONAS94 1994))(POS (PAPER.DESCRIPTION SAGONAS94 "
XSB is Warren's current Prolog implementation, which includes tabling.
"))(POS (PAPER.TOPIC SAGONAS94 "Logic Programming"))(POS (PAPER.INSTANCE SAIS94))(POS (PAPER.BIBTEX SAIS94 INPROCEEDINGS))(POS (PAPER.AUTHOR SAIS94 "Lakhdar Sais"))(POS (PAPER.TITLE SAIS94 "Characterization of the Set of Models by Means of Symmetries"))(POS (PAPER.PUBLICATION SAIS94 "Second International Workshop on Principles and Practice of Constraint Programming"))(POS (PAPER.LINK SAIS94 "http://citeseer.ist.psu.edu/162645.html"))(POS (PAPER.YEAR SAIS94 1994))(POS (PAPER.RANK SAIS94 "[**]"))(POS (PAPER.DESCRIPTION SAIS94 "
Sais gives an algorithm that seems to compute the characteristic models
of a given propositional, CNF theory.  There is no proof that the models
generated are exactly a set of characteristic models, but rather that
the models generated are non-symmetric.  [Maybe the equivalence is obvious,
but there is no theorem stating it.]
"))(POS (PAPER.TOPIC SAIS94 "Characteristic Models"))(POS (PAPER.INSTANCE SANDFORD80))(POS (PAPER.BIBTEX SANDFORD80 ARTICLE))(POS (PAPER.AUTHOR SANDFORD80 "David Sandford"))(POS (PAPER.TITLE SANDFORD80 "Using Sophisticated Models in Resolution Theorem Proving"))(POS (PAPER.PUBLISHER SANDFORD80 "Springer-Verlag"))(POS (PAPER.PUBLICATION SANDFORD80 "Lecture Notes in Computer Science"))(POS (PAPER.VOLUME SANDFORD80 "90"))(POS (PAPER.LINK SANDFORD80 ""))(POS (PAPER.YEAR SANDFORD80 1980))(POS (PAPER.RANK SANDFORD80 "[**]"))(POS (PAPER.DESCRIPTION SANDFORD80 "
Sandford describes a new refinement of semantic resolution, hereditary 
lock resolution, and a new approach for representing models as required 
in semantic resolution.  The pertinent part of the work is the model 
representation.  Semantic resolution puts clauses into two bins throughout 
the resolution process.  Part of the input to the procedure is a model, 
any model, and those clauses that are satisfied by the model are put into 
bin 1 while clauses not satisfied by the model are put into bin 2.  
This partitioning of clauses shrinks the search space since every resolution 
must use at least one clause from the set of unsatisfied clauses.  
Sandford describes a method for using a set of sentences to define that 
model (in possibly a totally different language) and using a satisfaction 
test to determine whether a clause belongs in bin 1 or 2.   Of course, 
the computational and complexity properties could be horrible, but so 
long as the satisfaction test is sound (only returns true when the sentences 
and clause are satisfiable), we retain completeness. 
"))(POS (PAPER.TOPIC SANDFORD80 "Model-Guided Proof Techniques"))(POS (PAPER.INSTANCE SCHULZ2001))(POS (PAPER.BIBTEX SCHULZ2001 INPROCEEDINGS))(POS (PAPER.AUTHOR SCHULZ2001 "S. Schulz"))(POS (PAPER.TITLE SCHULZ2001 "A Comparison of Different Techniques for Grounding Near-Propositional CNF Formulae"))(POS (PAPER.PUBLICATION SCHULZ2001 "Proc. 15th International FLAIRS Conference"))(POS (PAPER.STARTPAGE SCHULZ2001 72))(POS (PAPER.ENDPAGE SCHULZ2001 76))(POS (PAPER.LINK SCHULZ2001 "http://citeseer.ist.psu.edu/565512.html"))(POS (PAPER.YEAR SCHULZ2001 2002))(POS (PAPER.DESCRIPTION SCHULZ2001 "
Paper comparing various approaches for grounding a set of first-order, function-free clauses.  Won best-paper at FLAIR 2002.
"))(POS (PAPER.TOPIC SCHULZ2001 "Reformulation"))(POS (PAPER.INSTANCE SCHULZ2002))(POS (PAPER.BIBTEX SCHULZ2002 INPROCEEDINGS))(POS (PAPER.BIBTEX SCHULZ2002 ARTICLE))(POS (PAPER.AUTHOR SCHULZ2002 "Stephan Schulz"))(POS (PAPER.AUTHOR SCHULZ2002 "Stephan Schulz"))(POS (PAPER.TITLE SCHULZ2002 "A Comparison of Different Techniques for Grounding Near-Propositional CNF Formulae"))(POS (PAPER.TITLE SCHULZ2002 "E - A brainiac theorem prover"))(POS (PAPER.PUBLICATION SCHULZ2002 "Proceedings, 15th International FLAIRS Conference"))(POS (PAPER.PUBLICATION SCHULZ2002 "AI Communications"))(POS (PAPER.VOLUME SCHULZ2002 "15"))(POS (PAPER.STARTPAGE SCHULZ2002 72))(POS (PAPER.STARTPAGE SCHULZ2002 111))(POS (PAPER.ENDPAGE SCHULZ2002 76))(POS (PAPER.ENDPAGE SCHULZ2002 126))(POS (PAPER.LINK SCHULZ2002 "http://citeseer.ist.psu.edu/565512.html"))(POS (PAPER.LINK SCHULZ2002 "http://citeseer.ist.psu.edu/560030.html"))(POS (PAPER.YEAR SCHULZ2002 2002))(POS (PAPER.YEAR SCHULZ2002 2002))(POS (PAPER.RANK SCHULZ2002 ""))(POS (PAPER.DESCRIPTION SCHULZ2002 "
Schulz compares three techniques for reducing the cost of generating 
the grounding of universal clause sets without function symbols.  The
first is hypersplitting, a generalization of which is (now) used in
the model builders that ground and use SAT solvers, structural constraints,
restricting instantiations to avoid the creation of pure literals, and 
post-processing the grounded sentences via unit subsumption, unit
propagation, and tautology deletion.  The combination of all three
outperformed any one of the techniques.
"))(POS (PAPER.DESCRIPTION SCHULZ2002 "
Schulz describes E, a full first-order theorem prover with
equality.  It is a saturation-based prover from a purely 
equational view. It is based on the superposition calculus
with literal selection and was one of the first to use
the DISCOUNT algorithm.  The paper first describes the 
calculus, gives the proof search algorithm, discusses
search control by way of clause and literal selection,
term orderings, and auto configuration.  It delves into
implementation details: shared terms and indexing.
"))(POS (PAPER.TOPIC SCHULZ2002 "Herbrand Logic"))(POS (PAPER.TOPIC SCHULZ2002 "System Designs"))(POS (PAPER.INSTANCE SCHUTZ96))(POS (PAPER.BIBTEX SCHUTZ96 ARTICLE))(POS (PAPER.AUTHOR SCHUTZ96 "Heribert Schutz"))(POS (PAPER.TITLE SCHUTZ96 "Comparison of Two Complementary Herbrand Model Generators"))(POS (PAPER.LINK SCHUTZ96 "http://citeseer.ist.psu.edu/122874.html"))(POS (PAPER.YEAR SCHUTZ96 1996))(POS (PAPER.RANK SCHUTZ96 "[**]"))(POS (PAPER.DESCRIPTION SCHUTZ96 "
Schutz describes and analyzes two different Herbrand model-building 
techniques built on hyperresolution.  He shows that some of the 
strengths of one can be used to help on cases where the other is weak
and vice versa.  
"))(POS (PAPER.TOPIC SCHUTZ96 "Model Building"))(POS (PAPER.INSTANCE SELMAN91))(POS (PAPER.BIBTEX SELMAN91 INPROCEEDINGS))(POS (PAPER.AUTHOR SELMAN91 "Bart Selman and Henry Kautz"))(POS (PAPER.TITLE SELMAN91 "Knowledge Compilation Using Horn Approximations"))(POS (PAPER.PUBLICATION SELMAN91 "AAAI"))(POS (PAPER.LINK SELMAN91 "http://citeseer.ist.psu.edu/selman91knowledge.html"))(POS (PAPER.YEAR SELMAN91 1991))(POS (PAPER.RANK SELMAN91 "[****]"))(POS (PAPER.DESCRIPTION SELMAN91 "
This seems to be the seminal work on Knowledge Compilation.  Selman and
Kautz investigate finding two Horn approximations for a propositional 
knowledge base: one that is too strong and one that is too weak.  The 
algorithms for computing those approximations are anytime algorithms. 
To determine whether a given sentence p is entailed by the original
knowledge base, return yes if the strong approximation entails it and
no if the weak one doesn't.  If neither of these two cases hold, resort
to the original knowledge base.  Since entailment for propositional Horn
requires linear time, the worst case wastes O(2n) computation time, but
the best case might save exponential time.
"))(POS (PAPER.TOPIC SELMAN91 "Knowledge Base Compilation"))(POS (PAPER.INSTANCE SELMAN96))(POS (PAPER.BIBTEX SELMAN96 ARTICLE))(POS (PAPER.AUTHOR SELMAN96 "Bart Selman and Henry Kautz"))(POS (PAPER.TITLE SELMAN96 "Knowledge Compilation and Theory Approximation"))(POS (PAPER.PUBLICATION SELMAN96 "Journal of the ACM "))(POS (PAPER.VOLUME SELMAN96 "43(2)"))(POS (PAPER.STARTPAGE SELMAN96 193))(POS (PAPER.ENDPAGE SELMAN96 224))(POS (PAPER.LINK SELMAN96 "http://citeseer.ist.psu.edu/41052.html"))(POS (PAPER.YEAR SELMAN96 1996))(POS (PAPER.RANK SELMAN96 "[*****]"))(POS (PAPER.DESCRIPTION SELMAN96 "
This paper essentially glues together the work of kautz91, selman91,
kautz92,  and kautz95.  Especially noteworthy is the thorough related
work section.  It also brought together the fact that the Greatest
Upper Bound approximation of a propositional theory is always linear
in the size of the theory, but the Least Upper Bound can be exponential
in the size of the theory.
"))(POS (PAPER.TOPIC SELMAN96 "Knowledge Base Compilation"))(POS (PAPER.RELATED SELMAN96 SELMAN91))(POS (PAPER.RELATED SELMAN96 KAUTZ91))(POS (PAPER.RELATED SELMAN96 KAUTZ92))(POS (PAPER.RELATED SELMAN96 KAUTZ95))(POS (PAPER.INSTANCE SHERL93))(POS (PAPER.AUTHOR SHERL93 "R. Sherl and H. Levesque"))(POS (PAPER.TITLE SHERL93 "The frame problem and knowledge-producing actions"))(POS (PAPER.LINK SHERL93 "http://citeseer.ist.psu.edu/scherl93frame.html"))(POS (PAPER.YEAR SHERL93 1993))(POS (PAPER.DESCRIPTION SHERL93 "None yet.
"))(POS (PAPER.TOPIC SHERL93 "Planning with Sensing Actions"))(POS (PAPER.INSTANCE SHOSTAK84))(POS (PAPER.BIBTEX SHOSTAK84 ARTICLE))(POS (PAPER.AUTHOR SHOSTAK84 "Robert Shostak"))(POS (PAPER.TITLE SHOSTAK84 "Deciding Combinations of Theories"))(POS (PAPER.PUBLICATION SHOSTAK84 "Journal of the ACM
           "))(POS (PAPER.VOLUME SHOSTAK84 "31"))(POS (PAPER.STARTPAGE SHOSTAK84 1))(POS (PAPER.ENDPAGE SHOSTAK84 12))(POS (PAPER.LINK SHOSTAK84 "http://portal.acm.org/citation.cfm?id=322411&dl=ACM&coll=portal"))(POS (PAPER.YEAR SHOSTAK84 1984))(POS (PAPER.RANK SHOSTAK84 "[****]"))(POS (PAPER.DESCRIPTION SHOSTAK84 "
Shostak describes what is now commonly known as Shostak's decision procedure.
The decision procedure works on algebraically solvable and canonizable 
equational theories.  It functions by computing the congruence closure of 
the terms in the language representing each one by their canonical forms.  
The canonization takes into account both interpreted and unintepreted
functions.  Unlike Nelson Oppen, Shostak shows how to merge the decision
procedures for two theories by taking a solver and canonizer for each and
building a single solver and canonizer pair for the union of the theories.
"))(POS (PAPER.TOPIC SHOSTAK84 "Nelson-Oppen and Shostak"))(POS (PAPER.RELATED SHOSTAK84 NELSON79))(POS (PAPER.INSTANCE SIKKA96))(POS (PAPER.BIBTEX SIKKA96 PHDTHESIS))(POS (PAPER.AUTHOR SIKKA96 "Vishal Sikka"))(POS (PAPER.TITLE SIKKA96 "Integrating Specialized Procedures into Proof Systems"))(POS (PAPER.PUBLISHER SIKKA96 "Stanford University"))(POS (PAPER.LINK SIKKA96 "http://library.stanford.edu/depts/mathcs/mathcscoll/techreports.html"))(POS (PAPER.YEAR SIKKA96 1996))(POS (PAPER.RANK SIKKA96 "[*****]"))(POS (PAPER.DESCRIPTION SIKKA96 "
Compiled code can be used by a theorem prover to expedite a proof.  
Sikka describes a general method for integrating such specialized 
procedures into proof systems using function constants, data 
structure constants, and the 'apply' operator.  
"))(POS (PAPER.TOPIC SIKKA96 "Theorem Proving with Attachments"))(POS (PAPER.INSTANCE SIPSER))(POS (PAPER.BIBTEX SIPSER BOOK))(POS (PAPER.AUTHOR SIPSER "Michael Sipser"))(POS (PAPER.TITLE SIPSER "Introduction to the Theory of Computation"))(POS (PAPER.PUBLISHER SIPSER "Brooks Cole"))(POS (PAPER.LINK SIPSER "http://www.amazon.com/exec/obidos/tg/detail/-/053494728X/qid=1062605920/sr=1-1/ref=sr_1_1/102-6107129-2481765?v=glance&s=books"))(POS (PAPER.YEAR SIPSER 1996))(POS (PAPER.RANK SIPSER "[*****]"))(POS (PAPER.DESCRIPTION SIPSER "
One of the two definitive introductions to the theory of computation.  Sipser
covers automata and languages, computability theory, and complexity theory.
"))(POS (PAPER.TOPIC SIPSER ""))(POS (PAPER.INSTANCE SLANEY93))(POS (PAPER.BIBTEX SLANEY93 INPROCEEDINGS))(POS (PAPER.AUTHOR SLANEY93 "John Slaney"))(POS (PAPER.TITLE SLANEY93 "SCOTT: A Model-Guided Theorem Prover"))(POS (PAPER.PUBLICATION SLANEY93 "IJCAI"))(POS (PAPER.LINK SLANEY93 "http://citeseer.ist.psu.edu/slaney93scott.html"))(POS (PAPER.YEAR SLANEY93 1993))(POS (PAPER.RANK SLANEY93 "[***]"))(POS (PAPER.DESCRIPTION SLANEY93 "
Slaney describes a case study of SCOTT (Semantically Constrained
Otter).  SCOTT consists of OTTER augmented with a model-generator
FINDER.  It restricts the resolutions done by Otter to include one
parent clause not true in the model being generated.  A new model
is generated every time a new clause is generated that is false
in the current model (up to 100 clauses).  If no new model can 
be found, the old one is used.  SCOTT retains completeness
for binary resolution since every model generated is a model of the
usable list (those axioms assumed to be consistent).  
"))(POS (PAPER.TOPIC SLANEY93 "Model-Guided Proof Techniques"))(POS (PAPER.INSTANCE SLANEY94))(POS (PAPER.BIBTEX SLANEY94 INPROCEEDINGS))(POS (PAPER.BIBTEX SLANEY94 INPROCEEDINGS))(POS (PAPER.AUTHOR SLANEY94 "John Slaney"))(POS (PAPER.AUTHOR SLANEY94 "John Slaney"))(POS (PAPER.TITLE SLANEY94 "Finder: Finite Domain Enumerator System Description"))(POS (PAPER.TITLE SLANEY94 "The Crisis in Finite Mathematics: Automated Reasoning as Cause and Cure"))(POS (PAPER.PUBLICATION SLANEY94 "In proceedings, CADE-12"))(POS (PAPER.PUBLICATION SLANEY94 "CADE"))(POS (PAPER.LINK SLANEY94 "http://citeseer.ist.psu.edu/252758.html"))(POS (PAPER.LINK SLANEY94 "http://arp.anu.edu.au/~jks/constraints.html"))(POS (PAPER.YEAR SLANEY94 1994))(POS (PAPER.YEAR SLANEY94 1994))(POS (PAPER.RANK SLANEY94 ""))(POS (PAPER.DESCRIPTION SLANEY94 "
Very short description of Finder, a model builder for FOL.  It grounds and
then uses a combination of tableaux and negative hyperresolution.  Used
in SCOTT to constrain the search space of Otter.
"))(POS (PAPER.DESCRIPTION SLANEY94 "
Slaney describes the problems associated with using machines to exhaustively
check a solution space as proof of the non-existence of a solution.  Is that
really a proof?  Afterall, no one will actually verify such a proof.
But, if a theorem prover outputs a trace, we can check the trace with an
independent proof checker.  This trace-checking may be much easier than
proving the correctness of a theorem prover.
"))(POS (PAPER.TOPIC SLANEY94 "Model Building"))(POS (PAPER.TOPIC SLANEY94 "Theorem Proving"))(POS (PAPER.INSTANCE SOUTCHANSKI2000))(POS (PAPER.AUTHOR SOUTCHANSKI2000 "Mikhail Soutchanski"))(POS (PAPER.TITLE SOUTCHANSKI2000 "An On-line Decision-Theoretic Golog Interpreter"))(POS (PAPER.PUBLICATION SOUTCHANSKI2000 "AAAI"))(POS (PAPER.LINK SOUTCHANSKI2000 "http://www.cs.toronto.edu/~cebly/papers.html"))(POS (PAPER.YEAR SOUTCHANSKI2000 2000))(POS (PAPER.DESCRIPTION SOUTCHANSKI2000 "
Building on previous work, Southchanski couples Golog with a decision-theoretic planner based on Markov decision processes.  The original work found a optimal conditional policy, the probability that the policy could be executed, and the expected utility of the policy all offline.  This is really only possible in an environment without sensing actions with continuous return values.  Soutchanski also points out that only a single policy can be computed for an entire program, even if the program could be easily partitioned into two independent portions.  Soutchanski introduces optimize(p1);p2 to indicate that a single policy should be found for program p1 and another for program p2.  He also gives a new formulation of sensing actions of the form sense(act, value, s), meaning the result of executing the action act is value in situation s.  Since Golog is an online interpreter, sensing actions with continuous return values can be handled.
"))(POS (PAPER.TOPIC SOUTCHANSKI2000 "Logic Programming"))(POS (PAPER.INSTANCE SQALLI2001))(POS (PAPER.AUTHOR SQALLI2001 "Mohammed Sqalli and Eugene Freuder"))(POS (PAPER.TITLE SQALLI2001 "Solving InterOperability Problems Using Object-Oriented CSP 
 Modeling"))(POS (PAPER.LINK SQALLI2001 "http://citeseer.ist.psu.edu/487285.html"))(POS (PAPER.YEAR SQALLI2001 2001))(POS (PAPER.RANK SQALLI2001 "[**]"))(POS (PAPER.DESCRIPTION SQALLI2001 "
Sqalli and Freuder describe a combination of Case-based reasoning
and constraint satisfaction.  They use Paltrinieri's OOCSP definition
except that they add methods to classes.  To solve an OOCSP, they
convert it to a standard CSP.  
"))(POS (PAPER.TOPIC SQALLI2001 "Object Oriented Constraint Satisfaction"))(POS (PAPER.INSTANCE STICKEL85))(POS (PAPER.BIBTEX STICKEL85 ARTICLE))(POS (PAPER.AUTHOR STICKEL85 "Mark Stickel"))(POS (PAPER.TITLE STICKEL85 "Automated Deduction by Theory Resolution"))(POS (PAPER.PUBLICATION STICKEL85 "Journal of Automated Reasoning"))(POS (PAPER.VOLUME STICKEL85 "1"))(POS (PAPER.STARTPAGE STICKEL85 333))(POS (PAPER.ENDPAGE STICKEL85 356))(POS (PAPER.LINK STICKEL85 "http://citeseer.ist.psu.edu/stickel85automated.html"))(POS (PAPER.YEAR STICKEL85 1985))(POS (PAPER.RANK STICKEL85 "[***]"))(POS (PAPER.DESCRIPTION STICKEL85 "
The theory resolution paper.
"))(POS (PAPER.TOPIC STICKEL85 "Theorem Proving with Attachments"))(POS (PAPER.INSTANCE STICKEL87))(POS (PAPER.AUTHOR STICKEL87 "Mark Stickel"))(POS (PAPER.TITLE STICKEL87 "A Prolog Technology Theorem Prover"))(POS (PAPER.LINK STICKEL87 "http://citeseer.ist.psu.edu/stickel87prolog.html"))(POS (PAPER.YEAR STICKEL87 1987))(POS (PAPER.DESCRIPTION STICKEL87 "
"))(POS (PAPER.TOPIC STICKEL87 "Calculi"))(POS (PAPER.INSTANCE STICKEL94))(POS (PAPER.BIBTEX STICKEL94 ARTICLE))(POS (PAPER.AUTHOR STICKEL94 "Mark Stickel and Richard Waldinger and Michael Lowry and Thomas Pressburger and Ian Underwood"))(POS (PAPER.TITLE STICKEL94 "Deductive Composition of Astronomical Software from Subroutine Libraries"))(POS (PAPER.PUBLICATION STICKEL94 "Conference on Automated Deduction"))(POS (PAPER.STARTPAGE STICKEL94 341))(POS (PAPER.ENDPAGE STICKEL94 355))(POS (PAPER.LINK STICKEL94 "http://citeseer.ist.psu.edu/67907.html"))(POS (PAPER.YEAR STICKEL94 1994))(POS (PAPER.RANK STICKEL94 "[*]"))(POS (PAPER.DESCRIPTION STICKEL94 "
The authors describe a system that allows a user to graphically describe
a specification for a system relying on subroutine libraries and then uses
automated deduction techniques to produce a proof of the specification from
axioms describing the library.  That proof is then translated into a 
Fortran program.
"))(POS (PAPER.TOPIC STICKEL94 "Miscellaneous"))(POS (PAPER.INSTANCE STONE))(POS (PAPER.BIBTEX STONE ARTICLE))(POS (PAPER.AUTHOR STONE "Nicholas Stone"))(POS (PAPER.TITLE STONE "Object-Oriented Constraint Satisfaction Planning for Whole Farm
Management"))(POS (PAPER.PUBLICATION STONE "AI Applications"))(POS (PAPER.LINK STONE "http://everest.ento.vt.edu/Publications/NDS-Paper-.html"))(POS (PAPER.YEAR STONE NIL))(POS (PAPER.RANK STONE "[*]"))(POS (PAPER.DESCRIPTION STONE "
Stone describes an Object-oriented approach to writing a planner.
"))(POS (PAPER.TOPIC STONE "Miscellaneous"))(POS (PAPER.INSTANCE STRZALKOWSKI91))(POS (PAPER.BIBTEX STRZALKOWSKI91 ARTICLE))(POS (PAPER.AUTHOR STRZALKOWSKI91 "Tomek Strzalkowski"))(POS (PAPER.TITLE STRZALKOWSKI91 "A General Computational Method for Grammar Inversion"))(POS (PAPER.LINK STRZALKOWSKI91 "http://acl.ldc.upenn.edu/W/W91/W91-0112.pdf"))(POS (PAPER.YEAR STRZALKOWSKI91 1991))(POS (PAPER.RANK STRZALKOWSKI91 "[***]"))(POS (PAPER.DESCRIPTION STRZALKOWSKI91 "
Strzalkowski describes a procedure for converting a unification grammar defined in Prolog, which was built for sentence parsing, into another set of Prolog rules for sentence generation.
"))(POS (PAPER.TOPIC STRZALKOWSKI91 "Natural Language Processing"))(POS (PAPER.INSTANCE SUCHENEK93))(POS (PAPER.BIBTEX SUCHENEK93 ARTICLE))(POS (PAPER.AUTHOR SUCHENEK93 "Marek Suchenek"))(POS (PAPER.TITLE SUCHENEK93 "First-Order Syntactic Characterizations of Minimal Entailment, Domain-Minimal Entailment, and Herbrand Entailment"))(POS (PAPER.LINK SUCHENEK93 "www.springerlink.com/index/L14483241892Q613.pdf"))(POS (PAPER.YEAR SUCHENEK93 1993))(POS (PAPER.RANK SUCHENEK93 "[***]"))(POS (PAPER.DESCRIPTION SUCHENEK93 "
Suchenek treats formally three types of minimal-model theory: minimal
entailment (cwa), Herbrand entailment (only the Herbrand models exist),
and domain-minimal entailment (only elements in the domain are those
that must be in the domain).  Touches on domain closure, unique-names,
deductive databases, closed world, non-mon.
"))(POS (PAPER.TOPIC SUCHENEK93 "Herbrand Logic"))(POS (PAPER.INSTANCE SUSSMAN74))(POS (PAPER.AUTHOR SUSSMAN74 "Gerald J. Sussman"))(POS (PAPER.TITLE SUSSMAN74 "The Virtuous Nature of Bugs"))(POS (PAPER.YEAR SUSSMAN74 1974))(POS (PAPER.DESCRIPTION SUSSMAN74 "
Sussman describes HACKER, a total-order planner that composes stored subroutines to achieve its goal.  If subgoals conflict, HACKER identifies a bug in the plan it has generated and debugs it.  To do so, it matches a model of the behavior of the misbehaving plan with prototypes of bugs.  Once a match is found, a 'critic' is compiled with what HACKER has learned from the debugging.  In future plans, critics are used to avoid pitfalls already seen.
"))(POS (PAPER.TOPIC SUSSMAN74 "Historical"))(POS (PAPER.INSTANCE SUTCLIFFE98))(POS (PAPER.BIBTEX SUTCLIFFE98 ARTICLE))(POS (PAPER.AUTHOR SUTCLIFFE98 "G. Sutcliffe and C.B. Suttner"))(POS (PAPER.TITLE SUTCLIFFE98 "The TPTP Problem Library: CNF Release v1.2.1"))(POS (PAPER.PUBLICATION SUTCLIFFE98 "Journal of Automated Reasoning"))(POS (PAPER.VOLUME SUTCLIFFE98 "21(2)"))(POS (PAPER.STARTPAGE SUTCLIFFE98 177))(POS (PAPER.ENDPAGE SUTCLIFFE98 203))(POS (PAPER.LINK SUTCLIFFE98 "http://citeseer.ist.psu.edu/30379.html"))(POS (PAPER.YEAR SUTCLIFFE98 1998))(POS (PAPER.RANK SUTCLIFFE98 ""))(POS (PAPER.DESCRIPTION SUTCLIFFE98 "
Paper on the TPTP library.
"))(POS (PAPER.TOPIC SUTCLIFFE98 "Theorem Proving"))(POS (PAPER.INSTANCE SUTCLIFFE98CADE))(POS (PAPER.BIBTEX SUTCLIFFE98CADE ARTICLE))(POS (PAPER.AUTHOR SUTCLIFFE98CADE "Christian Suttner and Geoff Sutcliffe"))(POS (PAPER.TITLE SUTCLIFFE98CADE "The CADE-14 ATP System Competition"))(POS (PAPER.PUBLICATION SUTCLIFFE98CADE "Journal of Automated Reasoning"))(POS (PAPER.VOLUME SUTCLIFFE98CADE "21(1)"))(POS (PAPER.STARTPAGE SUTCLIFFE98CADE 99))(POS (PAPER.ENDPAGE SUTCLIFFE98CADE 134))(POS (PAPER.LINK SUTCLIFFE98CADE "http://citeseer.ist.psu.edu/87162.html"))(POS (PAPER.YEAR SUTCLIFFE98CADE 1998))(POS (PAPER.RANK SUTCLIFFE98CADE ""))(POS (PAPER.DESCRIPTION SUTCLIFFE98CADE "
Paper on the results of one of the CASC competitions: the yearly first-order theorem proving competition held at CADE.
"))(POS (PAPER.TOPIC SUTCLIFFE98CADE "Theorem Proving"))(POS (PAPER.INSTANCE SWAMY2000))(POS (PAPER.BIBTEX SWAMY2000 PHDTHESIS))(POS (PAPER.AUTHOR SWAMY2000 "Nikhil Swamy"))(POS (PAPER.TITLE SWAMY2000 "A Study in Automated Reasoning about Abstract Algebra"))(POS (PAPER.LINK SWAMY2000 "http://www.cs.umd.edu/~nswamy/thesis/ch2-IntroToATP.ps"))(POS (PAPER.YEAR SWAMY2000 2000))(POS (PAPER.RANK SWAMY2000 ""))(POS (PAPER.DESCRIPTION SWAMY2000 "
Swamy's second chapter (Advanced theorem proving techniques) gives a good
overview of resolution-style theorem-proving and definitions/proofs
of UR-Resolution, Hyperresolution, factoring, paramodulation,
subsumption, demodulation, set of support, and Knuth-Bendix completion.
Link goes to said chapter.
"))(POS (PAPER.TOPIC SWAMY2000 "Theorem Proving"))(POS (PAPER.INSTANCE TAMMET2001))(POS (PAPER.BIBTEX TAMMET2001 MISC))(POS (PAPER.AUTHOR TAMMET2001 "Tanel Tammet"))(POS (PAPER.TITLE TAMMET2001 "Finite model building: improvements and comparisons"))(POS (PAPER.LINK TAMMET2001 "http://citeseer.ist.psu.edu/675660.html"))(POS (PAPER.YEAR TAMMET2001 2001))(POS (PAPER.DESCRIPTION TAMMET2001 "
Comparison of Mace 2.0 and Falcon-style finite model builders, along
with some enhancements to Falcon to produce Gandolf.  Mace 2.0 used flattening,
grounding, and boolean sat solvers.  Falcon used consequence finding during
incremental model generation, much like arc consistency in CSPs.
"))(POS (PAPER.TOPIC TAMMET2001 "Model Building"))(POS (PAPER.INSTANCE TAMMET2002))(POS (PAPER.BIBTEX TAMMET2002 ARTICLE))(POS (PAPER.AUTHOR TAMMET2002 "Tanel Tammete"))(POS (PAPER.TITLE TAMMET2002 "Finite model building: improvements and comparisons"))(POS (PAPER.LINK TAMMET2002 "http://citeseer.ist.psu.edu/675660.html"))(POS (PAPER.YEAR TAMMET2002 2002))(POS (PAPER.RANK TAMMET2002 ""))(POS (PAPER.DESCRIPTION TAMMET2002 "
Tammet gives an overview of two different styles of finite model builders
after situating the topic in the context of automated reasoning: Mace and
Falcon.  Mace operates by reducing the problem to one of propositional 
satisfiability and employing a SAT solver.  Tammet describes an augmentation
of Mace (nonground splitting) to reduce the number of distinct variables
in a clause (suboptimally).  Falcon works almost as a naive model builder
but makes certain inferences to prune the search.  Both the Mace-style
and Falcon-style builder were implemented  in Gandalf, a theorem-prover/
model checker written in Scheme and compiled into C.  Various versions
of the two builders were run over the 2002 satisfiable CASC problems,
and some conclusions were drawn.
"))(POS (PAPER.TOPIC TAMMET2002 "Model Building"))(POS (PAPER.INSTANCE THIFFAULT2004))(POS (PAPER.BIBTEX THIFFAULT2004 INPROCEEDINGS))(POS (PAPER.AUTHOR THIFFAULT2004 "Christian Thiffault and Fahiem Bacchus and Toby Walsh"))(POS (PAPER.TITLE THIFFAULT2004 "Solving Non-clausal Formulas with DPLL Search"))(POS (PAPER.PUBLICATION THIFFAULT2004 "Proceedings of the 10th International Conference on Principles and Practice of Constraint Programming"))(POS (PAPER.STARTPAGE THIFFAULT2004 663))(POS (PAPER.ENDPAGE THIFFAULT2004 678))(POS (PAPER.LINK THIFFAULT2004 "http://www.satisfiability.org/SAT04/accepted/71.html"))(POS (PAPER.YEAR THIFFAULT2004 2004))(POS (PAPER.DESCRIPTION THIFFAULT2004 "
A paper that adopts DPLL to handle Non-CNF directly.
"))(POS (PAPER.TOPIC THIFFAULT2004 "SAT Solving"))(POS (PAPER.INSTANCE TIN94))(POS (PAPER.BIBTEX TIN94 ARTICLE))(POS (PAPER.AUTHOR TIN94 "Erkan Tin and Varol Akman"))(POS (PAPER.TITLE TIN94 "Computatinal Situation Theory"))(POS (PAPER.PUBLICATION TIN94 "SIGART Bulletin"))(POS (PAPER.VOLUME TIN94 "5(4)"))(POS (PAPER.STARTPAGE TIN94 4))(POS (PAPER.ENDPAGE TIN94 17))(POS (PAPER.LINK TIN94 "http://portal.acm.org/citation.cfm?id=191604.191608"))(POS (PAPER.YEAR TIN94 1994))(POS (PAPER.RANK TIN94 "[*]"))(POS (PAPER.DESCRIPTION TIN94 "
Tin and Akman give an overview of Situation Theory, which allows
one to describe states of the world relative to spatio and temporal
positions.  This theory is used to give semantics to natural language
utterances.  The authors then overview several systems that deal
with situation theory.
"))(POS (PAPER.TOPIC TIN94 "Miscellaneous"))(POS (PAPER.INSTANCE TINELLI2000))(POS (PAPER.BIBTEX TINELLI2000 INPROCEEDINGS))(POS (PAPER.AUTHOR TINELLI2000 "Cesare Tinelli"))(POS (PAPER.TITLE TINELLI2000 "Cooperation of Background Reasoners in Theory Reasoning by
Residue Sharing"))(POS (PAPER.PUBLICATION TINELLI2000 "International Workshop on First Order Theorem Proving (FTP)
           "))(POS (PAPER.LINK TINELLI2000 "http://citeseer.ist.psu.edu/572497.html"))(POS (PAPER.YEAR TINELLI2000 2000))(POS (PAPER.RANK TINELLI2000 "[****]"))(POS (PAPER.DESCRIPTION TINELLI2000 "
Tinelli shows how to use theory reasoning to combine specialized reasoners in
a sound and complete way in the context of semantic tableaus.  The theories
those reasoners embody must be universal, a requirement for theory reasoning.
Tinelli's results hinge on an interpolation lemma that
requires all the background theory signatures to include all the
same functions.   This lemma shows that determining unsatisfiability of
wrt a set of theories requires only passing disjunctions of literals in
the common signature among the theories.  One can thus alter the tableau
procedure by allowing a new type of derivation: hand off a subset of the
literals on a particular branch which are of the appropriate signature
to the corresponding background reasoner.  If the reasoner returns
'unsatisfiable', close the branch; otherwise, add the residue to the
end of the branch.
"))(POS (PAPER.TOPIC TINELLI2000 "Theorem Proving with Attachments"))(POS (PAPER.INSTANCE TORLAK2006))(POS (PAPER.BIBTEX TORLAK2006 TECHREPORT))(POS (PAPER.AUTHOR TORLAK2006 "Emina Torlak and Daniel Jackson"))(POS (PAPER.TITLE TORLAK2006 "The Design of a Relational Engine"))(POS (PAPER.PUBLISHER TORLAK2006 "MIT-CSAIL"))(POS (PAPER.LINK TORLAK2006 "http://web.mit.edu/emina/www/kodkod.html"))(POS (PAPER.YEAR TORLAK2006 2006))(POS (PAPER.DESCRIPTION TORLAK2006 "
The authors describe a model-builder for a relational logic with transitive
closure and a finite domain.  The system does symmetry detection, compresses
expressions using compact boolean circuits, and
translates to propositional logic to answer queries using a SAT solver.
"))(POS (PAPER.TOPIC TORLAK2006 "Model Building"))(POS (PAPER.INSTANCE ULLMAN))(POS (PAPER.BIBTEX ULLMAN BOOK))(POS (PAPER.AUTHOR ULLMAN "J. Hopcroft and J. Ullman"))(POS (PAPER.TITLE ULLMAN "Introduction to Automata Theory, Languages, and Computation"))(POS (PAPER.PUBLISHER ULLMAN "Addison Wesley"))(POS (PAPER.LINK ULLMAN "http://www-db.stanford.edu/~ullman/ialc.html"))(POS (PAPER.YEAR ULLMAN 1979))(POS (PAPER.RANK ULLMAN "[*****]"))(POS (PAPER.DESCRIPTION ULLMAN "
One of the two definitive introductions to the theory of computation. Hopcroft
and Ullman--the classic.
"))(POS (PAPER.TOPIC ULLMAN ""))(POS (PAPER.INSTANCE ULLMAN96))(POS (PAPER.BIBTEX ULLMAN96 ARTICLE))(POS (PAPER.AUTHOR ULLMAN96 "Jeffrey Ullman"))(POS (PAPER.TITLE ULLMAN96 "The Database Approach to Knowledge Representation"))(POS (PAPER.PUBLICATION ULLMAN96 "AAAI"))(POS (PAPER.LINK ULLMAN96 "http://citeseer.ist.psu.edu/ullman96database.html"))(POS (PAPER.YEAR ULLMAN96 1996))(POS (PAPER.RANK ULLMAN96 "[****]"))(POS (PAPER.DESCRIPTION ULLMAN96 "
Ullman explains to the AI community the database perspective on
knowledge representation: start at low expressiveness and efficient computation
and work your way up.  Datalog (prolog w/o negation or functions)
is given the fixed-point semantics.  When extended with negation,
the least-fixed-point semantics are troublesome; stratified negation
and well-founded semantics have been developed to handle this.
Query containment of conjunctive queries is NP complete in general,
but is linear if no predicate appears more than twice in any
query.  Whether a conjunctive query is contained in a Datalog
program is exponential, and the reverse is decidable.  Rewriting
a query in terms of views has been done when the views are 
conjunctive queries as well as when the views are described
by Datalog programs.  
"))(POS (PAPER.TOPIC ULLMAN96 "Logical Knowledge Representation"))(POS (PAPER.INSTANCE ULLMANDB))(POS (PAPER.BIBTEX ULLMANDB BOOK))(POS (PAPER.AUTHOR ULLMANDB "Jeffrey Ullman"))(POS (PAPER.TITLE ULLMANDB "Principles of Database and Knowledge-Base Systems"))(POS (PAPER.PUBLISHER ULLMANDB "Computer Science Press"))(POS (PAPER.LINK ULLMANDB "http://www.amazon.com/exec/obidos/tg/detail/-/0716781581/qid=1110684085/sr=8-3/ref=sr_8_xs_ap_i3_xgl14/104-0791189-4759116?v=glance&s=books&n=507846"))(POS (PAPER.YEAR ULLMANDB 1989))(POS (PAPER.RANK ULLMANDB "[*****]"))(POS (PAPER.DESCRIPTION ULLMANDB "
This two-volume set describes how database principles can be applied to 
produce knowledge-based systems.
"))(POS (PAPER.TOPIC ULLMANDB ""))(POS (PAPER.INSTANCE URIBE2000))(POS (PAPER.BIBTEX URIBE2000 INPROCEEDINGS))(POS (PAPER.AUTHOR URIBE2000 "Tomas Uribe"))(POS (PAPER.TITLE URIBE2000 "Combinations of Model Checking and Theorem Proving"))(POS (PAPER.PUBLICATION URIBE2000 "Frontiers of Combining Systems (FroCoS)"))(POS (PAPER.STARTPAGE URIBE2000 151))(POS (PAPER.ENDPAGE URIBE2000 170))(POS (PAPER.LINK URIBE2000 "http://citeseer.ist.psu.edu/uribe00combinations.html"))(POS (PAPER.YEAR URIBE2000 2000))(POS (PAPER.RANK URIBE2000 "[****]"))(POS (PAPER.DESCRIPTION URIBE2000 "
Uribe surveys combinations of model checkers and theorem provers in the
context of formal verification.  The paper is pretty much self-contained,
explaining transition systems, fair transition systems,
finite-state model checking, deductive verification, abstraction, and
invariant generation.   Then Uribe discusses loosely coupled systems,
which treat the model checker/theorem prover as a black box. Modularity
and abstraction, general deductive environments (debugging, incremental
verification, and formal decomposition), and abstraction generation using
theorem proving have all been investigated in this loosely-coupled way.  
Lastly he considers tightly coupled systems.  Diagram-based
formalisms provide abstractions.  Model checking infinite-state systems
can also be attacked with abstraction.  A handful of tightly integrated
systems are also mentioned.  This survey feels like it is made up of a
hodge-podge of attempts--whether that is characteristic of the field
or the paper is unclear.
"))(POS (PAPER.TOPIC URIBE2000 "Model Checking"))(POS (PAPER.INSTANCE VANGELDER91))(POS (PAPER.BIBTEX VANGELDER91 ARTICLE))(POS (PAPER.AUTHOR VANGELDER91 "Allen van Gelder and Kenneth Ross and John Schlipf"))(POS (PAPER.TITLE VANGELDER91 "The Well-Founded Semantics for General Logic Programs"))(POS (PAPER.PUBLICATION VANGELDER91 "Journal of the ACM"))(POS (PAPER.VOLUME VANGELDER91 "38(3)"))(POS (PAPER.STARTPAGE VANGELDER91 620))(POS (PAPER.ENDPAGE VANGELDER91 650))(POS (PAPER.LINK VANGELDER91 "http://citeseer.ist.psu.edu/gelder91wellfounded.html"))(POS (PAPER.YEAR VANGELDER91 1991))(POS (PAPER.DESCRIPTION VANGELDER91 "
Well-founded semantics for logic programming.
"))(POS (PAPER.TOPIC VANGELDER91 "Logic Programming"))(POS (PAPER.INSTANCE VANHOOF2004))(POS (PAPER.BIBTEX VANHOOF2004 ARTICLE))(POS (PAPER.AUTHOR VANHOOF2004 "Wim Vanhoof"))(POS (PAPER.TITLE VANHOOF2004 "Searching Semantically Equivalent Code Fragments in Logic Programs"))(POS (PAPER.PUBLICATION VANHOOF2004 "14th International Symposium, Logic Based Program Synthesis and Trnasformation (LOPSTR)"))(POS (PAPER.STARTPAGE VANHOOF2004 1))(POS (PAPER.ENDPAGE VANHOOF2004 18))(POS (PAPER.LINK VANHOOF2004 "http://wotan.liu.edu/docis/dbl/lopstr/index.html"))(POS (PAPER.YEAR VANHOOF2004 2004))(POS (PAPER.DESCRIPTION VANHOOF2004 "
In the context of logic programming over Horn rules, 
Vanhoof considers three problems: (1) determining when some portion
of a rule body is equivalent to a portion of another rule body, (2) 
determining when two relations are identical up to argument permutation,
and (3) whether two portions of rule bodies share enough functionality
to be generalized as a higher-order rule, e.g. mapcar.  The nice
part about this topic of semantic equivalence in LP is that two
relations/conjunctions are equivalent iff they have the same extensions.
Vanhoof gives approximation algorithms, i.e. algorithms that are 
sufficient, for determining various kinds of semantic equivalences.
"))(POS (PAPER.TOPIC VANHOOF2004 "Reformulation"))(POS (PAPER.INSTANCE VARDI82))(POS (PAPER.BIBTEX VARDI82 INPROCEEDINGS))(POS (PAPER.AUTHOR VARDI82 "Moshe Vardi"))(POS (PAPER.TITLE VARDI82 "The complexity of relational query languages"))(POS (PAPER.PUBLICATION VARDI82 "Proceedings of the fourteenth annual ACM symposium on Theory of computing"))(POS (PAPER.STARTPAGE VARDI82 137))(POS (PAPER.ENDPAGE VARDI82 146))(POS (PAPER.LINK VARDI82 "http://portal.acm.org/citation.cfm?id=802186&dl=ACM&coll=GUIDE"))(POS (PAPER.YEAR VARDI82 1982))(POS (PAPER.DESCRIPTION VARDI82 "
Data and expression complexity results for various database query languages.
"))(POS (PAPER.TOPIC VARDI82 "Databases"))(POS (PAPER.INSTANCE VOROBYOV98))(POS (PAPER.BIBTEX VOROBYOV98 INPROCEEDINGS))(POS (PAPER.AUTHOR VOROBYOV98 "Sergei Vorobyov and Andrei Voronkov"))(POS (PAPER.TITLE VOROBYOV98 "Complexity of Nonrecursive Logic Programs with Complex Values"))(POS (PAPER.PUBLICATION VOROBYOV98 "Proceedings of the Seventeenth ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems"))(POS (PAPER.STARTPAGE VOROBYOV98 244))(POS (PAPER.ENDPAGE VOROBYOV98 253))(POS (PAPER.LINK VOROBYOV98 "http://citeseer.ist.psu.edu/258671.html"))(POS (PAPER.YEAR VOROBYOV98 1998))(POS (PAPER.DESCRIPTION VOROBYOV98 "
Breaks down the complexity of nonrecursive logic programs based on the 
signature/vocabulary of the program.
"))(POS (PAPER.TOPIC VOROBYOV98 "Logic Programming"))(POS (PAPER.INSTANCE WAAL93))(POS (PAPER.BIBTEX WAAL93 ARTICLE))(POS (PAPER.AUTHOR WAAL93 "D.A. de Waal and J. Gallagher"))(POS (PAPER.TITLE WAAL93 "The Applicability of Logic Program Analysis and Transformation to Theorem Proving"))(POS (PAPER.PUBLICATION WAAL93 "CADE"))(POS (PAPER.LINK WAAL93 "http://citeseer.ist.psu.edu/dewaal93applicability.html"))(POS (PAPER.YEAR WAAL93 1993))(POS (PAPER.RANK WAAL93 "[****]"))(POS (PAPER.DESCRIPTION WAAL93 "
de Waal and Gallagher show how to employ the results of (1) approximation
of logic programs and (2) partial evaluation to produce strategies
for pruning the search space of theorem proving procedures.  They model
a theorem proving algorithm as a logic program, add in the theory and query
in question, and run approximation techniques after partially evaluating
the constructed logic program.  Regular unary clauses (r(f(x1,...,xn) <= 
t1(x1) ^ ... ^ tn(xn))are used to
do the approximations, but the technique can be applied to different
approximations as well.  The authors demonstrate this technique on
a model-elimination procedure and a Naive nH-Prolog proof system.
"))(POS (PAPER.TOPIC WAAL93 "Metalevel Reasoning"))(POS (PAPER.INSTANCE WALDINGER75))(POS (PAPER.AUTHOR WALDINGER75 "R. Waldinger"))(POS (PAPER.TITLE WALDINGER75 "Achieving several goals simultaneously"))(POS (PAPER.PUBLICATION WALDINGER75 "Machine Intelligence 8"))(POS (PAPER.STARTPAGE WALDINGER75 94))(POS (PAPER.ENDPAGE WALDINGER75 138))(POS (PAPER.YEAR WALDINGER75 1975))(POS (PAPER.DESCRIPTION WALDINGER75 "
Waldinger examines planning where sugoals interfere with one another.  He introduces regression  planning, where totally ordered plan steps are reordered.  A solution is constructed incrementally for each subgoal, but when a later subgoal interferes, the position of that subgoal is moved earlier in the plan.  He also touches on the ramification problem (but doesn't call it that) in an effort to show the STRIPS assumption as an unsatisfactory solution to the frame problem.
"))(POS (PAPER.TOPIC WALDINGER75 "Historical"))(POS (PAPER.INSTANCE WALSH2000))(POS (PAPER.BIBTEX WALSH2000 ARTICLE))(POS (PAPER.AUTHOR WALSH2000 "Toby Walsh"))(POS (PAPER.TITLE WALSH2000 "Reformulating Propositional Satisfiability as Constraint Satisfaction"))(POS (PAPER.PUBLICATION WALSH2000 "Symposium on Abstraction, Reformulation, and Approximation (SARA)"))(POS (PAPER.STARTPAGE WALSH2000 233))(POS (PAPER.ENDPAGE WALSH2000 246))(POS (PAPER.LINK WALSH2000 "http://citeseer.ifi.unizh.ch/walsh00reformulating.html"))(POS (PAPER.YEAR WALSH2000 2000))(POS (PAPER.DESCRIPTION WALSH2000 "
Walsh gives an overview of various approaches to encoding propositional
satisfiability as CSPs.  Then he goes on to discuss how various
algorithms operate on those CSPs.
"))(POS (PAPER.TOPIC WALSH2000 "Reformulation"))(POS (PAPER.INSTANCE WAM))(POS (PAPER.BIBTEX WAM BOOK))(POS (PAPER.AUTHOR WAM "Hassan Ait-Kaci"))(POS (PAPER.TITLE WAM "Warren's Abstract Machine: A Tutorial Reconstruction"))(POS (PAPER.PUBLISHER WAM "MIT Press"))(POS (PAPER.LINK WAM "http://mitpress.mit.edu/catalog/item/default.asp?ttype=2&tid=7292"))(POS (PAPER.YEAR WAM 1991))(POS (PAPER.RANK WAM "[*****]"))(POS (PAPER.DESCRIPTION WAM "
Description of the original Prolog compiler.
"))(POS (PAPER.TOPIC WAM ""))(POS (PAPER.INSTANCE WANG85))(POS (PAPER.BIBTEX WANG85 INPROCEEDINGS))(POS (PAPER.AUTHOR WANG85 "Tie Cheng Wang"))(POS (PAPER.TITLE WANG85 "Designing Examples for Semantically Guided Hierarchical Deduction"))(POS (PAPER.PUBLICATION WANG85 "IJCAI"))(POS (PAPER.YEAR WANG85 1985))(POS (PAPER.RANK WANG85 "[*]"))(POS (PAPER.DESCRIPTION WANG85 "
This paper describes a hierarchical theorem prover guided by a model
and gives guidelines for humans to pick a good model.
"))(POS (PAPER.TOPIC WANG85 "Model-Guided Proof Techniques"))(POS (PAPER.INSTANCE WARREN74))(POS (PAPER.AUTHOR WARREN74 "D.H.D. Warren"))(POS (PAPER.TITLE WARREN74 "Extract from APIC Studies in Data Processing"))(POS (PAPER.YEAR WARREN74 1974))(POS (PAPER.DESCRIPTION WARREN74 "
Quick synopsis of the Prolog implementation of Warren's WARPLAN.  WARPLAN was the first planner implemented in Prolog.  It was not optimal, sometimes finding longer plans than needed.
"))(POS (PAPER.TOPIC WARREN74 "Historical"))(POS (PAPER.INSTANCE WEYHRAUCH80))(POS (PAPER.BIBTEX WEYHRAUCH80 ARTICLE))(POS (PAPER.AUTHOR WEYHRAUCH80 "Richard Weyhrauch"))(POS (PAPER.TITLE WEYHRAUCH80 "Prolegomena to a theory of mechanized formal reasoning"))(POS (PAPER.PUBLICATION WEYHRAUCH80 "Artificial Intelligence"))(POS (PAPER.VOLUME WEYHRAUCH80 "13"))(POS (PAPER.STARTPAGE WEYHRAUCH80 133))(POS (PAPER.ENDPAGE WEYHRAUCH80 170))(POS (PAPER.YEAR WEYHRAUCH80 1980))(POS (PAPER.RANK WEYHRAUCH80 "[***]"))(POS (PAPER.DESCRIPTION WEYHRAUCH80 "
Weyhrauch describes the FOL system.  FOL allows rules to be written that
produce semantic attachments, i.e. attaching Lisp addition to the function
symbol '+'.  It also allows rules that rewrite expressions.  FOL includes
an evaluator for first order logic that combines the rewrite rules with
the semantic attachments to do proofs.  FOL is a system that operates on
'LS pairs': a set of logical sentences, a set of attachments, and a set
of facts.  Because this is done uniformly, FOL allows multiple LS pairs
to be defined at the same time.  A special LS pair, Meta, is a theory
of LS pairs; reflection is achieved in FOL by allowing Meta to
operate on another LS pair.   Metametalevel reasoning
can be accomplished in the same way.  Self-reflection is another special
case of this mechanism--give Meta the LS pair Meta to operate on.
"))(POS (PAPER.TOPIC WEYHRAUCH80 "Theorem Proving with Attachments"))(POS (PAPER.INSTANCE YAMATOMOTO2000))(POS (PAPER.AUTHOR YAMATOMOTO2000 "Akihiro Yamatomoto, Bertram Fronhofer"))(POS (PAPER.TITLE YAMATOMOTO2000 "Hypothesis Finding via Residue Hypotheses with the Resolution Principle"))(POS (PAPER.LINK YAMATOMOTO2000 "http://link.springer.de/link/service/series/0558/bibs/1968/19680156.htm"))(POS (PAPER.YEAR YAMATOMOTO2000 2000))(POS (PAPER.DESCRIPTION YAMATOMOTO2000 "
Given a set of background sentences B that do not entail a positive example E, we want to find a hypothesis H such that
B and H entail E.  The authors argue for the use of anti-subsumption over anti-instantiation as a method for
finding residue hypotheses.
"))(POS (PAPER.TOPIC YAMATOMOTO2000 "Theorem Proving Applications"))(POS (PAPER.INSTANCE ZHANG90))(POS (PAPER.BIBTEX ZHANG90 ARTICLE))(POS (PAPER.AUTHOR ZHANG90 "Weining Zhang and Clement Yu and Daniel Troy"))(POS (PAPER.TITLE ZHANG90 "Necessary and Sufficient Conditions to Linearize Doubly Recursive Programs in Logic Databases"))(POS (PAPER.PUBLICATION ZHANG90 "ACM Transactions on Database Systems"))(POS (PAPER.VOLUME ZHANG90 "15(3)"))(POS (PAPER.STARTPAGE ZHANG90 459))(POS (PAPER.ENDPAGE ZHANG90 482))(POS (PAPER.LINK ZHANG90 "http://portal.acm.org/citation.cfm?coll=GUIDE&dl=GUIDE&id=89237"))(POS (PAPER.YEAR ZHANG90 1990))(POS (PAPER.DESCRIPTION ZHANG90 "
The authors examine conditions under which a doubly recursive program, i.e. a program of the form r(xbar) if s(xbar) and r(xbar) if r(ybar) ^ q(ybar') ^ r(ybar''), can be expressed as a linear recursive program, i.e. where the first recursive r definition is resolved with s(xbar).  The only assumption is that 
all the variables in the head appear somewhere in the body.  This result
strengthens previous results.  All rules are horn, and the semantics are LP. 
The necessary and sufficient conditions are nasty, as you might expect.
"))(POS (PAPER.TOPIC ZHANG90 "Reformulation"))(POS (PAPER.INSTANCE ZHANG95))(POS (PAPER.BIBTEX ZHANG95 INPROCEEDINGS))(POS (PAPER.AUTHOR ZHANG95 "J. Zhang and H. Zhang"))(POS (PAPER.TITLE ZHANG95 "SEM: A System for Enumerating Models"))(POS (PAPER.PUBLICATION ZHANG95 "In proceedings, IJCAI-95, Morgan Kaufmann"))(POS (PAPER.LINK ZHANG95 "http://citeseer.ist.psu.edu/context/34167/0"))(POS (PAPER.YEAR ZHANG95 1995))(POS (PAPER.DESCRIPTION ZHANG95 "
Model builder based on searching for a model directly and using the Least Number Heuristic, a method for reducing symmetry in the search space.
"))(POS (PAPER.TOPIC ZHANG95 "Model Building"))(POS (PAPER.INSTANCE ZHANG96))(POS (PAPER.BIBTEX ZHANG96 ARTICLE))(POS (PAPER.AUTHOR ZHANG96 "J. Zhang"))(POS (PAPER.TITLE ZHANG96 "Constructing Finite Algebras with FALCON"))(POS (PAPER.PUBLICATION ZHANG96 "Journal of Automated Reasoning"))(POS (PAPER.VOLUME ZHANG96 "17(1)"))(POS (PAPER.STARTPAGE ZHANG96 1))(POS (PAPER.ENDPAGE ZHANG96 22))(POS (PAPER.LINK ZHANG96 "http://citeseer.ist.psu.edu/context/254103/0"))(POS (PAPER.YEAR ZHANG96 1996))(POS (PAPER.DESCRIPTION ZHANG96 "
Model builder based on searching for a model directly, the so-called
Falcon-style approach.
"))(POS (PAPER.TOPIC ZHANG96 "Model Building"))(POS (PAPER.INSTANCE ZHANG97))(POS (PAPER.BIBTEX ZHANG97 ARTICLE))(POS (PAPER.AUTHOR ZHANG97 "Yan Zhang and Norman Foo"))(POS (PAPER.TITLE ZHANG97 "Deriving Invariants and Constraints from Action Theories"))(POS (PAPER.PUBLICATION ZHANG97 "Fundamenta Informaticae"))(POS (PAPER.VOLUME ZHANG97 "30(1)"))(POS (PAPER.STARTPAGE ZHANG97 109))(POS (PAPER.ENDPAGE ZHANG97 123))(POS (PAPER.LINK ZHANG97 "http://citeseer.ist.psu.edu/zhang96deriving.html"))(POS (PAPER.YEAR ZHANG97 1997))(POS (PAPER.RANK ZHANG97 "[*****]"))(POS (PAPER.DESCRIPTION ZHANG97 "
Zhang and Foo describe an approach to the construction of action invariants
(statements that hold in the predecessor and successor states when
executing a particular action) and state constraints (statements
true in all states reachable from an initial state).   It is based
on a state-based persistence formalism (Zhang's work), and assumes
a domain-closure axiom.  It considers actions with disjunctive effects
and preconditions, but does not provide complete results for those
cases.  It relies on the use of induction to prove a candidate
state constraint is actually a state constraint, but the generation
of these candidates is done algorithmically.
"))(POS (PAPER.TOPIC ZHANG97 "Theories of Action"))(POS (PAPER.INSTANCE ZHU98))(POS (PAPER.BIBTEX ZHU98 PHDTHESIS))(POS (PAPER.AUTHOR ZHU98 "Yunshan Zhu"))(POS (PAPER.TITLE ZHU98 "Efficient First-Order Semantic Deduction Techniques"))(POS (PAPER.LINK ZHU98 "http://citeseer.ist.psu.edu/zhu98efficient.html"))(POS (PAPER.YEAR ZHU98 1998))(POS (PAPER.RANK ZHU98 "[*]"))(POS (PAPER.DESCRIPTION ZHU98 "
This is Zhu's thesis on Ordered Semantic Hyperlinking, complexity
measures of theorem proving, and OSHL applied to planning.
Contains some good citations to semantically driven proof techniques
in section 2.1.
"))(POS (PAPER.TOPIC ZHU98 "Resolution Variants"))(POS (PAPER.RELATED ZHU98 PLAISTED97))(POS (EXAMPLE.INSTANCE DRESDENQUEENS))(POS (EXAMPLE.DATEENTERED DRESDENQUEENS 3355255579))(POS (EXAMPLE.DATEMODIFIED DRESDENQUEENS 3355255579))(POS (EXAMPLE.TECHNIQUE DRESDENQUEENS DATAEXTRACTION))(POS (EXAMPLE.TECHNIQUE DRESDENQUEENS GENERATEOVERGUESS))(POS (EXAMPLE.DESCRIPTION DRESDENQUEENS "We extracted the data out of the rules and relied on generation instead of guess and check."))(POS (EXAMPLE.SOURCE DRESDENQUEENS "  (<= (goal player ?s)
      (attacks ?n)
      (mapnum2val ?n ?s))
  (mapnum2val s0 100)
  (mapnum2val s2 90)
  (mapnum2val s3 80)
  (mapnum2val s4 70)
  (mapnum2val s5 60)
  (mapnum2val s6 50)
  (mapnum2val s7 40)
  (mapnum2val s8 0)
  (mapnum2val s9 0)
  (mapnum2val s10 0)
"))(POS (EXAMPLE.TARGET DRESDENQUEENS "  (<= (goal player 100)
      (attacks s0))
  (<= (goal player 90)
      (attacks s2))
  (<= (goal player 80)
      (attacks s3))
  (<= (goal player 70)
      (attacks s4))
  (<= (goal player 60)
      (attacks s5))
  (<= (goal player 50)
      (attacks s6))
  (<= (goal player 40)
      (attacks s7))
  (<= (goal player 0)
      (attacks s8))
  (<= (goal player 0)
      (attacks s9))
  (<= (goal player 0)
      (attacks s10))
"))(POS (EXAMPLE.INSTANCE TOETICTAC))(POS (EXAMPLE.DATEENTERED TOETICTAC 3355255669))(POS (EXAMPLE.DATEMODIFIED TOETICTAC 3355255669))(POS (EXAMPLE.TECHNIQUE TOETICTAC RELATIONALIZING))(POS (EXAMPLE.DESCRIPTION TOETICTAC "The old: each of the 9 cells is labelled with an x, an o, or a b: cell(x,y,label).  The new: each of the 9 cells (a,b,c,d,e,f,g,h,i) is either true of ecks or ohs or blank, each of which is a unary relation. "))(POS (LANGUAGE.INSTANCE IKIF))(POS (LANGUAGE.INSTANCE KIF))(POS (LANGUAGE.INSTANCE XML))(POS (TECHNIQUE.INSTANCE CONSISTENCY2DEDUCTION))(POS (TECHNIQUE.DESCRIPTION CONSISTENCY2DEDUCTION "Consistency2Deduction[Delta,phi(xbar)] computes an expression that represents for all the query instances tbar such that Delta U {phi(tbar)} is consistent."))(POS (TECHNIQUE.INSTANCE REIFICATION))(POS (TECHNIQUE.DESCRIPTION REIFICATION "Reification is an umbrella technique that encompasses all kinds of vocabulary and conceptualization shifts."))(POS (TECHNIQUE.INSTANCE UNNAMED))(POS (TECHNIQUE.DESCRIPTION UNNAMED "Encompasses all unnamed techniques."))(POS (TECHNIQUE.INSTANCE RELATIONALIZING))(POS (TECHNIQUE.DESCRIPTION RELATIONALIZING "Form of reification where object/function constants are turned into relation constants."))(POS (TECHNIQUE.INSTANCE OBJECTIFYING))(POS (TECHNIQUE.DESCRIPTION OBJECTIFYING "Form of reification where relation constants become function or object constants."))(POS (TECHNIQUE.INSTANCE GENERATEOVERGUESS))(POS (TECHNIQUE.DESCRIPTION GENERATEOVERGUESS "Technique that changes a guess-and-check problem formulation reformulation into a formulation that generates the answer constructively."))(POS (TECHNIQUE.INSTANCE DATAEXTRACTION))(POS (TECHNIQUE.DESCRIPTION DATAEXTRACTION "Pulls data out of a rule or set of rules, places that data into tables, and appropriately adjusts the rule so that semantically the original and the new versions are identical.  Inverse of dataInfusion."))(POS (TECHNIQUE.INSTANCE DATAINFUSION))(POS (TECHNIQUE.DESCRIPTION DATAINFUSION "Pushes data from a table into rules, a special form of partial deduction from the logic programming literature.  Inverse of dataExtraction."))(POS (TECHNIQUE.INSTANCE CHIRKOVAREFORMULATION))(POS (TECHNIQUE.DESCRIPTION CHIRKOVAREFORMULATION "Computes the optimal viewset for transforming an unknown (but fixed-size) database into a new database that more efficiently answers a given query set."))(POS (PERSON.INSTANCE NATLOVE))(POS (PERSON.FIRSTNAME NATLOVE "Nat"))(POS (PERSON.LASTNAME NATLOVE "Love"))(POS (PERSON.TEAM NATLOVE NATLOVE))(POS (PERSON.EMAIL NATLOVE "natlove@stanford.edu"))(POS (PERSON.INSTANCE JDUCHI))(POS (PERSON.FIRSTNAME JDUCHI "John"))(POS (PERSON.LASTNAME JDUCHI "Duchi"))(POS (PERSON.TEAM JDUCHI JDUCHI))(POS (PERSON.EMAIL JDUCHI "jduchi@stanford.edu"))(POS (PERSON.INSTANCE DTARLOW))(POS (PERSON.FIRSTNAME DTARLOW "Danny"))(POS (PERSON.LASTNAME DTARLOW "Tarlow"))(POS (PERSON.TEAM DTARLOW DTARLOW))(POS (PERSON.EMAIL DTARLOW "dtarlow@stanford.edu"))(POS (PERSON.INSTANCE THINRICH))(POS (PERSON.FIRSTNAME THINRICH "Tim"))(POS (PERSON.LASTNAME THINRICH "Hinrichs"))(POS (PERSON.TEAM THINRICH THINRICH))(POS (PERSON.EMAIL THINRICH "thinrich@stanford.edu"))(POS (EXAMPLE.INSTANCE DRESDENQUEENS))(POS (EXAMPLE.DATEENTERED DRESDENQUEENS 3355255579))(POS (EXAMPLE.DATEMODIFIED DRESDENQUEENS 3355255579))(POS (EXAMPLE.TECHNIQUE DRESDENQUEENS DATAEXTRACTION))(POS (EXAMPLE.TECHNIQUE DRESDENQUEENS GENERATEOVERGUESS))(POS (EXAMPLE.DESCRIPTION DRESDENQUEENS "We extracted the data out of the rules and relied on generation instead of guess and check."))(POS (EXAMPLE.SOURCE DRESDENQUEENS "  (<= (goal player ?s)
      (attacks ?n)
      (mapnum2val ?n ?s))
  (mapnum2val s0 100)
  (mapnum2val s2 90)
  (mapnum2val s3 80)
  (mapnum2val s4 70)
  (mapnum2val s5 60)
  (mapnum2val s6 50)
  (mapnum2val s7 40)
  (mapnum2val s8 0)
  (mapnum2val s9 0)
  (mapnum2val s10 0)
"))(POS (EXAMPLE.TARGET DRESDENQUEENS "  (<= (goal player 100)
      (attacks s0))
  (<= (goal player 90)
      (attacks s2))
  (<= (goal player 80)
      (attacks s3))
  (<= (goal player 70)
      (attacks s4))
  (<= (goal player 60)
      (attacks s5))
  (<= (goal player 50)
      (attacks s6))
  (<= (goal player 40)
      (attacks s7))
  (<= (goal player 0)
      (attacks s8))
  (<= (goal player 0)
      (attacks s9))
  (<= (goal player 0)
      (attacks s10))
"))(POS (EXAMPLE.INSTANCE TOETICTAC))(POS (EXAMPLE.DATEENTERED TOETICTAC 3355255669))(POS (EXAMPLE.DATEMODIFIED TOETICTAC 3355255669))(POS (EXAMPLE.TECHNIQUE TOETICTAC RELATIONALIZING))(POS (EXAMPLE.DESCRIPTION TOETICTAC "The old: each of the 9 cells is labelled with an x, an o, or a b: cell(x,y,label).  The new: each of the 9 cells (a,b,c,d,e,f,g,h,i) is either true of ecks or ohs or blank, each of which is a unary relation. "))(POS (EXAMPLE.EFFICIENCYGAINS TOETICTAC "Notes: tictactoe is the original theory and toetictac is the new one.
? (time (brute-force-playable tictactoe))
(BRUTE-FORCE-PLAYABLE TICTACTOE) took 56,488 milliseconds (56.488 seconds) to run.
Of that, 2,602 milliseconds (2.602 seconds) were spent in The Cooperative Multitasking Experience.
 88,240,736 bytes of memory allocated.
T
? (time (brute-force-playable toetictac))
;Compiler warnings :
;   Undeclared free variable TOETICTAC, in an anonymous lambda form.
(BRUTE-FORCE-PLAYABLE TOETICTAC) took 38,920 milliseconds (38.920 seconds) to run.
Of that, 1,514 milliseconds (1.514 seconds) were spent in The Cooperative Multitasking Experience.
 48,237,344 bytes of memory allocated.
T
"))(POS (EXAMPLE.SOURCE TOETICTAC "    (role white)
    (role black)
    (init (cell 1 1 b))
    (init (cell 1 2 b))
    (init (cell 1 3 b))
    (init (cell 2 1 b))
    (init (cell 2 2 b))
    (init (cell 2 3 b))
    (init (cell 3 1 b))
    (init (cell 3 2 b))
    (init (cell 3 3 b))
    (init (control white))
    (<= (next (cell ?m ?n x))
        (does white (mark ?m ?n))
        (true (cell ?m ?n b)))
    (<= (next (cell ?m ?n o))
        (does black (mark ?m ?n))
        (true (cell ?m ?n b)))
    (<= (next (cell ?m ?n ?w))
        (true (cell ?m ?n ?w))
        (distinct ?w b))
    (<= (next (cell ?m ?n b))
        (does ?w (mark ?j ?k))
        (true (cell ?m ?n b))
        (or (distinct ?m ?j) (distinct ?n ?k)))
    (<= (next (control white))
        (true (control black)))
    (<= (next (control black))
        (true (control white)))
    (<= (row ?m ?x)
        (true (cell ?m 1 ?x))
        (true (cell ?m 2 ?x))
        (true (cell ?m 3 ?x)))
    (<= (column ?n ?x)
        (true (cell 1 ?n ?x))
        (true (cell 2 ?n ?x))
        (true (cell 3 ?n ?x)))
    (<= (diagonal ?x)
        (true (cell 1 1 ?x))
        (true (cell 2 2 ?x))
        (true (cell 3 3 ?x)))
    (<= (diagonal ?x)
        (true (cell 1 3 ?x))
        (true (cell 2 2 ?x))
        (true (cell 3 1 ?x)))
    (<= (line ?x)
        (row ?m ?x))
    (<= (line ?x)
        (column ?m ?x))
    (<= (line ?x)
        (diagonal ?x))
    (<= open
        (true (cell ?m ?n b)))
    (<= (legal ?w (mark ?x ?y))
        (true (cell ?x ?y b))
        (true (control ?w)))
    (<= (legal white noop)
        (true (cell ?x ?y b))
        (true (control black)))
    (<= (legal black noop)
        (true (cell ?x ?y b))
        (true (control white)))
    (<= (goal white 100)
        (line x))
    (<= (goal white 50)
        (not (line x))
        (not (line o))
        (not open))
    (<= (goal white 0)
        (line o))
    (<= (goal black 100)
        (line o))
    (<= (goal black 50)
        (not (line x))
        (not (line o))
        (not open))
    (<= (goal black 0)
        (line x))
    (<= terminal
        (line x))
    (<= terminal
        (line o))
    (<= terminal
        (not open))
"))(POS (EXAMPLE.TARGET TOETICTAC "    (role xplayer)
    (role oplayer)
    (init (blank a))
    (init (blank b))
    (init (blank c))
    (init (blank d))
    (init (blank e))
    (init (blank f))
    (init (blank g))
    (init (blank h))
    (init (blank i))
    (init (control xplayer))
    (<= (next (ecks ?m))
        (does xplayer (mark ?m))
        (true (blank ?m)))
    (<= (next (oh ?m))
        (does oplayer (mark ?m))
        (true (blank ?m)))
    (<= (next (ecks ?m))
        (true (ecks ?m)))
    (<= (next (oh ?m))
        (true (oh ?m)))
    (<= (next (blank ?m))
        (does ?w (mark ?n))
        (true (blank ?m))
        (distinct ?m ?n))
    (<= (next (control xplayer))
        (true (control oplayer)))
    (<= (next (control oplayer))
        (true (control xplayer)))
    (line a b c)
    (line a d g)
    (line d e f)
    (line b e h)
    (line g h i)
    (line c f i)
    (line a e i)
    (line c e g)
    (<= xline
        (line ?a ?b ?c)
        (true (ecks ?a))
        (true (ecks ?b))
        (true (ecks ?c)))
    (<= oline
        (line ?a ?b ?c)
        (true (oh ?a))
        (true (oh ?b))
        (true (oh ?c)))
    (<= open
        (true (blank ?m)))
    (<= (legal ?player (mark ?y))
        (true (blank ?y))
        (true (control ?player)))
    (<= (legal oplayer noop)
        (true (control xplayer)))
    (<= (legal xplayer noop)
        (true (control oplayer)))
    (<= (goal xplayer 100)
        xline)
    (<= (goal xplayer 50)
        (not xline)
        (not oline)
        (not open))
    (<= (goal xplayer 0)
        oline)
    (<= (goal oplayer 100)
        oline)
    (<= (goal oplayer 50)
        (not xline)
        (not oline)
        (not open))
    (<= (goal oplayer 0)
        xline)
    (<= terminal
        xline)
    (<= terminal
        oline)
    (<= terminal
        (not open))
"))(POS (EXAMPLE.INSTANCE MAZEWORLD))(POS (EXAMPLE.DATEENTERED MAZEWORLD 3355255765))(POS (EXAMPLE.DATEMODIFIED MAZEWORLD 3355255765))(POS (EXAMPLE.TECHNIQUE MAZEWORLD CONSISTENCY2DEDUCTION))(POS (EXAMPLE.TECHNIQUE MAZEWORLD UNNAMED))(POS (EXAMPLE.DESCRIPTION MAZEWORLD "Original maze world is an incomplete information game.  The new maze world is a complete information game, where all the uncertainty has been built into the role world.  When building the game tree for a 2-player incomplete game, the branching factor for your opponent is all possible moves since we don't necessarily know what moves that player can legally make.  Sometimes, some of those moves are inconsistent with the current state of the world.  By compiling the incompleteness into the world player, we can enumerate just the legal moves that are consistent with the state of the game."))(POS (EXAMPLE.SOURCE MAZEWORLD "  (role robot)

    (initial 1)
    (successor 1 2)
    (successor 2 3)
    (successor 3 4)
    (successor 4 5)
    (successor 5 6)
    (successor 6 7)
    (successor 7 8)
    (successor 8 9)
    (successor 9 10)

    (adjacent a b)
    (adjacent b c)
    (adjacent c d)
    (adjacent d a)

    (percept robot bright)

    ;;;;

    (<= (legal robot move ?n))
    (<= (legal robot noop ?n))

    (<= (goal robot 100 ?n)
        (true (cell ?x) ?n)
        (true (gold ?x) ?n))
    
    (<= (goal robot 0 ?n)
        (true (cell ?x) ?n)
	(true (gold ?y) ?n)
        (distinct ?x ?y))
        
    (terminal 7)

    ;;;;
    
    ; state
    (true (cell a) 1)
    (not (true (gold a) 1))

    ; effector
    (<= (true (cell ?y) ?n)
        (successor ?m ?n)
        (does robot move ?m)
        (true (cell ?x) ?m)
        (adjacent ?x ?y))

    (<= (true (cell ?y) ?n)
        (successor ?m ?n)
        (does robot noop ?m)
        (true (cell ?y) ?n))
		
    
    ; state
    (<= (true (gold d) ?n)
        (not (true (gold a) ?n))
        (not (true (gold b) ?n))
        (not (true (gold c) ?n))
        (not (true (gold i) ?n)))

    
    ; gold sensor
    (<= (true (gold ?x) ?n)
        (sees robot bright ?n)
        (true (cell ?x) ?n))

    (<= (not (true (gold ?x) ?n))
        (not (sees robot bright ?n)) 
        (true (cell ?x) ?n))
    

    ; frame: monotonicity of gold
    (<= (true (gold ?x) ?n)
        (successor ?m ?n)
        (true (gold ?x) ?m))

    (<= (not (true (gold ?x) ?n))
        (successor ?m ?n)
        (not (true (gold ?x) ?m)))
"))(POS (EXAMPLE.TARGET MAZEWORLD "  (role robot)
  (role world)
  
  (successor 1 2)
  (successor 2 3)
  (successor 3 4)
  (successor 4 5)
  (successor 5 6)
  (successor 6 7)
  (successor 7 8)
  (successor 8 9)
  (successor 9 10)
  
  (adjacent a b)
  (adjacent b c)
  (adjacent c d)
  (adjacent d a)
  
  (percept robot bright)

  ;;;;

  (init (step 1))
  (init (listof * * *))
  (init (cell a))
  
  ;;;;
  
  (<= (legal robot move))
  (<= (legal robot noop))
  
  (<= (legal world (listof ?x ?u ?v))
      (true (listof * ?u ?v))
      (bit3 ?x ?u ?v))
  (<= (legal world (listof ?x ?u ?v))
      (true (listof ?x * ?v))
      (bit3 ?x ?u ?v))
  (<= (legal world (listof ?x ?u ?v))
      (true (listof ?x ?u *))
      (bit3 ?x ?u ?v))
  (<= (legal world (listof ?x ?u ?v))
      (true (listof * * ?v))
      (bit3 ?x ?u ?v))
  (<= (legal world (listof ?x ?u ?v))
      (true (listof * ?u *))
      (bit3 ?x ?u ?v))
  (<= (legal world (listof ?x ?u ?v))
      (true (listof ?x * *))
      (bit3 ?x ?u ?v))
  (<= (legal world (listof ?x ?u ?v))
      (true (listof * * *))
      (bit3 ?x ?u ?v))
  
  
  (<= (bit3 ?x ?y ?z) (bit ?x) (bit ?y) (bit ?z))
  (bit 1) 
  (bit 0)
  
  (<= (goal robot 100)
      (true (cell ?x))
      (true (real (gold ?x))))
  
  (<= (goal robot 0)
      (true (cell ?x))
      (true (real ?y))
      (distinct ?x ?y))
  
  ;;;;
  
  ; counter
  (<= (next (step ?x))
      (true (step ?y))
      (successor ?y ?x))
  
  ; effector: world
  (<= (next (real ?x))
      (does world ?y)
      (item-true ?x ?y))
  
  (<= (item-true (gold b) (listof 1 ?y ?z)))
  (<= (item-true (gold c) (listof ?x 1 ?z)))
  (<= (item-true (gold d) (listof ?x ?y 1)))
  (<= (item-false (gold b) (listof 0 ?y ?z)))
  (<= (item-false (gold c) (listof ?x 0 ?z)))
  (<= (item-false (gold d) (listof ?x ?y 0)))
  
  ; effector: robot
  (<= (next (cell ?y))
      (does robot move)
      (true (cell ?x))
      (adjacent ?x ?y))
  
  (<= (next (cell ?y))
      (does robot noop)
      (true (cell ?y)))
  
  
  ; frame and sensor: skolem
  (<= (next (listof ?x ?y ?z))
      (val (gold b) ?x)
      (val (gold c) ?y)
      (val (gold d) ?z))
  
  (<= (val ?x 1)
      (tru ?x))
  (<= (val ?x 1)
      (true (listof @y))
      (item-true ?x (listof @y)))

  (<= (val ?x 0)
      (nottru ?x))
  (<= (val ?x 0)
      (true (listof @y))
      (item-false ?x (listof @y)))

  (<= (val ?x *)
      (true (listof @y))
      (not (item-true ?x (listof @y)))
      (not (item-false ?x (listof @y)))
      (not  (tru ?x))
      (not (nottru ?x)))

  
  (<= (nottru (gold ?y))
      (does robot move)
      (true (cell ?x))
      (adjacent ?x ?y)
      (does world ?wm)
      (item-false (gold ?y) ?wm)) 
  
  (<= (tru (gold ?y))
      (does robot move)
      (true (cell ?x))
      (adjacent ?x ?y)
      (does world ?wm)
      (item-true (gold ?y) ?wm)) 
"))(POS (EXAMPLE.INSTANCE MAPCOLORING))(POS (EXAMPLE.DATEENTERED MAPCOLORING 3355255875))(POS (EXAMPLE.DATEMODIFIED MAPCOLORING 3355255875))(POS (EXAMPLE.TECHNIQUE MAPCOLORING CONSISTENCY2DEDUCTION))(POS (EXAMPLE.TECHNIQUE MAPCOLORING CHIRKOVAREFORMULATION))(POS (EXAMPLE.SOURCE MAPCOLORING "  (<= (not (color ?r ?c))
      (not (region ?r)))

  (<= (not (color ?r ?c))
      (not (hue ?c)))

  (<= (not (color ?r1 ?c))
      (adjacent ?r1 ?r2)
      (color ?r2 ?c))

  (region r1)
  (region r2)
  (region r3)

  (hue red)
  (hue blue)

  (adjacent r1 r2)
  (adjacent r2 r1)
  (adjacent r2 r3)
  (adjacent r3 r2)
"))(POS (EXAMPLE.SOURCEQUERY MAPCOLORING "(and (color r1 ?x) (color r2 ?y) (color r3 ?z))
"))(POS (EXAMPLE.TARGET MAPCOLORING "(next red blue)
(next blue red)"))(POS (EXAMPLE.TARGETQUERY MAPCOLORING "(and (next ?x ?y) (next ?y ?z))"))(POS (EXAMPLE.DESCRIPTION MAPCOLORING "The first version is not deductive; in fact, it entails which colorings are invalid.  The second version is deductive.  The first can be separated from region, hue, adjacent, but the second version builds all 3 into the formulation.  The first is more natural, but the second seems to be more efficient. Instead of building an arbitrary model for the axioms, we can use CSP/LP techniques to find an answer.  Actually, it is unclear to what extent the second formulation is faster than the first."))(POS (EXAMPLE.INSTANCE EXAMPLE.3355256133))(POS (EXAMPLE.DATEENTERED EXAMPLE.3355256133 3355256133))(POS (EXAMPLE.DATEMODIFIED EXAMPLE.3355256133 3355256133))(POS (EXAMPLE.DESCRIPTION EXAMPLE.3355256133 "test description"))(NEG (EXAMPLE.DESCRIPTION EXAMPLE.3355256133 "test description"))(POS (EXAMPLE.DESCRIPTION EXAMPLE.3355256133 "test description 2"))(NEG (EXAMPLE.EFFICIENCYGAINS TOETICTAC "Notes: tictactoe is the original theory and toetictac is the new one.
? (time (brute-force-playable tictactoe))
(BRUTE-FORCE-PLAYABLE TICTACTOE) took 56,488 milliseconds (56.488 seconds) to run.
Of that, 2,602 milliseconds (2.602 seconds) were spent in The Cooperative Multitasking Experience.
 88,240,736 bytes of memory allocated.
T
? (time (brute-force-playable toetictac))
;Compiler warnings :
;   Undeclared free variable TOETICTAC, in an anonymous lambda form.
(BRUTE-FORCE-PLAYABLE TOETICTAC) took 38,920 milliseconds (38.920 seconds) to run.
Of that, 1,514 milliseconds (1.514 seconds) were spent in The Cooperative Multitasking Experience.
 48,237,344 bytes of memory allocated.
T
"))(POS (EXAMPLE.EFFICIENCYGAINS TOETICTAC "(brute-force-playable source) takes 56.5 seconds.
(brute-force-playable target) takes 39 seconds."))(NEG (EXAMPLE.DATEENTERED EXAMPLE.3355256133 3355256133))(NEG (EXAMPLE.DATEMODIFIED EXAMPLE.3355256133 3355256133))(NEG (EXAMPLE.DESCRIPTION EXAMPLE.3355256133 "test description 2"))(NEG (EXAMPLE.INSTANCE EXAMPLE.3355256133))(POS (EXAMPLE.EFFICIENCYGAINS DRESDENQUEENS "(reward player ?x)
Source: 425 seconds, Target: 3 seconds"))(POS (PRETTYNAME DRESDENQUEENS "Dresden Queens"))(POS (PRETTYNAME MAPCOLORING "Map Coloring"))(POS (PRETTYNAME MAZEWORLD "Maze World"))(POS (PRETTYNAME TOETICTAC "Toetictac"))(POS (PRETTYNAME CHIRKOVAREFORMULATION "Chirkova"))(POS (PRETTYNAME CONSISTENCY2DEDUCTION "Consistency2Deduction"))(NEG (PRETTYNAME CHIRKOVAREFORMULATION "Chirkova"))(POS (PRETTYNAME CHIRKOVAREFORMULATION "Chirkova Reformulation"))(POS (PRETTYNAME DATAEXTRACTION "Data Extraction"))(POS (PRETTYNAME DATAINFUSION "Data Infusion"))(POS (PRETTYNAME GENERATEOVERGUESS "Generate Over Guess"))(POS (PRETTYNAME OBJECTIFYING "Objectifying"))(POS (PRETTYNAME REIFICATION "Reification"))(POS (PRETTYNAME RELATIONALIZING "Relationalizing"))(POS (PRETTYNAME UNNAMED "Unnamed"))(POS (SHORTNAME CHIRKOVAREFORMULATION "Chirkova"))(POS (SHORTNAME CONSISTENCY2DEDUCTION "C2D"))(POS (SHORTNAME DATAEXTRACTION "Extraction"))(POS (SHORTNAME DATAINFUSION "Infusion"))(POS (SHORTNAME GENERATEOVERGUESS "GOG"))(POS (SHORTNAME OBJECTIFYING "2Obj"))(POS (SHORTNAME REIFICATION "Reification"))(POS (SHORTNAME RELATIONALIZING "2Reln"))(POS (SHORTNAME UNNAMED "?"))(POS (COMPLETENESS.INSTANCE COMPLETE))(POS (COMPLETENESS.INSTANCE INCOMPLETE))(POS (EXAMPLE.COMPLETE DRESDENQUEENS COMPLETE))(POS (EXAMPLE.COMPLETE TOETICTAC COMPLETE))(POS (EXAMPLE.COMPLETE MAZEWORLD INCOMPLETE))(POS (EXAMPLE.COMPLETE MAPCOLORING INCOMPLETE))(POS (EXAMPLE.TECHNIQUE TOETICTAC UNNAMED))(NEG (EXAMPLE.DESCRIPTION DRESDENQUEENS "We extracted the data out of the rules and relied on generation instead of guess and check."))(POS (EXAMPLE.DESCRIPTION DRESDENQUEENS "When a GGP class was taught in Dresden, the 8-queens puzzle was used at some point.  The original axioms they wrote ran slowly when asking the query for the reward a player earned after having placed the 8 queens on the board.  The formulation was propositional: check if there are 8 queens that are attacked by some other queen; if so, award 0 points.  Then check if there are 7 queens that are attacked, and award 40 points.  And so on.  Nat changed the axioms so that first they compute how many queens are attacked and then use a lookup table to compute the points awarded."))(NEG (EXAMPLE.DESCRIPTION TOETICTAC "The old: each of the 9 cells is labelled with an x, an o, or a b: cell(x,y,label).  The new: each of the 9 cells (a,b,c,d,e,f,g,h,i) is either true of ecks or ohs or blank, each of which is a unary relation. "))(POS (EXAMPLE.DESCRIPTION TOETICTAC "Toetictac is a reconceptualization of the original axioms for tictactoe.  In the original version each of the 9 cells is labelled with an x, an o, or a b: cell(x,y,label).  In the new version each of the 9 cells (a,b,c,d,e,f,g,h,i) is either true of ecks or ohs or blank, each of which is a unary relation."))(POS (TECHNIQUE.INSTANCE NAF))(POS (TECHNIQUE.DESCRIPTION NAF "Negation as failure is a meta-inference rule: if the closed sentence p is not entailed (cannot be proven) then infer -p.  We've found it useful for performing iteration, and it is also useful in complete theories when failing to prove p in the positive space is easier than proving -p directly.  "))(POS (PRETTYNAME NAF "Negation as Failure"))(POS (SHORTNAME NAF "NAF"))(POS (BOOLEAN.INSTANCE TRUE))(POS (PRETTYNAME TRUE "True"))(POS (SHORTNAME TRUE "T"))(POS (BOOLEAN.INSTANCE FALSE))(POS (PRETTYNAME FALSE "False"))(POS (SHORTNAME FALSE "F"))(POS (MATRIXSHOW CONSISTENCY2DEDUCTION TRUE))(POS (MATRIXSHOW DRESDENQUEENS TRUE))(POS (MATRIXSHOW REIFICATION TRUE))(POS (MATRIXSHOW UNNAMED TRUE))(POS (MATRIXSHOW RELATIONALIZING FALSE))(POS (MATRIXSHOW OBJECTIFYING FALSE))(POS (MATRIXSHOW GENERATEOVERGUESS TRUE))(POS (MATRIXSHOW DATAEXTRACTION TRUE))(POS (MATRIXSHOW DATAINFUSION TRUE))(POS (MATRIXSHOW CHIRKOVAREFORMULATION TRUE))(POS (MATRIXSHOW NAF TRUE))(POS (MATRIXSHOW TOETICTAC TRUE))(POS (MATRIXSHOW MAZEWORLD TRUE))(POS (MATRIXSHOW MAPCOLORING TRUE))(POS (EXAMPLE.INSTANCE EXAMPLE.3355774383))(POS (PRETTYNAME EXAMPLE.3355774383 "Exponential negation"))(POS (SHORTNAME EXAMPLE.3355774383 "ExpNeg"))(POS (EXAMPLE.COMPLETE EXAMPLE.3355774383 COMPLETE))(POS (EXAMPLE.TECHNIQUE EXAMPLE.3355774383 NAF))(POS (EXAMPLE.DESCRIPTION EXAMPLE.3355774383 "An iff can be used to compactly define a complete relation; however, when converting an iff to clausal form, negating the body can produce a large number of rules.  This example shows that an exponential number of rules can be produced.  In general, if this example is generalized to include n disjuncts of conjunctions of length m, there are m^n rules of length m for defining the negative space.  There would be n rules of length m for defining the positive space."))(POS (EXAMPLE.EFFICIENCYGAINS EXAMPLE.3355774383 "6/4 unis/infs to explore positive space versus 54/28 unis/infs to explore negative space"))(POS (MATRIXSHOW EXAMPLE.3355774383 TRUE))(POS (EXAMPLE.SOURCEQUERY EXAMPLE.3355774383 "(not illegal)"))(POS (EXAMPLE.SOURCE EXAMPLE.3355774383 "(<=> illegal (or (and p1 p2 p3) (and q1 q2 q3) (and r1 r2 r3)))
"))(POS (EXAMPLE.TARGETQUERY EXAMPLE.3355774383 "(not illegal)"))(POS (EXAMPLE.TARGET EXAMPLE.3355774383 "(<= illegal (or (and p1 p2 p3) (and q1 q2 q3) (and r1 r2 r3)))
"))(POS (EXAMPLE.INSTANCE EXPONENTIALNEGATION))(POS (PRETTYNAME EXPONENTIALNEGATION "Exponential negation"))(POS (SHORTNAME EXPONENTIALNEGATION "ExpNeg"))(POS (EXAMPLE.COMPLETE EXPONENTIALNEGATION COMPLETE))(POS (EXAMPLE.TECHNIQUE EXPONENTIALNEGATION NAF))(POS (EXAMPLE.DESCRIPTION EXPONENTIALNEGATION "An iff can be used to compactly define a complete relation; however, when converting an iff to clausal form, negating the body can produce a large number of rules.  This example shows that an exponential number of rules can be produced.  In general, if this example is generalized to include n disjuncts of conjunctions of length m, there are m^n rules of length m for defining the negative space.  There would be n rules of length m for defining the positive space."))(POS (EXAMPLE.EFFICIENCYGAINS EXPONENTIALNEGATION "6/4 unis/infs to explore positive space versus 54/28 unis/infs to explore negative space"))(POS (MATRIXSHOW EXPONENTIALNEGATION TRUE))(POS (EXAMPLE.SOURCEQUERY EXPONENTIALNEGATION "(not illegal)"))(POS (EXAMPLE.SOURCE EXPONENTIALNEGATION "(<=> illegal (or (and p1 p2 p3) (and q1 q2 q3) (and r1 r2 r3)))
"))(POS (EXAMPLE.TARGETQUERY EXPONENTIALNEGATION "(not illegal)"))(POS (EXAMPLE.TARGET EXPONENTIALNEGATION "(<= illegal (or (and p1 p2 p3) (and q1 q2 q3) (and r1 r2 r3)))
"))(NEG (EXAMPLE.INSTANCE EXAMPLE.3355774383))(POS (EXAMPLE.INSTANCE JIGSAW))(POS (PRETTYNAME JIGSAW "Jigsaw"))(POS (SHORTNAME JIGSAW "Jigsaw"))(POS (EXAMPLE.COMPLETE JIGSAW INCOMPLETE))(POS (EXAMPLE.TECHNIQUE JIGSAW UNNAMED))(POS (EXAMPLE.DESCRIPTION JIGSAW "This is a 4-piece jigsaw puzzle.  The original jigsaw axioms are complicated, and converting them into clausal form is expensive.  Moreover, finding an answer after conversion takes a very, very long time.  Lastly, the relations included have modular definitions--they could be picked up and moved to other theories without (much) modification.  The new axioms include less information, but they include sufficient information to answer the query goal.  The new axioms find all answers in less than a second."))(POS (EXAMPLE.EFFICIENCYGAINS JIGSAW "13000x speedup"))(POS (MATRIXSHOW JIGSAW TRUE))(POS (EXAMPLE.SOURCEQUERY JIGSAW "(goal ?x ?y ?z ?w)"))(POS (EXAMPLE.SOURCE JIGSAW "  (<=> (cardinal ?x) (or (= ?x north) (= ?x south) (= ?x west) (= ?x east)))
  (<=> (piece ?x) (or (= ?x p1) (= ?x p2) (= ?x p3) (= ?x p4) (= ?x p0)))
  (<=> (orientation ?x) (or (= ?x 0) (= ?x 90) (= ?x 180) (= ?x 270)))

  ;(or (piece ?x) (orientation ?x) (cardinal ?x))

  (<=> (edge ?x ?y) 
       (or (and (= ?x p1) (or (= ?y east) (= ?y north)))
           (and (= ?x p2) (or (= ?y west) (= ?y north)))
           (and (= ?x p3) (or (= ?y west) (= ?y south)))
           (and (= ?x p4) (or (= ?y north) (= ?y east)))) )

  (<=> (rotate ?x ?amt ?y) 
       (or (and (= ?x north) (= ?amt 0) (= ?y north)) 
           (and (= ?x north) (= ?amt 90) (= ?y east))
           (and (= ?x north) (= ?amt 180) (= ?y south))
           (and (= ?x north) (= ?amt 270) (= ?y west))
           
           (and (= ?x south) (= ?amt 0) (= ?y south)) 
           (and (= ?x south) (= ?amt 90) (= ?y west))
           (and (= ?x south) (= ?amt 180) (= ?y north))
           (and (= ?x south) (= ?amt 270) (= ?y east))

           (and (= ?x east) (= ?amt 0) (= ?y east)) 
           (and (= ?x east) (= ?amt 90) (= ?y south))
           (and (= ?x east) (= ?amt 180) (= ?y west))
           (and (= ?x east) (= ?amt 270) (= ?y north))

           (and (= ?x west) (= ?amt 0) (= ?y west)) 
           (and (= ?x west) (= ?amt 90) (= ?y north))
           (and (= ?x west) (= ?amt 180) (= ?y east))
           (and (= ?x west) (= ?amt 270) (= ?y south))
           ))

  (<=> (orientededge ?x ?o ?e)
       (and (piece ?x) 
            (orientation ?o)
            (cardinal ?e)
            (or (and (edge ?x north)
                     (rotate north ?o ?e))
                (and (edge ?x south)
                     (rotate south ?o ?e))
                (and (edge ?x east)
                     (rotate east ?o ?e))
                (and (edge ?x west)
                     (rotate west ?o ?e)) )))

  (<=> (connectedh ?x ?xo ?y ?yo)
       (and (piece ?x)
            (orientation ?xo)
            (piece ?y)
            (orientation ?yo)
            (or (and (orientededge ?x ?xo east)
                     (orientededge ?y ?yo west))
                (and (not (orientededge ?x ?xo east))
                     (not (orientededge ?y ?yo west))) )))
 
  (<=> (connectedv ?x ?xo ?y ?yo)
       (and (piece ?x)
            (orientation ?xo)
            (piece ?y)
            (orientation ?yo)
            (or (and (orientededge ?x ?xo south)
                     (orientededge ?y ?yo north))
                (and (not (orientededge ?x ?xo south))
                     (not (orientededge ?y ?yo north))) )))

  ; border uses p0, a piece with no edges
  (<=> (border ?o1 ?o2 ?o3 ?o4)
       (and (connectedh p0 0 p1 ?o1)
            (connectedv p0 0 p1 ?o1)
            (connectedv p0 0 p2 ?o2)
            (connectedh p2 ?o2 p0 0)
            (connectedh p4 ?o4 p0 0)
            (connectedv p4 ?o4 p0 0)
            (connectedv p3 ?o3 p0 0)
            (connectedh p0 0 p3 ?o3)))

  (<=> (connected ?o1 ?o2 ?o3 ?o4)
       (and (connectedh p1 ?o1 p2 ?o2)
            (connectedh p3 ?o3 p4 ?o4)
            (connectedv p1 ?o1 p3 ?o3)
            (connectedv p2 ?o2 p4 ?o4)
            (border ?o1 ?o2 ?o3 ?o4)))

  (<= (goal ?o1 ?o2 ?o3 ?o4)
      (connected ?o1 ?o2 ?o3 ?o4))
 
"))(POS (EXAMPLE.TARGETQUERY JIGSAW "(goal ?x ?y ?z ?w)"))(POS (EXAMPLE.TARGET JIGSAW "  (piece p1) 
  (piece p2) 
  (piece p3) 
  (piece p4) 
   
  (rotation 0) 
  (rotation 90) 
  (rotation 180) 
  (rotation 270) 
   
  (cardinal north) 
  (cardinal south) 
  (cardinal east) 
  (cardinal west) 
   
  (edge p1 north) 
  (edge p1 east) 
  (edge p2 north) 
  (edge p2 west) 
  (edge p3 south) 
  (edge p3 west) 
  (edge p4 north) 
  (edge p4 east) 
   
  (<= (east ?p ?rot) 
      (or (and (edge ?p east) (same ?rot 0)) 
          (and (edge ?p north) (same ?rot 90)) 
          (and (edge ?p west) (same ?rot 180)) 
          (and (edge ?p south) (same ?rot 270)))) 
   
  (<= (west ?p ?rot) 
      (or (and (edge ?p west) (same ?rot 0)) 
          (and (edge ?p south) (same ?rot 90)) 
          (and (edge ?p east) (same ?rot 180)) 
          (and (edge ?p north) (same ?rot 270)))) 
   
  (<= (north ?p ?rot) 
      (or (and (edge ?p north) (same ?rot 0)) 
          (and (edge ?p west) (same ?rot 90)) 
          (and (edge ?p south) (same ?rot 180)) 
          (and (edge ?p east) (same ?rot 270)))) 
   
  (<= (south ?p ?rot) 
      (or (and (edge ?p south) (same ?rot 0)) 
          (and (edge ?p east) (same ?rot 90)) 
          (and (edge ?p north) (same ?rot 180)) 
          (and (edge ?p west) (same ?rot 270)))) 
   
   
  (<= (goal ?nw ?ne ?sw ?se) 
      (rotation ?nw) 
      (rotation ?ne) 
      (rotation ?sw) 
      (rotation ?se) 
      (east p1 ?nw) 
      (west p2 ?ne) 
      (east p3 ?sw) 
      (west p4 ?se) 
      (south p1 ?nw) 
      (north p3 ?sw) 
      (south p2 ?ne) 
      (north p4 ?se))
"))(POS (TECHNIQUE.INSTANCE RESIDUESREWRITE))(POS (PRETTYNAME RESIDUESREWRITE "Rewrite with Residues"))(POS (SHORTNAME RESIDUESREWRITE "Residue"))(POS (MATRIXSHOW RESIDUESREWRITE TRUE))(POS (TECHNIQUE.DESCRIPTION RESIDUESREWRITE "Given a query phi, a set of sentences Delta, and a set of relations R, find all residues for phi in Delta wrt R.  Turn the result into a disjunction and simplify it."))(NEG (EXAMPLE.TECHNIQUE JIGSAW UNNAMED))(POS (EXAMPLE.TECHNIQUE JIGSAW RESIDUESREWRITE))(POS (EXAMPLE.TECHNIQUE JIGSAW UNNAMED))(NEG (EXAMPLE.TARGET JIGSAW "  (piece p1) 
  (piece p2) 
  (piece p3) 
  (piece p4) 
   
  (rotation 0) 
  (rotation 90) 
  (rotation 180) 
  (rotation 270) 
   
  (cardinal north) 
  (cardinal south) 
  (cardinal east) 
  (cardinal west) 
   
  (edge p1 north) 
  (edge p1 east) 
  (edge p2 north) 
  (edge p2 west) 
  (edge p3 south) 
  (edge p3 west) 
  (edge p4 north) 
  (edge p4 east) 
   
  (<= (east ?p ?rot) 
      (or (and (edge ?p east) (same ?rot 0)) 
          (and (edge ?p north) (same ?rot 90)) 
          (and (edge ?p west) (same ?rot 180)) 
          (and (edge ?p south) (same ?rot 270)))) 
   
  (<= (west ?p ?rot) 
      (or (and (edge ?p west) (same ?rot 0)) 
          (and (edge ?p south) (same ?rot 90)) 
          (and (edge ?p east) (same ?rot 180)) 
          (and (edge ?p north) (same ?rot 270)))) 
   
  (<= (north ?p ?rot) 
      (or (and (edge ?p north) (same ?rot 0)) 
          (and (edge ?p west) (same ?rot 90)) 
          (and (edge ?p south) (same ?rot 180)) 
          (and (edge ?p east) (same ?rot 270)))) 
   
  (<= (south ?p ?rot) 
      (or (and (edge ?p south) (same ?rot 0)) 
          (and (edge ?p east) (same ?rot 90)) 
          (and (edge ?p north) (same ?rot 180)) 
          (and (edge ?p west) (same ?rot 270)))) 
   
   
  (<= (goal ?nw ?ne ?sw ?se) 
      (rotation ?nw) 
      (rotation ?ne) 
      (rotation ?sw) 
      (rotation ?se) 
      (east p1 ?nw) 
      (west p2 ?ne) 
      (east p3 ?sw) 
      (west p4 ?se) 
      (south p1 ?nw) 
      (north p3 ?sw) 
      (south p2 ?ne) 
      (north p4 ?se))
"))(POS (EXAMPLE.TARGET JIGSAW "  (piece p1) 
  (piece p2) 
  (piece p3) 
  (piece p4) 
   
  (rotation 0) 
  (rotation 90) 
  (rotation 180) 
  (rotation 270) 
   
  (cardinal north) 
  (cardinal south) 
  (cardinal east) 
  (cardinal west) 
   
  (edge p1 north) 
  (edge p1 east) 
  (edge p2 north) 
  (edge p2 west) 
  (edge p3 south) 
  (edge p3 west) 
  (edge p4 north) 
  (edge p4 east) 
   
  (<= (rotate ?p ?rot east) 
      (or (and (edge ?p east) (same ?rot 0)) 
          (and (edge ?p north) (same ?rot 90)) 
          (and (edge ?p west) (same ?rot 180)) 
          (and (edge ?p south) (same ?rot 270)))) 
   
  (<= (rotate ?p ?rot west) 
      (or (and (edge ?p west) (same ?rot 0)) 
          (and (edge ?p south) (same ?rot 90)) 
          (and (edge ?p east) (same ?rot 180)) 
          (and (edge ?p north) (same ?rot 270)))) 
   
  (<= (rotate ?p ?rot north) 
      (or (and (edge ?p north) (same ?rot 0)) 
          (and (edge ?p west) (same ?rot 90)) 
          (and (edge ?p south) (same ?rot 180)) 
          (and (edge ?p east) (same ?rot 270)))) 
   
  (<= (rotate ?p ?rot south) 
      (or (and (edge ?p south) (same ?rot 0)) 
          (and (edge ?p east) (same ?rot 90)) 
          (and (edge ?p north) (same ?rot 180)) 
          (and (edge ?p west) (same ?rot 270)))) 
   
   
  (<= (goal ?nw ?ne ?sw ?se) 
      (rotation ?nw) 
      (rotation ?ne) 
      (rotation ?sw) 
      (rotation ?se) 
      (rotate p1 ?nw east) 
      (rotate p2 ?ne west) 
      (rotate p3 ?sw east) 
      (rotate p4 ?se west) 
      (rotate p1 ?nw south) 
      (rotate p3 ?sw north) 
      (rotate p2 ?ne south) 
      (rotate p4 ?se north))
"))(NEG (EXAMPLE.TECHNIQUE JIGSAW UNNAMED))(POS (EXAMPLE.TECHNIQUE JIGSAW NAF))(POS (EXAMPLE.TECHNIQUE JIGSAW UNNAMED))(POS (TECHNIQUE.INSTANCE STATICCONJORDERING))(POS (PRETTYNAME STATICCONJORDERING "Static Conjunct Ordering"))(POS (SHORTNAME STATICCONJORDERING "statconjorder"))(POS (MATRIXSHOW STATICCONJORDERING TRUE))(POS (TECHNIQUE.DESCRIPTION STATICCONJORDERING "For model elimination, ordering conjuncts statically requires simply changing the sequence of literals in the body of the rules."))(POS (EXAMPLE.INSTANCE GUESS))(POS (PRETTYNAME GUESS "Guess"))(POS (SHORTNAME GUESS "Guess"))(POS (EXAMPLE.COMPLETE GUESS COMPLETE))(POS (EXAMPLE.TECHNIQUE GUESS STATICCONJORDERING))(POS (EXAMPLE.DESCRIPTION GUESS "Example where a bad conjunct ordering requires non-zero work to find legal moves because the ground conjuncts are not moved all the way to the front."))(POS (EXAMPLE.EFFICIENCYGAINS GUESS "In this game, search space shrinks from 64^2 to 1 per rule."))(POS (MATRIXSHOW GUESS TRUE))(POS (EXAMPLE.COMMENTS GUESS "There may be a bug in the game -- something about greater than."))(POS (EXAMPLE.SOURCEQUERY GUESS "(legal chooser ?x)"))(POS (EXAMPLE.SOURCE GUESS "  (role guesser)
  (role chooser)
  (<= (legal guesser ?g)
      (true (possible ?g))
      (true (control guesser))
  (<= (legal guesser wait)
      (true (control chooser))
  (<= (next (control guesser))
      (true (control chooser))
  (<= (next (control chooser))
      (true (control guesser))
  (<= (next (guess ?x))
      (does guesser ?x)
      (true (possible ?x))
  (<= (legal chooser higher)
      (true (possible ?n))
      (greater ?n ?x)
      (true (guess ?x))
      (true (control chooser))
  (<= (legal chooser lower)
      (true (possible ?n))
      (greater ?x ?n)
      (true (guess ?x))
      (true (control chooser))
  (<= (legal chooser wait)
      (true (control guesser))
  (<= (next (possible ?x))
      (true (possible ?x))
      (true (control guesser))
  (<= (next (possible ?x))
      (true (possible ?x))
      (greater ?x ?y)
      (true (guess ?y))
      (does chooser higher)
  (<= (next (possible ?x))
      (true (possible ?x))
      (greater ?y ?x)
      (true (guess ?y))
      (does chooser lower)
  (<= (next (step ?x))
      (true (step ?y))
      (succ ?y ?x)
  (<= (goal guesser 100)
      (not unfinished)
  (<= (goal guesser 0)
      unfinished
  (<= (goal chooser 100)
      unfinished
  (<= (goal chooser 0)
      (not unfinished)
  (<= terminal
      (not unfinished)
  (<= terminal
      (true (step 12))
  (<= unfinished
      (true (possible ?x))
      (true (possible ?y))
      (distinct ?x ?y)
  (<= (greater ?x ?y)
      (succ ?y ?x)
  (<= (greater ?x ?y)
      (succ ?x ?z)
      (greater ?z ?y)
  (init (step 1))
  (init (control guesser))
  (init (possible 1))
  (init (possible 2))
  (init (possible 3))
  (init (possible 4))
  (init (possible 5))
  (init (possible 6))
  (init (possible 7))
  (init (possible 8))
  (init (possible 9))
  (init (possible 10))
  (init (possible 11))
  (init (possible 12))
  (init (possible 13))
  (init (possible 14))
  (init (possible 15))
  (init (possible 16))
  (init (possible 17))
  (init (possible 18))
  (init (possible 19))
  (init (possible 20))
  (init (possible 21))
  (init (possible 22))
  (init (possible 23))
  (init (possible 24))
  (init (possible 25))
  (init (possible 26))
  (init (possible 27))
  (init (possible 28))
  (init (possible 29))
  (init (possible 30))
  (init (possible 31))
  (init (possible 32))
  (init (possible 33))
  (init (possible 34))
  (init (possible 35))
  (init (possible 36))
  (init (possible 37))
  (init (possible 38))
  (init (possible 39))
  (init (possible 40))
  (init (possible 41))
  (init (possible 42))
  (init (possible 43))
  (init (possible 44))
  (init (possible 45))
  (init (possible 46))
  (init (possible 47))
  (init (possible 48))
  (init (possible 49))
  (init (possible 50))
  (init (possible 51))
  (init (possible 52))
  (init (possible 53))
  (init (possible 54))
  (init (possible 55))
  (init (possible 56))
  (init (possible 57))
  (init (possible 58))
  (init (possible 59))
  (init (possible 60))
  (init (possible 61))
  (init (possible 62))
  (init (possible 63))
  (succ 1 2)
  (succ 2 3)
  (succ 3 4)
  (succ 4 5)
  (succ 5 6)
  (succ 6 7)
  (succ 7 8)
  (succ 8 9)
  (succ 9 10)
  (succ 10 11)
  (succ 11 12)
  (succ 12 13)
  (succ 13 14)
  (succ 14 15)
  (succ 15 16)
  (succ 16 17)
  (succ 17 18)
  (succ 18 19)
  (succ 19 20)
  (succ 20 21)
  (succ 21 22)
  (succ 22 23)
  (succ 23 24)
  (succ 24 25)
  (succ 25 26)
  (succ 26 27)
  (succ 27 28)
  (succ 28 29)
  (succ 29 30)
  (succ 30 31)
  (succ 31 32)
  (succ 32 33)
  (succ 33 34)
  (succ 34 35)
  (succ 35 36)
  (succ 36 37)
  (succ 37 38)
  (succ 38 39)
  (succ 39 40)
  (succ 40 41)
  (succ 41 42)
  (succ 42 43)
  (succ 43 44)
  (succ 44 45)
  (succ 45 46)
  (succ 46 47)
  (succ 47 48)
  (succ 48 49)
  (succ 49 50)
  (succ 50 51)
  (succ 51 52)
  (succ 52 53)
  (succ 53 54)
  (succ 54 55)
  (succ 55 56)
  (succ 56 57)
  (succ 57 58)
  (succ 58 59)
  (succ 59 60)
  (succ 60 61)
  (succ 61 62)
  (succ 62 63)"))(POS (EXAMPLE.TARGETQUERY GUESS "(legal chooser ?x)"))(POS (EXAMPLE.TARGET GUESS "  (role guesser)
  (role chooser)

  (<= (legal guesser ?g)
      (true (control guesser))
      (true (possible ?g)))

  (<= (legal guesser wait)
      (true (control chooser)))

  (<= (next (control guesser))
      (true (control chooser)))

  (<= (next (control chooser))
      (true (control guesser)))

  (<= (next (guess ?x))
      (does guesser ?x)
      (true (possible ?x)))

  (<= (legal chooser higher)
      (true (control chooser))
      (true (possible ?n))
      (greater ?n ?x)
      (true (guess ?x)))

  (<= (legal chooser lower)
      (true (control chooser))
      (true (possible ?n))
      (greater ?x ?n)
      (true (guess ?x)))

  (<= (legal chooser wait)
      (true (control guesser)))

  (<= (next (possible ?x))
      (true (control guesser))
      (true (possible ?x)))

  (<= (next (possible ?x))
      (does chooser higher)
      (true (possible ?x))
      (greater ?x ?y)
      (true (guess ?y)))

  (<= (next (possible ?x))
      (does chooser lower)
      (true (possible ?x))
      (greater ?y ?x)
      (true (guess ?y)))

  (<= (next (step ?x))
      (true (step ?y))
      (succ ?y ?x))

  (<= (goal guesser 100)
      (not unfinished))
  (<= (goal guesser 0)
      unfinished)
  (<= (goal chooser 100)
      unfinished)
  (<= (goal chooser 0)
      (not unfinished))
  (<= terminal
      (not unfinished))
  (<= terminal
      (true (step 12)))
  (<= unfinished
      (true (possible ?x))
      (true (possible ?y))
      (distinct ?x ?y))
  (<= (greater ?x ?y)
      (succ ?y ?x))
  (<= (greater ?x ?y)
      (succ ?x ?z)
      (greater ?z ?y))
  (init (step 1))
  (init (control guesser))
  (init (possible 1))
  (init (possible 2))
  (init (possible 3))
  (init (possible 4))
  (init (possible 5))
  (init (possible 6))
  (init (possible 7))
  (init (possible 8))
  (init (possible 9))
  (init (possible 10))
  (init (possible 11))
  (init (possible 12))
  (init (possible 13))
  (init (possible 14))
  (init (possible 15))
  (init (possible 16))
  (init (possible 17))
  (init (possible 18))
  (init (possible 19))
  (init (possible 20))
  (init (possible 21))
  (init (possible 22))
  (init (possible 23))
  (init (possible 24))
  (init (possible 25))
  (init (possible 26))
  (init (possible 27))
  (init (possible 28))
  (init (possible 29))
  (init (possible 30))
  (init (possible 31))
  (init (possible 32))
  (init (possible 33))
  (init (possible 34))
  (init (possible 35))
  (init (possible 36))
  (init (possible 37))
  (init (possible 38))
  (init (possible 39))
  (init (possible 40))
  (init (possible 41))
  (init (possible 42))
  (init (possible 43))
  (init (possible 44))
  (init (possible 45))
  (init (possible 46))
  (init (possible 47))
  (init (possible 48))
  (init (possible 49))
  (init (possible 50))
  (init (possible 51))
  (init (possible 52))
  (init (possible 53))
  (init (possible 54))
  (init (possible 55))
  (init (possible 56))
  (init (possible 57))
  (init (possible 58))
  (init (possible 59))
  (init (possible 60))
  (init (possible 61))
  (init (possible 62))
  (init (possible 63))
  (succ 1 2)
  (succ 2 3)
  (succ 3 4)
  (succ 4 5)
  (succ 5 6)
  (succ 6 7)
  (succ 7 8)
  (succ 8 9)
  (succ 9 10)
  (succ 10 11)
  (succ 11 12)
  (succ 12 13)
  (succ 13 14)
  (succ 14 15)
  (succ 15 16)
  (succ 16 17)
  (succ 17 18)
  (succ 18 19)
  (succ 19 20)
  (succ 20 21)
  (succ 21 22)
  (succ 22 23)
  (succ 23 24)
  (succ 24 25)
  (succ 25 26)
  (succ 26 27)
  (succ 27 28)
  (succ 28 29)
  (succ 29 30)
  (succ 30 31)
  (succ 31 32)
  (succ 32 33)
  (succ 33 34)
  (succ 34 35)
  (succ 35 36)
  (succ 36 37)
  (succ 37 38)
  (succ 38 39)
  (succ 39 40)
  (succ 40 41)
  (succ 41 42)
  (succ 42 43)
  (succ 43 44)
  (succ 44 45)
  (succ 45 46)
  (succ 46 47)
  (succ 47 48)
  (succ 48 49)
  (succ 49 50)
  (succ 50 51)
  (succ 51 52)
  (succ 52 53)
  (succ 53 54)
  (succ 54 55)
  (succ 55 56)
  (succ 56 57)
  (succ 57 58)
  (succ 58 59)
  (succ 59 60)
  (succ 60 61)
  (succ 61 62)
  (succ 62 63)"))(NEG (SHORTNAME STATICCONJORDERING "statconjorder"))(POS (SHORTNAME STATICCONJORDERING "StatCO"))(NEG (EXAMPLE.COMPLETE JIGSAW INCOMPLETE))(POS (EXAMPLE.COMPLETE JIGSAW COMPLETE))(POS (TECHNIQUE.INSTANCE BILEVEL))(POS (PRETTYNAME BILEVEL "Bilevel Reasoning"))(POS (SHORTNAME BILEVEL "Bi"))(POS (MATRIXSHOW BILEVEL TRUE))(POS (TECHNIQUE.DESCRIPTION BILEVEL "Split the problem into two pieces: the data and the axioms."))(POS (EXAMPLE.INSTANCE 4QUEENS))(POS (PRETTYNAME 4QUEENS "4-Queens"))(POS (SHORTNAME 4QUEENS "4queens"))(POS (EXAMPLE.COMPLETE 4QUEENS INCOMPLETE))(POS (EXAMPLE.TECHNIQUE 4QUEENS CONSISTENCY2DEDUCTION))(POS (EXAMPLE.TECHNIQUE 4QUEENS BILEVEL))(POS (EXAMPLE.TECHNIQUE 4QUEENS NAF))(POS (EXAMPLE.DESCRIPTION 4QUEENS "The traditional 8-queens puzzle, shrunken to a 4x4 board with 4 queens.  Two solutions exist to what is usually a CSP.  But in this example, we are asking an entailment query about those solutions: is the upper left square always blank?"))(POS (MATRIXSHOW 4QUEENS TRUE))(POS (EXAMPLE.COMMENTS 4QUEENS "Add in UNA and DCA for all object constants, i.e. this is finite Herbrand logic."))(POS (EXAMPLE.SOURCEQUERY 4QUEENS "      (forall (?x1 ?y1 ?x2 ?y2 ?x3 ?y3 ?x4 ?y4) 
              (=> (ans ?x1 ?y1 ?x2 ?y2 ?x3 ?y3 ?x4 ?y4)
                  (and (not (= ?x1 1))
                       (not (= ?y1 1))
                       (not (= ?x2 1))
                       (not (= ?y2 1))
                       (not (= ?x3 1))
                       (not (= ?y3 1))
                       (not (= ?x4 1))
                       (not (= ?y4 1))))"))(POS (EXAMPLE.SOURCE 4QUEENS "  (<= (ans ?x1 ?y1 ?x2 ?y2 ?x3 ?y3 ?x4 ?y4)
      (and (row q1 ?x1) (col q1 ?y1) (row q2 ?x2) (col q2 ?y2) (row q3 ?x3) (col q3 ?y3) (row q4 ?x4) (col q4 ?y4)))

  ; all the queens have different rows
  (<= (not (row ?x ?c))
      (row ?y ?c)
      (not (= ?x ?y)))

  ; all the queens have different columns
  (<= (not (col ?x ?c))
      (col ?y ?c)
      (not (= ?x ?y)))

  ; given a row and column, we can compute the two diagonals it is on.
  (<= (d ?q pos ?z) (row ?q ?x) (col ?q ?y) (sub ?y ?x ?z))
  (<= (d ?q neg ?z) (row ?q ?x) (col ?q ?y) (add ?y ?x ?z))

  ; all the queens have different diagonals
  (<= (not (d ?q1 ?sign ?z))
      (d ?q2 ?sign ?z)
      (not (= ?q1 ?q2)))

  ; add and subtract
  (add 1 1 2)
  (add 1 2 3)
  (add 1 3 4)
  (add 1 4 5)
  (add 2 1 3)
  (add 2 2 4)
  (add 2 3 5)
  (add 2 4 6)
  (add 3 1 4)
  (add 3 2 5)
  (add 3 3 6)
  (add 3 4 7)
  (add 4 1 5)
  (add 4 2 6)
  (add 4 3 7)
  (add 4 4 8)

  (sub 1 1 0)
  (sub 1 2 -1)
  (sub 1 3 -2)
  (sub 1 4 -3)
  (sub 2 1 1)
  (sub 2 2 0)
  (sub 2 3 -1)
  (sub 2 4 -2)
  (sub 3 1 2)
  (sub 3 2 1)
  (sub 3 3 0)
  (sub 3 4 -1)
  (sub 4 1 3)
  (sub 4 2 2)
  (sub 4 3 1)
  (sub 4 4 0)
"))(POS (EXAMPLE.TARGETQUERY 4QUEENS "ent"))(POS (EXAMPLE.TARGET 4QUEENS "  (<= ent
      (not notent))
  (<= notent
      (goal17 ?X1 ?Y1 ?X2 ?Y2 ?X3 ?Y3 ?X4 ?Y4)
      (not (phi ?X1 ?Y1 ?X2 ?Y2 ?X3 ?Y3 ?X4 ?Y4)))
 
  (<= (phi ?X1 ?Y1 ?X2 ?Y2 ?X3 ?Y3 ?X4 ?Y4)
      (or (distinct ?x1 1)
          (distinct ?y1 1))
      (or (distinct ?x2 1)
          (distinct ?y2 1))
      (or (distinct ?x3 1)
          (distinct ?y3 1))
      (or (distinct ?x4 1)
          (distinct ?y4 1)))
      
  ; below ne is the not equal table
  (<= (goal17 ?X1 ?Y1 ?X2 ?Y2 ?X3 ?Y3 ?X4 ?Y4)
      
      (sub ?y1 ?x1 ?neg1)
      (add ?y1 ?x1 ?pos1)
      (sub ?y2 ?x2 ?neg2)
      (distinct ?X1 ?X2)
      (distinct ?Y1 ?Y2)
      (distinct ?neg2 ?neg1)
      (add ?y2 ?x2 ?pos2)
      (distinct ?pos2 ?pos1)
      
      
      (sub ?y3 ?x3 ?neg3)
      (distinct ?X1 ?X3) 
      (distinct ?Y1 ?Y3)
      (distinct ?X2 ?X3)
      (distinct ?Y2 ?Y3)
      (distinct ?neg3 ?neg2)
      (distinct ?neg3 ?neg1)
      (add ?y3 ?x3 ?pos3)
      (distinct ?pos3 ?pos2)
      (distinct ?pos3 ?pos1)
      
      (sub ?y4 ?x4 ?neg4)
      (distinct ?X1 ?X4)
      (distinct ?X2 ?X4)
      (distinct ?X3 ?X4)
      (distinct ?Y1 ?Y4)
      (distinct ?Y2 ?Y4)
      (distinct ?Y3 ?Y4)
      (distinct ?neg4 ?neg3)
      (distinct ?neg4 ?neg2)
      (distinct ?neg4 ?neg1)
      (add ?y4 ?x4 ?pos4)
      (distinct ?pos4 ?pos3)
      (distinct ?pos4 ?pos2)
      (distinct ?pos4 ?pos1))
  
  (add 1 1 2)
  (add 1 2 3)
  (add 1 3 4)
  (add 1 4 5)
  (add 2 1 3)
  (add 2 2 4)
  (add 2 3 5)
  (add 2 4 6)
  (add 3 1 4)
  (add 3 2 5)
  (add 3 3 6)
  (add 3 4 7)
  (add 4 1 5)
  (add 4 2 6)
  (add 4 3 7)
  (add 4 4 8)

  (sub 1 1 0)
  (sub 1 2 -1)
  (sub 1 3 -2)
  (sub 1 4 -3)
  (sub 2 1 1)
  (sub 2 2 0)
  (sub 2 3 -1)
  (sub 2 4 -2)
  (sub 3 1 2)
  (sub 3 2 1)
  (sub 3 3 0)
  (sub 3 4 -1)
  (sub 4 1 3)
  (sub 4 2 2)
  (sub 4 3 1)
  (sub 4 4 0)"))(NEG (EXAMPLE.DESCRIPTION 4QUEENS "The traditional 8-queens puzzle, shrunken to a 4x4 board with 4 queens.  Two solutions exist to what is usually a CSP.  But in this example, we are asking an entailment query about those solutions: is the upper left square always blank?"))(POS (EXAMPLE.DESCRIPTION 4QUEENS "The traditional 8-queens puzzle, shrunken to a 4x4 board with 4 queens.  Two solutions exist to what is usually a CSP.  But in this example, we are asking an entailment query about those solutions: is the upper left square always blank?  This translation turns an entailment query stated in FHL into a datalog query."))(POS (EXAMPLE.TECHNIQUE 4QUEENS UNNAMED))(NEG (EXAMPLE.SOURCEQUERY 4QUEENS "      (forall (?x1 ?y1 ?x2 ?y2 ?x3 ?y3 ?x4 ?y4) 
              (=> (ans ?x1 ?y1 ?x2 ?y2 ?x3 ?y3 ?x4 ?y4)
                  (and (not (= ?x1 1))
                       (not (= ?y1 1))
                       (not (= ?x2 1))
                       (not (= ?y2 1))
                       (not (= ?x3 1))
                       (not (= ?y3 1))
                       (not (= ?x4 1))
                       (not (= ?y4 1))))"))(POS (EXAMPLE.SOURCEQUERY 4QUEENS "goal"))(NEG (EXAMPLE.SOURCE 4QUEENS "  (<= (ans ?x1 ?y1 ?x2 ?y2 ?x3 ?y3 ?x4 ?y4)
      (and (row q1 ?x1) (col q1 ?y1) (row q2 ?x2) (col q2 ?y2) (row q3 ?x3) (col q3 ?y3) (row q4 ?x4) (col q4 ?y4)))

  ; all the queens have different rows
  (<= (not (row ?x ?c))
      (row ?y ?c)
      (not (= ?x ?y)))

  ; all the queens have different columns
  (<= (not (col ?x ?c))
      (col ?y ?c)
      (not (= ?x ?y)))

  ; given a row and column, we can compute the two diagonals it is on.
  (<= (d ?q pos ?z) (row ?q ?x) (col ?q ?y) (sub ?y ?x ?z))
  (<= (d ?q neg ?z) (row ?q ?x) (col ?q ?y) (add ?y ?x ?z))

  ; all the queens have different diagonals
  (<= (not (d ?q1 ?sign ?z))
      (d ?q2 ?sign ?z)
      (not (= ?q1 ?q2)))

  ; add and subtract
  (add 1 1 2)
  (add 1 2 3)
  (add 1 3 4)
  (add 1 4 5)
  (add 2 1 3)
  (add 2 2 4)
  (add 2 3 5)
  (add 2 4 6)
  (add 3 1 4)
  (add 3 2 5)
  (add 3 3 6)
  (add 3 4 7)
  (add 4 1 5)
  (add 4 2 6)
  (add 4 3 7)
  (add 4 4 8)

  (sub 1 1 0)
  (sub 1 2 -1)
  (sub 1 3 -2)
  (sub 1 4 -3)
  (sub 2 1 1)
  (sub 2 2 0)
  (sub 2 3 -1)
  (sub 2 4 -2)
  (sub 3 1 2)
  (sub 3 2 1)
  (sub 3 3 0)
  (sub 3 4 -1)
  (sub 4 1 3)
  (sub 4 2 2)
  (sub 4 3 1)
  (sub 4 4 0)
"))(POS (EXAMPLE.SOURCE 4QUEENS "  (<= goal 
      (forall (?x1 ?y1 ?x2 ?y2 ?x3 ?y3 ?x4 ?y4) 
              (=> (and (row q1 ?x1) (col q1 ?y1) (row q2 ?x2) (col q2 ?y2) (row q3 ?x3) (col q3 ?y3) (row q4 ?x4) (col q4 ?y4))
                  (not (or (and (= ?x1 1) (= ?y1 1))
                           (and (= ?x2 1) (= ?y2 1))
                           (and (= ?x3 1) (= ?y3 1))
                           (and (= ?x4 1) (= ?y4 1)))))))

  ; all the queens have different rows
  (<= (not (row ?x ?c))
      (row ?y ?c)
      (not (= ?x ?y)))

  ; all the queens have different columns
  (<= (not (col ?x ?c))
      (col ?y ?c)
      (not (= ?x ?y)))

  ; given a row and column, we can compute the two diagonals it is on.
  (<= (d ?q pos ?z) (row ?q ?x) (col ?q ?y) (sub ?y ?x ?z))
  (<= (d ?q neg ?z) (row ?q ?x) (col ?q ?y) (add ?y ?x ?z))

  ; all the queens have different diagonals
  (<= (not (d ?q1 ?sign ?z))
      (d ?q2 ?sign ?z)
      (not (= ?q1 ?q2)))

  ; add and subtract
  (add 1 1 2)
  (add 1 2 3)
  (add 1 3 4)
  (add 1 4 5)
  (add 2 1 3)
  (add 2 2 4)
  (add 2 3 5)
  (add 2 4 6)
  (add 3 1 4)
  (add 3 2 5)
  (add 3 3 6)
  (add 3 4 7)
  (add 4 1 5)
  (add 4 2 6)
  (add 4 3 7)
  (add 4 4 8)

  (sub 1 1 0)
  (sub 1 2 -1)
  (sub 1 3 -2)
  (sub 1 4 -3)
  (sub 2 1 1)
  (sub 2 2 0)
  (sub 2 3 -1)
  (sub 2 4 -2)
  (sub 3 1 2)
  (sub 3 2 1)
  (sub 3 3 0)
  (sub 3 4 -1)
  (sub 4 1 3)
  (sub 4 2 2)
  (sub 4 3 1)
  (sub 4 4 0)
"))(NEG (EXAMPLE.SOURCEQUERY 4QUEENS "goal"))(POS (EXAMPLE.SOURCEQUERY 4QUEENS "(forall (?x1 ?y1 ?x2 ?y2 ?x3 ?y3 ?x4 ?y4) 
              (=> (and (row q1 ?x1) (col q1 ?y1) (row q2 ?x2) (col q2 ?y2) (row q3 ?x3) (col q3 ?y3) (row q4 ?x4) (col q4 ?y4))
                  (not (or (and (= ?x1 1) (= ?y1 1))
                           (and (= ?x2 1) (= ?y2 1))
                           (and (= ?x3 1) (= ?y3 1))
                           (and (= ?x4 1) (= ?y4 1))))))"))(NEG (EXAMPLE.SOURCE 4QUEENS "  (<= goal 
      (forall (?x1 ?y1 ?x2 ?y2 ?x3 ?y3 ?x4 ?y4) 
              (=> (and (row q1 ?x1) (col q1 ?y1) (row q2 ?x2) (col q2 ?y2) (row q3 ?x3) (col q3 ?y3) (row q4 ?x4) (col q4 ?y4))
                  (not (or (and (= ?x1 1) (= ?y1 1))
                           (and (= ?x2 1) (= ?y2 1))
                           (and (= ?x3 1) (= ?y3 1))
                           (and (= ?x4 1) (= ?y4 1)))))))

  ; all the queens have different rows
  (<= (not (row ?x ?c))
      (row ?y ?c)
      (not (= ?x ?y)))

  ; all the queens have different columns
  (<= (not (col ?x ?c))
      (col ?y ?c)
      (not (= ?x ?y)))

  ; given a row and column, we can compute the two diagonals it is on.
  (<= (d ?q pos ?z) (row ?q ?x) (col ?q ?y) (sub ?y ?x ?z))
  (<= (d ?q neg ?z) (row ?q ?x) (col ?q ?y) (add ?y ?x ?z))

  ; all the queens have different diagonals
  (<= (not (d ?q1 ?sign ?z))
      (d ?q2 ?sign ?z)
      (not (= ?q1 ?q2)))

  ; add and subtract
  (add 1 1 2)
  (add 1 2 3)
  (add 1 3 4)
  (add 1 4 5)
  (add 2 1 3)
  (add 2 2 4)
  (add 2 3 5)
  (add 2 4 6)
  (add 3 1 4)
  (add 3 2 5)
  (add 3 3 6)
  (add 3 4 7)
  (add 4 1 5)
  (add 4 2 6)
  (add 4 3 7)
  (add 4 4 8)

  (sub 1 1 0)
  (sub 1 2 -1)
  (sub 1 3 -2)
  (sub 1 4 -3)
  (sub 2 1 1)
  (sub 2 2 0)
  (sub 2 3 -1)
  (sub 2 4 -2)
  (sub 3 1 2)
  (sub 3 2 1)
  (sub 3 3 0)
  (sub 3 4 -1)
  (sub 4 1 3)
  (sub 4 2 2)
  (sub 4 3 1)
  (sub 4 4 0)
"))(POS (EXAMPLE.SOURCE 4QUEENS "
  ; all the queens have different rows
  (<= (not (row ?x ?c))
      (row ?y ?c)
      (not (= ?x ?y)))

  ; all the queens have different columns
  (<= (not (col ?x ?c))
      (col ?y ?c)
      (not (= ?x ?y)))

  ; given a row and column, we can compute the two diagonals it is on.
  (<= (d ?q pos ?z) (row ?q ?x) (col ?q ?y) (sub ?y ?x ?z))
  (<= (d ?q neg ?z) (row ?q ?x) (col ?q ?y) (add ?y ?x ?z))

  ; all the queens have different diagonals
  (<= (not (d ?q1 ?sign ?z))
      (d ?q2 ?sign ?z)
      (not (= ?q1 ?q2)))

  ; add and subtract
  (add 1 1 2)
  (add 1 2 3)
  (add 1 3 4)
  (add 1 4 5)
  (add 2 1 3)
  (add 2 2 4)
  (add 2 3 5)
  (add 2 4 6)
  (add 3 1 4)
  (add 3 2 5)
  (add 3 3 6)
  (add 3 4 7)
  (add 4 1 5)
  (add 4 2 6)
  (add 4 3 7)
  (add 4 4 8)

  (sub 1 1 0)
  (sub 1 2 -1)
  (sub 1 3 -2)
  (sub 1 4 -3)
  (sub 2 1 1)
  (sub 2 2 0)
  (sub 2 3 -1)
  (sub 2 4 -2)
  (sub 3 1 2)
  (sub 3 2 1)
  (sub 3 3 0)
  (sub 3 4 -1)
  (sub 4 1 3)
  (sub 4 2 2)
  (sub 4 3 1)
  (sub 4 4 0)
"))(POS (TECHNIQUE.INSTANCE SYMMETRYANALYSIS))(POS (PRETTYNAME SYMMETRYANALYSIS "Symmetry Analysis"))(POS (SHORTNAME SYMMETRYANALYSIS "Sym"))(POS (MATRIXSHOW SYMMETRYANALYSIS TRUE))(POS (TECHNIQUE.DESCRIPTION SYMMETRYANALYSIS "Take advantage of symmetry in the problem to reduce the search space."))(POS (EXAMPLE.INSTANCE 4QSDATALOG))(POS (PRETTYNAME 4QSDATALOG "4-Queens Datalog"))(POS (SHORTNAME 4QSDATALOG "4qsdatalog"))(POS (EXAMPLE.COMPLETE 4QSDATALOG COMPLETE))(POS (EXAMPLE.TECHNIQUE 4QSDATALOG SYMMETRYANALYSIS))(POS (EXAMPLE.DESCRIPTION 4QSDATALOG "Take advantage of the fact that we can order the queens so that the first one is always placed left of the second, the second left of the third, and so on.  To do this, we use less-than instead of just distinct."))(POS (EXAMPLE.EFFICIENCYGAINS 4QSDATALOG "5x"))(POS (MATRIXSHOW 4QSDATALOG TRUE))(POS (EXAMPLE.COMMENTS 4QSDATALOG "We should be able to detect the fact that the query doesn't care about what order the queens are in; determining that less-than can be used and how to do that should then be possible."))(POS (EXAMPLE.SOURCEQUERY 4QSDATALOG "ent"))(POS (EXAMPLE.SOURCE 4QSDATALOG "  (<= ent
      (not notent))
  (<= notent
      (goal17 ?X1 ?Y1 ?X2 ?Y2 ?X3 ?Y3 ?X4 ?Y4)
      (not (phi ?X1 ?Y1 ?X2 ?Y2 ?X3 ?Y3 ?X4 ?Y4)))
 
  (<= (phi ?X1 ?Y1 ?X2 ?Y2 ?X3 ?Y3 ?X4 ?Y4)
      (or (distinct ?x1 1)
          (distinct ?y1 1))
      (or (distinct ?x2 1)
          (distinct ?y2 1))
      (or (distinct ?x3 1)
          (distinct ?y3 1))
      (or (distinct ?x4 1)
          (distinct ?y4 1)))
      
  ; below ne is the not equal table
  (<= (goal17 ?X1 ?Y1 ?X2 ?Y2 ?X3 ?Y3 ?X4 ?Y4)
      
      (sub ?y1 ?x1 ?neg1)
      (add ?y1 ?x1 ?pos1)
      (sub ?y2 ?x2 ?neg2)
      (distinct ?X1 ?X2)
      (distinct ?Y1 ?Y2)
      (distinct ?neg2 ?neg1)
      (add ?y2 ?x2 ?pos2)
      (distinct ?pos2 ?pos1)
      
      
      (sub ?y3 ?x3 ?neg3)
      (distinct ?X1 ?X3) 
      (distinct ?Y1 ?Y3)
      (distinct ?X2 ?X3)
      (distinct ?Y2 ?Y3)
      (distinct ?neg3 ?neg2)
      (distinct ?neg3 ?neg1)
      (add ?y3 ?x3 ?pos3)
      (distinct ?pos3 ?pos2)
      (distinct ?pos3 ?pos1)
      
      (sub ?y4 ?x4 ?neg4)
      (distinct ?X1 ?X4)
      (distinct ?X2 ?X4)
      (distinct ?X3 ?X4)
      (distinct ?Y1 ?Y4)
      (distinct ?Y2 ?Y4)
      (distinct ?Y3 ?Y4)
      (distinct ?neg4 ?neg3)
      (distinct ?neg4 ?neg2)
      (distinct ?neg4 ?neg1)
      (add ?y4 ?x4 ?pos4)
      (distinct ?pos4 ?pos3)
      (distinct ?pos4 ?pos2)
      (distinct ?pos4 ?pos1))
  
  (add 1 1 2)
  (add 1 2 3)
  (add 1 3 4)
  (add 1 4 5)
  (add 2 1 3)
  (add 2 2 4)
  (add 2 3 5)
  (add 2 4 6)
  (add 3 1 4)
  (add 3 2 5)
  (add 3 3 6)
  (add 3 4 7)
  (add 4 1 5)
  (add 4 2 6)
  (add 4 3 7)
  (add 4 4 8)

  (sub 1 1 0)
  (sub 1 2 -1)
  (sub 1 3 -2)
  (sub 1 4 -3)
  (sub 2 1 1)
  (sub 2 2 0)
  (sub 2 3 -1)
  (sub 2 4 -2)
  (sub 3 1 2)
  (sub 3 2 1)
  (sub 3 3 0)
  (sub 3 4 -1)
  (sub 4 1 3)
  (sub 4 2 2)
  (sub 4 3 1)
  (sub 4 4 0)"))(POS (EXAMPLE.TARGETQUERY 4QSDATALOG "ent"))(POS (EXAMPLE.TARGET 4QSDATALOG "  (<= ent
      (not notent))
  (<= notent
      (goal17 ?X1 ?Y1 ?X2 ?Y2 ?X3 ?Y3 ?X4 ?Y4)
      (not (phi ?X1 ?Y1 ?X2 ?Y2 ?X3 ?Y3 ?X4 ?Y4)))
 
  (<= (phi ?X1 ?Y1 ?X2 ?Y2 ?X3 ?Y3 ?X4 ?Y4)
      (or (distinct ?x1 1)
          (distinct ?y1 1))
      (or (distinct ?x2 1)
          (distinct ?y2 1))
      (or (distinct ?x3 1)
          (distinct ?y3 1))
      (or (distinct ?x4 1)
          (distinct ?y4 1)))
      
  ; below ne is the not equal table
  (<= (goal17 ?X1 ?Y1 ?X2 ?Y2 ?X3 ?Y3 ?X4 ?Y4)
      
      (sub ?y1 ?x1 ?neg1)
      (add ?y1 ?x1 ?pos1)
      (sub ?y2 ?x2 ?neg2)
      (< ?x1 ?x2)
      (distinct ?y1 ?y2)
      (distinct ?neg2 ?neg1)
      (add ?y2 ?x2 ?pos2)
      (distinct ?pos2 ?pos1)
      
      
      (sub ?y3 ?x3 ?neg3)
      (< ?x2 ?x3)
      (distinct ?y3 ?y1)
      (distinct ?y3 ?y2)
      (distinct ?neg3 ?neg2)
      (distinct ?neg3 ?neg1)
      (add ?y3 ?x3 ?pos3)
      (distinct ?pos3 ?pos2)
      (distinct ?pos3 ?pos1)
      
      (sub ?y4 ?x4 ?neg4)
      (< ?x3 ?x4)
      (distinct ?y4 ?y1)
      (distinct ?y4 ?y2)
      (distinct ?y4 ?y3)
      (distinct ?neg4 ?neg3)
      (distinct ?neg4 ?neg2)
      (distinct ?neg4 ?neg1)
      (add ?y4 ?x4 ?pos4)
      (distinct ?pos4 ?pos3)
      (distinct ?pos4 ?pos2)
      (distinct ?pos4 ?pos1))
  
  (add 1 1 2)
  (add 1 2 3)
  (add 1 3 4)
  (add 1 4 5)
  (add 2 1 3)
  (add 2 2 4)
  (add 2 3 5)
  (add 2 4 6)
  (add 3 1 4)
  (add 3 2 5)
  (add 3 3 6)
  (add 3 4 7)
  (add 4 1 5)
  (add 4 2 6)
  (add 4 3 7)
  (add 4 4 8)

  (sub 1 1 0)
  (sub 1 2 -1)
  (sub 1 3 -2)
  (sub 1 4 -3)
  (sub 2 1 1)
  (sub 2 2 0)
  (sub 2 3 -1)
  (sub 2 4 -2)
  (sub 3 1 2)
  (sub 3 2 1)
  (sub 3 3 0)
  (sub 3 4 -1)
  (sub 4 1 3)
  (sub 4 2 2)
  (sub 4 3 1)
  (sub 4 4 0)"))(NEG (EXAMPLE.COMMENTS 4QUEENS "Add in UNA and DCA for all object constants, i.e. this is finite Herbrand logic."))(POS (EXAMPLE.COMMENTS 4QUEENS "In the source, add in UNA and DCA for all object constants, i.e. this is finite Herbrand logic."))(NEG (EXAMPLE.SOURCE 4QUEENS "
  ; all the queens have different rows
  (<= (not (row ?x ?c))
      (row ?y ?c)
      (not (= ?x ?y)))

  ; all the queens have different columns
  (<= (not (col ?x ?c))
      (col ?y ?c)
      (not (= ?x ?y)))

  ; given a row and column, we can compute the two diagonals it is on.
  (<= (d ?q pos ?z) (row ?q ?x) (col ?q ?y) (sub ?y ?x ?z))
  (<= (d ?q neg ?z) (row ?q ?x) (col ?q ?y) (add ?y ?x ?z))

  ; all the queens have different diagonals
  (<= (not (d ?q1 ?sign ?z))
      (d ?q2 ?sign ?z)
      (not (= ?q1 ?q2)))

  ; add and subtract
  (add 1 1 2)
  (add 1 2 3)
  (add 1 3 4)
  (add 1 4 5)
  (add 2 1 3)
  (add 2 2 4)
  (add 2 3 5)
  (add 2 4 6)
  (add 3 1 4)
  (add 3 2 5)
  (add 3 3 6)
  (add 3 4 7)
  (add 4 1 5)
  (add 4 2 6)
  (add 4 3 7)
  (add 4 4 8)

  (sub 1 1 0)
  (sub 1 2 -1)
  (sub 1 3 -2)
  (sub 1 4 -3)
  (sub 2 1 1)
  (sub 2 2 0)
  (sub 2 3 -1)
  (sub 2 4 -2)
  (sub 3 1 2)
  (sub 3 2 1)
  (sub 3 3 0)
  (sub 3 4 -1)
  (sub 4 1 3)
  (sub 4 2 2)
  (sub 4 3 1)
  (sub 4 4 0)
"))(POS (EXAMPLE.SOURCE 4QUEENS "  ; all the queens have different rows
  (<= (not (row ?x ?c))
      (row ?y ?c)
      (not (= ?x ?y)))

  ; all the queens have different columns
  (<= (not (col ?x ?c))
      (col ?y ?c)
      (not (= ?x ?y)))

  ; given a row and column, we can compute the two diagonals it is on.
  (<= (d ?q pos ?z) (row ?q ?x) (col ?q ?y) (sub ?y ?x ?z))
  (<= (d ?q neg ?z) (row ?q ?x) (col ?q ?y) (add ?y ?x ?z))

  ; all the queens have different diagonals
  (<= (not (d ?q1 ?sign ?z))
      (d ?q2 ?sign ?z)
      (not (= ?q1 ?q2)))

  ; add and subtract
  (add 1 1 2)
  (add 1 2 3)
  (add 1 3 4)
  (add 1 4 5)
  (add 2 1 3)
  (add 2 2 4)
  (add 2 3 5)
  (add 2 4 6)
  (add 3 1 4)
  (add 3 2 5)
  (add 3 3 6)
  (add 3 4 7)
  (add 4 1 5)
  (add 4 2 6)
  (add 4 3 7)
  (add 4 4 8)

  (sub 1 1 0)
  (sub 1 2 -1)
  (sub 1 3 -2)
  (sub 1 4 -3)
  (sub 2 1 1)
  (sub 2 2 0)
  (sub 2 3 -1)
  (sub 2 4 -2)
  (sub 3 1 2)
  (sub 3 2 1)
  (sub 3 3 0)
  (sub 3 4 -1)
  (sub 4 1 3)
  (sub 4 2 2)
  (sub 4 3 1)
  (sub 4 4 0)
"))(POS (EXAMPLE.INSTANCE NQUEENS))(POS (PRETTYNAME NQUEENS "N-Queens"))(POS (SHORTNAME NQUEENS "nqueens"))(POS (EXAMPLE.COMPLETE NQUEENS INCOMPLETE))(POS (EXAMPLE.TECHNIQUE NQUEENS BILEVEL))(POS (EXAMPLE.TECHNIQUE NQUEENS NAF))(POS (EXAMPLE.TECHNIQUE NQUEENS CONSISTENCY2DEDUCTION))(POS (EXAMPLE.TECHNIQUE NQUEENS UNNAMED))(POS (EXAMPLE.DESCRIPTION NQUEENS "Here we use (a minimal-model semantic version of) metalevel logic to describe the class of all X-queens queries, where the constraints are written as usual in FHL.  The recursive query definition is guarded by a single table that says how many queens are available (which I believe may play a crucial role in doing the translation).  The datalog version uses recursion and functions, again bounded by the single table with the number of queens.  "))(POS (MATRIXSHOW NQUEENS TRUE))(POS (EXAMPLE.COMMENTS NQUEENS "Here we can do the reformulation once and apply it to any n-queens problem by simply changing the value in that NumQueens table and the add/sub facts.  We pay a little more in interpreting the Datalog because of the added recursion.

This example illustrates just C2D: we just want to enumerate all the solutiions.  (query ?x) is true in the Datalog version if ?x is a list of queen locations, ?x satisfies the constraints of n-queens, and ?x has n locations, where n is the value in the table querylength.
"))(POS (EXAMPLE.SOURCEQUERY NQUEENS "  (query ?x)"))(POS (EXAMPLE.SOURCE NQUEENS "
 ;;;;;;;;;; metalevel query definition ;;;;;;;;;;;;
(<= (query ?x)
      (queens ?x)
      (query-length ?n)
      (length ?x ?n))

  (<= (queen \"(and (row <?q> <?x>) (col <?q> <?y>))\")
      (queen ?q)
      (var ?x)
      (var ?y)
      (not (= ?x ?y)))

  (<= (queens \"(and ?x ?y)\")
      (queen ?x)
      (queens ?y))

  (<= (length \"(?x ?y ?z)\" (s 0))
      (not (= ?x \"and\")))
  (<= (length \"(and <?x> <?y>)\" (s ?z))
      (length ?y ?z))

  ;;;;;;; then we have the normal constraints ;;;;;;;;
  ; all the queens have different rows
  (<= (not (row ?x ?c))
      (row ?y ?c)
      (not (= ?x ?y)))

  ; all the queens have different columns
  (<= (not (col ?x ?c))
      (col ?y ?c)
      (not (= ?x ?y)))

  ; given a row and column, we can compute the two diagonals it is on.
  (<= (d ?q pos ?z) (row ?q ?x) (col ?q ?y) (sub ?y ?x ?z))
  (<= (d ?q neg ?z) (row ?q ?x) (col ?q ?y) (add ?y ?x ?z))

  ; all the queens have different diagonals
  (<= (not (d ?q1 ?sign ?z))
      (d ?q2 ?sign ?z)
      (not (= ?q1 ?q2)))

  ; add and subtract
  (add 1 1 2)
  (add 1 2 3)
  (add 1 3 4)
  (add 1 4 5)
  (add 2 1 3)
  (add 2 2 4)
  (add 2 3 5)
  (add 2 4 6)
  (add 3 1 4)
  (add 3 2 5)
  (add 3 3 6)
  (add 3 4 7)
  (add 4 1 5)
  (add 4 2 6)
  (add 4 3 7)
  (add 4 4 8)

  (sub 1 1 0)
  (sub 1 2 -1)
  (sub 1 3 -2)
  (sub 1 4 -3)
  (sub 2 1 1)
  (sub 2 2 0)
  (sub 2 3 -1)
  (sub 2 4 -2)
  (sub 3 1 2)
  (sub 3 2 1)
  (sub 3 3 0)
  (sub 3 4 -1)
  (sub 4 1 3)
  (sub 4 2 2)
  (sub 4 3 1)
  (sub 4 4 0)
"))(POS (EXAMPLE.TARGETQUERY NQUEENS "(query ?x)"))(POS (EXAMPLE.TARGET NQUEENS "  (<= (query ?x)
      (querylength ?n)
      (ans ?x ?n))

  (<= (ans nil 0))
  (<= (ans (f ?x ?y) (s ?z))
      (ans ?y ?z)
      (augmentans ?x ?y))

  (<= (augmentans ?x ?y)
      (place-queen ?x)
      (not (some-queen-attacks ?x ?y)))

  (<= (place-queen (loc ?x ?y ?neg ?pos))
      (sub ?y ?x ?neg)
      (add ?y ?x ?pos))
      
  (<= (some-queen-attacks (loc ?x ?y ?neg ?pos) (f (loc ?x2 ?y2 ?neg2 ?pos2) ?rest))
      (or (= ?x ?x2)
          (= ?y ?y2)
          (= ?neg ?neg2)
          (= ?pos ?pos2)
          (some-queen-attacks (loc ?x ?y ?neg ?pos) ?rest)))
  (= ?x ?x)

  (querylength (s (s (s (s 0)))))
  (add 1 1 2)
  (add 1 2 3)
  (add 1 3 4)
  (add 1 4 5)
  (add 2 1 3)
  (add 2 2 4)
  (add 2 3 5)
  (add 2 4 6)
  (add 3 1 4)
  (add 3 2 5)
  (add 3 3 6)
  (add 3 4 7)
  (add 4 1 5)
  (add 4 2 6)
  (add 4 3 7)
  (add 4 4 8)

  (sub 1 1 0)
  (sub 1 2 -1)
  (sub 1 3 -2)
  (sub 1 4 -3)
  (sub 2 1 1)
  (sub 2 2 0)
  (sub 2 3 -1)
  (sub 2 4 -2)
  (sub 3 1 2)
  (sub 3 2 1)
  (sub 3 3 0)
  (sub 3 4 -1)
  (sub 4 1 3)
  (sub 4 2 2)
  (sub 4 3 1)
  (sub 4 4 0)
"))(POS (EXAMPLE.INSTANCE WUMPUSPERCEPTS))(POS (PRETTYNAME WUMPUSPERCEPTS "Wumpus World with Percepts"))(POS (SHORTNAME WUMPUSPERCEPTS "wumpus.per"))(POS (EXAMPLE.COMPLETE WUMPUSPERCEPTS INCOMPLETE))(POS (EXAMPLE.TECHNIQUE WUMPUSPERCEPTS BILEVEL))(POS (EXAMPLE.TECHNIQUE WUMPUSPERCEPTS CONSISTENCY2DEDUCTION))(POS (EXAMPLE.TECHNIQUE WUMPUSPERCEPTS NAF))(POS (EXAMPLE.TECHNIQUE WUMPUSPERCEPTS UNNAMED))(POS (EXAMPLE.DESCRIPTION WUMPUSPERCEPTS "A snapshot of wumpus world, after sensing a stench at one location and a shine at another.  Is the gold to the west of the wumpus in all cases?  Translate this problem stated in logic, where the data is the set of percepts, into a datalog program (with a single function for representing the structure of a grid location) that checks the entailment by cases."))(POS (MATRIXSHOW WUMPUSPERCEPTS TRUE))(POS (EXAMPLE.COMMENTS WUMPUSPERCEPTS "There is nothing mystical about introducing (cell x y) instead of sticking to opaque names for cells.  It was partly laziness and partly I believe we may be able to automatically produce this translation by analyzing the constraints on the data (which we might include as integrity constraints)."))(POS (EXAMPLE.SOURCEQUERY WUMPUSPERCEPTS "      (=> (gold ?x) (wumpus ?y) (westof ?x ?y)))
"))(POS (EXAMPLE.SOURCE WUMPUSPERCEPTS "  (north a e)
  (north e i)
  (north i m)
  (north b f)
  (north f j)
  (north j n)
  (north c g)
  (north g k)
  (north k o)
  (north d h)
  (north h l)
  (north l p)

  (east a b)
  (east b c)
  (east c d)
  (east e f)
  (east f g)
  (east g h)
  (east i j)
  (east j k)
  (east k l)
  (east m n)
  (east n o)
  (east o p)


  (<=> (west ?x ?y) (east ?y ?x))
  (<=> (south ?x ?y) (north ?y ?x))

  (<=> (westof ?x ?y)
       (or (west ?x ?y)
           (exists ?z (and (west ?x ?z) (west ?z ?y)))
           (exists (?z ?w) (and (west ?x ?z) (west ?z ?w) (west ?w ?y)))))

  (westborder e)
  (westborder i)
  (eastborder h)
  (eastborder l)
  (northborder b)
  (northborder c)
  (southborder n)
  (southborder o)

  (nwcorner a)
  (necorner d)
  (swcorner m)
  (secorner p)
  
  (notborder f)
  (notborder g)
  (notborder j)
  (notborder k)


  ; center
  (=> (stench ?cell)
      (notborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?celle)
          (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (notborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))
           (not (wumpus ?cellw))
           (not (wumpus ?cells))))

  ;;; borders

  ;west
  (=> (stench ?cell)
      (westborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (or (wumpus ?celln)
          (wumpus ?celle)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (westborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))
           (not (wumpus ?cells))))


  ; north
  (=> (stench ?cell)
      (northborder ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (or (wumpus ?celle)
          (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (northborder ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (and (not (wumpus ?celle))
           (not (wumpus ?cellw))
           (not (wumpus ?cells))))

      
  ; south
  (=> (stench ?cell)
      (southborder ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?celle)
          (wumpus ?cellw)))

  (=> (not (stench ?cell))
      (southborder ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))
           (not (wumpus ?cellw))))

  ; east
  (=> (stench ?cell)
      (eastborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (eastborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?cellw))
           (not (wumpus ?cells))))

  ;;; corners

  ; nw
  (=> (stench ?cell)
      (nwcorner ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (or (wumpus ?celle)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (nwcorner ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (and (not (wumpus ?celle))
           (not (wumpus ?cells))))

  ; ne
  (=> (stench ?cell)
      (necorner ?cell)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (or (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (necorner ?cell)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (and (not (wumpus ?cellw))
           (not (wumpus ?cells))))

  ; sw
  (=> (stench ?cell)
      (wwcorner ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (or (wumpus ?celln)
          (wumpus ?celle)))

  (=> (not (stench ?cell))
      (wwcorner ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))))

  ; se
  (=> (stench ?cell)
      (secorner ?cell)
      (north ?cell ?celln)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?cellw)))

  (=> (not (stench ?cell))
      (secorner ?cell)
      (north ?cell ?celln)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?cellw))))

  ;(or (wumpus a) (wumpus b) (wumpus c) (wumpus d) (wumpus e) (wumpus f) (wumpus g) (wumpus h) (wumpus i))

  (shiney e)
  (not (stench e))
  (stench l)
  (not (shiney l))
"))(POS (EXAMPLE.TARGETQUERY WUMPUSPERCEPTS "ent"))(POS (EXAMPLE.TARGET WUMPUSPERCEPTS "(deftheory datalog-wumpusworld2

  (<= ent
      (not notent))
  (<= notent
      (possworld ?x ?y)
      (not (westof ?x ?y)))

  (<= (westof ?x ?y)
      (or (west ?x ?y)
          (and (west ?x ?z) (west ?z ?y))
          (and (west ?x ?z) (west ?z ?w) (west ?w ?y))))

  (<= (possworld ?x ?y)
      (possgold ?x)
      (posswumpus ?y))

  ; poss gold
  (<= (possgold ?x)
      (adjacentshiney ?x)
      (not (some-adjacentnonshiney ?x))
      (not (some-nonadjacentshiney ?x)))

  (<= (adjacentshiney ?x)
      (shiney ?s)
      (adjacent ?s ?x))

  (<= (some-nonadjacentshiney ?x)
      (shiney ?s)
      (not (adjacent ?s ?x)))

  (<= (some-adjacentnonshiney ?x)
      (adjacent ?x ?y)
      (nshiney ?y))

  ; poss wumpus
  (<= (posswumpus ?x)
      (adjacentstench ?x)
      (not (some-adjacentnonstench ?x))
      (not (some-nonadjacentstench ?x)))

  (<= (adjacentstench ?x)
      (stench ?s)
      (adjacent ?s ?x))

  (<= (some-nonadjacentstench ?x)
      (stench ?s)
      (not (adjacent ?s ?x)))

  (<= (some-adjacentnonstench ?x)
      (adjacent ?x ?y)
      (nstench ?y))
      

  (adj 1 2)
  (adj 2 3)
  (adj 3 4)
  (<= (next ?x ?y)
      (or (adj ?x ?y) (adj ?y ?x)))
  
  (<= (adjacent (cell ?x ?y) (cell ?z ?y))
      (next ?x ?z))

  (<= (adjacent (cell ?x ?y) (cell ?x ?w))
      (next ?y ?w))

  (<= (adjacent (cell ?x ?y) (cell ?z ?w))
      (next ?x ?z)
      (next ?y ?w))

  (<= (west (cell ?x ?y) (cell ?x2 ?w))
      (adj ?x ?x2))

  (shiney (cell 1 3))
  (nstench (cell 1 3))
  (stench (cell 4 2))
  (nshiney (cell 4 2))
)"))(NEG (EXAMPLE.TARGET WUMPUSPERCEPTS "(deftheory datalog-wumpusworld2

  (<= ent
      (not notent))
  (<= notent
      (possworld ?x ?y)
      (not (westof ?x ?y)))

  (<= (westof ?x ?y)
      (or (west ?x ?y)
          (and (west ?x ?z) (west ?z ?y))
          (and (west ?x ?z) (west ?z ?w) (west ?w ?y))))

  (<= (possworld ?x ?y)
      (possgold ?x)
      (posswumpus ?y))

  ; poss gold
  (<= (possgold ?x)
      (adjacentshiney ?x)
      (not (some-adjacentnonshiney ?x))
      (not (some-nonadjacentshiney ?x)))

  (<= (adjacentshiney ?x)
      (shiney ?s)
      (adjacent ?s ?x))

  (<= (some-nonadjacentshiney ?x)
      (shiney ?s)
      (not (adjacent ?s ?x)))

  (<= (some-adjacentnonshiney ?x)
      (adjacent ?x ?y)
      (nshiney ?y))

  ; poss wumpus
  (<= (posswumpus ?x)
      (adjacentstench ?x)
      (not (some-adjacentnonstench ?x))
      (not (some-nonadjacentstench ?x)))

  (<= (adjacentstench ?x)
      (stench ?s)
      (adjacent ?s ?x))

  (<= (some-nonadjacentstench ?x)
      (stench ?s)
      (not (adjacent ?s ?x)))

  (<= (some-adjacentnonstench ?x)
      (adjacent ?x ?y)
      (nstench ?y))
      

  (adj 1 2)
  (adj 2 3)
  (adj 3 4)
  (<= (next ?x ?y)
      (or (adj ?x ?y) (adj ?y ?x)))
  
  (<= (adjacent (cell ?x ?y) (cell ?z ?y))
      (next ?x ?z))

  (<= (adjacent (cell ?x ?y) (cell ?x ?w))
      (next ?y ?w))

  (<= (adjacent (cell ?x ?y) (cell ?z ?w))
      (next ?x ?z)
      (next ?y ?w))

  (<= (west (cell ?x ?y) (cell ?x2 ?w))
      (adj ?x ?x2))

  (shiney (cell 1 3))
  (nstench (cell 1 3))
  (stench (cell 4 2))
  (nshiney (cell 4 2))
)"))(POS (EXAMPLE.TARGET WUMPUSPERCEPTS "  (<= ent
      (not notent))
  (<= notent
      (possworld ?x ?y)
      (not (westof ?x ?y)))

  (<= (westof ?x ?y)
      (or (west ?x ?y)
          (and (west ?x ?z) (west ?z ?y))
          (and (west ?x ?z) (west ?z ?w) (west ?w ?y))))

  (<= (possworld ?x ?y)
      (possgold ?x)
      (posswumpus ?y))

  ; poss gold
  (<= (possgold ?x)
      (adjacentshiney ?x)
      (not (some-adjacentnonshiney ?x))
      (not (some-nonadjacentshiney ?x)))

  (<= (adjacentshiney ?x)
      (shiney ?s)
      (adjacent ?s ?x))

  (<= (some-nonadjacentshiney ?x)
      (shiney ?s)
      (not (adjacent ?s ?x)))

  (<= (some-adjacentnonshiney ?x)
      (adjacent ?x ?y)
      (nshiney ?y))

  ; poss wumpus
  (<= (posswumpus ?x)
      (adjacentstench ?x)
      (not (some-adjacentnonstench ?x))
      (not (some-nonadjacentstench ?x)))

  (<= (adjacentstench ?x)
      (stench ?s)
      (adjacent ?s ?x))

  (<= (some-nonadjacentstench ?x)
      (stench ?s)
      (not (adjacent ?s ?x)))

  (<= (some-adjacentnonstench ?x)
      (adjacent ?x ?y)
      (nstench ?y))
      

  (adj 1 2)
  (adj 2 3)
  (adj 3 4)
  (<= (next ?x ?y)
      (or (adj ?x ?y) (adj ?y ?x)))
  
  (<= (adjacent (cell ?x ?y) (cell ?z ?y))
      (next ?x ?z))

  (<= (adjacent (cell ?x ?y) (cell ?x ?w))
      (next ?y ?w))

  (<= (adjacent (cell ?x ?y) (cell ?z ?w))
      (next ?x ?z)
      (next ?y ?w))

  (<= (west (cell ?x ?y) (cell ?x2 ?w))
      (adj ?x ?x2))

  (shiney (cell 1 3))
  (nstench (cell 1 3))
  (stench (cell 4 2))
  (nshiney (cell 4 2))"))(NEG (EXAMPLE.DESCRIPTION WUMPUSPERCEPTS "A snapshot of wumpus world, after sensing a stench at one location and a shine at another.  Is the gold to the west of the wumpus in all cases?  Translate this problem stated in logic, where the data is the set of percepts, into a datalog program (with a single function for representing the structure of a grid location) that checks the entailment by cases."))(POS (EXAMPLE.DESCRIPTION WUMPUSPERCEPTS "A snapshot of wumpus world, after sensing a stench at one location and a shine at another.  Is the gold to the west of the wumpus in all cases?  Translate this problem stated in logic, where the data is the set of percepts, into a datalog program that checks the entailment by cases.  The tricky part here is that the percept tables (the ones that are supposed to be left out of the transformation) are incomplete; thus, we cannot import them directly into datalog. Because the tables are incomplete but not disjunctive, we create a complete table for stench, another complete table for notstench; likewise for shine.  The stench table includes all those cells where we observed a stench; the notstench table contains all those cells without a stench.  These can both be complete, and we know the environment maintains consistency. "))(NEG (EXAMPLE.COMMENTS WUMPUSPERCEPTS "There is nothing mystical about introducing (cell x y) instead of sticking to opaque names for cells.  It was partly laziness and partly I believe we may be able to automatically produce this translation by analyzing the constraints on the data (which we might include as integrity constraints)."))(POS (EXAMPLE.COMMENTS WUMPUSPERCEPTS "Here I'm using some functions in the source, simply because the problem was easier to write down this way.  It may also be a case that demonstrates that sometimes we can deal with functions.  I'm conflating this with completing the tables stench and shine, but I couldn't bring myself to write it without functions."))(NEG (EXAMPLE.SOURCE WUMPUSPERCEPTS "  (north a e)
  (north e i)
  (north i m)
  (north b f)
  (north f j)
  (north j n)
  (north c g)
  (north g k)
  (north k o)
  (north d h)
  (north h l)
  (north l p)

  (east a b)
  (east b c)
  (east c d)
  (east e f)
  (east f g)
  (east g h)
  (east i j)
  (east j k)
  (east k l)
  (east m n)
  (east n o)
  (east o p)


  (<=> (west ?x ?y) (east ?y ?x))
  (<=> (south ?x ?y) (north ?y ?x))

  (<=> (westof ?x ?y)
       (or (west ?x ?y)
           (exists ?z (and (west ?x ?z) (west ?z ?y)))
           (exists (?z ?w) (and (west ?x ?z) (west ?z ?w) (west ?w ?y)))))

  (westborder e)
  (westborder i)
  (eastborder h)
  (eastborder l)
  (northborder b)
  (northborder c)
  (southborder n)
  (southborder o)

  (nwcorner a)
  (necorner d)
  (swcorner m)
  (secorner p)
  
  (notborder f)
  (notborder g)
  (notborder j)
  (notborder k)


  ; center
  (=> (stench ?cell)
      (notborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?celle)
          (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (notborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))
           (not (wumpus ?cellw))
           (not (wumpus ?cells))))

  ;;; borders

  ;west
  (=> (stench ?cell)
      (westborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (or (wumpus ?celln)
          (wumpus ?celle)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (westborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))
           (not (wumpus ?cells))))


  ; north
  (=> (stench ?cell)
      (northborder ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (or (wumpus ?celle)
          (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (northborder ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (and (not (wumpus ?celle))
           (not (wumpus ?cellw))
           (not (wumpus ?cells))))

      
  ; south
  (=> (stench ?cell)
      (southborder ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?celle)
          (wumpus ?cellw)))

  (=> (not (stench ?cell))
      (southborder ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))
           (not (wumpus ?cellw))))

  ; east
  (=> (stench ?cell)
      (eastborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (eastborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?cellw))
           (not (wumpus ?cells))))

  ;;; corners

  ; nw
  (=> (stench ?cell)
      (nwcorner ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (or (wumpus ?celle)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (nwcorner ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (and (not (wumpus ?celle))
           (not (wumpus ?cells))))

  ; ne
  (=> (stench ?cell)
      (necorner ?cell)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (or (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (necorner ?cell)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (and (not (wumpus ?cellw))
           (not (wumpus ?cells))))

  ; sw
  (=> (stench ?cell)
      (wwcorner ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (or (wumpus ?celln)
          (wumpus ?celle)))

  (=> (not (stench ?cell))
      (wwcorner ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))))

  ; se
  (=> (stench ?cell)
      (secorner ?cell)
      (north ?cell ?celln)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?cellw)))

  (=> (not (stench ?cell))
      (secorner ?cell)
      (north ?cell ?celln)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?cellw))))

  ;(or (wumpus a) (wumpus b) (wumpus c) (wumpus d) (wumpus e) (wumpus f) (wumpus g) (wumpus h) (wumpus i))

  (shiney e)
  (not (stench e))
  (stench l)
  (not (shiney l))
"))(POS (EXAMPLE.SOURCE WUMPUSPERCEPTS "
  (succ 1 2)
  (succ 2 3)
  (succ 3 4)

  (<=> (next ?x ?y)
       (or (succ ?x ?y)
           (succ ?y ?x)))

  (<=> (west (cell ?x ?y) (cell ?x2 ?y))
       (succ ?x2 ?x))
  (<=> (north (cell ?x ?y) (cell ?x ?y2))
       (succ ?y2 ?y))
  
  (<=> (east ?x ?y) (west ?y ?x))
  (<=> (south ?x ?y) (north ?y ?x))

  (<=> (westof (cell ?x ?y) (cell ?x2 ?y2))
       (or (adj ?x ?x2)
           (exists ?z (and (adj ?x ?z) (adj ?z ?x2)))
           (exists (?z ?w) (and (adj ?x ?z) (adj ?z ?w) (adj ?w ?x2)))))

  (<=> (westborder (cell 1 ?x))
       (not (= ?x 1))
       (not (= ?x 4)))

  (<=> (eastborder (cell 4 ?x))
       (not (= ?x 1))
       (not (= ?x 4)))

  (<=> (southborder (cell ?x 1))
       (not (= ?x 1))
       (not (= ?x 4)))

  (<=> (northborder (cell ?x 4))
       (not (= ?x 1))
       (not (= ?x 4)))

  (nwcorner (cell 1 4))
  (necorner (cell 4 4))
  (swcorner (cell 1 1))
  (secorner (cell 4 1))
  
  (<=> (notborder (cell ?x ?y))
       (and (not (= ?x 1))
            (not (= ?x 4))
            (not (= ?y 1))
            (not (= ?y 4))))

  ; center
  (=> (stench ?cell)
      (notborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?celle)
          (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (notborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))
           (not (wumpus ?cellw))
           (not (wumpus ?cells))))

  ;;; borders

  ;west
  (=> (stench ?cell)
      (westborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (or (wumpus ?celln)
          (wumpus ?celle)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (westborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))
           (not (wumpus ?cells))))


  ; north
  (=> (stench ?cell)
      (northborder ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (or (wumpus ?celle)
          (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (northborder ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (and (not (wumpus ?celle))
           (not (wumpus ?cellw))
           (not (wumpus ?cells))))

      
  ; south
  (=> (stench ?cell)
      (southborder ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?celle)
          (wumpus ?cellw)))

  (=> (not (stench ?cell))
      (southborder ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))
           (not (wumpus ?cellw))))

  ; east
  (=> (stench ?cell)
      (eastborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (eastborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?cellw))
           (not (wumpus ?cells))))

  ;;; corners

  ; nw
  (=> (stench ?cell)
      (nwcorner ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (or (wumpus ?celle)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (nwcorner ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (and (not (wumpus ?celle))
           (not (wumpus ?cells))))

  ; ne
  (=> (stench ?cell)
      (necorner ?cell)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (or (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (necorner ?cell)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (and (not (wumpus ?cellw))
           (not (wumpus ?cells))))

  ; sw
  (=> (stench ?cell)
      (wwcorner ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (or (wumpus ?celln)
          (wumpus ?celle)))

  (=> (not (stench ?cell))
      (wwcorner ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))))

  ; se
  (=> (stench ?cell)
      (secorner ?cell)
      (north ?cell ?celln)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?cellw)))

  (=> (not (stench ?cell))
      (secorner ?cell)
      (north ?cell ?celln)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?cellw))))

  (exists (?x ?y) (wumpus (cell ?x ?y)))

  (shiney (cell 1 3))
  (not (stench (cell 1 3)))
  (stench (cell 4 2))
  (not (shiney (cell 4 2)))
"))(NEG (EXAMPLE.SOURCEQUERY WUMPUSPERCEPTS "      (=> (gold ?x) (wumpus ?y) (westof ?x ?y)))
"))(POS (EXAMPLE.SOURCEQUERY WUMPUSPERCEPTS "      (=> (gold ?x) (wumpus ?y) (westof ?x ?y))
"))(NEG (EXAMPLE.SOURCE WUMPUSPERCEPTS "
  (succ 1 2)
  (succ 2 3)
  (succ 3 4)

  (<=> (next ?x ?y)
       (or (succ ?x ?y)
           (succ ?y ?x)))

  (<=> (west (cell ?x ?y) (cell ?x2 ?y))
       (succ ?x2 ?x))
  (<=> (north (cell ?x ?y) (cell ?x ?y2))
       (succ ?y2 ?y))
  
  (<=> (east ?x ?y) (west ?y ?x))
  (<=> (south ?x ?y) (north ?y ?x))

  (<=> (westof (cell ?x ?y) (cell ?x2 ?y2))
       (or (adj ?x ?x2)
           (exists ?z (and (adj ?x ?z) (adj ?z ?x2)))
           (exists (?z ?w) (and (adj ?x ?z) (adj ?z ?w) (adj ?w ?x2)))))

  (<=> (westborder (cell 1 ?x))
       (not (= ?x 1))
       (not (= ?x 4)))

  (<=> (eastborder (cell 4 ?x))
       (not (= ?x 1))
       (not (= ?x 4)))

  (<=> (southborder (cell ?x 1))
       (not (= ?x 1))
       (not (= ?x 4)))

  (<=> (northborder (cell ?x 4))
       (not (= ?x 1))
       (not (= ?x 4)))

  (nwcorner (cell 1 4))
  (necorner (cell 4 4))
  (swcorner (cell 1 1))
  (secorner (cell 4 1))
  
  (<=> (notborder (cell ?x ?y))
       (and (not (= ?x 1))
            (not (= ?x 4))
            (not (= ?y 1))
            (not (= ?y 4))))

  ; center
  (=> (stench ?cell)
      (notborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?celle)
          (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (notborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))
           (not (wumpus ?cellw))
           (not (wumpus ?cells))))

  ;;; borders

  ;west
  (=> (stench ?cell)
      (westborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (or (wumpus ?celln)
          (wumpus ?celle)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (westborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))
           (not (wumpus ?cells))))


  ; north
  (=> (stench ?cell)
      (northborder ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (or (wumpus ?celle)
          (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (northborder ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (and (not (wumpus ?celle))
           (not (wumpus ?cellw))
           (not (wumpus ?cells))))

      
  ; south
  (=> (stench ?cell)
      (southborder ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?celle)
          (wumpus ?cellw)))

  (=> (not (stench ?cell))
      (southborder ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))
           (not (wumpus ?cellw))))

  ; east
  (=> (stench ?cell)
      (eastborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (eastborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?cellw))
           (not (wumpus ?cells))))

  ;;; corners

  ; nw
  (=> (stench ?cell)
      (nwcorner ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (or (wumpus ?celle)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (nwcorner ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (and (not (wumpus ?celle))
           (not (wumpus ?cells))))

  ; ne
  (=> (stench ?cell)
      (necorner ?cell)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (or (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (necorner ?cell)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (and (not (wumpus ?cellw))
           (not (wumpus ?cells))))

  ; sw
  (=> (stench ?cell)
      (wwcorner ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (or (wumpus ?celln)
          (wumpus ?celle)))

  (=> (not (stench ?cell))
      (wwcorner ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))))

  ; se
  (=> (stench ?cell)
      (secorner ?cell)
      (north ?cell ?celln)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?cellw)))

  (=> (not (stench ?cell))
      (secorner ?cell)
      (north ?cell ?celln)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?cellw))))

  (exists (?x ?y) (wumpus (cell ?x ?y)))

  (shiney (cell 1 3))
  (not (stench (cell 1 3)))
  (stench (cell 4 2))
  (not (shiney (cell 4 2)))
"))(POS (EXAMPLE.SOURCE WUMPUSPERCEPTS "  (succ 1 2)
  (succ 2 3)
  (succ 3 4)

  (<=> (next ?x ?y)
       (or (succ ?x ?y)
           (succ ?y ?x)))

  (<=> (west (cell ?x ?y) (cell ?x2 ?y))
       (succ ?x2 ?x))
  (<=> (north (cell ?x ?y) (cell ?x ?y2))
       (succ ?y2 ?y))
  
  (<=> (east ?x ?y) (west ?y ?x))
  (<=> (south ?x ?y) (north ?y ?x))

  (<=> (westof (cell ?x ?y) (cell ?x2 ?y2))
       (or (adj ?x ?x2)
           (exists ?z (and (adj ?x ?z) (adj ?z ?x2)))
           (exists (?z ?w) (and (adj ?x ?z) (adj ?z ?w) (adj ?w ?x2)))))

  (<=> (westborder (cell 1 ?x))
       (not (= ?x 1))
       (not (= ?x 4)))

  (<=> (eastborder (cell 4 ?x))
       (not (= ?x 1))
       (not (= ?x 4)))

  (<=> (southborder (cell ?x 1))
       (not (= ?x 1))
       (not (= ?x 4)))

  (<=> (northborder (cell ?x 4))
       (not (= ?x 1))
       (not (= ?x 4)))

  (nwcorner (cell 1 4))
  (necorner (cell 4 4))
  (swcorner (cell 1 1))
  (secorner (cell 4 1))
  
  (<=> (notborder (cell ?x ?y))
       (and (not (= ?x 1))
            (not (= ?x 4))
            (not (= ?y 1))
            (not (= ?y 4))))

  ; center
  (=> (stench ?cell)
      (notborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?celle)
          (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (notborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))
           (not (wumpus ?cellw))
           (not (wumpus ?cells))))

  ;;; borders

  ;west
  (=> (stench ?cell)
      (westborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (or (wumpus ?celln)
          (wumpus ?celle)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (westborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))
           (not (wumpus ?cells))))


  ; north
  (=> (stench ?cell)
      (northborder ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (or (wumpus ?celle)
          (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (northborder ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (and (not (wumpus ?celle))
           (not (wumpus ?cellw))
           (not (wumpus ?cells))))

      
  ; south
  (=> (stench ?cell)
      (southborder ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?celle)
          (wumpus ?cellw)))

  (=> (not (stench ?cell))
      (southborder ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))
           (not (wumpus ?cellw))))

  ; east
  (=> (stench ?cell)
      (eastborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (eastborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?cellw))
           (not (wumpus ?cells))))

  ;;; corners

  ; nw
  (=> (stench ?cell)
      (nwcorner ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (or (wumpus ?celle)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (nwcorner ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (and (not (wumpus ?celle))
           (not (wumpus ?cells))))

  ; ne
  (=> (stench ?cell)
      (necorner ?cell)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (or (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (necorner ?cell)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (and (not (wumpus ?cellw))
           (not (wumpus ?cells))))

  ; sw
  (=> (stench ?cell)
      (wwcorner ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (or (wumpus ?celln)
          (wumpus ?celle)))

  (=> (not (stench ?cell))
      (wwcorner ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))))

  ; se
  (=> (stench ?cell)
      (secorner ?cell)
      (north ?cell ?celln)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?cellw)))

  (=> (not (stench ?cell))
      (secorner ?cell)
      (north ?cell ?celln)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?cellw))))

  (exists (?x ?y) (wumpus (cell ?x ?y)))

  (shiney (cell 1 3))
  (not (stench (cell 1 3)))
  (stench (cell 4 2))
  (not (shiney (cell 4 2)))
"))(NEG (EXAMPLE.SOURCE WUMPUSPERCEPTS "  (succ 1 2)
  (succ 2 3)
  (succ 3 4)

  (<=> (next ?x ?y)
       (or (succ ?x ?y)
           (succ ?y ?x)))

  (<=> (west (cell ?x ?y) (cell ?x2 ?y))
       (succ ?x2 ?x))
  (<=> (north (cell ?x ?y) (cell ?x ?y2))
       (succ ?y2 ?y))
  
  (<=> (east ?x ?y) (west ?y ?x))
  (<=> (south ?x ?y) (north ?y ?x))

  (<=> (westof (cell ?x ?y) (cell ?x2 ?y2))
       (or (adj ?x ?x2)
           (exists ?z (and (adj ?x ?z) (adj ?z ?x2)))
           (exists (?z ?w) (and (adj ?x ?z) (adj ?z ?w) (adj ?w ?x2)))))

  (<=> (westborder (cell 1 ?x))
       (not (= ?x 1))
       (not (= ?x 4)))

  (<=> (eastborder (cell 4 ?x))
       (not (= ?x 1))
       (not (= ?x 4)))

  (<=> (southborder (cell ?x 1))
       (not (= ?x 1))
       (not (= ?x 4)))

  (<=> (northborder (cell ?x 4))
       (not (= ?x 1))
       (not (= ?x 4)))

  (nwcorner (cell 1 4))
  (necorner (cell 4 4))
  (swcorner (cell 1 1))
  (secorner (cell 4 1))
  
  (<=> (notborder (cell ?x ?y))
       (and (not (= ?x 1))
            (not (= ?x 4))
            (not (= ?y 1))
            (not (= ?y 4))))

  ; center
  (=> (stench ?cell)
      (notborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?celle)
          (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (notborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))
           (not (wumpus ?cellw))
           (not (wumpus ?cells))))

  ;;; borders

  ;west
  (=> (stench ?cell)
      (westborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (or (wumpus ?celln)
          (wumpus ?celle)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (westborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))
           (not (wumpus ?cells))))


  ; north
  (=> (stench ?cell)
      (northborder ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (or (wumpus ?celle)
          (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (northborder ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (and (not (wumpus ?celle))
           (not (wumpus ?cellw))
           (not (wumpus ?cells))))

      
  ; south
  (=> (stench ?cell)
      (southborder ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?celle)
          (wumpus ?cellw)))

  (=> (not (stench ?cell))
      (southborder ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))
           (not (wumpus ?cellw))))

  ; east
  (=> (stench ?cell)
      (eastborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (eastborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?cellw))
           (not (wumpus ?cells))))

  ;;; corners

  ; nw
  (=> (stench ?cell)
      (nwcorner ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (or (wumpus ?celle)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (nwcorner ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (and (not (wumpus ?celle))
           (not (wumpus ?cells))))

  ; ne
  (=> (stench ?cell)
      (necorner ?cell)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (or (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (necorner ?cell)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (and (not (wumpus ?cellw))
           (not (wumpus ?cells))))

  ; sw
  (=> (stench ?cell)
      (wwcorner ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (or (wumpus ?celln)
          (wumpus ?celle)))

  (=> (not (stench ?cell))
      (wwcorner ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))))

  ; se
  (=> (stench ?cell)
      (secorner ?cell)
      (north ?cell ?celln)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?cellw)))

  (=> (not (stench ?cell))
      (secorner ?cell)
      (north ?cell ?celln)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?cellw))))

  (exists (?x ?y) (wumpus (cell ?x ?y)))

  (shiney (cell 1 3))
  (not (stench (cell 1 3)))
  (stench (cell 4 2))
  (not (shiney (cell 4 2)))
"))(POS (EXAMPLE.SOURCE WUMPUSPERCEPTS "
  (succ 1 2)
  (succ 2 3)
  (succ 3 4)

  (<=> (next ?x ?y)
       (or (succ ?x ?y)
           (succ ?y ?x)))

  (<=> (west (cell ?x ?y) (cell ?x2 ?y))
       (succ ?x2 ?x))
  (<=> (north (cell ?x ?y) (cell ?x ?y2))
       (succ ?y2 ?y))
  
  (<=> (east ?x ?y) (west ?y ?x))
  (<=> (south ?x ?y) (north ?y ?x))

  (<=> (westof (cell ?x ?y) (cell ?x2 ?y2))
       (or (succ ?x ?x2)
           (exists ?z (and (succ ?x ?z) (succ ?z ?x2)))
           (exists (?z ?w) (and (succ ?x ?z) (succ ?z ?w) (succ ?w ?x2)))))

  (<=> (westborder (cell 1 ?x))
       (not (= ?x 1))
       (not (= ?x 4)))

  (<=> (eastborder (cell 4 ?x))
       (not (= ?x 1))
       (not (= ?x 4)))

  (<=> (southborder (cell ?x 1))
       (not (= ?x 1))
       (not (= ?x 4)))

  (<=> (northborder (cell ?x 4))
       (not (= ?x 1))
       (not (= ?x 4)))

  (nwcorner (cell 1 4))
  (necorner (cell 4 4))
  (swcorner (cell 1 1))
  (secorner (cell 4 1))
  
  (<=> (notborder (cell ?x ?y))
       (and (not (= ?x 1))
            (not (= ?x 4))
            (not (= ?y 1))
            (not (= ?y 4))))

  ; center
  (=> (stench ?cell)
      (notborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?celle)
          (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (notborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))
           (not (wumpus ?cellw))
           (not (wumpus ?cells))))

  ;;; borders

  ;west
  (=> (stench ?cell)
      (westborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (or (wumpus ?celln)
          (wumpus ?celle)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (westborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))
           (not (wumpus ?cells))))


  ; north
  (=> (stench ?cell)
      (northborder ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (or (wumpus ?celle)
          (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (northborder ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (and (not (wumpus ?celle))
           (not (wumpus ?cellw))
           (not (wumpus ?cells))))

      
  ; south
  (=> (stench ?cell)
      (southborder ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?celle)
          (wumpus ?cellw)))

  (=> (not (stench ?cell))
      (southborder ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))
           (not (wumpus ?cellw))))

  ; east
  (=> (stench ?cell)
      (eastborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (eastborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?cellw))
           (not (wumpus ?cells))))

  ;;; corners

  ; nw
  (=> (stench ?cell)
      (nwcorner ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (or (wumpus ?celle)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (nwcorner ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (and (not (wumpus ?celle))
           (not (wumpus ?cells))))

  ; ne
  (=> (stench ?cell)
      (necorner ?cell)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (or (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (necorner ?cell)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (and (not (wumpus ?cellw))
           (not (wumpus ?cells))))

  ; sw
  (=> (stench ?cell)
      (wwcorner ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (or (wumpus ?celln)
          (wumpus ?celle)))

  (=> (not (stench ?cell))
      (wwcorner ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))))

  ; se
  (=> (stench ?cell)
      (secorner ?cell)
      (north ?cell ?celln)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?cellw)))

  (=> (not (stench ?cell))
      (secorner ?cell)
      (north ?cell ?celln)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?cellw))))

  (exists (?x ?y) (wumpus (cell ?x ?y)))

  (shiney (cell 1 3))
  (not (stench (cell 1 3)))
  (stench (cell 4 2))
  (not (shiney (cell 4 2)))
"))(POS (EXAMPLE.INSTANCE WUMPUSDISJUNCTIVE))(POS (PRETTYNAME WUMPUSDISJUNCTIVE "Disjunctive Wumpus World"))(POS (SHORTNAME WUMPUSDISJUNCTIVE "wumpus.disj"))(POS (EXAMPLE.COMPLETE WUMPUSDISJUNCTIVE INCOMPLETE))(POS (EXAMPLE.TECHNIQUE WUMPUSDISJUNCTIVE BILEVEL))(POS (EXAMPLE.TECHNIQUE WUMPUSDISJUNCTIVE CONSISTENCY2DEDUCTION))(POS (EXAMPLE.TECHNIQUE WUMPUSDISJUNCTIVE NAF))(POS (EXAMPLE.TECHNIQUE WUMPUSDISJUNCTIVE UNNAMED))(POS (EXAMPLE.DESCRIPTION WUMPUSDISJUNCTIVE "In this snapshot version of wumpus world, at each step of the game, we write down what the percepts we have received mean.  For example, if we sense a stench then we write down that the wumpus is in one of the surrounding squares.  This incomplete theory is built on top of incomplete and, more to the point, disjunctive base tables.  The reformulation must then take into account that those base tables must be completed each time new info is added.  The way we complete the tables is to introduce new object constants into the language, that is at least what we would have done had we used object constants to name each cell instead of functional terms.  This example illustrates the need to change the universe of discourse."))(POS (MATRIXSHOW WUMPUSDISJUNCTIVE TRUE))(POS (EXAMPLE.COMMENTS WUMPUSDISJUNCTIVE "This example definitely illustrates the issues of starting with DISJUNCTIVE base tables can produce.  One way to deal with that is to increase the size of the universe, as indicated in the description.  Another way is to add functional terms, as is done in the actual example below.

The only reason this example might be problematic for Otter/Vampire is that the query is a universal statement, and we have a DCA to worry about."))(POS (EXAMPLE.SOURCEQUERY WUMPUSDISJUNCTIVE "(=> (gold ?x) (wumpus ?y) (westof ?x ?y))"))(POS (EXAMPLE.SOURCE WUMPUSDISJUNCTIVE "  (succ 1 2)
  (succ 2 3)
  (succ 3 4)

  (<=> (westof (cell ?x ?y) (cell ?x2 ?y2))
       (or (succ ?x ?x2)
           (exists ?z (and (succ ?x ?z) (succ ?z ?x2)))
           (exists (?z ?w) (and (succ ?x ?z) (succ ?z ?w) (succ ?w ?x2)))))


  (or (gold (cell 1 4)) (gold (cell 1 2)) (gold (cell 2 2)) (gold (cell 2 3)) (gold (cell 2 4)))
  (not (wumpus (cell 1 4)))
  (not (wumpus (cell 1 2)))
  (not (wumpus (cell 2 2)))
  (not (wumpus (cell 2 3)))
  (not (wumpus (cell 2 4)))

  (or (wumpus (cell 3 1)) (wumpus (cell 3 2)) (wumpus (cell 3 3)) (wumpus (cell 4 1)) (wumpus (cell 4 3)))
  (not (gold (cell 3 1)))
  (not (gold (cell 3 2)))
  (not (gold (cell 3 3)))
  (not (gold (cell 4 1)))
  (not (gold (cell 4 3)))
"))(POS (EXAMPLE.TARGETQUERY WUMPUSDISJUNCTIVE "ent"))(POS (EXAMPLE.TARGET WUMPUSDISJUNCTIVE " (<= ent
      (not notent))
  (<= notent
      (possgold ?x)
      (posswumpus ?y)
      (not (westof ?x ?y)))
      
  (<= (possgold ?x)
      (gold ?y)
      (part ?y ?x)
      (not (ngold ?x))
      (not (some-goldnotin ?x)))

  (<= (some-goldnotin ?x)
      (gold ?y)
      (not (part ?y ?x)))

  (<= (posswumpus ?x)
      (wumpus ?y)
      (part ?y ?x)
      (not (nwumpus ?x))
      (not (some-wumpusnotin ?x)))
  
  (<= (some-wumpusnotin ?x)
      (wumpus ?y)
      (not (part ?y ?x)))

  (<= (part (listof ?x @y) ?x))
  (<= (part (listof ?z @y) ?x)
      (part (listof @y) ?x))

  (adj 1 2)
  (adj 2 3)
  (adj 3 4)

  (<= (west (cell ?x ?y) (cell ?x2 ?w))
      (adj ?x ?x2))

  (<= (westof ?x ?y)
      (or (west ?x ?y)
          (and (west ?x ?z) (west ?z ?y))
          (and (west ?x ?z) (west ?z ?w) (west ?w ?y))))

  (gold (listof (cell 1 4) (cell 1 2) (cell 2 2) (cell 2 3) (cell 2 4)))
  (ngold (cell 3 1))
  (ngold (cell 3 2))
  (ngold (cell 3 3))
  (ngold (cell 4 1))
  (ngold (cell 4 3))

  (wumpus (listof (cell 3 1) (cell 3 2) (cell 3 3) (cell 4 1) (cell 4 3)))
  (nwumpus (cell 1 4))
  (nwumpus (cell 1 2))
  (nwumpus (cell 2 2))
  (nwumpus (cell 2 3))
  (nwumpus (cell 2 4))
"))(NEG (EXAMPLE.DESCRIPTION WUMPUSDISJUNCTIVE "In this snapshot version of wumpus world, at each step of the game, we write down what the percepts we have received mean.  For example, if we sense a stench then we write down that the wumpus is in one of the surrounding squares.  This incomplete theory is built on top of incomplete and, more to the point, disjunctive base tables.  The reformulation must then take into account that those base tables must be completed each time new info is added.  The way we complete the tables is to introduce new object constants into the language, that is at least what we would have done had we used object constants to name each cell instead of functional terms.  This example illustrates the need to change the universe of discourse."))(POS (EXAMPLE.DESCRIPTION WUMPUSDISJUNCTIVE "In this snapshot version of wumpus world, at each step of the game, we write down what the percepts we have received mean.  For example, if we sense a stench then we write down that the wumpus is in one of the surrounding squares.  This incomplete theory is built on top of incomplete and, more to the point, disjunctive base tables.  The reformulation must then take into account that those base tables must be completed each time new info is added.  The way we complete the tables is to introduce new object constants into the language.  This example illustrates the problem of disjunctive base tables and a solution: the introduction of new object constants."))(NEG (EXAMPLE.COMMENTS WUMPUSDISJUNCTIVE "This example definitely illustrates the issues of starting with DISJUNCTIVE base tables can produce.  One way to deal with that is to increase the size of the universe, as indicated in the description.  Another way is to add functional terms, as is done in the actual example below.

The only reason this example might be problematic for Otter/Vampire is that the query is a universal statement, and we have a DCA to worry about."))(POS (EXAMPLE.COMMENTS WUMPUSDISJUNCTIVE "The only reason this example might be problematic for Otter/Vampire is that the query is a universal statement, and we have a DCA to worry about.

Add UNA/DCA to the source."))(NEG (EXAMPLE.SOURCEQUERY WUMPUSDISJUNCTIVE "(=> (gold ?x) (wumpus ?y) (westof ?x ?y))"))(POS (EXAMPLE.SOURCEQUERY WUMPUSDISJUNCTIVE "(forall (?x ?y) (=> (gold ?x) (wumpus ?y) (westof ?x ?y)))"))(NEG (EXAMPLE.SOURCE WUMPUSDISJUNCTIVE "  (succ 1 2)
  (succ 2 3)
  (succ 3 4)

  (<=> (westof (cell ?x ?y) (cell ?x2 ?y2))
       (or (succ ?x ?x2)
           (exists ?z (and (succ ?x ?z) (succ ?z ?x2)))
           (exists (?z ?w) (and (succ ?x ?z) (succ ?z ?w) (succ ?w ?x2)))))


  (or (gold (cell 1 4)) (gold (cell 1 2)) (gold (cell 2 2)) (gold (cell 2 3)) (gold (cell 2 4)))
  (not (wumpus (cell 1 4)))
  (not (wumpus (cell 1 2)))
  (not (wumpus (cell 2 2)))
  (not (wumpus (cell 2 3)))
  (not (wumpus (cell 2 4)))

  (or (wumpus (cell 3 1)) (wumpus (cell 3 2)) (wumpus (cell 3 3)) (wumpus (cell 4 1)) (wumpus (cell 4 3)))
  (not (gold (cell 3 1)))
  (not (gold (cell 3 2)))
  (not (gold (cell 3 3)))
  (not (gold (cell 4 1)))
  (not (gold (cell 4 3)))
"))(POS (EXAMPLE.SOURCE WUMPUSDISJUNCTIVE "  (or (gold a) (gold i) (gold b) (gold f) (gold j))
  (not (wumpus a))
  (not (wumpus i))
  (not (wumpus b))
  (not (wumpus f))
  (not (wumpus j))

  (or (wumpus g) (wumpus k) (wumpus o) (wumpus h) (wumpus p))
  (not (gold g))
  (not (gold k))
  (not (gold o))
  (not (gold h))
  (not (gold p))

(westof A B)
(westof A F)
(westof A J)
(westof A N)
(westof A C)
(westof A G)
(westof A K)
(westof A O)
(westof A D)
(westof A H)
(westof A L)
(westof A P)
(westof E B)
(westof E F)
(westof E J)
(westof E N)
(westof E C)
(westof E G)
(westof E K)
(westof E O)
(westof E D)
(westof E H)
(westof E L)
(westof E P)
(westof I B)
(westof I F)
(westof I J)
(westof I N)
(westof I C)
(westof I G)
(westof I K)
(westof I O)
(westof I D)
(westof I H)
(westof I L)
(westof I P)
(westof M B)
(westof M F)
(westof M J)
(westof M N)
(westof M C)
(westof M G)
(westof M K)
(westof M O)
(westof M D)
(westof M H)
(westof M L)
(westof M P)
(westof B C)
(westof B G)
(westof B K)
(westof B O)
(westof B D)
(westof B H)
(westof B L)
(westof B P)
(westof F C)
(westof F G)
(westof F K)
(westof F O)
(westof F D)
(westof F H)
(westof F L)
(westof F P)
(westof J C)
(westof J G)
(westof J K)
(westof J O)
(westof J D)
(westof J H)
(westof J L)
(westof J P)
(westof N C)
(westof N G)
(westof N K)
(westof N O)
(westof N D)
(westof N H)
(westof N L)
(westof N P)
(westof C D)
(westof C H)
(westof C L)
(westof C P)
(westof G D)
(westof G H)
(westof G L)
(westof G P)
(westof K D)
(westof K H)
(westof K L)
(westof K P)
(westof O D)
(westof O H)
(westof O L)
(westof O P)"))(NEG (EXAMPLE.TARGET WUMPUSDISJUNCTIVE " (<= ent
      (not notent))
  (<= notent
      (possgold ?x)
      (posswumpus ?y)
      (not (westof ?x ?y)))
      
  (<= (possgold ?x)
      (gold ?y)
      (part ?y ?x)
      (not (ngold ?x))
      (not (some-goldnotin ?x)))

  (<= (some-goldnotin ?x)
      (gold ?y)
      (not (part ?y ?x)))

  (<= (posswumpus ?x)
      (wumpus ?y)
      (part ?y ?x)
      (not (nwumpus ?x))
      (not (some-wumpusnotin ?x)))
  
  (<= (some-wumpusnotin ?x)
      (wumpus ?y)
      (not (part ?y ?x)))

  (<= (part (listof ?x @y) ?x))
  (<= (part (listof ?z @y) ?x)
      (part (listof @y) ?x))

  (adj 1 2)
  (adj 2 3)
  (adj 3 4)

  (<= (west (cell ?x ?y) (cell ?x2 ?w))
      (adj ?x ?x2))

  (<= (westof ?x ?y)
      (or (west ?x ?y)
          (and (west ?x ?z) (west ?z ?y))
          (and (west ?x ?z) (west ?z ?w) (west ?w ?y))))

  (gold (listof (cell 1 4) (cell 1 2) (cell 2 2) (cell 2 3) (cell 2 4)))
  (ngold (cell 3 1))
  (ngold (cell 3 2))
  (ngold (cell 3 3))
  (ngold (cell 4 1))
  (ngold (cell 4 3))

  (wumpus (listof (cell 3 1) (cell 3 2) (cell 3 3) (cell 4 1) (cell 4 3)))
  (nwumpus (cell 1 4))
  (nwumpus (cell 1 2))
  (nwumpus (cell 2 2))
  (nwumpus (cell 2 3))
  (nwumpus (cell 2 4))
"))(POS (EXAMPLE.TARGET WUMPUSDISJUNCTIVE "  (<= ent
      (not notent))
  (<= notent
      (possgold ?x)
      (posswumpus ?y)
      (not (westof ?x ?y)))
      
  (<= (possgold ?x)
      (gold ?y)
      (part ?y ?x)
      (not (ngold ?x))
      (not (some-goldnotin ?x)))

  (<= (some-goldnotin ?x)
      (gold ?y)
      (not (part ?y ?x)))

  (<= (posswumpus ?x)
      (wumpus ?y)
      (part ?y ?x)
      (not (nwumpus ?x))
      (not (some-wumpusnotin ?x)))
  
  (<= (some-wumpusnotin ?x)
      (wumpus ?y)
      (not (part ?y ?x)))

  (gold aibfj)
  (ngold g)
  (ngold k)
  (ngold o)
  (ngold h)
  (ngold p)

  (wumpus gkohp)
  (nwumpus a)
  (nwumpus i)
  (nwumpus b)
  (nwumpus f)
  (nwumpus j)

  (part aibfj a)
  (part aibfj i)
  (part aibfj b)
  (part aibfj f)
  (part aibfj j)

  (part gkohp g)
  (part gkohp k)
  (part gkohp o)
  (part gkohp h)
  (part gkohp p)

(westof A B)
(westof A F)
(westof A J)
(westof A N)
(westof A C)
(westof A G)
(westof A K)
(westof A O)
(westof A D)
(westof A H)
(westof A L)
(westof A P)
(westof E B)
(westof E F)
(westof E J)
(westof E N)
(westof E C)
(westof E G)
(westof E K)
(westof E O)
(westof E D)
(westof E H)
(westof E L)
(westof E P)
(westof I B)
(westof I F)
(westof I J)
(westof I N)
(westof I C)
(westof I G)
(westof I K)
(westof I O)
(westof I D)
(westof I H)
(westof I L)
(westof I P)
(westof M B)
(westof M F)
(westof M J)
(westof M N)
(westof M C)
(westof M G)
(westof M K)
(westof M O)
(westof M D)
(westof M H)
(westof M L)
(westof M P)
(westof B C)
(westof B G)
(westof B K)
(westof B O)
(westof B D)
(westof B H)
(westof B L)
(westof B P)
(westof F C)
(westof F G)
(westof F K)
(westof F O)
(westof F D)
(westof F H)
(westof F L)
(westof F P)
(westof J C)
(westof J G)
(westof J K)
(westof J O)
(westof J D)
(westof J H)
(westof J L)
(westof J P)
(westof N C)
(westof N G)
(westof N K)
(westof N O)
(westof N D)
(westof N H)
(westof N L)
(westof N P)
(westof C D)
(westof C H)
(westof C L)
(westof C P)
(westof G D)
(westof G H)
(westof G L)
(westof G P)
(westof K D)
(westof K H)
(westof K L)
(westof K P)
(westof O D)
(westof O H)
(westof O L)
(westof O P)
"))(NEG (EXAMPLE.COMMENTS WUMPUSPERCEPTS "Here I'm using some functions in the source, simply because the problem was easier to write down this way.  It may also be a case that demonstrates that sometimes we can deal with functions.  I'm conflating this with completing the tables stench and shine, but I couldn't bring myself to write it without functions."))(POS (EXAMPLE.COMMENTS WUMPUSPERCEPTS "There is a version using functions to name cells.  Add UNA and DCA to the source."))(NEG (EXAMPLE.SOURCEQUERY WUMPUSPERCEPTS "      (=> (gold ?x) (wumpus ?y) (westof ?x ?y))
"))(POS (EXAMPLE.SOURCEQUERY WUMPUSPERCEPTS "     (forall (?x ?y) (=> (gold ?x) (wumpus ?y) (westof ?x ?y)))
"))(NEG (EXAMPLE.SOURCE WUMPUSPERCEPTS "
  (succ 1 2)
  (succ 2 3)
  (succ 3 4)

  (<=> (next ?x ?y)
       (or (succ ?x ?y)
           (succ ?y ?x)))

  (<=> (west (cell ?x ?y) (cell ?x2 ?y))
       (succ ?x2 ?x))
  (<=> (north (cell ?x ?y) (cell ?x ?y2))
       (succ ?y2 ?y))
  
  (<=> (east ?x ?y) (west ?y ?x))
  (<=> (south ?x ?y) (north ?y ?x))

  (<=> (westof (cell ?x ?y) (cell ?x2 ?y2))
       (or (succ ?x ?x2)
           (exists ?z (and (succ ?x ?z) (succ ?z ?x2)))
           (exists (?z ?w) (and (succ ?x ?z) (succ ?z ?w) (succ ?w ?x2)))))

  (<=> (westborder (cell 1 ?x))
       (not (= ?x 1))
       (not (= ?x 4)))

  (<=> (eastborder (cell 4 ?x))
       (not (= ?x 1))
       (not (= ?x 4)))

  (<=> (southborder (cell ?x 1))
       (not (= ?x 1))
       (not (= ?x 4)))

  (<=> (northborder (cell ?x 4))
       (not (= ?x 1))
       (not (= ?x 4)))

  (nwcorner (cell 1 4))
  (necorner (cell 4 4))
  (swcorner (cell 1 1))
  (secorner (cell 4 1))
  
  (<=> (notborder (cell ?x ?y))
       (and (not (= ?x 1))
            (not (= ?x 4))
            (not (= ?y 1))
            (not (= ?y 4))))

  ; center
  (=> (stench ?cell)
      (notborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?celle)
          (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (notborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))
           (not (wumpus ?cellw))
           (not (wumpus ?cells))))

  ;;; borders

  ;west
  (=> (stench ?cell)
      (westborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (or (wumpus ?celln)
          (wumpus ?celle)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (westborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))
           (not (wumpus ?cells))))


  ; north
  (=> (stench ?cell)
      (northborder ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (or (wumpus ?celle)
          (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (northborder ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (and (not (wumpus ?celle))
           (not (wumpus ?cellw))
           (not (wumpus ?cells))))

      
  ; south
  (=> (stench ?cell)
      (southborder ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?celle)
          (wumpus ?cellw)))

  (=> (not (stench ?cell))
      (southborder ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))
           (not (wumpus ?cellw))))

  ; east
  (=> (stench ?cell)
      (eastborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (eastborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?cellw))
           (not (wumpus ?cells))))

  ;;; corners

  ; nw
  (=> (stench ?cell)
      (nwcorner ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (or (wumpus ?celle)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (nwcorner ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (and (not (wumpus ?celle))
           (not (wumpus ?cells))))

  ; ne
  (=> (stench ?cell)
      (necorner ?cell)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (or (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (necorner ?cell)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (and (not (wumpus ?cellw))
           (not (wumpus ?cells))))

  ; sw
  (=> (stench ?cell)
      (wwcorner ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (or (wumpus ?celln)
          (wumpus ?celle)))

  (=> (not (stench ?cell))
      (wwcorner ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))))

  ; se
  (=> (stench ?cell)
      (secorner ?cell)
      (north ?cell ?celln)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?cellw)))

  (=> (not (stench ?cell))
      (secorner ?cell)
      (north ?cell ?celln)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?cellw))))

  (exists (?x ?y) (wumpus (cell ?x ?y)))

  (shiney (cell 1 3))
  (not (stench (cell 1 3)))
  (stench (cell 4 2))
  (not (shiney (cell 4 2)))
"))(POS (EXAMPLE.SOURCE WUMPUSPERCEPTS "  ; complete tables
  (north a e)
  (north e i)
  (north i m)
  (north b f)
  (north f j)
  (north j n)
  (north c g)
  (north g k)
  (north k o)
  (north d h)
  (north h l)
  (north l p)

  (west a b)
  (west b c)
  (west c d)
  (west e f)
  (west f g)
  (west g h)
  (west i j)
  (west j k)
  (west k l)
  (west m n)
  (west n o)
  (west o p)
  
  (<=> (east ?x ?y) (west ?y ?x))
  (<=> (south ?x ?y) (north ?y ?x))

  ; more complete tables
  (westborder e)
  (westborder i)
  (northborder b)
  (northborder c)
  (eastborder h)
  (eastborder l)
  (southborder n)
  (southborder o)

  (nwcorner a)
  (necorner d)
  (swcorner m)
  (swcorner p)

  (notborder f)
  (notborder g)
  (notborder j)
  (notborder k)
  
  ; center
  (=> (stench ?cell)
      (notborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?celle)
          (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (notborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))
           (not (wumpus ?cellw))
           (not (wumpus ?cells))))

  ;;; borders

  ;west
  (=> (stench ?cell)
      (westborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (or (wumpus ?celln)
          (wumpus ?celle)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (westborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))
           (not (wumpus ?cells))))


  ; north
  (=> (stench ?cell)
      (northborder ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (or (wumpus ?celle)
          (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (northborder ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (and (not (wumpus ?celle))
           (not (wumpus ?cellw))
           (not (wumpus ?cells))))

      
  ; south
  (=> (stench ?cell)
      (southborder ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?celle)
          (wumpus ?cellw)))

  (=> (not (stench ?cell))
      (southborder ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))
           (not (wumpus ?cellw))))

  ; east
  (=> (stench ?cell)
      (eastborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (eastborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?cellw))
           (not (wumpus ?cells))))

  ;;; corners

  ; nw
  (=> (stench ?cell)
      (nwcorner ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (or (wumpus ?celle)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (nwcorner ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (and (not (wumpus ?celle))
           (not (wumpus ?cells))))

  ; ne
  (=> (stench ?cell)
      (necorner ?cell)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (or (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (necorner ?cell)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (and (not (wumpus ?cellw))
           (not (wumpus ?cells))))

  ; sw
  (=> (stench ?cell)
      (wwcorner ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (or (wumpus ?celln)
          (wumpus ?celle)))

  (=> (not (stench ?cell))
      (wwcorner ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))))

  ; se
  (=> (stench ?cell)
      (secorner ?cell)
      (north ?cell ?celln)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?cellw)))

  (=> (not (stench ?cell))
      (secorner ?cell)
      (north ?cell ?celln)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?cellw))))


  (exists ?x (wumpus ?x))
  (exists ?x (gold ?x))

  (shiney e)
  (not (stench e))
  (stench l)
  (not (shiney l))



; a complete table
(westof A B)
(westof A F)
(westof A J)
(westof A N)
(westof A C)
(westof A G)
(westof A K)
(westof A O)
(westof A D)
(westof A H)
(westof A L)
(westof A P)
(westof E B)
(westof E F)
(westof E J)
(westof E N)
(westof E C)
(westof E G)
(westof E K)
(westof E O)
(westof E D)
(westof E H)
(westof E L)
(westof E P)
(westof I B)
(westof I F)
(westof I J)
(westof I N)
(westof I C)
(westof I G)
(westof I K)
(westof I O)
(westof I D)
(westof I H)
(westof I L)
(westof I P)
(westof M B)
(westof M F)
(westof M J)
(westof M N)
(westof M C)
(westof M G)
(westof M K)
(westof M O)
(westof M D)
(westof M H)
(westof M L)
(westof M P)
(westof B C)
(westof B G)
(westof B K)
(westof B O)
(westof B D)
(westof B H)
(westof B L)
(westof B P)
(westof F C)
(westof F G)
(westof F K)
(westof F O)
(westof F D)
(westof F H)
(westof F L)
(westof F P)
(westof J C)
(westof J G)
(westof J K)
(westof J O)
(westof J D)
(westof J H)
(westof J L)
(westof J P)
(westof N C)
(westof N G)
(westof N K)
(westof N O)
(westof N D)
(westof N H)
(westof N L)
(westof N P)
(westof C D)
(westof C H)
(westof C L)
(westof C P)
(westof G D)
(westof G H)
(westof G L)
(westof G P)
(westof K D)
(westof K H)
(westof K L)
(westof K P)
(westof O D)
(westof O H)
(westof O L)
(westof O P)
"))(NEG (EXAMPLE.TARGET WUMPUSPERCEPTS "  (<= ent
      (not notent))
  (<= notent
      (possworld ?x ?y)
      (not (westof ?x ?y)))

  (<= (westof ?x ?y)
      (or (west ?x ?y)
          (and (west ?x ?z) (west ?z ?y))
          (and (west ?x ?z) (west ?z ?w) (west ?w ?y))))

  (<= (possworld ?x ?y)
      (possgold ?x)
      (posswumpus ?y))

  ; poss gold
  (<= (possgold ?x)
      (adjacentshiney ?x)
      (not (some-adjacentnonshiney ?x))
      (not (some-nonadjacentshiney ?x)))

  (<= (adjacentshiney ?x)
      (shiney ?s)
      (adjacent ?s ?x))

  (<= (some-nonadjacentshiney ?x)
      (shiney ?s)
      (not (adjacent ?s ?x)))

  (<= (some-adjacentnonshiney ?x)
      (adjacent ?x ?y)
      (nshiney ?y))

  ; poss wumpus
  (<= (posswumpus ?x)
      (adjacentstench ?x)
      (not (some-adjacentnonstench ?x))
      (not (some-nonadjacentstench ?x)))

  (<= (adjacentstench ?x)
      (stench ?s)
      (adjacent ?s ?x))

  (<= (some-nonadjacentstench ?x)
      (stench ?s)
      (not (adjacent ?s ?x)))

  (<= (some-adjacentnonstench ?x)
      (adjacent ?x ?y)
      (nstench ?y))
      

  (adj 1 2)
  (adj 2 3)
  (adj 3 4)
  (<= (next ?x ?y)
      (or (adj ?x ?y) (adj ?y ?x)))
  
  (<= (adjacent (cell ?x ?y) (cell ?z ?y))
      (next ?x ?z))

  (<= (adjacent (cell ?x ?y) (cell ?x ?w))
      (next ?y ?w))

  (<= (adjacent (cell ?x ?y) (cell ?z ?w))
      (next ?x ?z)
      (next ?y ?w))

  (<= (west (cell ?x ?y) (cell ?x2 ?w))
      (adj ?x ?x2))

  (shiney (cell 1 3))
  (nstench (cell 1 3))
  (stench (cell 4 2))
  (nshiney (cell 4 2))"))(POS (EXAMPLE.TARGET WUMPUSPERCEPTS "  (<= ent
      (not notent))
  (<= notent
      (possworld ?x ?y)
      (not (westof ?x ?y)))


  (<= (possworld ?x ?y)
      (possgold ?x)
      (posswumpus ?y))

  ; poss gold
  (<= (possgold ?x)
      (adjacentshiney ?x)
      (not (some-adjacentnonshiney ?x))
      (not (some-nonadjacentshiney ?x)))

  (<= (adjacentshiney ?x)
      (shiney ?s)
      (adjacent ?s ?x))

  (<= (some-nonadjacentshiney ?x)
      (shiney ?s)
      (not (adjacent ?s ?x)))

  (<= (some-adjacentnonshiney ?x)
      (adjacent ?x ?y)
      (nshiney ?y))

  ; poss wumpus
  (<= (posswumpus ?x)
      (adjacentstench ?x)
      (not (some-adjacentnonstench ?x))
      (not (some-nonadjacentstench ?x)))

  (<= (adjacentstench ?x)
      (stench ?s)
      (adjacent ?s ?x))

  (<= (some-nonadjacentstench ?x)
      (stench ?s)
      (not (adjacent ?s ?x)))

  (<= (some-adjacentnonstench ?x)
      (adjacent ?x ?y)
      (nstench ?y))
      
#|
 --- --- --- ---
| a | b | c | d |
 --- --- --- ---
| e | f | g | h |
 --- --- --- ---
| i | j | k | l |
 --- --- --- ---
| m | n | o | p |
 --- --- --- ---
Shine: e
Stench: l

|#

  (<= (adjacent ?x ?y)
      (or (north ?x ?y)
          (north ?y ?x)
          (west ?x ?y)
          (west ?y ?x)
          (and (west ?z ?x) (north ?y ?z))
          (and (west ?z ?x) (north ?z ?y))
          (and (west ?x ?z) (north ?y ?z))
          (and (west ?x ?z) (north ?z ?y))))

  (north a e)
  (north e i)
  (north i m)
  (north b f)
  (north f j)
  (north j n)
  (north c g)
  (north g k)
  (north k o)
  (north d h)
  (north h l)
  (north l p)

  (west a b)
  (west b c)
  (west c d)
  (west e f)
  (west f g)
  (west g h)
  (west i j)
  (west j k)
  (west k l)
  (west m n)
  (west n o)
  (west o p)
  
  (<= (east ?x ?y) (west ?y ?x))
  (<= (south ?x ?y) (north ?y ?x))


  (shiney e)
  (nstench e)
  (stench l)
  (nshiney l)

(westof A B)
(westof A F)
(westof A J)
(westof A N)
(westof A C)
(westof A G)
(westof A K)
(westof A O)
(westof A D)
(westof A H)
(westof A L)
(westof A P)
(westof E B)
(westof E F)
(westof E J)
(westof E N)
(westof E C)
(westof E G)
(westof E K)
(westof E O)
(westof E D)
(westof E H)
(westof E L)
(westof E P)
(westof I B)
(westof I F)
(westof I J)
(westof I N)
(westof I C)
(westof I G)
(westof I K)
(westof I O)
(westof I D)
(westof I H)
(westof I L)
(westof I P)
(westof M B)
(westof M F)
(westof M J)
(westof M N)
(westof M C)
(westof M G)
(westof M K)
(westof M O)
(westof M D)
(westof M H)
(westof M L)
(westof M P)
(westof B C)
(westof B G)
(westof B K)
(westof B O)
(westof B D)
(westof B H)
(westof B L)
(westof B P)
(westof F C)
(westof F G)
(westof F K)
(westof F O)
(westof F D)
(westof F H)
(westof F L)
(westof F P)
(westof J C)
(westof J G)
(westof J K)
(westof J O)
(westof J D)
(westof J H)
(westof J L)
(westof J P)
(westof N C)
(westof N G)
(westof N K)
(westof N O)
(westof N D)
(westof N H)
(westof N L)
(westof N P)
(westof C D)
(westof C H)
(westof C L)
(westof C P)
(westof G D)
(westof G H)
(westof G L)
(westof G P)
(westof K D)
(westof K H)
(westof K L)
(westof K P)
(westof O D)
(westof O H)
(westof O L)
(westof O P)"))(POS (LANGUAGE.INSTANCE IKIF))(POS (LANGUAGE.INSTANCE KIF))(POS (LANGUAGE.INSTANCE XML))(POS (TECHNIQUE.INSTANCE CONSISTENCY2DEDUCTION))(POS (TECHNIQUE.DESCRIPTION CONSISTENCY2DEDUCTION "Consistency2Deduction[Delta,phi(xbar)] computes an expression that represents for all the query instances tbar such that Delta U {phi(tbar)} is consistent."))(POS (TECHNIQUE.INSTANCE REIFICATION))(POS (TECHNIQUE.DESCRIPTION REIFICATION "Reification is an umbrella technique that encompasses all kinds of vocabulary and conceptualization shifts."))(POS (TECHNIQUE.INSTANCE UNNAMED))(POS (TECHNIQUE.DESCRIPTION UNNAMED "Encompasses all unnamed techniques."))(POS (TECHNIQUE.INSTANCE RELATIONALIZING))(POS (TECHNIQUE.DESCRIPTION RELATIONALIZING "Form of reification where object/function constants are turned into relation constants."))(POS (TECHNIQUE.INSTANCE OBJECTIFYING))(POS (TECHNIQUE.DESCRIPTION OBJECTIFYING "Form of reification where relation constants become function or object constants."))(POS (TECHNIQUE.INSTANCE GENERATEOVERGUESS))(POS (TECHNIQUE.DESCRIPTION GENERATEOVERGUESS "Technique that changes a guess-and-check problem formulation reformulation into a formulation that generates the answer constructively."))(POS (TECHNIQUE.INSTANCE DATAEXTRACTION))(POS (TECHNIQUE.DESCRIPTION DATAEXTRACTION "Pulls data out of a rule or set of rules, places that data into tables, and appropriately adjusts the rule so that semantically the original and the new versions are identical.  Inverse of dataInfusion."))(POS (TECHNIQUE.INSTANCE DATAINFUSION))(POS (TECHNIQUE.DESCRIPTION DATAINFUSION "Pushes data from a table into rules, a special form of partial deduction from the logic programming literature.  Inverse of dataExtraction."))(POS (TECHNIQUE.INSTANCE CHIRKOVAREFORMULATION))(POS (TECHNIQUE.DESCRIPTION CHIRKOVAREFORMULATION "Computes the optimal viewset for transforming an unknown (but fixed-size) database into a new database that more efficiently answers a given query set."))(POS (PERSON.INSTANCE NATLOVE))(POS (PERSON.FIRSTNAME NATLOVE "Nat"))(POS (PERSON.LASTNAME NATLOVE "Love"))(POS (PERSON.TEAM NATLOVE NATLOVE))(POS (PERSON.EMAIL NATLOVE "natlove@stanford.edu"))(POS (PERSON.INSTANCE JDUCHI))(POS (PERSON.FIRSTNAME JDUCHI "John"))(POS (PERSON.LASTNAME JDUCHI "Duchi"))(POS (PERSON.TEAM JDUCHI JDUCHI))(POS (PERSON.EMAIL JDUCHI "jduchi@stanford.edu"))(POS (PERSON.INSTANCE DTARLOW))(POS (PERSON.FIRSTNAME DTARLOW "Danny"))(POS (PERSON.LASTNAME DTARLOW "Tarlow"))(POS (PERSON.TEAM DTARLOW DTARLOW))(POS (PERSON.EMAIL DTARLOW "dtarlow@stanford.edu"))(POS (PERSON.INSTANCE THINRICH))(POS (PERSON.FIRSTNAME THINRICH "Tim"))(POS (PERSON.LASTNAME THINRICH "Hinrichs"))(POS (PERSON.TEAM THINRICH THINRICH))(POS (PERSON.EMAIL THINRICH "thinrich@stanford.edu"))(POS (PAPER.INSTANCE ABITEBOUL))(POS (PAPER.BIBTEX ABITEBOUL BOOK))(POS (PAPER.AUTHOR ABITEBOUL "Serge Abiteboul and Richard Hull and Victor Vianu"))(POS (PAPER.TITLE ABITEBOUL "Foundations of Databases"))(POS (PAPER.PUBLISHER ABITEBOUL "Addison-Wesley Publishing Company"))(POS (PAPER.LINK ABITEBOUL "http://www.amazon.com/Foundations-Databases-Logical-Serge-Abiteboul/dp/0201537710"))(POS (PAPER.YEAR ABITEBOUL 1995))(POS (PAPER.DESCRIPTION ABITEBOUL "
The definitive guide for comparing various database query languages.
"))(POS (PAPER.TOPIC ABITEBOUL ""))(POS (PAPER.INSTANCE AGRAWAL2000))(POS (PAPER.BIBTEX AGRAWAL2000 INPROCEEDINGS))(POS (PAPER.AUTHOR AGRAWAL2000 "Agrawal and Chaudrhuri and Narasavya"))(POS (PAPER.TITLE AGRAWAL2000 "Automatic selection of materialized views and indexes in Microsoft SQL Server"))(POS (PAPER.PUBLICATION AGRAWAL2000 "In proceedings of Very Large Databases (VLDB)"))(POS (PAPER.STARTPAGE AGRAWAL2000 496))(POS (PAPER.ENDPAGE AGRAWAL2000 505))(POS (PAPER.YEAR AGRAWAL2000 2000))(POS (PAPER.DESCRIPTION AGRAWAL2000 "
Another paper on view selection problem in databases.
"))(POS (PAPER.TOPIC AGRAWAL2000 "Databases"))(POS (PAPER.INSTANCE AIELLO80))(POS (PAPER.BIBTEX AIELLO80 INPROCEEDINGS))(POS (PAPER.AUTHOR AIELLO80 "Luigia Aiello"))(POS (PAPER.TITLE AIELLO80 "Automatic Generation of Semantic Attachments in FOL"))(POS (PAPER.PUBLICATION AIELLO80 "AAAI"))(POS (PAPER.YEAR AIELLO80 1980))(POS (PAPER.RANK AIELLO80 "[**]"))(POS (PAPER.DESCRIPTION AIELLO80 "
Aiello describes a process of generating new semantic attachments from old
ones by compiling FOL into Lisp.
"))(POS (PAPER.TOPIC AIELLO80 "Theorem Proving with Attachments"))(POS (PAPER.INSTANCE ALFERES94))(POS (PAPER.AUTHOR ALFERES94 "J.J. Alferes, R. Li and L.M. Pereira"))(POS (PAPER.TITLE ALFERES94 "Concurrent Actions and Changes in the Situation Calculus"))(POS (PAPER.PUBLICATION ALFERES94 "Proceedings of IBERAMIA 94"))(POS (PAPER.STARTPAGE ALFERES94 93))(POS (PAPER.ENDPAGE ALFERES94 104))(POS (PAPER.LINK ALFERES94 "http://centria.fct.unl.pt/~lmp/publications/Biblio.html"))(POS (PAPER.YEAR ALFERES94 1994))(POS (PAPER.DESCRIPTION ALFERES94 "
Alferes shows that Situation Calculus extended with concurrent actions (e.g. buytoothpaste||buyshampoo) is no more expressive than standard Situation Calculus.  Intuitively, give names to every subset of actions since there are only 2^n such subsets of n actions.  Use those names as the actions in situation calculus.  The trouble here is how do we produce the effect axioms of a concurrent action set given the effect axioms of the individual actions?  Some of these axioms simply must be given by the user, e.g. buying toothpaste and shampoo at the same time might result in a free bar of soap, though neither effect axiom for buying toothpaste or shampoo would mention soap.  For those actions whose composition (in Alferes terms) can be determined automatically, the authors offer a solution using nonmonotonic logic: if Holds(p, Result(a, Result(b,s))) and Holds(p, Result(b, Result(a,s))) and there is no definition for Holds(p, Result(a||b),s), then conclude Holds(p, Result(a||b,s)).  Alferes elaborates the rule to include preconditions and subsets of size other than 2 (though some technical details arise in doing the latter).
"))(POS (PAPER.TOPIC ALFERES94 "Fundamentals"))(POS (PAPER.INSTANCE ALLEN90))(POS (PAPER.AUTHOR ALLEN90 "J. Allen, J. Hendler and A. Tate"))(POS (PAPER.TITLE ALLEN90 "Readings in Planning"))(POS (PAPER.LINK ALLEN90 "http://www.amazon.com/exec/obidos/ASIN/1558601309/qid%3D954347291/sr%3D1-13/002-1714614-2412067"))(POS (PAPER.YEAR ALLEN90 1990))(POS (PAPER.DESCRIPTION ALLEN90 "
Survey book on planning through 1990.
"))(POS (PAPER.TOPIC ALLEN90 "Historical"))(POS (PAPER.INSTANCE ALLWEIN96))(POS (PAPER.BIBTEX ALLWEIN96 BOOK))(POS (PAPER.AUTHOR ALLWEIN96 "Gerard Allwein and Jon Barwise"))(POS (PAPER.TITLE ALLWEIN96 "Logical Reasoning with Diagrams"))(POS (PAPER.PUBLISHER ALLWEIN96 "Oxford University Press"))(POS (PAPER.LINK ALLWEIN96 "http://www.amazon.com/exec/obidos/tg/detail/-/0195104277/104-6992918-7685512?vi=glance"))(POS (PAPER.YEAR ALLWEIN96 1996))(POS (PAPER.RANK ALLWEIN96 "[***]"))(POS (PAPER.DESCRIPTION ALLWEIN96 "
This book advocates the appropriate use of diagrams in formal, rigorous
proofs.  It formalizes the notions of entailment from a diagram and 
adjustments to a diagram.  The formalization is pretty complex, but
it is not obvious how to simplify it.  The book also looks at various
logics that can incorporate diagramatic methods.  The last two sections
are non-theoretical: a series of case studies and a series of heterogeneous
systems.  The bibiliography looks helpful.
"))(POS (PAPER.TOPIC ALLWEIN96 "Graphical Reasoning Techniques"))(POS (PAPER.INSTANCE ALSAC2002))(POS (PAPER.AUTHOR ALSAC2002 "Guray Alsac and Chitta Baral "))(POS (PAPER.TITLE ALSAC2002 "Reasoning in description logics using declarative logic programming"))(POS (PAPER.LINK ALSAC2002 "http://citeseer.ist.psu.edu/context/2398354/0"))(POS (PAPER.YEAR ALSAC2002 2002))(POS (PAPER.DESCRIPTION ALSAC2002 "
The authors discuss a nontrivial translation of a particular 
description logic into logic programming.
"))(POS (PAPER.TOPIC ALSAC2002 "Logic Programming"))(POS (PAPER.INSTANCE AMIR2001))(POS (PAPER.BIBTEX AMIR2001 PHDTHESIS))(POS (PAPER.AUTHOR AMIR2001 "Eyal Amir"))(POS (PAPER.TITLE AMIR2001 "Dividing and Conquering Logic"))(POS (PAPER.PUBLISHER AMIR2001 "Stanford University"))(POS (PAPER.LINK AMIR2001 ""))(POS (PAPER.YEAR AMIR2001 2001))(POS (PAPER.DESCRIPTION AMIR2001 "
Amir's thesis considers several problems related to the construction and
reasoning about large knowledge bases.  First he discusses object-oriented
first-order logic, a synthesis of the object oriented paradigm and
FOL.  Second he applies this logic to theories of action, most notably
situation calculus.  Third he shows how to parallelize automated
theorem proving where a theory has been partitioned into pieces.  Fourth
he gives algorithms for automatically decomposing theories, based on
the syntactic character of the axioms.  Last he describes a logic-based
subsumption architecture for automated robot control, similar in spirit
to Golog.  An appendix on logic, one on reactive control systems, and
30 pages of references round out the thesis.  It should be noted
that while he does augment various resolution procedures to work
in this parallel setting, the rest of the results are independent of
a particular calculus.
"))(POS (PAPER.TOPIC AMIR2001 "Logical Knowledge Representation"))(POS (PAPER.INSTANCE ARENAS98))(POS (PAPER.AUTHOR ARENAS98 "Marcello Arenas and Leopoldo Bertossi"))(POS (PAPER.TITLE ARENAS98 "Hypothetical Temporal Reasoning with History Encoding"))(POS (PAPER.PUBLICATION ARENAS98 "Knowledge Representation Meets Database"))(POS (PAPER.VOLUME ARENAS98 "4.1-4.8"))(POS (PAPER.LINK ARENAS98 "http://citeseer.ist.psu.edu/529093.html"))(POS (PAPER.YEAR ARENAS98 1998))(POS (PAPER.RANK ARENAS98 "[***]"))(POS (PAPER.DESCRIPTION ARENAS98 "
Arenas and Bertossi build on J. Chomicki's work of progressing a history of a database transaction's effects through the execution of a transaction to save on the costs of doing temporal constraint checking.  They also use Reiter's work on evaluating a query in the state that results after executing a sequence of actions.  The authors meld these two approaches to answer queries about the evolution of a database that contain quantification over states (for two specific types of queries).  This work also leads to a process for transforming dynamic integrity constraints into static ones and transforming history dependent action preconditions into local preconditions. 
"))(POS (PAPER.TOPIC ARENAS98 "Hypothetical Temporal DB Queries"))(POS (PAPER.RELATED ARENAS98 CHOMICKI95))(POS (PAPER.INSTANCE ARENAS98B))(POS (PAPER.AUTHOR ARENAS98B "Marcelo Arenas, Leopoldo Bertossi and Javier Pinto"))(POS (PAPER.TITLE ARENAS98B "Representation of Temporal Knowledge in the Situation Calculus"))(POS (PAPER.LINK ARENAS98B "http://citeseer.ist.psu.edu/527517.html"))(POS (PAPER.YEAR ARENAS98B 1998))(POS (PAPER.RANK ARENAS98B "[***]"))(POS (PAPER.DESCRIPTION ARENAS98B "
This incomplete paper describes translating a first-order modal temporal logic, Metric Time Temporal Logic, into situation calculus in the context of database updates.  The key insight is the creation of new relations that summarize information about the past.  Doing this gives us the power to write non-Markovian axioms (those that depend on a history of states instead of a just the last state).  
"))(POS (PAPER.TOPIC ARENAS98B "Hypothetical Temporal DB Queries"))(POS (PAPER.INSTANCE ARMANDO93))(POS (PAPER.BIBTEX ARMANDO93 ARTICLE))(POS (PAPER.AUTHOR ARMANDO93 "A. Armando and E. Giunchiglia"))(POS (PAPER.TITLE ARMANDO93 "Embedding complex decision procedures inside an interative theorem prover"))(POS (PAPER.PUBLICATION ARMANDO93 "Annals of Mathematics and Artificial Intelligence"))(POS (PAPER.VOLUME ARMANDO93 "8(3-4)"))(POS (PAPER.STARTPAGE ARMANDO93 475))(POS (PAPER.ENDPAGE ARMANDO93 502))(POS (PAPER.LINK ARMANDO93 "http://citeseer.ist.psu.edu/context/552111/0"))(POS (PAPER.YEAR ARMANDO93 1993))(POS (PAPER.DESCRIPTION ARMANDO93 "
Building a Non-CNF SAT solver out of a CNF SAT-solver.  
"))(POS (PAPER.TOPIC ARMANDO93 "SAT Solving"))(POS (PAPER.INSTANCE ARMANDO97))(POS (PAPER.BIBTEX ARMANDO97 TECHREPORT))(POS (PAPER.AUTHOR ARMANDO97 "A. Armando and S. Ranise"))(POS (PAPER.TITLE ARMANDO97 "From Integrated Reasoning Specialists to Plug-and-Play Reasoning Components"))(POS (PAPER.PUBLICATION ARMANDO97 "Technical Report
           "))(POS (PAPER.LINK ARMANDO97 "http://citeseer.ist.psu.edu/armando98from.html"))(POS (PAPER.YEAR ARMANDO97 1997))(POS (PAPER.RANK ARMANDO97 "[***]"))(POS (PAPER.DESCRIPTION ARMANDO97 "
Armando and Ranise investigate breaking apart a reasoner into its
constituent pieces.  This investigation aims at learning how to
describe reasoners in an effort to promote the heterogeneous integration
of reasoners.  Their case study is NQTHM, Boyer and Moore's linear
arithmetic decision procedure.
"))(POS (PAPER.TOPIC ARMANDO97 "Architectures"))(POS (PAPER.INSTANCE ASTRACHAN92))(POS (PAPER.BIBTEX ASTRACHAN92 INPROCEEDINGS))(POS (PAPER.AUTHOR ASTRACHAN92 "Owen Astrachan and Mark Stickel"))(POS (PAPER.TITLE ASTRACHAN92 "Caching and Lemmaizing in Model Elimination Theorem Provers"))(POS (PAPER.PUBLICATION ASTRACHAN92 "Proceedings of CADE"))(POS (PAPER.LINK ASTRACHAN92 "http://citeseer.ist.psu.edu/astrachan92caching.html"))(POS (PAPER.YEAR ASTRACHAN92 1992))(POS (PAPER.RANK ASTRACHAN92 "[***]"))(POS (PAPER.DESCRIPTION ASTRACHAN92 "
Caching essentially saves intermediate results of a proof in a lookup table and
checks that table to avoid repeating the search for a result already computed.
It keeps track of the depth at which solutions are found to ensure
the same solutions are found given the appropriate depth cutoff using
iterative deepening.  Lemmaizing adds a derived result to the set of input 
clauses, which hopefully will decrease the depth of the proof by more 
than it increases the branching factor. This seminal paper deals with the 
Horn case.
"))(POS (PAPER.TOPIC ASTRACHAN92 "Theorem Proving with Attachments"))(POS (PAPER.INSTANCE AUDEMARD2000))(POS (PAPER.BIBTEX AUDEMARD2000 INPROCEEDINGS))(POS (PAPER.AUTHOR AUDEMARD2000 "Gilles Audemard and Belaid Benhamou and Laurent Henocque"))(POS (PAPER.TITLE AUDEMARD2000 "Two techniques to improve Finite Model Search"))(POS (PAPER.PUBLICATION AUDEMARD2000 "Proceedings of the 17th International Conference on Automated Deduction"))(POS (PAPER.LINK AUDEMARD2000 "http://citeseer.ist.psu.edu/386981.html"))(POS (PAPER.YEAR AUDEMARD2000 2000))(POS (PAPER.DESCRIPTION AUDEMARD2000 "
Two techniques are introduced to speed up SEM-style model finding.
"))(POS (PAPER.TOPIC AUDEMARD2000 "Model Building"))(POS (PAPER.INSTANCE BACHMAIR97))(POS (PAPER.AUTHOR BACHMAIR97 "Leo Bachmair and Harald Ganzinger and Andrei Voronkov"))(POS (PAPER.TITLE BACHMAIR97 "Elimination of Equality via Transformation with Ordering Constraints"))(POS (PAPER.PUBLICATION BACHMAIR97 "CADE"))(POS (PAPER.LINK BACHMAIR97 "http://portal.acm.org/citation.cfm?id=648234.753446"))(POS (PAPER.YEAR BACHMAIR97 1997))(POS (PAPER.DESCRIPTION BACHMAIR97 "
This paper  builds on Brand's method for eliminating the substitution,
reflexivity, symmetry, and transitivity axioms of equality by rewriting
the rules.  It adds ordering constraints in the process of transformation,
which seems to be one of the big benefits.
"))(POS (PAPER.TOPIC BACHMAIR97 "Transformations"))(POS (PAPER.INSTANCE BARALIS97))(POS (PAPER.BIBTEX BARALIS97 INPROCEEDINGS))(POS (PAPER.AUTHOR BARALIS97 "Baralis and Paraboschi and Teniente"))(POS (PAPER.TITLE BARALIS97 "Materialized view selection in a multidimensional database"))(POS (PAPER.PUBLICATION BARALIS97 "In proceedings of Very Large Databases (VLDB)"))(POS (PAPER.STARTPAGE BARALIS97 155))(POS (PAPER.ENDPAGE BARALIS97 165))(POS (PAPER.YEAR BARALIS97 1997))(POS (PAPER.DESCRIPTION BARALIS97 "
Paper on view selection problem in databases
"))(POS (PAPER.TOPIC BARALIS97 "Databases"))(POS (PAPER.INSTANCE BARRETT2000))(POS (PAPER.BIBTEX BARRETT2000 INPROCEEDINGS))(POS (PAPER.AUTHOR BARRETT2000 "Clark Barrett and David Dill and Aaron Stump"))(POS (PAPER.TITLE BARRETT2000 "A Framework for Cooperating Decision Procedures"))(POS (PAPER.PUBLICATION BARRETT2000 "17th International Conference on Automated Deduction
           "))(POS (PAPER.LINK BARRETT2000 "http://citeseer.ist.psu.edu/barrett00framework.html"))(POS (PAPER.YEAR BARRETT2000 2000))(POS (PAPER.RANK BARRETT2000 "[**]"))(POS (PAPER.DESCRIPTION BARRETT2000 "
Barrett et. al. describe a framework approach for building reasoners
that combine decision procedures.  This work is a precurser to janicic2002.
They introduce half a dozen operations that can be used to interrelate
these decision procedures; they further show how Nelson Oppen and
Shostak procedures can be built in their framework.
"))(POS (PAPER.TOPIC BARRETT2000 "Architectures"))(POS (PAPER.RELATED BARRETT2000 JANICIC2002))(POS (PAPER.INSTANCE BAUMGARTNER2003))(POS (PAPER.BIBTEX BAUMGARTNER2003 ARTICLE))(POS (PAPER.AUTHOR BAUMGARTNER2003 "Peter Baumgartner and Cesare Tinelli"))(POS (PAPER.TITLE BAUMGARTNER2003 "The Model Evolution Calculus"))(POS (PAPER.PUBLICATION BAUMGARTNER2003 "19th International Conference on Automated
    Deduction"))(POS (PAPER.STARTPAGE BAUMGARTNER2003 350))(POS (PAPER.ENDPAGE BAUMGARTNER2003 364))(POS (PAPER.LINK BAUMGARTNER2003 "http://sherry.ifi.unizh.ch/577584.html"))(POS (PAPER.YEAR BAUMGARTNER2003 2003))(POS (PAPER.RANK BAUMGARTNER2003 "[****]"))(POS (PAPER.DESCRIPTION BAUMGARTNER2003 "
Baumgartner and Tinelli describe a first-order version of the DPLL 
(Davis-Putnam-Logemann-Loveland) SAT solver.  In the case of
propositional logic, ME reduces to DPLL.  It differs in the first-order
case because of additional inference rules and skolemization.  The procedure
works by exaustively trying to build a first-order model.  If the search 
fails, the sentences are unsatisfiable.  But if the sentences are satisfiable,
the procedure may run forever trying to construct one.  (Obviously if there
are only infinite models this technique may have issues.) 
"))(POS (PAPER.TOPIC BAUMGARTNER2003 "The Model Evolution Calculus"))(POS (PAPER.INSTANCE BAUMGARTNER2007))(POS (PAPER.BIBTEX BAUMGARTNER2007 ARTICLE))(POS (PAPER.AUTHOR BAUMGARTNER2007 "Peter Baumgartner and Alexander Fuchs and Hans Nivelle and Cesare Tinelli"))(POS (PAPER.TITLE BAUMGARTNER2007 "Computing Finite Models by Reduction to Function-Free Clause Logic"))(POS (PAPER.PUBLICATION BAUMGARTNER2007 "Journal of Applied Logic"))(POS (PAPER.LINK BAUMGARTNER2007 "http://goedel.cs.uiowa.edu/Darwin/"))(POS (PAPER.YEAR BAUMGARTNER2007 2007))(POS (PAPER.DESCRIPTION BAUMGARTNER2007 "
Paper on FMDarwin for building finite models of clause sets.  Unlike
techniques for finding a model directly and techniques that ground out
sentences and invoke a SAT solver, FMDarwin reduces a set of clauses
to function-free clause logic in a way that preserves satisfiability
for a particular size domain.  Then it uses Darwin, an implementation
of the model evolution calculus, to check the satisfiability of
the function-free clauses, iterating through domain sizes.  
"))(POS (PAPER.TOPIC BAUMGARTNER2007 "Model Building"))(POS (PAPER.INSTANCE BAUMGARTNER94))(POS (PAPER.AUTHOR BAUMGARTNER94 "Peter Baumgartner and Ulrich Furbach"))(POS (PAPER.TITLE BAUMGARTNER94 "Model Elimination Without Contrapositives"))(POS (PAPER.PUBLICATION BAUMGARTNER94 "Proceedings of Conference on Automated Deduction"))(POS (PAPER.VOLUME BAUMGARTNER94 "814"))(POS (PAPER.STARTPAGE BAUMGARTNER94 87))(POS (PAPER.ENDPAGE BAUMGARTNER94 101))(POS (PAPER.LINK BAUMGARTNER94 "http://portal.acm.org/citation.cfm?id=752966"))(POS (PAPER.YEAR BAUMGARTNER94 1994))(POS (PAPER.DESCRIPTION BAUMGARTNER94 "
Baumgartner and Furbach introduce Restart Model Elimination and a couple of refinements.
RME obviates the need for contrapositives; all the rules are written in the form
A1 | ... | An <= B1 ^ ... ^ Bm, i.e. the only extension steps that can be performed
are on one of the Ai.  The price we pay is that whenever the literal on the top of the 
stack is positive, we put the goal literal onto the top of the stack (forcibly in
strict RME), hence the name Restart ME.  Also, this means that ancestry pruning cannot
be used with RME if completeness is to be preserved.  Soundness and refutational 
completeness results.  Some experimental results and fairly lengthy comparison
to other calculi.
"))(POS (PAPER.TOPIC BAUMGARTNER94 "Calculi"))(POS (PAPER.INSTANCE BAUMGARTNER95))(POS (PAPER.BIBTEX BAUMGARTNER95 ARTICLE))(POS (PAPER.AUTHOR BAUMGARTNER95 "Peter Baumgartner and Ulrich Furbach and Frieder Stolzenburg"))(POS (PAPER.TITLE BAUMGARTNER95 "Model Elimination, Logic Programming and Computing Answers"))(POS (PAPER.PUBLICATION BAUMGARTNER95 "Technical Report"))(POS (PAPER.LINK BAUMGARTNER95 "http://citeseer.ist.psu.edu/144755.html"))(POS (PAPER.YEAR BAUMGARTNER95 1995))(POS (PAPER.DESCRIPTION BAUMGARTNER95 "
The authors demonstrate that restart model elimination can be used as a complete
interpreter for positive disjunctive logic programming.  That is, they show how
to adjust RME so that it is complete for (definite) answer extraction.  With proofs.
Also, they introduce a limited form of ancestry pruning.  More experiments.
"))(POS (PAPER.TOPIC BAUMGARTNER95 "Calculi"))(POS (PAPER.INSTANCE BELL95))(POS (PAPER.BIBTEX BELL95 ARTICLE))(POS (PAPER.AUTHOR BELL95 "John Bell"))(POS (PAPER.TITLE BELL95 "Pragmatic Reasoning: A model-based theory"))(POS (PAPER.PUBLISHER BELL95 "Kluwer Academic Publishers"))(POS (PAPER.PUBLICATION BELL95 "Applied Logic: How, What and Why"))(POS (PAPER.LINK BELL95 "http://citeseer.ist.psu.edu/bell92pragmatic.html"))(POS (PAPER.YEAR BELL95 1995))(POS (PAPER.RANK BELL95 "[****]"))(POS (PAPER.DESCRIPTION BELL95 "
Bell defines pragmatic reasoning as context-dependent reasoning, in
contrast to deduction which is context-free.  He mathematizes
the two model-theoretically and discusses different versions
of pragmatic entailment.  He compares it to mental models, and
looks at different techniques that have been developed for
expressing pragmatic reasoning tasks.
"))(POS (PAPER.TOPIC BELL95 "Logical Knowledge Representation"))(POS (PAPER.INSTANCE BEREZIN2002))(POS (PAPER.BIBTEX BEREZIN2002 PHDTHESIS))(POS (PAPER.AUTHOR BEREZIN2002 "Sergey Berezin"))(POS (PAPER.TITLE BEREZIN2002 "Model Checking and Theorem Proving: A Unified Framework"))(POS (PAPER.PUBLICATION BEREZIN2002 "CMU Ph.D. Thesis"))(POS (PAPER.LINK BEREZIN2002 "http://chicory.stanford.edu/~berezin/thesis/"))(POS (PAPER.YEAR BEREZIN2002 2002))(POS (PAPER.RANK BEREZIN2002 "[**]"))(POS (PAPER.DESCRIPTION BEREZIN2002 "
This thesis builds a framework for integrating model checking and 
theorem proving, focusing on formal verification applications.  
The basic framework proves first-order branching time mu-calculus
properties of Kripke models, but the inference rules can be easily
changed to facilitate the fast development of new proof systems
(called model provers).  Related work is not so thorough. 
"))(POS (PAPER.TOPIC BEREZIN2002 "Model Checking"))(POS (PAPER.INSTANCE BLACKBURN))(POS (PAPER.BIBTEX BLACKBURN BOOK))(POS (PAPER.AUTHOR BLACKBURN "Patrick Blackburn and Johan van Benthem and Frank Wolter"))(POS (PAPER.TITLE BLACKBURN "Handbook of Modal Logic"))(POS (PAPER.PUBLISHER BLACKBURN "Elsevier Science"))(POS (PAPER.LINK BLACKBURN "http://www.elsevier.com/wps/find/bookdescription.cws_home/708884/description#description"))(POS (PAPER.YEAR BLACKBURN 2006))(POS (PAPER.RANK BLACKBURN "[*****]"))(POS (PAPER.DESCRIPTION BLACKBURN "
A handbook for modal logic, covering basic and advanced theory, variations and extensions, and applications.
"))(POS (PAPER.TOPIC BLACKBURN ""))(POS (PAPER.INSTANCE BODIRSKY2004))(POS (PAPER.BIBTEX BODIRSKY2004 PHDTHESIS))(POS (PAPER.AUTHOR BODIRSKY2004 "Manuel Bodirsky"))(POS (PAPER.TITLE BODIRSKY2004 "Constraint Satisfaction with Infinite Domains"))(POS (PAPER.LINK BODIRSKY2004 "http://www.informatik.hu-berlin.de/~bodirsky/publications/diss.html"))(POS (PAPER.YEAR BODIRSKY2004 2004))(POS (PAPER.DESCRIPTION BODIRSKY2004 "
Bodirsky examines the problem of the homomorphic CSP: given one structure,
is it homomorphic to the target structure?  He for the first time
considers target structures that are countably large; more precisely,
those that are countably large but are omega categorical, i.e. 
all countable models of the first-order theory of that model are isomorphic.
In this work, he produces an algorithm for constructing a tree that
satisfies a given set of constraints, where those constraints require
the existence of nodes that meet certain conditions.  Three possible conditions:
x is an ancestor of y, x and y are equal, and x occurs in a subtree to
the left of the subtree that includes y.  While these constraints force
nodes to exist that satisfy particular relationships, OOCSPs force 
particular nodes to have a particular relationship.
"))(POS (PAPER.TOPIC BODIRSKY2004 "Miscellaneous"))(POS (PAPER.INSTANCE BONACINA97))(POS (PAPER.BIBTEX BONACINA97 INPROCEEDINGS))(POS (PAPER.AUTHOR BONACINA97 "Maria Bonacina"))(POS (PAPER.TITLE BONACINA97 "Machine-independent evaluation of theorem-proving strategies"))(POS (PAPER.PUBLICATION BONACINA97 "Workshop on Theorem Proving Strategies"))(POS (PAPER.STARTPAGE BONACINA97 37))(POS (PAPER.ENDPAGE BONACINA97 39))(POS (PAPER.LINK BONACINA97 "http://citeseer.ist.psu.edu/bonacina97machineindependent.html"))(POS (PAPER.YEAR BONACINA97 1997))(POS (PAPER.RANK BONACINA97 "[***]"))(POS (PAPER.DESCRIPTION BONACINA97 "
Bonacina's position piece explains the need for 'strategy analysis' of
theorem proving techniques.  'Strategy analysis' focuses on theorem-proving
complexity as in plaisted94, but also incorporates indexing, data-structures,
unification complexity, etc.   Bonacina gives a summary of another paper 
that confronts the problem representing deletion strategies in a search
space.  Cites kowalski69 as handling the case where results are never
deleted.  She also explains how a sizable body of related work 
concentrates on the complexity of a logical formalism without reference
to any automated proof-finding system, e.g. goubault94.  
"))(POS (PAPER.TOPIC BONACINA97 "Comparative Analysis"))(POS (PAPER.RELATED BONACINA97 KOWALSKI69))(POS (PAPER.RELATED BONACINA97 GOUBAULT94))(POS (PAPER.INSTANCE BONACINA98))(POS (PAPER.BIBTEX BONACINA98 MISC))(POS (PAPER.AUTHOR BONACINA98 "Maria Bonacina"))(POS (PAPER.TITLE BONACINA98 "Strategy analysis: from Sequential to parallel strategies"))(POS (PAPER.STARTPAGE BONACINA98 21))(POS (PAPER.ENDPAGE BONACINA98 23))(POS (PAPER.LINK BONACINA98 "http://citeseer.ist.psu.edu/36838.html"))(POS (PAPER.YEAR BONACINA98 1998))(POS (PAPER.RANK BONACINA98 "[*]"))(POS (PAPER.DESCRIPTION BONACINA98 "
Bonacina's position paper describes the formalization of the
search space for parallelized theorem proving with contraction
operations.  This paper covers the main ideas, but the meat looks
to be cited in two technical reports.
"))(POS (PAPER.TOPIC BONACINA98 "Comparative Analysis"))(POS (PAPER.INSTANCE BORGER))(POS (PAPER.BIBTEX BORGER BOOK))(POS (PAPER.AUTHOR BORGER "Egon Borger and Erich Gradel and Yuri Gurevich"))(POS (PAPER.TITLE BORGER "The Classical Decision Problem"))(POS (PAPER.PUBLISHER BORGER "Springer-Verlag"))(POS (PAPER.LINK BORGER "http://books.google.com/books?id=3po2Tv_UVcMC&dq=&pg=PP1&ots=FMOqyLGt4N&sig=7pB4XtFUSbGbiUuF4XlKGattRts&prev=http://www.google.com/search%3Fclient%3Dsafari%26rls%3Den%26q%3Dthe%2Bclassical%2Bdecision%2Bproblem%26ie%3DUTF-8%26oe%3DUTF-8&sa=X&oi=print&ct=title#PPP1,M1"))(POS (PAPER.YEAR BORGER 1997))(POS (PAPER.DESCRIPTION BORGER "
The book detailing decidability results for entailment in various prefix
classes of first-order logic, along with complexity results for the 
decidable classes.
"))(POS (PAPER.TOPIC BORGER ""))(POS (PAPER.INSTANCE BORNING92))(POS (PAPER.BIBTEX BORNING92 ARTICLE))(POS (PAPER.AUTHOR BORNING92 "A. Borning and B.N. Freeman-Benson and M. Wilson"))(POS (PAPER.TITLE BORNING92 "Constraint hierarchies"))(POS (PAPER.PUBLICATION BORNING92 "Lisp and Symbolic Computation"))(POS (PAPER.VOLUME BORNING92 "5"))(POS (PAPER.STARTPAGE BORNING92 223))(POS (PAPER.ENDPAGE BORNING92 270))(POS (PAPER.LINK BORNING92 "http://citeseer.ist.psu.edu/borning92constraint.html"))(POS (PAPER.YEAR BORNING92 1992))(POS (PAPER.RANK BORNING92 "[*]"))(POS (PAPER.DESCRIPTION BORNING92 "
Constraint hierarchies, aka Hierarchical Constraint Satisfaction Problems,
impose a precedence hierarchy on constraints.  Only the highest 
precedence constraints must be satisfied; the others constraints
form an ordered set of preferences on the solutions.
"))(POS (PAPER.TOPIC BORNING92 "Object Oriented Constraint Satisfaction"))(POS (PAPER.INSTANCE BORRETT2001))(POS (PAPER.AUTHOR BORRETT2001 "James Borrett and Edward Tsang"))(POS (PAPER.TITLE BORRETT2001 "A Context for Constraint Satisfaction Problem Formulation Selection"))(POS (PAPER.PUBLICATION BORRETT2001 "Constraints"))(POS (PAPER.VOLUME BORRETT2001 "6"))(POS (PAPER.STARTPAGE BORRETT2001 299))(POS (PAPER.ENDPAGE BORRETT2001 327))(POS (PAPER.LINK BORRETT2001 "http://citeseer.ist.psu.edu/borret99context.html"))(POS (PAPER.YEAR BORRETT2001 2001))(POS (PAPER.RANK BORRETT2001 "[***]"))(POS (PAPER.DESCRIPTION BORRETT2001 "
Borrett and Tsang construct a framework for searching through various constraint satisfaction problem formulations and selecting one.  They only consider
formulations of the form <V,D,C>, i.e. typical CSP formulations.  They break the problem into 4 parts: generating an initial formulation, constructing operators to change that formulation, constructing heuristics for choosing which operator to apply, and constructing an evaluation function to that determines the cost of a given formulation.  They go on to demonstrate a particular type of operator: the introduction of redundant constraints and show how searching through CSP formulations with this type of operator works in their framework.
"))(POS (PAPER.TOPIC BORRETT2001 "Reformulation"))(POS (PAPER.INSTANCE BOWEN91))(POS (PAPER.BIBTEX BOWEN91 ARTICLE))(POS (PAPER.AUTHOR BOWEN91 "J. Bowen and D. Bahler"))(POS (PAPER.TITLE BOWEN91 "Conditional Existence of Variables in Generalized Constraint Networks
"))(POS (PAPER.PUBLICATION BOWEN91 "AAAI "))(POS (PAPER.LINK BOWEN91 "http://www.csc.ncsu.edu/faculty/bahler/aaai91/aaai91.pdf"))(POS (PAPER.YEAR BOWEN91 1991))(POS (PAPER.DESCRIPTION BOWEN91 "
Bowen and Bahler employ Free Logic to construct a constraint network
where not all variables must be assigned values.  A constraint network
is defined as a set of logical sentences with a DCA; 
a solution is an interpretation
of the vocabulary in a model so that the sentences are satisfied.  
Free logic differs from FOL in that not every element in the vocabulary
needs to be mapped into the model.
"))(POS (PAPER.TOPIC BOWEN91 "Miscellaneous"))(POS (PAPER.INSTANCE BRY2007))(POS (PAPER.BIBTEX BRY2007 ARTICLE))(POS (PAPER.AUTHOR BRY2007 "Francois Bry and Norbert Eisinger and Thomas Eiter and Tim Furche and Georg Gottlob and Clemens Ley and Benedikt Linse and Reinhard Pichler and Fang Wei"))(POS (PAPER.TITLE BRY2007 "Foundations of Rule-Based Query Answering"))(POS (PAPER.PUBLICATION BRY2007 "Reasoning Web, Third International Summer School 2007, Grigoris Antoniou, Uwe Assmann, Cristina Baroglio, Stefan Decker, Nicola Henze, Paula-Lavinia Patranjan, Robert Tolksdorf (editors)"))(POS (PAPER.VOLUME BRY2007 "LNCS 4636"))(POS (PAPER.LINK BRY2007 "http://www.pms.ifi.lmu.de/publikationen/index.html#PMS-FB-2007-7"))(POS (PAPER.YEAR BRY2007 2007))(POS (PAPER.DESCRIPTION BRY2007 "
The mathematical foundations of logical query languages.
"))(POS (PAPER.TOPIC BRY2007 "Logical Knowledge Representation"))(POS (PAPER.INSTANCE BUNDY73))(POS (PAPER.BIBTEX BUNDY73 INPROCEEDINGS))(POS (PAPER.AUTHOR BUNDY73 "Alan Bundy"))(POS (PAPER.TITLE BUNDY73 "Doing Arithmetic With Diagrams"))(POS (PAPER.PUBLICATION BUNDY73 "IJCAI"))(POS (PAPER.YEAR BUNDY73 1973))(POS (PAPER.RANK BUNDY73 "[**]"))(POS (PAPER.DESCRIPTION BUNDY73 "
Bundy describes SUMS (System which Understands Mathematical
Symbols), a theorem prover for theorems over natural numbers.
The SUMS proof process represents the natural numbers in
a diagram, and by manipulating the diagram, determines the
truth of a conjecture.  Bundy makes an interesting point at the 
end of the paper: mathematicians do not usually manipulate
logic to prove theorems.  Rather, they convince themselves
of the correctness of a conjecture through diagrams or other
semantic insights and then use logic as a language for
communicating to others the proof of the theorem.  SUMS
is an attempt at building a machine that simply 
convinces itself of the truth of a conjecture.
"))(POS (PAPER.TOPIC BUNDY73 "Graphical Reasoning Techniques"))(POS (PAPER.INSTANCE BUNDY99))(POS (PAPER.AUTHOR BUNDY99 "Alan Bundy"))(POS (PAPER.TITLE BUNDY99 "A Survey of Automated Deduction"))(POS (PAPER.LINK BUNDY99 "http://citeseer.ist.psu.edu/bundy99survey.html"))(POS (PAPER.YEAR BUNDY99 1999))(POS (PAPER.RANK BUNDY99 ""))(POS (PAPER.DESCRIPTION BUNDY99 "
Bundy surveys research in automated deduction.  He focuses on resolution,
term rewriting, built-in unification, higher-order logics and type-theory,
induction, interactive theorem-proving, meta-reasoning, common sense
reasoning, and logic programming.
"))(POS (PAPER.TOPIC BUNDY99 "Theorem Proving"))(POS (PAPER.INSTANCE BYLANDER94))(POS (PAPER.AUTHOR BYLANDER94 "Tom Bylander"))(POS (PAPER.TITLE BYLANDER94 "The Computational Complexity of Propositional STRIPS Planning"))(POS (PAPER.PUBLICATION BYLANDER94 "Artificial Intelligence"))(POS (PAPER.VOLUME BYLANDER94 "69(1-2)"))(POS (PAPER.STARTPAGE BYLANDER94 165))(POS (PAPER.ENDPAGE BYLANDER94 204))(POS (PAPER.LINK BYLANDER94 "http://citeseer.ist.psu.edu/bylander94computational.html"))(POS (PAPER.YEAR BYLANDER94 1994))(POS (PAPER.DESCRIPTION BYLANDER94 "
Bylander discusses complexity results for propositional STRIPS; he also mentions that a class of first-order STRIPS can be reduced in polynomial time to propositional STRIPS, making these results widely applicable.  PLANSAT (decision problem for determining whether an instance of prop STRIPS planning is satisfiable) is PSPACE-complete.  PLANSAT[2+,2] (PLANSAT where all operators have at least 2 positive preconditions and 2 postconditions) is also PSPACE-complete.  Results are shown for a variety of restrictions, concluding that without severe restrictions, PLANSAT is NP-complete or PSPACE-complete.
These results carry over to PLANMIN (the decision problem of determining whether an instance has a solution of k or fewer operators.  The new results here show a variety of PLANMIN are NP-complete, and a couple, very restricted versions are polynomial.  He also shows results for Propositional Strips with formulas (Extended Propositional STRIPS).  EPLANSAT, EPLANSAT[0,1+] restricted to define Horn clauses are PSPACE-complete.  More results are shown for EPLANSAT and EPLANSATMIN.  See paper for details.
"))(POS (PAPER.TOPIC BYLANDER94 "Historical"))(POS (PAPER.INSTANCE BYRNE2000))(POS (PAPER.BIBTEX BYRNE2000 MISC))(POS (PAPER.AUTHOR BYRNE2000 "Ruth Byrne and Lisa Gilroy"))(POS (PAPER.TITLE BYRNE2000 "Mental Models Website"))(POS (PAPER.LINK BYRNE2000 "http://www.tcd.ie/Psychology/Ruth_Byrne/mental_models/index.html"))(POS (PAPER.YEAR BYRNE2000 2000))(POS (PAPER.DESCRIPTION BYRNE2000 "
Mental Models website--the Psychology version of model-based reasoning.
"))(POS (PAPER.TOPIC BYRNE2000 "Model-Based Reasoning"))(POS (PAPER.INSTANCE CADOLI2000))(POS (PAPER.BIBTEX CADOLI2000 MISC))(POS (PAPER.AUTHOR CADOLI2000 "Marco Cadoli and Francesco M. Donini and Paolo Liberatore and Marco Schaerf"))(POS (PAPER.TITLE CADOLI2000 "Preprocessing of Intractable Problems"))(POS (PAPER.PUBLICATION CADOLI2000 "Information and Computation"))(POS (PAPER.VOLUME CADOLI2000 "176(2)"))(POS (PAPER.STARTPAGE CADOLI2000 89))(POS (PAPER.ENDPAGE CADOLI2000 120))(POS (PAPER.LINK CADOLI2000 "http://citeseer.ist.psu.edu/cadoli00preprocessing.html"))(POS (PAPER.YEAR CADOLI2000 2000))(POS (PAPER.RANK CADOLI2000 "[**]"))(POS (PAPER.DESCRIPTION CADOLI2000 "
This paper describes complexity classes for algorithms after they
have been preprocessed, or compiled.  The problems targeted have two
parts, one that is fixed, and one that changes frequently.  For
example, determining whether Delta entails a sentence phi has a
fixed part (Delta) and a changing part (phi).  If we could compile
Delta into a more vivid representation, computing entailment might
be easier.  This paper formalizes that idea, gives a complexity class
hierarchy, and a method for reductions.  Cool ideas, but very
theoretical (and only with propositional KB examples).
"))(POS (PAPER.TOPIC CADOLI2000 "Knowledge Base Compilation"))(POS (PAPER.INSTANCE CADOLI2000B))(POS (PAPER.BIBTEX CADOLI2000B MISC))(POS (PAPER.AUTHOR CADOLI2000B "Marco Cadoli and Francesco Donini and Paolo Liberatore and Marco Schaerf"))(POS (PAPER.TITLE CADOLI2000B "Space Efficiency of Propositional Knowledge Representation Formalisms"))(POS (PAPER.PUBLICATION CADOLI2000B "Journal of Artificial Intelligence Research"))(POS (PAPER.VOLUME CADOLI2000B "13"))(POS (PAPER.STARTPAGE CADOLI2000B 1))(POS (PAPER.ENDPAGE CADOLI2000B 31))(POS (PAPER.LINK CADOLI2000B "http://citeseer.ist.psu.edu/cadoli00space.html"))(POS (PAPER.YEAR CADOLI2000B 2000))(POS (PAPER.RANK CADOLI2000B "[*****]"))(POS (PAPER.DESCRIPTION CADOLI2000B "
The authors leverage previous work on compilation complexity classes to compare
various propositional knowledge formalisms.  They introduce two axes for comparing
such formalisms under translation: theorem-preservation and model-preservation.
That is, given a set of sentences in one formalism, translate those sentences
into another formalism so that (1) the theorems are preserved across the translation
after a translation of their own or (2) the models are preserved across the
translation after a translation of their own.  The translation of premise sets
is assumed to be polynomial in size; the requirement on the translation of
theorems/models is that the representation of the translation process itself
must be polynomial in size.  

The authors then introduce the notion of 
model-C and thm-C classes.  A formalism belongs to the model-C class iff 
model checking in that formalism is in the compilability class C, where the KB is 
the fixed part and the model is the varying part.  A formalism belongs to
the thm-C class iff inference in that formalism is in the compilability class C,
where the KB is the fixed part and the query is the varying part.

Next the authors prove that two formalisms in the same model-C/thm-C class then
there must be a poly-size reduction between the two formalisms that 
preserves models/theorems.  They also show that if two problems are in different
classes there is no polynomial size reduction satisfying models/theorems.

Finally, the propositional formalisms stable model semantics, circumscription, 
generalized closed world, skeptical default logic, credulous default logic, 
WIDTIO belief revision, and skeptical belief revision are analyzed in this 
framework, giving fairly complete coverage of inference/model space complexity.
"))(POS (PAPER.TOPIC CADOLI2000B "Knowledge Base Compilation"))(POS (PAPER.INSTANCE CADOLI2001))(POS (PAPER.AUTHOR CADOLI2001 "Marco Cadoli and Andrea Schaerf"))(POS (PAPER.TITLE CADOLI2001 "Compiling Problem Specifications into SAT"))(POS (PAPER.PUBLICATION CADOLI2001 "Lecture Notes in Computer Science"))(POS (PAPER.VOLUME CADOLI2001 "2028"))(POS (PAPER.LINK CADOLI2001 "http://citeseer.ist.psu.edu/cadoli01compiling.html"))(POS (PAPER.RANK CADOLI2001 "[***]"))(POS (PAPER.DESCRIPTION CADOLI2001 "
Cadoli and Schaerf describe a language, NP-Spec, for specifying problems
in NP, and a technique for translating that language into SAT.  They
mention a previous translation into Prolog.  With SAT, results were
far better than with Prolog; that is, they could solve what they called
medium-sized problems instead of just small problems.  NP-Spec is based
on Prolog without negation (except on some predefined predicates) with
a fixed database. It includes a mix of metalevel constraints and object-level
constraints.
"))(POS (PAPER.TOPIC CADOLI2001 "Knowledge Base Compilation"))(POS (PAPER.INSTANCE CADOLI2002))(POS (PAPER.AUTHOR CADOLI2002 "Marco Cadoli and Toni Mancini"))(POS (PAPER.TITLE CADOLI2002 "Knowledge compilation = Query rewriting + View synthesis"))(POS (PAPER.PUBLICATION CADOLI2002 "Symposium on Principles of Database Systems"))(POS (PAPER.STARTPAGE CADOLI2002 199))(POS (PAPER.ENDPAGE CADOLI2002 208))(POS (PAPER.LINK CADOLI2002 "http://citeseer.ist.psu.edu/641562.html"))(POS (PAPER.RANK CADOLI2002 "[***]"))(POS (PAPER.DESCRIPTION CADOLI2002 "
Cadoli describes a class of propositional knowledge compilation  where
the problem is transformed into a database and a second-order
query over that database.  The database is a straight-forward representation
of the clausal form of the input.  The authors give syntactic conditions
under which the problem can be compiled into P using this technique.
"))(POS (PAPER.TOPIC CADOLI2002 "Knowledge Base Compilation"))(POS (PAPER.INSTANCE CADOLI97))(POS (PAPER.BIBTEX CADOLI97 ARTICLE))(POS (PAPER.AUTHOR CADOLI97 "Marco Cadoli and Francesco M. Donini"))(POS (PAPER.TITLE CADOLI97 "A Survey on Knowledge Compilation"))(POS (PAPER.PUBLICATION CADOLI97 "AI Communications"))(POS (PAPER.VOLUME CADOLI97 "10(3-4)"))(POS (PAPER.STARTPAGE CADOLI97 137))(POS (PAPER.ENDPAGE CADOLI97 150))(POS (PAPER.LINK CADOLI97 "http://citeseer.ist.psu.edu/cadoli98survey.html"))(POS (PAPER.YEAR CADOLI97 1997))(POS (PAPER.RANK CADOLI97 "[***]"))(POS (PAPER.DESCRIPTION CADOLI97 "
Cadoli and Donini review techniques for propositional knowledge base compilation.  
The goal
is to rewrite a KB in a form that will answer queries more quickly.  They survey
exact compilation: prime implicates and implicants, unit-resolution-complete 
methods, and theory prime implicates.  They look at approximate compilation:
anytime versions of exact methods, horn approximations (can result in unsound
inference).  They consider compiling non-monotonic knowledge bases with
circumscription, default logic, and belief revision.  All those techniques aim
to reduce intractable query answering to tractable query answering.  Lastly,
Cadoli and Donini mention compilations of _polynomial-time_ query answering,
compilations into something other than a KB, and compare compilation to 
fixed-parameter tractability.
"))(POS (PAPER.TOPIC CADOLI97 "Knowledge Base Compilation"))(POS (PAPER.INSTANCE CASEAU94))(POS (PAPER.AUTHOR CASEAU94 "Yves Caseau"))(POS (PAPER.TITLE CASEAU94 "Constraint Satisfaction with an Object-Oriented Knowledge
Representation Language"))(POS (PAPER.PUBLICATION CASEAU94 "Applied Intelligence "))(POS (PAPER.VOLUME CASEAU94 "4(2)"))(POS (PAPER.STARTPAGE CASEAU94 157))(POS (PAPER.ENDPAGE CASEAU94 184))(POS (PAPER.LINK CASEAU94 "http://citeseer.ist.psu.edu/caseau94constraint.html"))(POS (PAPER.YEAR CASEAU94 1994))(POS (PAPER.RANK CASEAU94 "[***]"))(POS (PAPER.DESCRIPTION CASEAU94 "
Caseau describes how one might solve constraint satisfaction problems
using Laure, an object-oriented language that combines declarative
and procedural knowledge.  In Laure, a Database is used to model
the world; solving a problem amounts to finding objects to fill
goals and satisfy constraints.  Those objects are completions of
the database.  CSPs can be represented by attaching constraints
to objects; a finite number of these objects allows standard 
CSP techniques, e.g. arc consistency, to find solutions.
"))(POS (PAPER.TOPIC CASEAU94 "OO Languages with Native Constraint Satisfaction"))(POS (PAPER.INSTANCE CASEAU96))(POS (PAPER.BIBTEX CASEAU96 ARTICLE))(POS (PAPER.AUTHOR CASEAU96 "Yves Caseau, Francois Laburthe"))(POS (PAPER.TITLE CASEAU96 "CLAIRE: a brief overview"))(POS (PAPER.PUBLICATION CASEAU96 ""))(POS (PAPER.LINK CASEAU96 "http://citeseer.ist.psu.edu/caseau96claire.html"))(POS (PAPER.YEAR CASEAU96 1996))(POS (PAPER.RANK CASEAU96 "[**]"))(POS (PAPER.DESCRIPTION CASEAU96 "
CLAIRE is a programming language designed to be C++ compliant that  
can compute using constraints natively.
"))(POS (PAPER.TOPIC CASEAU96 "OO Languages with Native Constraint Satisfaction"))(POS (PAPER.INSTANCE CHANGLEE))(POS (PAPER.BIBTEX CHANGLEE BOOK))(POS (PAPER.AUTHOR CHANGLEE "Chin-Liang Chang and Richard Lee"))(POS (PAPER.TITLE CHANGLEE "Symbolic Logic and Mechanical Theorem Proving"))(POS (PAPER.PUBLISHER CHANGLEE "Academic Press"))(POS (PAPER.LINK CHANGLEE "http://www.amazon.com/exec/obidos/ASIN/0121703509/qid%3D965533387/sr%3D1-1/102-6107129-2481765"))(POS (PAPER.YEAR CHANGLEE 1973))(POS (PAPER.RANK CHANGLEE ""))(POS (PAPER.DESCRIPTION CHANGLEE "
A classic text for automated reasoning.  Chang and Lee cover propositional and
first-order logic, Herbrand's theorem, resolution (standard, semantic, lock,
and linear) and equality.  They discuss an alternative to resolution, 
Prawitz's procedure and V-resolution.  A chapter on program analysis
leads to query answering and program synthesis in the final chapter.
"))(POS (PAPER.TOPIC CHANGLEE ""))(POS (PAPER.INSTANCE CHEN2000))(POS (PAPER.AUTHOR CHEN2000 "Hubie Chen"))(POS (PAPER.TITLE CHEN2000 "A Theory of Average-Case Compilability in Knowledge Representation"))(POS (PAPER.LINK CHEN2000 "http://citeseer.ist.psu.edu/590465.html"))(POS (PAPER.RANK CHEN2000 "[***]"))(POS (PAPER.DESCRIPTION CHEN2000 "Chen gives an overview of the Compilability hierarchy given
by Cadoli2000.  Then Chen gives theorems concerning average-case
compilability, i.e. analogs of the Cadoli hierarchy when there is a 
distribution over the space of knowledge representations within a class.
The results are pretty densely presented.  
"))(POS (PAPER.TOPIC CHEN2000 "Knowledge Base Compilation"))(POS (PAPER.INSTANCE CHIRKOVA2002))(POS (PAPER.BIBTEX CHIRKOVA2002 PHDTHESIS))(POS (PAPER.AUTHOR CHIRKOVA2002 "Rada Chirkova"))(POS (PAPER.TITLE CHIRKOVA2002 "Automated Database Restructuring"))(POS (PAPER.PUBLISHER CHIRKOVA2002 "Stanford University"))(POS (PAPER.LINK CHIRKOVA2002 ""))(POS (PAPER.YEAR CHIRKOVA2002 2002))(POS (PAPER.RANK CHIRKOVA2002 "[****]"))(POS (PAPER.DESCRIPTION CHIRKOVA2002 "
Chirkova's thesis presents algorithms for computing the set of views
that if materialized would allow queries to be answered optimally.  That is
there is no set of views that if materialized would answer those queries
any more efficiently.  Three results: the problem is decidable, it
has a triply exponential upper bound in the queries, and it has an
exponential lower bound.  Only conjunctions, i.e. SPJ,
are considered, both for view definitions and the queries.
"))(POS (PAPER.TOPIC CHIRKOVA2002 "Databases"))(POS (PAPER.INSTANCE CHOI2000))(POS (PAPER.BIBTEX CHOI2000 MISC))(POS (PAPER.AUTHOR CHOI2000 "Seungyeob Choi"))(POS (PAPER.TITLE CHOI2000 "Semantically Guided Proof Planning"))(POS (PAPER.LINK CHOI2000 "http://citeseer.ist.psu.edu/464153.html"))(POS (PAPER.YEAR CHOI2000 2000))(POS (PAPER.RANK CHOI2000 "[***]"))(POS (PAPER.DESCRIPTION CHOI2000 "
This thesis proposal focuses on adding semantic guidance to
automated theorem proving in two ways: 1) by incorporating
the use of models with a clause graph procedure and 2) by
incorporating the use of models with a proof planning
procedure.  This gives a good overview of various theorem
proving techniques and semantic techniques.
"))(POS (PAPER.TOPIC CHOI2000 "Model-Guided Proof Techniques"))(POS (PAPER.INSTANCE CHOMICKI95))(POS (PAPER.AUTHOR CHOMICKI95 "Jan Chomicki"))(POS (PAPER.TITLE CHOMICKI95 "Efficient Checking of Temporal Integrity Constraints Using Bounded History Encoding"))(POS (PAPER.PUBLICATION CHOMICKI95 "ACM Transactions on Database Systems"))(POS (PAPER.VOLUME CHOMICKI95 "20(2)"))(POS (PAPER.STARTPAGE CHOMICKI95 149))(POS (PAPER.ENDPAGE CHOMICKI95 186))(POS (PAPER.LINK CHOMICKI95 "http://citeseer.ist.psu.edu/chomicki95efficient.html"))(POS (PAPER.YEAR CHOMICKI95 1995))(POS (PAPER.RANK CHOMICKI95 "[**]"))(POS (PAPER.DESCRIPTION CHOMICKI95 "
Chomicki describes an algorithm for maintaining temporal constraints on a database, which are written in past first order temporal logic.  Instead of storing the entire history of the database, Chomicki describes a way to roll up the history (in a lossy way) into auxiliary relations in the database.  She assumes the set of constraints is fixed, which means a single auxiliary relation can be stored for each sentence in the constraints.  She proves this encoding to be polynomially-bounded in the number of domain values that appear in the database over time.  Chomicki extends this work to include real-time constraints, which refer to a clock.
"))(POS (PAPER.TOPIC CHOMICKI95 "Hypothetical Temporal DB Queries"))(POS (PAPER.INSTANCE CHRISTIAN93))(POS (PAPER.BIBTEX CHRISTIAN93 ARTICLE))(POS (PAPER.AUTHOR CHRISTIAN93 "Jim Christian"))(POS (PAPER.TITLE CHRISTIAN93 "Flatterms, Discrimination Nets, and Fast Term Rewriting"))(POS (PAPER.PUBLICATION CHRISTIAN93 "Journal of Automated Reasoning
"))(POS (PAPER.VOLUME CHRISTIAN93 "10"))(POS (PAPER.STARTPAGE CHRISTIAN93 95))(POS (PAPER.ENDPAGE CHRISTIAN93 113))(POS (PAPER.LINK CHRISTIAN93 ""))(POS (PAPER.YEAR CHRISTIAN93 1993))(POS (PAPER.RANK CHRISTIAN93 ""))(POS (PAPER.DESCRIPTION CHRISTIAN93 "
One of the early papers on Discrimination Nets, which is argued as
a reason for representing terms as flat terms.
"))(POS (PAPER.TOPIC CHRISTIAN93 "Indexing"))(POS (PAPER.INSTANCE CLAESSEN2003))(POS (PAPER.BIBTEX CLAESSEN2003 INPROCEEDINGS))(POS (PAPER.AUTHOR CLAESSEN2003 "K. Claessen and N. Sorensson"))(POS (PAPER.TITLE CLAESSEN2003 "New Techniues that Improve MACE-style Finite Model Finding"))(POS (PAPER.PUBLICATION CLAESSEN2003 "CADE-19 Workshop on Model Computation"))(POS (PAPER.LINK CLAESSEN2003 "http://citeseer.ist.psu.edu/claessen03new.html"))(POS (PAPER.YEAR CLAESSEN2003 2003))(POS (PAPER.DESCRIPTION CLAESSEN2003 "
A serieis of techniques are introduced for constructing a finite model
by conversion to SAT, aka the MACE-style model building.  A/the paradox paper.
"))(POS (PAPER.TOPIC CLAESSEN2003 "Model Building"))(POS (PAPER.INSTANCE CLARKE))(POS (PAPER.BIBTEX CLARKE BOOK))(POS (PAPER.AUTHOR CLARKE "Edmund M. Clarke Jr. and Orna Grumberg and Doron Peled"))(POS (PAPER.TITLE CLARKE "Model Checking"))(POS (PAPER.PUBLISHER CLARKE "The MIT Press"))(POS (PAPER.LINK CLARKE "http://mitpress.mit.edu/catalog/item/default.asp?ttype=2&tid=3730"))(POS (PAPER.YEAR CLARKE 1999))(POS (PAPER.RANK CLARKE "[*****]"))(POS (PAPER.DESCRIPTION CLARKE "
An introduction to model checking as performed by the formal methods community.
"))(POS (PAPER.TOPIC CLARKE ""))(POS (PAPER.INSTANCE COHEN90))(POS (PAPER.AUTHOR COHEN90 "P.R. Cohen and H.J. Levesque"))(POS (PAPER.TITLE COHEN90 "Intention is choice with commitment"))(POS (PAPER.PUBLICATION COHEN90 "Artificial Intelligence"))(POS (PAPER.VOLUME COHEN90 "42(3)"))(POS (PAPER.YEAR COHEN90 1990))(POS (PAPER.RANK COHEN90 "[*]"))(POS (PAPER.DESCRIPTION COHEN90 "
Cohen and Levesque use modal operators without explicit mention of time to describe an agent's persistent goals.  These goals will be worked upon until 1) they are achieved or 2) they are deemed impossible.  No work was done here on planning to achieve these goals. 
"))(POS (PAPER.TOPIC COHEN90 "Behavioral Goals"))(POS (PAPER.INSTANCE COMON99))(POS (PAPER.BIBTEX COMON99 ARTICLE))(POS (PAPER.AUTHOR COMON99 "Hubert Comon and Mehmet Dincbas and Jean-pierre Jouannaud and Claude Kirchner"))(POS (PAPER.TITLE COMON99 "A Methodological View of Constraint Solving"))(POS (PAPER.PUBLICATION COMON99 "Constraints"))(POS (PAPER.VOLUME COMON99 "4"))(POS (PAPER.STARTPAGE COMON99 337))(POS (PAPER.ENDPAGE COMON99 361))(POS (PAPER.LINK COMON99 "http://citeseer.ist.psu.edu/13836.html"))(POS (PAPER.YEAR COMON99 1999))(POS (PAPER.DESCRIPTION COMON99 "
The authors motivate why sets are described using constraints and go on to survey the various techniques that have been used for processing those constraints, i.e. (1) determining whether an element belongs to a set or (2) determining whether one set is included entirely in another set (entailment).  They discuss 3 types of techniques: syntactic, semantic, and hybrid.  Syntactic techniques translate a formula into another formula.  Semantic techniques translate formulas into automata or another such formalism.  Hybrid techniques use both.  For more info on automata, try http://www.grappa.univ-lille3.fr/tata/.
"))(POS (PAPER.TOPIC COMON99 "General"))(POS (PAPER.INSTANCE COOK71))(POS (PAPER.BIBTEX COOK71 ARTICLE))(POS (PAPER.AUTHOR COOK71 "Stephen Cook"))(POS (PAPER.TITLE COOK71 "The Complexity of Theorem-Proving Procedures"))(POS (PAPER.PUBLICATION COOK71 "Symposium on the Theory of Computing (STOC)"))(POS (PAPER.STARTPAGE COOK71 151))(POS (PAPER.ENDPAGE COOK71 158))(POS (PAPER.LINK COOK71 "http://citeseer.ist.psu.edu/context/5446/0"))(POS (PAPER.YEAR COOK71 1971))(POS (PAPER.RANK COOK71 "[*]"))(POS (PAPER.DESCRIPTION COOK71 "
This is Cook's paper which introduces the theory of NP completeness
and polynomial reductions.  He gives complexity bounds on theorem-
proving procedures relative to the minimum number of copies of 
axioms required for propositional unsatisfiability.
"))(POS (PAPER.TOPIC COOK71 "Comparative Analysis"))(POS (PAPER.INSTANCE CRAIG2004))(POS (PAPER.BIBTEX CRAIG2004 ARTICLE))(POS (PAPER.AUTHOR CRAIG2004 "S. Craig and J. Gallagher and M. Leuschel and K. Henriksen"))(POS (PAPER.TITLE CRAIG2004 "Fully Automatic Binding-Time Analysis for Prolog"))(POS (PAPER.PUBLICATION CRAIG2004 "14th International Symposium, Logic Based Program Synthesis and Trnasformation (LOPSTR)"))(POS (PAPER.STARTPAGE CRAIG2004 53))(POS (PAPER.ENDPAGE CRAIG2004 68))(POS (PAPER.LINK CRAIG2004 "http://wotan.liu.edu/docis/dbl/lopstr/index.html"))(POS (PAPER.YEAR CRAIG2004 2004))(POS (PAPER.DESCRIPTION CRAIG2004 "
The authors consider the problem of computing modes, i.e. binding
patterns, for prolog relations, and whether to unroll or inline
such relations.  The first computes a set of disjoint types 
from regular types and then propagates them.  The second 
uses binary clause semantics and convex hull abstraction
to determine which relations will not terminate.  Apparently,
very similar work was done in 2001 by Vanhoof and Bruynooghe
in 2001.
"))(POS (PAPER.TOPIC CRAIG2004 "Reformulation"))(POS (PAPER.INSTANCE CYRLUK96SHOSTAKS))(POS (PAPER.BIBTEX CYRLUK96SHOSTAKS INPROCEEDINGS))(POS (PAPER.AUTHOR CYRLUK96SHOSTAKS "David Cyrluk, Patrick Lincoln, and Natarajan Shankar"))(POS (PAPER.TITLE CYRLUK96SHOSTAKS "On Shostak's Decision Procedure for Combinations of Theories"))(POS (PAPER.PUBLICATION CYRLUK96SHOSTAKS "13th International Conference on Automated Deduction
           "))(POS (PAPER.LINK CYRLUK96SHOSTAKS "http://citeseer.ist.psu.edu/cyrluk96shostaks.html"))(POS (PAPER.YEAR CYRLUK96SHOSTAKS 1996))(POS (PAPER.RANK CYRLUK96SHOSTAKS "[****]"))(POS (PAPER.DESCRIPTION CYRLUK96SHOSTAKS "
Cyrluk, Lincoln, and Shankar give a crisp description of the Shostak
procedure and sketch proofs of its properties.  It breaks the algorithm
down into 1) a congruence closure computation and 2) the interpretation
of functions through canonization.  This version of Shostak and all its
counterparts were later shown incomplete.
"))(POS (PAPER.TOPIC CYRLUK96SHOSTAKS "Nelson-Oppen and Shostak"))(POS (PAPER.RELATED CYRLUK96SHOSTAKS SHOSTAK84))(POS (PAPER.RELATED CYRLUK96SHOSTAKS RUEB2000DECONSTRUCTING))(POS (PAPER.INSTANCE DANTSIN2001))(POS (PAPER.AUTHOR DANTSIN2001 "Evgeny Dantsin and Thomas Eiter and Georg Gottlob and Andrei Voronkov"))(POS (PAPER.TITLE DANTSIN2001 "Complexity and Expressive Power of Logic Programming"))(POS (PAPER.PUBLICATION DANTSIN2001 "ACM Computing Surveys"))(POS (PAPER.VOLUME DANTSIN2001 "33(3)"))(POS (PAPER.STARTPAGE DANTSIN2001 374))(POS (PAPER.ENDPAGE DANTSIN2001 425))(POS (PAPER.LINK DANTSIN2001 "http://portal.acm.org/citation.cfm?id=502810&dl=ACM&coll=GUIDE"))(POS (PAPER.YEAR DANTSIN2001 2001))(POS (PAPER.DESCRIPTION DANTSIN2001 "
Complexity results for logic programming.
"))(POS (PAPER.TOPIC DANTSIN2001 "Logic Programming"))(POS (PAPER.INSTANCE DARWICHE2002))(POS (PAPER.BIBTEX DARWICHE2002 ARTICLE))(POS (PAPER.AUTHOR DARWICHE2002 "Adnan Darwiche and Pierre Marquis"))(POS (PAPER.TITLE DARWICHE2002 "A Knowledge Compilation Map"))(POS (PAPER.PUBLICATION DARWICHE2002 "Journal of Artificial Intelligence Research"))(POS (PAPER.VOLUME DARWICHE2002 "17"))(POS (PAPER.STARTPAGE DARWICHE2002 229))(POS (PAPER.ENDPAGE DARWICHE2002 264))(POS (PAPER.LINK DARWICHE2002 "http://citeseer.ist.psu.edu/497263.html"))(POS (PAPER.YEAR DARWICHE2002 2002))(POS (PAPER.DESCRIPTION DARWICHE2002 "
The authors analyze knowledge compilation on two axes: the succinctness of
the target language and the class of queries and transformations that the
language supports in polytime.  They analyze a large number of existing
approaches.
"))(POS (PAPER.TOPIC DARWICHE2002 "Knowledge Base Compilation"))(POS (PAPER.INSTANCE DAVIS60))(POS (PAPER.BIBTEX DAVIS60 ARTICLE))(POS (PAPER.AUTHOR DAVIS60 "M. Davis and H. Putnam"))(POS (PAPER.TITLE DAVIS60 "A Machine Program for Theorem Proving"))(POS (PAPER.PUBLICATION DAVIS60 "Journal of the ACM"))(POS (PAPER.VOLUME DAVIS60 "7"))(POS (PAPER.STARTPAGE DAVIS60 201))(POS (PAPER.ENDPAGE DAVIS60 215))(POS (PAPER.YEAR DAVIS60 1960))(POS (PAPER.DESCRIPTION DAVIS60 "
One of the DPLL papers.
"))(POS (PAPER.TOPIC DAVIS60 "Calculi"))(POS (PAPER.INSTANCE DAVIS62))(POS (PAPER.BIBTEX DAVIS62 ARTICLE))(POS (PAPER.AUTHOR DAVIS62 "M. Davis and G. Logemann an D. Loveland"))(POS (PAPER.TITLE DAVIS62 "A Computing Procedure for Quantification Theory"))(POS (PAPER.PUBLICATION DAVIS62 "Communications of the ACM"))(POS (PAPER.VOLUME DAVIS62 "5"))(POS (PAPER.STARTPAGE DAVIS62 394))(POS (PAPER.ENDPAGE DAVIS62 397))(POS (PAPER.YEAR DAVIS62 1962))(POS (PAPER.DESCRIPTION DAVIS62 "
One of the DPLL papers.
"))(POS (PAPER.TOPIC DAVIS62 "Calculi"))(POS (PAPER.INSTANCE DAVIS94))(POS (PAPER.BIBTEX DAVIS94 TECHREPORT))(POS (PAPER.AUTHOR DAVIS94 "Ernest Davis"))(POS (PAPER.TITLE DAVIS94 "Lucid Representations"))(POS (PAPER.PUBLISHER DAVIS94 "New York University"))(POS (PAPER.LINK DAVIS94 "http://citeseer.ist.psu.edu/davis94lucid.html"))(POS (PAPER.YEAR DAVIS94 1994))(POS (PAPER.RANK DAVIS94 "[****]"))(POS (PAPER.DESCRIPTION DAVIS94 "
Davis writes Lucid Representations in part to argue Levesque's
Making Believers Out of Computers paper.  Davis claims Levesque argues
that the only representations one should allow are complete ones,
in the database sense to ensure reasoning is fast.  Davis argues
that no AI system could get by with only complete information.
Incomplete information is imperative.  Davis attempts to propose
a technique for achieving the benefits of complete information
from starting from incomplete information by first instantiating
to complete the theory, then reasoning quickly, and finally 
ignoring those results which were artificially  introduced by
the process of instantiation.  This is a position piece trying to
refute Levesque's vision of the future and replacing
it with a vision of its own.
"))(POS (PAPER.TOPIC DAVIS94 "Logical Knowledge Representation"))(POS (PAPER.INSTANCE DEBRAY93))(POS (PAPER.BIBTEX DEBRAY93 ARTICLE))(POS (PAPER.AUTHOR DEBRAY93 "Saumya Debray and Nai-Wei Lin"))(POS (PAPER.TITLE DEBRAY93 "Cost Analysis of Logic Programs"))(POS (PAPER.PUBLICATION DEBRAY93 "ACM Transactions on Programming Languages and Systems>"))(POS (PAPER.VOLUME DEBRAY93 "15(5)"))(POS (PAPER.STARTPAGE DEBRAY93 826))(POS (PAPER.ENDPAGE DEBRAY93 875))(POS (PAPER.YEAR DEBRAY93 1993))(POS (PAPER.DESCRIPTION DEBRAY93 "
Debray and Lin outline techniques for computing upper bounds on the cost
of a logic program, taking in account multiple solutions and nondeterminism.
Based on relationship between argument size, moded relations, and typed 
relations.
"))(POS (PAPER.TOPIC DEBRAY93 "Logic Programming"))(POS (PAPER.INSTANCE DECHTER92))(POS (PAPER.BIBTEX DECHTER92 ARTICLE))(POS (PAPER.AUTHOR DECHTER92 "Rina Dechter and Judea Pearl"))(POS (PAPER.TITLE DECHTER92 "Structure Identificatioin in Relational Data"))(POS (PAPER.PUBLICATION DECHTER92 "Artificial Intelligence"))(POS (PAPER.VOLUME DECHTER92 "58(1-3)"))(POS (PAPER.STARTPAGE DECHTER92 237))(POS (PAPER.ENDPAGE DECHTER92 270))(POS (PAPER.LINK DECHTER92 "http://citeseer.ist.psu.edu/dechter97structure.html"))(POS (PAPER.YEAR DECHTER92 1992))(POS (PAPER.RANK DECHTER92 "[**]"))(POS (PAPER.DESCRIPTION DECHTER92 "
Dechter and Pearl describe building a propositional Horn representation
of a given set of models.  Identifying whether such a representation 
exists turns out to be polynomial in the size of the models.  Building
such a representation is polynomial in the size of the models and
the number of variables.  For k-Horn theories, a tightest approximation
can also be calculated in polynomial time.  
"))(POS (PAPER.TOPIC DECHTER92 "Knowledge Base Compilation"))(POS (PAPER.INSTANCE DELVAL96))(POS (PAPER.BIBTEX DELVAL96 INPROCEEDINGS))(POS (PAPER.AUTHOR DELVAL96 "Alvaro del Val"))(POS (PAPER.TITLE DELVAL96 "Approximate Knowledge Compilation: The First Order Case"))(POS (PAPER.PUBLICATION DELVAL96 "AAAI"))(POS (PAPER.STARTPAGE DELVAL96 498))(POS (PAPER.ENDPAGE DELVAL96 503))(POS (PAPER.LINK DELVAL96 "http://citeseer.ist.psu.edu/delval96approximate.html"))(POS (PAPER.YEAR DELVAL96 1996))(POS (PAPER.RANK DELVAL96 "[****]"))(POS (PAPER.DESCRIPTION DELVAL96 "
This seems to be the seminal work on Knowledge Compilation for FOL.  
del Val introduces a new algorithm for computing the Least Upper
Bound approximation for a propositional knowledge base, at times
exponentially better than the previously known algorithm.  He then
lifts both algorithms to first order logic under some restrictions.
"))(POS (PAPER.TOPIC DELVAL96 "Knowledge Base Compilation"))(POS (PAPER.RELATED DELVAL96 SELMAN91))(POS (PAPER.INSTANCE DERSHOWITZ82))(POS (PAPER.AUTHOR DERSHOWITZ82 "Nachum Dershowitz"))(POS (PAPER.TITLE DERSHOWITZ82 "Orderings for Term-rewriting Systems"))(POS (PAPER.PUBLICATION DERSHOWITZ82 "Theoretical Computer Science"))(POS (PAPER.VOLUME DERSHOWITZ82 "17"))(POS (PAPER.STARTPAGE DERSHOWITZ82 279))(POS (PAPER.ENDPAGE DERSHOWITZ82 301))(POS (PAPER.LINK DERSHOWITZ82 "http://citeseer.ist.psu.edu/context/20249/0"))(POS (PAPER.YEAR DERSHOWITZ82 1982))(POS (PAPER.DESCRIPTION DERSHOWITZ82 "
This paper confronts termination in term-rewriting systems.  
Dershowitz first defines the notion of a non-terminating rewrite system,
i.e. one with an infinite homeomorphic self-embedding derivation.  Then
he defines a simplification ordering as a partial ordering with
the replacement (monotonicity), subterm, and deletion properties.  If there
is a simplification ordering for a term rewriting system such that l > r for
every rewrite rule l -> r then the rewrite system terminates.  Dershowitz
goes on to define a quasi-simplification ordering, which is weaker than
a simplification ordering, making it easier to prove rewrite systems
terminate.  The reason this paper is located in this section is that
the notion of a recursive path ordering is then defined.  RPO and
variants thereof are used in modern theorem provers when ordering
is necessary.  The last section goes through a series of examples
that demonstrate how to prove rewrite systems terminate.
"))(POS (PAPER.TOPIC DERSHOWITZ82 "Orderings"))(POS (PAPER.INSTANCE DERSHOWITZ93))(POS (PAPER.BIBTEX DERSHOWITZ93 INBOOK))(POS (PAPER.AUTHOR DERSHOWITZ93 "Nachum Dershowitz"))(POS (PAPER.TITLE DERSHOWITZ93 "A Taste of Rewrite Systems"))(POS (PAPER.PUBLICATION DERSHOWITZ93 "Functional Programming, Concurrency, Simulation, and
Automated Reasoning"))(POS (PAPER.STARTPAGE DERSHOWITZ93 199))(POS (PAPER.ENDPAGE DERSHOWITZ93 228))(POS (PAPER.LINK DERSHOWITZ93 "http://citeseer.ist.psu.edu/dershowitz93taste.html"))(POS (PAPER.YEAR DERSHOWITZ93 1993))(POS (PAPER.RANK DERSHOWITZ93 ""))(POS (PAPER.DESCRIPTION DERSHOWITZ93 "
Dershowitz gives a whirlwind tour of rewrite systems, covering the
basic properties termination (existence of normal forms), 
confluence (the uniqueness of those forms), completion (how to construct 
confluent systems), checking entailment and solving equations via 
basically abduction.  He also discusses special techniques for dealing
with associative and commutative systems and conditional rewriting rules.
Applications include theorem proving and programming
"))(POS (PAPER.TOPIC DERSHOWITZ93 "Theorem Proving"))(POS (PAPER.INSTANCE DOYLE91))(POS (PAPER.BIBTEX DOYLE91 ARTICLE))(POS (PAPER.AUTHOR DOYLE91 "Jon Doyle and Ramesh Patil"))(POS (PAPER.TITLE DOYLE91 "Two Theses of Knowledge Representation: Language Restrictions, Taxonomic Classification, and the Utility of Representation Services"))(POS (PAPER.PUBLICATION DOYLE91 "Artificial Intelligence"))(POS (PAPER.VOLUME DOYLE91 "48(3)"))(POS (PAPER.STARTPAGE DOYLE91 261))(POS (PAPER.ENDPAGE DOYLE91 298))(POS (PAPER.LINK DOYLE91 "http://citeseer.ist.psu.edu/doyle91two.html"))(POS (PAPER.YEAR DOYLE91 1991))(POS (PAPER.RANK DOYLE91 "[****]"))(POS (PAPER.DESCRIPTION DOYLE91 "
Doyle and Patil argue against Levesque and Brachman's position that a
general purpose KB system must be able to answer all questions 
in a bounded amount of time.  In particular, they examine KL-ONE
and its variants, enumerating classes of problems that a restricted
language cannot express but that would be natural for use in a KB
system.  They argue that worst-case complexity is the right measure for
just a small fraction of all potential applications of a Knowledge-based
system.  
"))(POS (PAPER.TOPIC DOYLE91 "Logical Knowledge Representation"))(POS (PAPER.INSTANCE DYMETMAN91))(POS (PAPER.BIBTEX DYMETMAN91 ARTICLE))(POS (PAPER.AUTHOR DYMETMAN91 "M. Dymetman"))(POS (PAPER.TITLE DYMETMAN91 "Inherently Reversible Grammars, Logic Programming and Computability"))(POS (PAPER.LINK DYMETMAN91 "http://acl.ldc.upenn.edu/W/W91/W91-0104.pdf"))(POS (PAPER.YEAR DYMETMAN91 1991))(POS (PAPER.RANK DYMETMAN91 "[***]"))(POS (PAPER.DESCRIPTION DYMETMAN91 "
Dymetman offers a decoupling of the term reversible grammar into (1)
uniformity of implementation for parsers and generators and (2) 
reversibility as an inherent property of a grammar.  He formalizes
the second idea, which includes various notions about the completeness
and termination of answer extraction for logic programming.
"))(POS (PAPER.TOPIC DYMETMAN91 "Natural Language Processing"))(POS (PAPER.INSTANCE EBBINGHAUS))(POS (PAPER.BIBTEX EBBINGHAUS BOOK))(POS (PAPER.AUTHOR EBBINGHAUS "Heinz-Dieter Ebbinghaus and Jorg Flum"))(POS (PAPER.TITLE EBBINGHAUS "Finite Model Theory"))(POS (PAPER.PUBLISHER EBBINGHAUS "Springer-Verlag"))(POS (PAPER.LINK EBBINGHAUS "http://www.amazon.com/Finite-Theory-Springer-Monographs-Mathematics/dp/3540287876"))(POS (PAPER.YEAR EBBINGHAUS 1999))(POS (PAPER.RANK EBBINGHAUS "[*****]"))(POS (PAPER.DESCRIPTION EBBINGHAUS "
The authors introduce Finite Model Theory, a logic that is identical to first-order
logic but where a model is defined as having a finite universe.  Topics covered
include Ehrenfeucht-Fraisse Method, 01 laws, finite automata, descriptive
complexity theory, fixed-point operators, logic programs, logics for PTIME, 
and logical reductions.
"))(POS (PAPER.TOPIC EBBINGHAUS ""))(POS (PAPER.INSTANCE EITER2001))(POS (PAPER.BIBTEX EITER2001 INPROCEEDINGS))(POS (PAPER.AUTHOR EITER2001 "Thomas Eiter and Toshihide Ibaraki and Kazuhisa Makino"))(POS (PAPER.TITLE EITER2001 "Disjunctions of Horn Theories and their Cores"))(POS (PAPER.PUBLICATION EITER2001 "ISAAC"))(POS (PAPER.LINK EITER2001 "http://citeseer.ist.psu.edu/eiter01disjunctions.html"))(POS (PAPER.YEAR EITER2001 2001))(POS (PAPER.RANK EITER2001 "[*]"))(POS (PAPER.DESCRIPTION EITER2001 "
This paper studies the problem of determining whether a disjunction of 
Horn theories is Horn and if not computing a Horn core and envelope.
Eiter et. al. investigate both the characteristic model representation
of Horn theories and the CNF representation.  For both representations 
the problem is intractable.
"))(POS (PAPER.TOPIC EITER2001 "Characteristic Models"))(POS (PAPER.INSTANCE EITER2004))(POS (PAPER.BIBTEX EITER2004 INPROCEEDINGS))(POS (PAPER.AUTHOR EITER2004 "Thomas Eiter and Thomas Lukasiewicz and Roman Schindlauer and Hans Tompits"))(POS (PAPER.TITLE EITER2004 "Combining Answer Set Programming with Description Logics for the Semantic Web"))(POS (PAPER.PUBLICATION EITER2004 "Proceedings of Knowledge Representation and Reasoning"))(POS (PAPER.LINK EITER2004 "http://citeseer.ist.psu.edu/727609.html"))(POS (PAPER.YEAR EITER2004 2004))(POS (PAPER.DESCRIPTION EITER2004 "
A language that integrates SHIF(D) and SHOIN(D) with answer set programming
"))(POS (PAPER.TOPIC EITER2004 "Semantic Web"))(POS (PAPER.INSTANCE EITER98))(POS (PAPER.BIBTEX EITER98 INPROCEEDINGS))(POS (PAPER.AUTHOR EITER98 "Thomas Eiter and Thoshihide Ibaraki and Kazuhisa Makino"))(POS (PAPER.TITLE EITER98 "Computing Intersections of Horn Theories for Reasoning with Models"))(POS (PAPER.PUBLICATION EITER98 "AAAI"))(POS (PAPER.LINK EITER98 "http://citeseer.ist.psu.edu/537461.html"))(POS (PAPER.YEAR EITER98 1998))(POS (PAPER.RANK EITER98 "[****]"))(POS (PAPER.DESCRIPTION EITER98 "
The authors examine complexity issues that arise when intersecting several
propositional horn knowledge bases, which are represented with 
characteristic models.  Finding
the unique minimal model (which is a characteristic model) can be done
in linear time in the number of KBs.  Finding all-models can be solved
with polynomial delay (a polynomial amount of time between outputting
models).  In a sense, that means the procedure is polynomial, but the 
number of outputs could be exponential.  Finding all characteristic
models of the intersection has no polynomial time algorithm (even if
P = NP).  Answering deductive queries can still be accomplished in
polynomial time by looking at each KB independently.  Finally, abduction
is shown to be intractable, which differs from the result of a single
KB (where it is polynomial).
"))(POS (PAPER.TOPIC EITER98 "Characteristic Models"))(POS (PAPER.INSTANCE ENDERTON))(POS (PAPER.BIBTEX ENDERTON BOOK))(POS (PAPER.AUTHOR ENDERTON "Herbert Enderton"))(POS (PAPER.TITLE ENDERTON "A Mathematical Introduction to Logic"))(POS (PAPER.PUBLISHER ENDERTON "Academic Press"))(POS (PAPER.LINK ENDERTON "http://www.amazon.com/exec/obidos/tg/detail/-/0122384520/qid=1062605496/sr=1-6/ref=sr_1_6/102-6107129-2481765?v=glance&s=books"))(POS (PAPER.YEAR ENDERTON 2000))(POS (PAPER.RANK ENDERTON "[*****]"))(POS (PAPER.DESCRIPTION ENDERTON "
The definitive text on introductory mathematical logic.  Enderton covers both 
propositional (sentential),  and first-order logic including compactness, completeness,
and soundness proofs.  The third chapter covers undecidability, Godel's 
incompleteness proof, and Church's and Tarski's theorems.  The last chapter
covers second-order logic. 
"))(POS (PAPER.TOPIC ENDERTON ""))(POS (PAPER.INSTANCE ETHERINGTON89))(POS (PAPER.BIBTEX ETHERINGTON89 ARTICLE))(POS (PAPER.AUTHOR ETHERINGTON89 "David Etherington and Alex Borgida and Ronald Brachman and Henry Kautz"))(POS (PAPER.TITLE ETHERINGTON89 "Vivid Knowledge and Tractable Reasoning"))(POS (PAPER.PUBLICATION ETHERINGTON89 "IJCAI"))(POS (PAPER.STARTPAGE ETHERINGTON89 1146))(POS (PAPER.ENDPAGE ETHERINGTON89 1152))(POS (PAPER.LINK ETHERINGTON89 "http://citeseer.ist.psu.edu/etherington89vivid.html"))(POS (PAPER.YEAR ETHERINGTON89 1989))(POS (PAPER.RANK ETHERINGTON89 "[****]"))(POS (PAPER.DESCRIPTION ETHERINGTON89 "
Etherington, et.al. give a preliminary description of representing a KB with a set of atoms.  They try to motivate the work by appealing to the speed of humans' commonsense reasoning facilities as evidence that much such reasoning is done via lookup.   A set of atoms is not very expressive, so the first extension is to allow definite clauses: a(x)=>b(x).  To deal with this they use a closed world assumption.  Second extension tries to deal with disjunction: age(joe,53) | age(joe,55) is replaced by age(joe,x)^in50s(x).  Third extension uses skolems to remove disjunction: p(a) | p(b) becomes p(k). 
"))(POS (PAPER.TOPIC ETHERINGTON89 "Logical Knowledge Representation"))(POS (PAPER.INSTANCE FAGIN82))(POS (PAPER.BIBTEX FAGIN82 ARTICLE))(POS (PAPER.AUTHOR FAGIN82 "Ronald Fagin"))(POS (PAPER.TITLE FAGIN82 "Horn Clauses and Database Dependencies"))(POS (PAPER.PUBLICATION FAGIN82 "Journal of the ACM"))(POS (PAPER.VOLUME FAGIN82 "29(4)"))(POS (PAPER.STARTPAGE FAGIN82 952))(POS (PAPER.ENDPAGE FAGIN82 985))(POS (PAPER.LINK FAGIN82 "http://citeseer.ist.psu.edu/context/62052/0"))(POS (PAPER.YEAR FAGIN82 1982))(POS (PAPER.RANK FAGIN82 "[****]"))(POS (PAPER.DESCRIPTION FAGIN82 "
Fagin generalizes dependencies in the database literature and
shows the following are all equivalent for a given set of sentences
S.  1) There is an operator O that maps nonempty families of models
into models such that if sigma is a sentence in S and R_i is a
nonempty family of models, then sigma holds for O(R_i) iff sigma
holds for each R_i.  2) Whenever Sigma is a consistent subset of S
and Sigma* is the set of sentences in S that are logical consequences
of Sigma, there is an Armstrong model--it obeys Sigma* and no other
sentences in S.  3) Whenever Sigma is a subset of S and phi_i is a 
nonempty subset of S then Sigma |= V phi_i iff there is some i for
which Sigma |= phi_i.  For FOL in general, there is no Armstrong relation for 
first-order axiom sets.  Take the empty set of axioms, and assume
there is an Armstrong relation R.  R will either entail or not
entail any non-tautology sigma, which means R is not an Armstrong
relation for the axiom set.  A corollary to this theorem shows
that any axiom set Delta in a Horn-related subset of FOL can be
represented with a single, infinite model.
"))(POS (PAPER.TOPIC FAGIN82 "Characteristic Models"))(POS (PAPER.INSTANCE FIKES71))(POS (PAPER.AUTHOR FIKES71 "R.E. Fikes and N.J. Nilsson"))(POS (PAPER.TITLE FIKES71 "STRIPS: a new approach to the application of theorem proving to problem solving"))(POS (PAPER.PUBLICATION FIKES71 "Artificial Intelligence"))(POS (PAPER.VOLUME FIKES71 "2(3-4)"))(POS (PAPER.STARTPAGE FIKES71 189))(POS (PAPER.ENDPAGE FIKES71 208))(POS (PAPER.YEAR FIKES71 1971))(POS (PAPER.DESCRIPTION FIKES71 "
The STRIPS paper.  Fikes and Nilsson allow first-order formulas to describe the action preconditions and effects (add/delete lists) but maintain that each operator instanatiation must be ground.  They note that the case of non-ground instantiations needs more study.  Interestingly, they generate successor states in the search tree using a form of residue from a proof that a given world state achieves a given subgoal.  They implement a world state as being a set of changes from the initial state.
"))(POS (PAPER.TOPIC FIKES71 "Historical"))(POS (PAPER.INSTANCE FIKES72))(POS (PAPER.AUTHOR FIKES72 "Richard Fikes, Peter Hart and Nils Nilsson"))(POS (PAPER.TITLE FIKES72 "Learning and Executing Generalized Robot Plans"))(POS (PAPER.PUBLICATION FIKES72 "Artificial Intelligence"))(POS (PAPER.VOLUME FIKES72 "3(4)"))(POS (PAPER.STARTPAGE FIKES72 251))(POS (PAPER.ENDPAGE FIKES72 288))(POS (PAPER.YEAR FIKES72 1972))(POS (PAPER.DESCRIPTION FIKES72 "
Fikes, Hart, and Nillson take a STRIPS planner, 1) describe a concise
representation for plans (triangle tables), 2) develop a method for
generalizing plans to make new primitive actions (MACROPs), 3) describe
an execution engine (PLANEX) that uses these Macrops that does replanning and
handles coincidental goal achievement.  They go on to describe needed future
improvements: 1) creating a set of abstractions for the new primitives actions
to avoid dealing with large numbers of preconditions and 2) discarding
subsumed or otherwise unused primitive operators to avoid an ever-growing
operator set.
"))(POS (PAPER.TOPIC FIKES72 "Historical"))(POS (PAPER.INSTANCE FIKES93))(POS (PAPER.AUTHOR FIKES93 "R.E. Fikes and N.J. Nilsson"))(POS (PAPER.TITLE FIKES93 "STRIPS, a retrospective"))(POS (PAPER.PUBLICATION FIKES93 "Artificial Intelligence"))(POS (PAPER.VOLUME FIKES93 "59(1-2)"))(POS (PAPER.STARTPAGE FIKES93 227))(POS (PAPER.ENDPAGE FIKES93 232))(POS (PAPER.YEAR FIKES93 1993))(POS (PAPER.DESCRIPTION FIKES93 "
This short paper puts the STRIPS work in a historical context, examining both the plan generator and execution monitor.  Green's work on deductive plan synthesis was the first real planner, but most researchers didn't explore monitoring execution (they were assuming computational environments).  Fikes and Nilsson used 'kernels' to represent the sentences that must be true at each stage of the plan for the rest of the plan to succeed.  They also used the notion of a 'triangle table' to represent plans so that serendipitous acts and action-failure-but-that's-all-you-can-do-so-just-try-again events would not require replanning.
"))(POS (PAPER.TOPIC FIKES93 "Historical"))(POS (PAPER.INSTANCE FITTING2007))(POS (PAPER.BIBTEX FITTING2007 ARTICLE))(POS (PAPER.AUTHOR FITTING2007 "Melvin Fitting"))(POS (PAPER.TITLE FITTING2007 "Intensional Logic"))(POS (PAPER.PUBLICATION FITTING2007 "The Stanford Encyclopedia of Philosophy (Spring 2007 Edition), Edward N. Zalta (ed.)"))(POS (PAPER.LINK FITTING2007 "http://plato.stanford.edu/archives/spr2007/entries/logic-intensional/"))(POS (PAPER.YEAR FITTING2007 2007))(POS (PAPER.DESCRIPTION FITTING2007 "
The mathematical foundations of logical query languages.
"))(POS (PAPER.TOPIC FITTING2007 "Logical Knowledge Representation"))(POS (PAPER.INSTANCE FOLLETT80))(POS (PAPER.BIBTEX FOLLETT80 ARTICLE))(POS (PAPER.AUTHOR FOLLETT80 "Ria Follett"))(POS (PAPER.TITLE FOLLETT80 "Synthesising Recursive Functions with Side Effects"))(POS (PAPER.PUBLICATION FOLLETT80 "Artificial Intelligence"))(POS (PAPER.VOLUME FOLLETT80 "13:3"))(POS (PAPER.STARTPAGE FOLLETT80 175))(POS (PAPER.ENDPAGE FOLLETT80 200))(POS (PAPER.YEAR FOLLETT80 1980))(POS (PAPER.RANK FOLLETT80 "[*]"))(POS (PAPER.DESCRIPTION FOLLETT80 "
"))(POS (PAPER.TOPIC FOLLETT80 "Theorem Proving with Attachments"))(POS (PAPER.INSTANCE FRANCONI2004))(POS (PAPER.BIBTEX FRANCONI2004 INPROCEEDINGS))(POS (PAPER.AUTHOR FRANCONI2004 "Enrico Franconi and Sergio Tessaris"))(POS (PAPER.TITLE FRANCONI2004 "Rules and Queries with Ontologies: A Unified Logical Framework"))(POS (PAPER.PUBLICATION FRANCONI2004 "Proceedings of Principles and Practice of Semantic Web Reasoning"))(POS (PAPER.LINK FRANCONI2004 "http://www.springerlink.com/content/1hnwcggw510elp4y/"))(POS (PAPER.YEAR FRANCONI2004 2004))(POS (PAPER.DESCRIPTION FRANCONI2004 "
A comparison of various techniques for integrating logic programming with 
description logics.
"))(POS (PAPER.TOPIC FRANCONI2004 "Semantic Web"))(POS (PAPER.INSTANCE GAMMER2007))(POS (PAPER.BIBTEX GAMMER2007 INPROCEEDINGS))(POS (PAPER.AUTHOR GAMMER2007 "Igor Gammer and Eyal Amir"))(POS (PAPER.TITLE GAMMER2007 "Solving Satisfiability in Ground Logic with Equality by Efficient Conversion to Propositional Logic"))(POS (PAPER.PUBLICATION GAMMER2007 "Proc. 7th Symposium on Abstraction, Reformulation, and Approximation"))(POS (PAPER.LINK GAMMER2007 "http://reason.cs.uiuc.edu/eyal/paper.html"))(POS (PAPER.YEAR GAMMER2007 2007))(POS (PAPER.DESCRIPTION GAMMER2007 "
The authors consider ground first-order logic with equality and show
how one can employ Craig's Interpolation theorem to reduce the cost
of grounding out the usual axiomatization of equality.
"))(POS (PAPER.TOPIC GAMMER2007 "Reformulation"))(POS (PAPER.INSTANCE GEDDIS95))(POS (PAPER.BIBTEX GEDDIS95 PHDTHESIS))(POS (PAPER.AUTHOR GEDDIS95 "Don Geddis"))(POS (PAPER.TITLE GEDDIS95 "Caching and Non-Horn Inference in Model Elimination Theorem Provers"))(POS (PAPER.PUBLISHER GEDDIS95 "Stanford University"))(POS (PAPER.LINK GEDDIS95 "http://library.stanford.edu/depts/mathcs/mathcscoll/techreports.html"))(POS (PAPER.YEAR GEDDIS95 1995))(POS (PAPER.RANK GEDDIS95 "[***]"))(POS (PAPER.DESCRIPTION GEDDIS95 "
Geddis investigates Nonhorn caching for model elimination.  Astrachan and
Stickel did the seminal work on caching for the Horn case.  Nonhorn
caching is made difficult by the reduction operation, i.e. proofs of
subgoals are context dependent.  Previous work stored the context and
the proven subgoal.  Geddis shows that if a literal has a completion in
one context, it has a completion in every context.  Thus, if a subgoal
cannot be completed, it can be added to a failure cache.  A completion is
not the same as a proof, however, and there are no results for success
caching.  If a depth-limited search-strategy is used, incompleteness can
result; Geddis found no solution for this problem.  Also discussed is an
extension to David Smith's work: postponement caching.  It basically avoids
infinite recursions if possible by 'enslaving' a subgoal to an ancestor
if the two unify.  It is complete for Horn and incomplete for nonHorn.
"))(POS (PAPER.TOPIC GEDDIS95 "Theorem Proving with Attachments"))(POS (PAPER.INSTANCE GELERNTER63))(POS (PAPER.BIBTEX GELERNTER63 ARTICLE))(POS (PAPER.AUTHOR GELERNTER63 "H. Gelernter"))(POS (PAPER.TITLE GELERNTER63 "Realization of a Geometry-Theorem Proving Machine"))(POS (PAPER.PUBLICATION GELERNTER63 "Computers and Thought"))(POS (PAPER.STARTPAGE GELERNTER63 134))(POS (PAPER.ENDPAGE GELERNTER63 152))(POS (PAPER.YEAR GELERNTER63 1963))(POS (PAPER.RANK GELERNTER63 "[*]"))(POS (PAPER.DESCRIPTION GELERNTER63 "
Gelernter describes the Geometry Machine, an ad hoc theorem prover
for Euclidian geometry.  It uses a diagram as a heuristic to guide
the theorem prover's search, eliminating subgoals when not 
satisfied by the diagram.  Sometimes that diagram prunes too much,
in which case multiple diagrams need to be generated to achieve
completeness.  The system is also unique in the fact that it does
not give the theorem prover a complete axiomitization of geometry,
but rather allows it to add axioms that are 'obvious' from the 
diagram, much as a human might do.
"))(POS (PAPER.TOPIC GELERNTER63 "Graphical Reasoning Techniques"))(POS (PAPER.INSTANCE GELFOND88))(POS (PAPER.BIBTEX GELFOND88 ARTICLE))(POS (PAPER.AUTHOR GELFOND88 "Michael Gelfond and Vladimir Lifschitz"))(POS (PAPER.TITLE GELFOND88 "The Stable Model Semantics for Logic Programming"))(POS (PAPER.PUBLICATION GELFOND88 "Proceedings of the Fifth International Conference on Logic Programming"))(POS (PAPER.STARTPAGE GELFOND88 1070))(POS (PAPER.ENDPAGE GELFOND88 1080))(POS (PAPER.LINK GELFOND88 "http://citeseer.ist.psu.edu/gelfond88stable.html"))(POS (PAPER.YEAR GELFOND88 1988))(POS (PAPER.DESCRIPTION GELFOND88 "
Stable model semantics for logic programming.
"))(POS (PAPER.TOPIC GELFOND88 "Logic Programming"))(POS (PAPER.INSTANCE GENESERETH87))(POS (PAPER.BIBTEX GENESERETH87 BOOK))(POS (PAPER.AUTHOR GENESERETH87 "Michael Genesereth and Nils Nilsson"))(POS (PAPER.TITLE GENESERETH87 "Logical Foundations of Artificial Intelligence"))(POS (PAPER.PUBLISHER GENESERETH87 "Morgan Kaufmann Publishers"))(POS (PAPER.LINK GENESERETH87 "http://www.amazon.com/Foundations-Artificial-Intelligence-Michael-Genesereth/dp/0934613311"))(POS (PAPER.YEAR GENESERETH87 1987))(POS (PAPER.RANK GENESERETH87 "[*****]"))(POS (PAPER.DESCRIPTION GENESERETH87 "
Genesereth and Nilsson construct the foundations of AI using logic.  Covers logic, resolution and various strategies, nonmonotonic reasoning, induction, uncertainty, belief,
metaknowledge and metareasoning, a changing environment, and agent architectures.
"))(POS (PAPER.TOPIC GENESERETH87 ""))(POS (PAPER.INSTANCE GIACOMO2000))(POS (PAPER.AUTHOR GIACOMO2000 "G. De Giacomo, Y. Lesperance, and H.J. Levesque"))(POS (PAPER.TITLE GIACOMO2000 "ConGolog, a concurrent prrogramming language based on the situation calculus"))(POS (PAPER.PUBLICATION GIACOMO2000 "Artificial Intelligence"))(POS (PAPER.VOLUME GIACOMO2000 "121"))(POS (PAPER.STARTPAGE GIACOMO2000 109))(POS (PAPER.ENDPAGE GIACOMO2000 169))(POS (PAPER.LINK GIACOMO2000 "http://www.cs.yorku.ca/~lesperan/publications.html"))(POS (PAPER.YEAR GIACOMO2000 2000))(POS (PAPER.DESCRIPTION GIACOMO2000 "
ConGolog extends Golog (both implementations being in Prolog) to include concurrent actions (conceptualized as interleaving actions of different processes that can block, in the OS sense).  The constructs introduced here include synchronized conditionals (test-and-set), synchronized loops, concurrent execution, concurrency with different priorities (the lower priority process can only execute if the higher priority one is blocked or finished), concurrent iteration, and interrupts.  Nondeterminstic iteration can be useful when an unspecified number of programs need to be run concurrently, e.g. an FTP server.  Some more work is required to handle procedures.  The semantics given in the original Golog paper were evaluation semantics.  Here the authors switch to transition semantics and require all the macros of Golog to become embedded in the language.
Exogenous events are handled by allowing the user to specify which primitive actions may occurs outside the control of the program.  A predefined program for choosing a possible exogenous action, checking its preconditions, and executing it if possible is run concurrently with the user-defined program. To handle truly overlapping actions such as filling-bath-tub and singing-do-re-mi, the authors suggest thinking of filling-bath-tub as not an action, but rather as a state, which requires the start-filling action to enter the state and the stop-filling action to exit the state.  This way, interleaving filling-bath-tub and singing-do-re-mi can happen at the same time.
"))(POS (PAPER.TOPIC GIACOMO2000 "Logic Programming"))(POS (PAPER.INSTANCE GIUNCHIGLIA92))(POS (PAPER.BIBTEX GIUNCHIGLIA92 ARTICLE))(POS (PAPER.AUTHOR GIUNCHIGLIA92 "Fausto Giunchiglia and Toby Walsh"))(POS (PAPER.TITLE GIUNCHIGLIA92 "A theory of abstraction"))(POS (PAPER.PUBLICATION GIUNCHIGLIA92 "Artificial Intelligence"))(POS (PAPER.VOLUME GIUNCHIGLIA92 "57"))(POS (PAPER.STARTPAGE GIUNCHIGLIA92 323))(POS (PAPER.ENDPAGE GIUNCHIGLIA92 389))(POS (PAPER.LINK GIUNCHIGLIA92 "http://citeseer.ist.psu.edu/27696.html"))(POS (PAPER.YEAR GIUNCHIGLIA92 1992))(POS (PAPER.RANK GIUNCHIGLIA92 "[****]"))(POS (PAPER.DESCRIPTION GIUNCHIGLIA92 "
Giunchiglia and Walsh describe a theory of abstraction in very general terms,
which is intended to be independent of proof system.  Most generally,
an abstraction is a mapping between a pair of formal systems, where a
formal system consists of a language and a subset of that language defining
the axioms.  Axiomatic formal systems include an extra element: the
proof system.  Abstractions are categorized by whether they increase, decrease, or
leave constant the set of consequences of the theory: TI, TD, TC.  The authors
claim the TI abstractions is the true meaning of abstraction.  TD abstractions
can be used to prove entailment, i.e. if TD(Delta) |= phi then Delta |= phi.
TI abstractions can be used to prove negative entailment, i.e. if
TI(Delta) |/= phi then Delta |/= phi.  Refutation systems are concerned
not with provability but with inconsistency.  Abstractions in this setting
are characterized as NTI, NTD, and NTC.  If the formal system includes
negation and the abstraction f is negation preserving, i.e. f(-phi) = -f(phi)
then NT* and T* are equivalent.  Further classifications are made of abstractions,
depending on how independently an abstraction translates axioms, inference rules, etc.
A large section explaining how various peoples' work fits into this framework follows.
Then sections follow on inconsistent abstract spaces, operations performed
on abstractions, ordering abstractions, hierarchies of abstraction spaces, and building
abstractions.
"))(POS (PAPER.TOPIC GIUNCHIGLIA92 "Abstraction"))(POS (PAPER.INSTANCE GIUNCHIGLIA96REASONING))(POS (PAPER.BIBTEX GIUNCHIGLIA96REASONING INPROCEEDINGS))(POS (PAPER.AUTHOR GIUNCHIGLIA96REASONING "Fausto Giunchiglia and Paolo Pecchiari and Carolyn Talcott"))(POS (PAPER.TITLE GIUNCHIGLIA96REASONING "Reasoning Theories - Towards an Architecture for Open Mechanized Reasoning Systems"))(POS (PAPER.PUBLICATION GIUNCHIGLIA96REASONING "1st International Workshop: Frontiers of Combining Systems
           "))(POS (PAPER.STARTPAGE GIUNCHIGLIA96REASONING 157))(POS (PAPER.ENDPAGE GIUNCHIGLIA96REASONING 174))(POS (PAPER.LINK GIUNCHIGLIA96REASONING "http://citeseer.ist.psu.edu/354680.html"))(POS (PAPER.YEAR GIUNCHIGLIA96REASONING 1996))(POS (PAPER.RANK GIUNCHIGLIA96REASONING "[***]"))(POS (PAPER.DESCRIPTION GIUNCHIGLIA96REASONING "Giunchiglia et al. describe a formalization of logical reasoners.  Such
reasoners (quoting) might be based on different logics; have different domain models;
use different vocabularies and data structures; use different reasoning
strategies; and have different interaction capabilities.  The authors
put forth a general architecture called Open Mechanized Reasoning Systems
(OMRS) for integrating reasoners described by what they call a
Reasoning Theory.  They use NQTHM as an example to illustrate the construction
of a Reasoning Theory.
"))(POS (PAPER.TOPIC GIUNCHIGLIA96REASONING "Architectures"))(POS (PAPER.INSTANCE GIUNCHIGLIA99APPLYING))(POS (PAPER.BIBTEX GIUNCHIGLIA99APPLYING INPROCEEDINGS))(POS (PAPER.AUTHOR GIUNCHIGLIA99APPLYING "Enrico Giunchiglia and Roberto Sebastiani"))(POS (PAPER.TITLE GIUNCHIGLIA99APPLYING "Applying the Davis-Putnam Procedure to Non-clausal Formulas"))(POS (PAPER.PUBLICATION GIUNCHIGLIA99APPLYING "Proceedings of the 6th Congress of the Italian Association for Artificial Intelligence on Advances in Artificial Intelligence"))(POS (PAPER.STARTPAGE GIUNCHIGLIA99APPLYING 84))(POS (PAPER.ENDPAGE GIUNCHIGLIA99APPLYING 94))(POS (PAPER.LINK GIUNCHIGLIA99APPLYING "http://citeseer.ist.psu.edu/giunchiglia99applying.html"))(POS (PAPER.YEAR GIUNCHIGLIA99APPLYING 1999))(POS (PAPER.DESCRIPTION GIUNCHIGLIA99APPLYING "
Continuation of their earlier work on building a SAT solver that handles
non-clausal form by translating the problem into CNF in such a way that 
the search space of the non-CNF problem is preserved in some way.
"))(POS (PAPER.TOPIC GIUNCHIGLIA99APPLYING "SAT Solving"))(POS (PAPER.INSTANCE GIUNCHIGLIA99PLANNING))(POS (PAPER.BIBTEX GIUNCHIGLIA99PLANNING INPROCEEDINGS))(POS (PAPER.AUTHOR GIUNCHIGLIA99PLANNING "Fausto Giunchiglia and Paolo Traverso"))(POS (PAPER.TITLE GIUNCHIGLIA99PLANNING "Planning as Model Checking"))(POS (PAPER.LINK GIUNCHIGLIA99PLANNING "http://citeseer.ist.psu.edu/giunchiglia99planning.html"))(POS (PAPER.YEAR GIUNCHIGLIA99PLANNING 1999))(POS (PAPER.RANK GIUNCHIGLIA99PLANNING "[*]"))(POS (PAPER.DESCRIPTION GIUNCHIGLIA99PLANNING "
This paper gives an introduction to Planning as Model Checking for
both deterministic and nondeterministic domains.  It explains
the model checking problem, planning as model checking, 
planning in nondeterministic domains, an implementation, and
related work.  They look at problems formalized in Computation
Tree Logic (CTL).
"))(POS (PAPER.TOPIC GIUNCHIGLIA99PLANNING "Model Checking"))(POS (PAPER.INSTANCE GRAMLICH2005))(POS (PAPER.BIBTEX GRAMLICH2005 ARTICLE))(POS (PAPER.AUTHOR GRAMLICH2005 "Bernhard Gramlich"))(POS (PAPER.TITLE GRAMLICH2005 "Strategic issues, Problems and Challenges in Inductive Theorem Proving"))(POS (PAPER.LINK GRAMLICH2005 "http://www.logic.at/staff/gramlich/ papers/strategies04-entcs05.pdf.gz"))(POS (PAPER.YEAR GRAMLICH2005 2005))(POS (PAPER.RANK GRAMLICH2005 "[***]"))(POS (PAPER.DESCRIPTION GRAMLICH2005 "
Gramlich outlines the inductive theorem proving, how it differs from
first-order theorem proving, and some of the obstacles that must be
overcome to make automated inductive theorem proving a reality.
"))(POS (PAPER.TOPIC GRAMLICH2005 "Herbrand Logic"))(POS (PAPER.INSTANCE GREEN69))(POS (PAPER.AUTHOR GREEN69 "C. Green"))(POS (PAPER.TITLE GREEN69 "Theorem-proving by resolution as a basis for question-answering systems."))(POS (PAPER.PUBLICATION GREEN69 "Machine Intelligence 4"))(POS (PAPER.STARTPAGE GREEN69 183))(POS (PAPER.ENDPAGE GREEN69 205))(POS (PAPER.YEAR GREEN69 1969))(POS (PAPER.DESCRIPTION GREEN69 "
Green describes using a theorem prover, QA3, to build a question-answering system.  Both statements and questions are written in FOL.  Questions can be True/False or Constructive (i.e. ask for an x such that ...).  Constructive answers are produced by adding the rule question-of-user(x) => Answer(x).  Green goes on to describe what we now call deductive plan synthesis, i.e. answer extraction of situation calculus axioms.  QA3 uses subsumption, duplicate literal elimination, unit preference, a variant on set of support, and no equality (yet).
"))(POS (PAPER.TOPIC GREEN69 "Fundamentals"))(POS (PAPER.INSTANCE GREINER91))(POS (PAPER.BIBTEX GREINER91 ARTICLE))(POS (PAPER.AUTHOR GREINER91 "Russell Greiner and Charles Elkan"))(POS (PAPER.TITLE GREINER91 "Measuring and Improving the Effectiveness of Representations"))(POS (PAPER.PUBLICATION GREINER91 "IJCAI"))(POS (PAPER.STARTPAGE GREINER91 518))(POS (PAPER.ENDPAGE GREINER91 524))(POS (PAPER.LINK GREINER91 "http://citeseer.ist.psu.edu/114212.html"))(POS (PAPER.YEAR GREINER91 1991))(POS (PAPER.RANK GREINER91 "[****]"))(POS (PAPER.DESCRIPTION GREINER91 "
Greiner and Elkan give axes upon which a representation, i.e. black box
for answering questions, can be evaluated: accuracy (how often the answer
given is correct), categoricity (how often the answer is I don't know), and
efficiency. A representation is thus evaluated wrt a query stream.  This 
external form of evaluation captures what any system using a representation
system actually cares about -- how well that representation works.  The
internal representation might also be evaluated by, for example, its
conciseness or elegance, but that is not covered here.  They also formalize
all bounded, linearly separable utility measures, i.e. ways of combining
evaluations wrt the 3 axes above.  Finally the authors confront statistical
approaches for performing evaluation, comparing representations, and improving
existing representations.   Well written.
"))(POS (PAPER.TOPIC GREINER91 "Logical Knowledge Representation"))(POS (PAPER.INSTANCE GREINER98))(POS (PAPER.BIBTEX GREINER98 ARTICLE))(POS (PAPER.AUTHOR GREINER98 "Russell Greiner and Christian Darken and N. Santoso"))(POS (PAPER.TITLE GREINER98 "Efficient Reasoning"))(POS (PAPER.PUBLICATION GREINER98 "ACM Computing Surveys"))(POS (PAPER.VOLUME GREINER98 "33(1)"))(POS (PAPER.STARTPAGE GREINER98 1))(POS (PAPER.ENDPAGE GREINER98 30))(POS (PAPER.LINK GREINER98 "http://citeseer.ist.psu.edu/greiner98efficient.html"))(POS (PAPER.YEAR GREINER98 1998))(POS (PAPER.RANK GREINER98 "[*]"))(POS (PAPER.DESCRIPTION GREINER98 "
Greiner gives a survey of techniques for efficient reasoning: both deductive 
and probabilistic.  He talks about the various techniques available for
dealing with exponential run times: unsound inference, incompleteness, etc.
"))(POS (PAPER.TOPIC GREINER98 "Logical Knowledge Representation"))(POS (PAPER.INSTANCE GROHE2001))(POS (PAPER.BIBTEX GROHE2001 INPROCEEDINGS))(POS (PAPER.AUTHOR GROHE2001 "Martin Grohe"))(POS (PAPER.TITLE GROHE2001 "Generalized Model-Checking Problems for First-Order Logic"))(POS (PAPER.PUBLICATION GROHE2001 "Symposium on Theoretical Aspects of Computer Science"))(POS (PAPER.STARTPAGE GROHE2001 12))(POS (PAPER.ENDPAGE GROHE2001 26))(POS (PAPER.LINK GROHE2001 "http://www.dcs.ed.ac.uk/home/grohe/pub.html"))(POS (PAPER.YEAR GROHE2001 2001))(POS (PAPER.RANK GROHE2001 "[****]"))(POS (PAPER.DESCRIPTION GROHE2001 "
Grohe investigates the parameterized complexity of various model-checking
problems in first-order logic.  In general, the problem is PSPACE-complete
for the combined size of the query and the model.  Under the assumption
of a small query, the parameterized complexity is still AW[*].  However,
some types of formulas and models lend themselves to tractable algorithms:
those with an underlying tree structure.  This paper gives a survey
of various model-checking complexity results for first-order logic.
"))(POS (PAPER.TOPIC GROHE2001 "Model Checking"))(POS (PAPER.RELATED GROHE2001 GROHE2002))(POS (PAPER.INSTANCE GROHE2002))(POS (PAPER.BIBTEX GROHE2002 ARTICLE))(POS (PAPER.AUTHOR GROHE2002 "Martin Grohe"))(POS (PAPER.TITLE GROHE2002 "Parameterized Complexity for the Database Theorist"))(POS (PAPER.PUBLICATION GROHE2002 "SIGMOD"))(POS (PAPER.VOLUME GROHE2002 "31(4)"))(POS (PAPER.LINK GROHE2002 "http://www.dcs.ed.ac.uk/home/grohe/pub.html"))(POS (PAPER.YEAR GROHE2002 2002))(POS (PAPER.RANK GROHE2002 "[*]"))(POS (PAPER.DESCRIPTION GROHE2002 "
Grohe gives a gentle introduction to Parameterized Complexity Theory for
database theorists.  The theory defines a complexity hierarchy for
problems with nonstandard constraints and reductions for proofs
of problem locations within the hierarchy.
These parameterized problems include more information than their standard
counterparts, and thus, can have better solutions.
"))(POS (PAPER.TOPIC GROHE2002 "Knowledge Base Compilation"))(POS (PAPER.INSTANCE GROSOF2003))(POS (PAPER.BIBTEX GROSOF2003 INPROCEEDINGS))(POS (PAPER.AUTHOR GROSOF2003 "Benjamin Grosof and Ian Horrocks and Raphael Volz and Stefan Decker"))(POS (PAPER.TITLE GROSOF2003 "Description Logic Programs: Combining Logic Programs with Description Logic"))(POS (PAPER.PUBLICATION GROSOF2003 "Proceedings of the 12th International Conference on the World Wide Web"))(POS (PAPER.LINK GROSOF2003 "http://citeseer.ist.psu.edu/grosof03description.html"))(POS (PAPER.YEAR GROSOF2003 2003))(POS (PAPER.DESCRIPTION GROSOF2003 "
Description Logic Programs are introduced, which lie in the intersection 
of logic programming and OWL DL.  In addition, mechanisms for reasoning
about this fragment with either description logic or logic programming
tools are introduced.
"))(POS (PAPER.TOPIC GROSOF2003 "Semantic Web"))(POS (PAPER.INSTANCE GUREVICH90))(POS (PAPER.BIBTEX GUREVICH90 ARTICLE))(POS (PAPER.AUTHOR GUREVICH90 "Yuri Gurevich"))(POS (PAPER.TITLE GUREVICH90 "On the Classical Decision Problem"))(POS (PAPER.PUBLICATION GUREVICH90 "Bulletin of the European Association for Theoretical Computer Science"))(POS (PAPER.VOLUME GUREVICH90 "42"))(POS (PAPER.STARTPAGE GUREVICH90 140))(POS (PAPER.ENDPAGE GUREVICH90 150))(POS (PAPER.LINK GUREVICH90 "http://citeseer.ist.psu.edu/gurevich93classical.html"))(POS (PAPER.YEAR GUREVICH90 1990))(POS (PAPER.RANK GUREVICH90 "[*]"))(POS (PAPER.DESCRIPTION GUREVICH90 "
This paper takes the form of a dialogue between the Author and Quisani.
It gives an introduction to the problem of determining whether a first-
order formula is satisfiable (or valid).  The classic decision problem
is whether this problem is decidable.  Church and Turing showed
it to be undecidable.  Then the question becomes, for which
formulas is this decidable?  Classes are given based on the 
quantifier prefixes that are decidable.  More interestingly, 
a certain set of 4 prefixes are enough to completely solve the
decision problem for prefix classes.
"))(POS (PAPER.TOPIC GUREVICH90 "Decidable Fragments of First-Order Logic"))(POS (PAPER.INSTANCE HAAS86))(POS (PAPER.AUTHOR HAAS86 "Andrew R. Haas"))(POS (PAPER.TITLE HAAS86 "A Syntactic Theory of Belief and Action"))(POS (PAPER.PUBLICATION HAAS86 "Artificial Intelligence"))(POS (PAPER.VOLUME HAAS86 "28(3)"))(POS (PAPER.STARTPAGE HAAS86 245))(POS (PAPER.ENDPAGE HAAS86 292))(POS (PAPER.LINK HAAS86 "http://www.reviews.com/Review/Review_review.cfm?media_id=778843&reviewer=110938&pos=3&page=4"))(POS (PAPER.YEAR HAAS86 1986))(POS (PAPER.DESCRIPTION HAAS86 "
Haas describes an approach for reasoning about belief, both an agent's own
beliefs and another agent's belief's.  First, we represent an agent's belief's
with Believes(agent, sentence), where sentence names a sentence of FOL.  Haas
names sentences of FOL by quoting each component, i.e. p(a) is named 'p('a)
(it looks cleaner in prefix notation).  He also gives names for intervals of
time so he can state how long it will take for an agent to believe a certain
sentence; afterall inference is not instantaneous.   In order to give an agent
the ability to determine what another agent will infer, Haas borrows
Konolige's suggestion of implanting an agent's inference rules into the
Believes statements.  Then, Haas introduces The Reflection Schema to do
inference.  Specifically,
Ax1,..,xn. (ClosedTerm x1)^...^(ClosedTerm xn) => IsProof(s)
s is a proof quoted appropriately.  He shows this schema sound and complete.
Haas goes on to define 'Knowing What' in terms of the context of what was asked.
'Knowing How' means a robot has a program to execute.  Finally, Haas connnects
belief and truth using the truth predicate: 'true(quote p) 'iff 'p.  The
Liar's paradox shows up here, but Haas avoids it by proving if p is ground,
true produces no contradictions.
"))(POS (PAPER.TOPIC HAAS86 "Metalevel Reasoning"))(POS (PAPER.INSTANCE HAHNLE2002))(POS (PAPER.AUTHOR HAHNLE2002 "Reiner Hahnle and Neil Murray and Erik Rosenthal"))(POS (PAPER.TITLE HAHNLE2002 "Ordered Resolution vs. Connection Graph Resolution"))(POS (PAPER.LINK HAHNLE2002 "http://citeseer.ist.psu.edu/446349.html"))(POS (PAPER.YEAR HAHNLE2002 2002))(POS (PAPER.DESCRIPTION HAHNLE2002 "
Hahnle et. al. first describe connection graph resolution for
propositional logic, introduced by Kowalski in 1975.  
CGR begins with a graph of clauses with
edges between complementary literals.  Activating an edge
means performing a step of resolution, producing a new 
clause graph.  Then they show that ordered resolution
is a special case of cg-resolution (for prop logic) and then
that ordered cg-resolution will always terminate.  Ordered
cg-resolution enforces a total ordering on literals so
that resolution is applied only to the maximally ordered
literal in a clause.  It is a little unclear to what extent
the results are new, but apparently
the proofs are simpler than those given in the past.  At the end,
the authors discuss issues for lifting this to first-order and
give Eisinger's example that shows unrestricted cg-resolution
is non-terminal.  
"))(POS (PAPER.TOPIC HAHNLE2002 "Calculi"))(POS (PAPER.INSTANCE HALEVY2001))(POS (PAPER.BIBTEX HALEVY2001 ARTICLE))(POS (PAPER.AUTHOR HALEVY2001 "Alon Halevy"))(POS (PAPER.TITLE HALEVY2001 "Answering Queries Using Views: A Survey"))(POS (PAPER.PUBLICATION HALEVY2001 "VLDB Journal: Very Large Data Bases"))(POS (PAPER.VOLUME HALEVY2001 "10(4)"))(POS (PAPER.STARTPAGE HALEVY2001 270))(POS (PAPER.ENDPAGE HALEVY2001 294))(POS (PAPER.LINK HALEVY2001 "http://citeseer.ist.psu.edu/halevy00answering.html"))(POS (PAPER.YEAR HALEVY2001 2001))(POS (PAPER.RANK HALEVY2001 "[****]"))(POS (PAPER.DESCRIPTION HALEVY2001 "
Halevy's survey splits the work that answers queries using views into two
cateogires: using materialized views to speed up query answering and
data integration.  In the former setting, materialized views have the potential
to speed up query answering because some portion of the query may have already
been computed and stored in the db as a materialized view.  The goal here is
to produce an efficient execution plan that uses base tables and materialized views.
In the latter setting, data integration techniques provide a schema, sometimes
called the mediated schema, for a user to query a large number of separate
databases.  To define how each individual schema relates to the mediated schema,
the tables in the individual schemas are expressed as views of the mediated schema.
Here the work focuses on rewriting the query in terms of the views of the mediated
schema, i.e. in terms of the database schema that actually exist.  This case is
particularly interesting because it requires the views to be treated as
incomplete, e.g. both the database of american cars and the database of foreign
cars contribute to the car table.
"))(POS (PAPER.TOPIC HALEVY2001 "Databases"))(POS (PAPER.INSTANCE HALMOS))(POS (PAPER.BIBTEX HALMOS BOOK))(POS (PAPER.AUTHOR HALMOS "Paul Halmos"))(POS (PAPER.TITLE HALMOS "Naive Set Theory"))(POS (PAPER.PUBLISHER HALMOS "Van Nostrand Reinhold Company"))(POS (PAPER.LINK HALMOS "http://www.amazon.com/Naive-Theory-Undergraduate-Texts-Mathematics/dp/0387900926"))(POS (PAPER.YEAR HALMOS 1960))(POS (PAPER.RANK HALMOS ""))(POS (PAPER.DESCRIPTION HALMOS "
A 100-page book on naive set theory.
"))(POS (PAPER.TOPIC HALMOS ""))(POS (PAPER.INSTANCE HALPERN91))(POS (PAPER.AUTHOR HALPERN91 "Joseph Halpern and Moshe Vardi"))(POS (PAPER.TITLE HALPERN91 "Model Checking vs. Theorem Proving: A Manifesto"))(POS (PAPER.PUBLICATION HALPERN91 "Artificial and mathematical Theory of Computation
       (Papers in Honor of John McCarthy)"))(POS (PAPER.LINK HALPERN91 "http://www.cs.cornell.edu/home/halpern/abstract.html#bookart4"))(POS (PAPER.YEAR HALPERN91 1991))(POS (PAPER.RANK HALPERN91 "[****]"))(POS (PAPER.DESCRIPTION HALPERN91 "
Halpern and Vardi prescribe using a semantic model to represent an agent's
knowledge and use model checking to determine logical entailment.  This differs
greatly from the standard approach of using logical sentences to represent
knowledge and then doing theorem proving to check entailment.  The authors
outline constructing such models in a few contexts and consider problems with
the model checking.
"))(POS (PAPER.TOPIC HALPERN91 "Model Checking"))(POS (PAPER.INSTANCE HAMMER93))(POS (PAPER.BIBTEX HAMMER93 ARTICLE))(POS (PAPER.AUTHOR HAMMER93 "Peter Hammer and Alexander Kogan"))(POS (PAPER.TITLE HAMMER93 "Optimal Compression of Propositional Horn Knowledge Bases: Complexity and Approximation"))(POS (PAPER.PUBLICATION HAMMER93 "Artificial Intelligence"))(POS (PAPER.VOLUME HAMMER93 "64(1)"))(POS (PAPER.STARTPAGE HAMMER93 131))(POS (PAPER.ENDPAGE HAMMER93 145))(POS (PAPER.LINK HAMMER93 "http://citeseer.ist.psu.edu/hammer93optimal.html"))(POS (PAPER.YEAR HAMMER93 1993))(POS (PAPER.RANK HAMMER93 "[*]"))(POS (PAPER.DESCRIPTION HAMMER93 "
Hammer and Kogan show that finding the minimum propositional Horn
KB of a given Horn KB is NP-Complete.  They also show a previous
O(n^2) approximation algorithm to be a good one since it allows
no more than a linear factor more rules.
"))(POS (PAPER.TOPIC HAMMER93 "Knowledge Base Compilation"))(POS (PAPER.INSTANCE HAYES75))(POS (PAPER.AUTHOR HAYES75 "Philip J. Hayes"))(POS (PAPER.TITLE HAYES75 "A Representation for Robot Plans"))(POS (PAPER.PUBLICATION HAYES75 "IJCAI"))(POS (PAPER.STARTPAGE HAYES75 181))(POS (PAPER.ENDPAGE HAYES75 188))(POS (PAPER.YEAR HAYES75 1975))(POS (PAPER.DESCRIPTION HAYES75 "
Due to the need for replanning, Hayes advocates producing plans that consist
of two data structures: a subgoal tree and a decision graph.  The subgoal tree represents the plan in a hierarchical-type planner, i.e. root is the overall
goal; each internal node is a reduction of its parent; each leaf is a
primitive action.  The decision graph records the decisions made by the planner while producing the plan.  Links exist between the decision graph and the
subgoal tree so that when a failure occurs during plan execution, the
appropriate parts of both data structures can be removed.
"))(POS (PAPER.TOPIC HAYES75 "Historical"))(POS (PAPER.INSTANCE HENTENRYCK89))(POS (PAPER.BIBTEX HENTENRYCK89 BOOK))(POS (PAPER.AUTHOR HENTENRYCK89 "Pascal Van Hentenryck"))(POS (PAPER.TITLE HENTENRYCK89 "Constraint Satisfaction in Logic Programming"))(POS (PAPER.PUBLISHER HENTENRYCK89 "MIT Press"))(POS (PAPER.YEAR HENTENRYCK89 1989))(POS (PAPER.DESCRIPTION HENTENRYCK89 "
This is an extended form of Hentenryck's thesis.  It concerns the integration
of two standard CSP techniques (forward checking and arc consistency) into
Prolog.  First, there is a thorough introduction to Prolog--syntax,
semantics, proof theory.  Then he formally shows how to do the
integration.  Next he explains an implementation of the integration
that allows users the ability to specify when to apply the
new techniques.  
"))(POS (PAPER.TOPIC HENTENRYCK89 "Logic Programming"))(POS (PAPER.INSTANCE HEYMANS2003))(POS (PAPER.BIBTEX HEYMANS2003 INPROCEEDINGS))(POS (PAPER.AUTHOR HEYMANS2003 "S. Heymans and D. Vermeir"))(POS (PAPER.TITLE HEYMANS2003 "Integrating Semantic Web Reasoning and Answer Set Programming"))(POS (PAPER.PUBLICATION HEYMANS2003 "Proceedings of the 2nd International ASP Workshop"))(POS (PAPER.LINK HEYMANS2003 "http://citeseer.ist.psu.edu/727609.html"))(POS (PAPER.YEAR HEYMANS2003 2003))(POS (PAPER.DESCRIPTION HEYMANS2003 "
Translating another description logic into logic programming, this time
using stable model semantics.
"))(POS (PAPER.TOPIC HEYMANS2003 "Semantic Web"))(POS (PAPER.INSTANCE HINRICHS2004))(POS (PAPER.BIBTEX HINRICHS2004 ARTICLE))(POS (PAPER.BIBTEX HINRICHS2004 PROCEEDINGS))(POS (PAPER.AUTHOR HINRICHS2004 "T. Hinrichs and N. Love and C. Petrie and L. Ramshaw and A. Sahai and S. Singhal."))(POS (PAPER.AUTHOR HINRICHS2004 "Tim Hinrichs, Nathaniel Love, Charles Petrie, Lyle Ramshaw, Akhil Sahai and Sharad Singhal"))(POS (PAPER.TITLE HINRICHS2004 "Using Object-Oriented Constraint Satisfaction for Automated Configuration Generation"))(POS (PAPER.TITLE HINRICHS2004 "Using Object-Oriented Constraint Satisfaction for Automated Configuration Generation"))(POS (PAPER.PUBLICATION HINRICHS2004 "DSOM"))(POS (PAPER.PUBLICATION HINRICHS2004 "Utility Computing: 15th IFIP/IEEE International Workshop on Distributed Systems: Operations and Management, DSOM 2004"))(POS (PAPER.LINK HINRICHS2004 "http://logic.stanford.edu/~thinrich/publications.htm"))(POS (PAPER.LINK HINRICHS2004 "papers/hinrichs2004using.pdf"))(POS (PAPER.YEAR HINRICHS2004 2004))(POS (PAPER.YEAR HINRICHS2004 2004))(POS (PAPER.RANK HINRICHS2004 ""))(POS (PAPER.DESCRIPTION HINRICHS2004 "
Hinrichs, et. al. describe an application of Object-Oriented Constraint 
Satisfaction to configuration management.
"))(POS (PAPER.DESCRIPTION HINRICHS2004 "
In this paper, we describe an approach for automatically generating configurations for complex applications. Automated generation of system configurations is required to allow large-scale deployment of custom applications within utility computing environments. Our approach models the configuration management problem as an Object-Oriented Constraint Satisfaction Problem (OOCSP) that can be solved efficiently using a resolution-based theorem-prover. We outline the approach and discuss both the benefits of the approach as well as its limitations, and highlight certain unresolved issues that require further work. We demonstrate the viability of this approach using an e-Commerce site as an example, and provide results on the complexity and time required to solve for the configuration of such an application.
"))(POS (PAPER.TOPIC HINRICHS2004 "Object Oriented Constraint Satisfaction"))(POS (PAPER.TOPIC HINRICHS2004 "References"))(POS (PAPER.INSTANCE HINRICHS2005AXIOM))(POS (PAPER.BIBTEX HINRICHS2005AXIOM INPROCEEDINGS))(POS (PAPER.AUTHOR HINRICHS2005AXIOM "Timothy Hinrichs and Michael Genesereth"))(POS (PAPER.TITLE HINRICHS2005AXIOM "Axiom Schemata as Metalevel Axioms: Model Theory"))(POS (PAPER.PUBLICATION HINRICHS2005AXIOM "In proceedings of American Association for Aritificial Intelligence"))(POS (PAPER.LINK HINRICHS2005AXIOM "http://logic.stanford.edu/~thinrich/papers/hinrichs2005axiom.pdf"))(POS (PAPER.YEAR HINRICHS2005AXIOM 2005))(POS (PAPER.DESCRIPTION HINRICHS2005AXIOM "
Logicians frequently use axiom schemata to encode (potentially infinite) sets of sentences with particular syntactic form. In this paper we examine a first-order language in which it is possible to write expressions that both describe sentences and assert the truth of the sentences so described. The effect of adding such expressions to a knowledge base is the same as directly including the set of described sentences. 
"))(POS (PAPER.TOPIC HINRICHS2005AXIOM "References"))(POS (PAPER.INSTANCE HINRICHS2006HERBRAND))(POS (PAPER.BIBTEX HINRICHS2006HERBRAND TECHREPORT))(POS (PAPER.AUTHOR HINRICHS2006HERBRAND "Timothy Hinrichs and Michael Genesereth"))(POS (PAPER.TITLE HINRICHS2006HERBRAND "Herbrand Logic"))(POS (PAPER.PUBLISHER HINRICHS2006HERBRAND "Stanford University"))(POS (PAPER.LINK HINRICHS2006HERBRAND "http://logic.stanford.edu/reports/LG-2006-02.pdf"))(POS (PAPER.YEAR HINRICHS2006HERBRAND 2006))(POS (PAPER.DESCRIPTION HINRICHS2006HERBRAND "
Herbrand logic has the same syntax as first-order logic but has Herbrand semantics. That is, the only models that exist in Herbrand logic are the Herbrand models. This logic is easier to learn than first-order logic and is often better suited for modeling and manipulating today's computer systems, the central concerns of computer science. In Herbrand logic, arithmetic using the natural numbers if finitely axiomatizable; however, neither entailment nor satisfiability are semi-decidable. Nevertheless, four of the most industrially successful applications of logic in computer science have been built within fragments of Herbrand logic: deductive databases, logic programming, constraint satisfaction, and formal verification. In this paper, we define Herbrand logic formally, prove several of its properties, discuss Goedel's incompleteness result with respect to Herbrand logic, and demonstrate how each of the four applications mentioned above can be formalized within Herbrand logic. 
"))(POS (PAPER.TOPIC HINRICHS2006HERBRAND "References"))(POS (PAPER.INSTANCE HINRICHS2007EXTENSIONAL))(POS (PAPER.BIBTEX HINRICHS2007EXTENSIONAL INPROCEEDINGS))(POS (PAPER.AUTHOR HINRICHS2007EXTENSIONAL "Timothy Hinrichs and Michael Genesereth"))(POS (PAPER.TITLE HINRICHS2007EXTENSIONAL "Extensional Reasoning"))(POS (PAPER.PUBLICATION HINRICHS2007EXTENSIONAL "In proceedings of CADE Workshop on Empirically Successful Automated Reasoning in Large Theories (ESARLT)"))(POS (PAPER.LINK HINRICHS2007EXTENSIONAL "http://logic.stanford.edu/~thinrich/papers/hinrichs2007extensional.pdf"))(POS (PAPER.YEAR HINRICHS2007EXTENSIONAL 2007))(POS (PAPER.DESCRIPTION HINRICHS2007EXTENSIONAL "
Relational databases are one of the most industrially successful applications of logic in computer science, built for handling massive amounts of data. The power of the paradigm is clear both because of its widespread adoption and theoretical analysis. Today, automated theorem provers are not able to take advantage of database query engines and therefore do not routinely leverage that source of power. Extensional Reasoning is an approach to automated theorem proving where the machine automatically translates a logical entailment query into a database, a set of view definitions, and a database query such that the entailment query can be answered by answering the database query. This paper discusses the framework for Extensional Reasoning, describes algorithms that enable a theorem prover to leverage the power of the database in the case of axiomatically complete theories, and discusses theory resolution for handling incomplete theories. 
"))(POS (PAPER.TOPIC HINRICHS2007EXTENSIONAL "References"))(POS (PAPER.INSTANCE HINRICHS2007REFORMULATION))(POS (PAPER.BIBTEX HINRICHS2007REFORMULATION INPROCEEDINGS))(POS (PAPER.AUTHOR HINRICHS2007REFORMULATION "Timothy Hinrichs and Michael Genesereth"))(POS (PAPER.TITLE HINRICHS2007REFORMULATION "Reformulation for Extensional Reasoning"))(POS (PAPER.PUBLICATION HINRICHS2007REFORMULATION "In proceedings of the Symposium of Abstraction, Reformulation, and Approximation (SARA)"))(POS (PAPER.LINK HINRICHS2007REFORMULATION "http://logic.stanford.edu/~thinrich/papers/hinrichs2007reformulation.pdf"))(POS (PAPER.YEAR HINRICHS2007REFORMULATION 2007))(POS (PAPER.DESCRIPTION HINRICHS2007REFORMULATION "
Relational databases have had great industrial success in computer science. The power of the paradigm is made clear both by its widespread adoption and by theoretical analysis. Today, automated theorem provers are not able to take advantage of database query engines and therefore do not routinely leverage that source of power. Extensional Reasoning (ER) is an approach to automated theorem proving where the machine automatically translates a logical entailment query into a database, a set of view definitions, and a database query such that the entailment query can be answered by answering the database query. The techniques developed for ER to date are applicable only when the logical theory is axiomatically complete. This paper discusses techniques for reformulating an incomplete theory into a complete theory so that Extensional Reasoning techniques can be applied. 

"))(POS (PAPER.TOPIC HINRICHS2007REFORMULATION "References"))(POS (PAPER.INSTANCE HITZLER2005))(POS (PAPER.BIBTEX HITZLER2005 INPROCEEDINGS))(POS (PAPER.AUTHOR HITZLER2005 "Pascal Hitzler and Peter Haase and Markus Krotzsch and York Sure and Rudi Studer"))(POS (PAPER.TITLE HITZLER2005 "DLP isn't so bad after all"))(POS (PAPER.PUBLICATION HITZLER2005 "Proceedings of the WS OWL -- Experiences and Directions"))(POS (PAPER.LINK HITZLER2005 "http://citeseer.ist.psu.edu/733286.html"))(POS (PAPER.YEAR HITZLER2005 2005))(POS (PAPER.DESCRIPTION HITZLER2005 "
The authors try to clarify the controversy surrounding Description Logic
Programs, which is a fragment of OWL DL that can be reasoned about effectively
with logic programming engines.  
"))(POS (PAPER.TOPIC HITZLER2005 "Semantic Web"))(POS (PAPER.INSTANCE HODGSON2002))(POS (PAPER.BIBTEX HODGSON2002 ARTICLE))(POS (PAPER.AUTHOR HODGSON2002 "Kahlil Hodgson and John Slaney"))(POS (PAPER.TITLE HODGSON2002 "TPTP, CASC and the development of a semantically guided 
theorem prover"))(POS (PAPER.PUBLICATION HODGSON2002 "AI Communications"))(POS (PAPER.VOLUME HODGSON2002 "15"))(POS (PAPER.STARTPAGE HODGSON2002 135))(POS (PAPER.ENDPAGE HODGSON2002 146))(POS (PAPER.LINK HODGSON2002 "http://citeseer.ist.psu.edu/558093.html"))(POS (PAPER.YEAR HODGSON2002 2002))(POS (PAPER.RANK HODGSON2002 ""))(POS (PAPER.DESCRIPTION HODGSON2002 "
Hodgson and Slaney describe SCOTT 5, the fifth generation of
semantically constrained otter.  The authors give a quick
description of the differences between the five versions
and explain the algorithm for the newest.  Instead of
maintaining a single model that satisfies some of the
constraints, they maintain several models.  Moreover,
sometimes they use these models to implement the semantic
queue strategy.  Pick the largest set of clauses known
to be satisfiable and if the number of clauses complementary
to a clause in S in the passive list is small, into the
active list. If none of these so called co-NMCSs are small
enough, cycle through them and add clauses to the active
queue.  SCOTT keeps separate the model builder and the theorem
prover from semantic guidance routines to allow, in principle,
a plug and play architecture.
"))(POS (PAPER.TOPIC HODGSON2002 "System Designs"))(POS (PAPER.INSTANCE HOHFELD88))(POS (PAPER.BIBTEX HOHFELD88 ARTICLE))(POS (PAPER.AUTHOR HOHFELD88 "M. Hohfeld and Gert Smolka"))(POS (PAPER.TITLE HOHFELD88 "Definite Relations over Constraint Languages"))(POS (PAPER.LINK HOHFELD88 "http://citeseer.ist.psu.edu/hohfeld88definite.html"))(POS (PAPER.YEAR HOHFELD88 1988))(POS (PAPER.RANK HOHFELD88 "[****]"))(POS (PAPER.DESCRIPTION HOHFELD88 "
Hohfeld and Smolka generalize the previous formal foundations of Constraint
Logic Programming by allowing arbitrary constraints placed on definite
logic programming clauses.  Their definition for constraint states  that
it is simply a restriction on variables; predicate logic is simply a special
case.  They give a generalization of SLD resolution that is sound and 
complete for this broader definition of CLP.  The authors go on to give a 'semantic type discipline' for these CLP clause sets.
"))(POS (PAPER.TOPIC HOHFELD88 "Constraint Logic Programming"))(POS (PAPER.INSTANCE HORIYAMA99))(POS (PAPER.BIBTEX HORIYAMA99 INPROCEEDINGS))(POS (PAPER.AUTHOR HORIYAMA99 "Takashi Horiyama and Toshihide ibaraki"))(POS (PAPER.TITLE HORIYAMA99 "Ordered Binary Decision Diagrams as Knowledge-Bases"))(POS (PAPER.PUBLICATION HORIYAMA99 "International Symposium on Algorithms and Computation"))(POS (PAPER.LINK HORIYAMA99 "http://citeseer.ist.psu.edu/horiyama99ordered.html"))(POS (PAPER.YEAR HORIYAMA99 1999))(POS (PAPER.RANK HORIYAMA99 "[*]"))(POS (PAPER.DESCRIPTION HORIYAMA99 "
Ordered binary decision diagrams can be used to represent propositional 
knowledge bases.  Deduction can be done from such a representation in 
polynomial time; not surprisingly, some knowledge bases require exponential
space while others require only polynomial space.  On the up-side, the
space requirements are not correlated with either characteristic models
(see kautz and khardon) or standard CNF representations.
"))(POS (PAPER.TOPIC HORIYAMA99 "Model-Based Reasoning"))(POS (PAPER.RELATED HORIYAMA99 KAUTZ93))(POS (PAPER.RELATED HORIYAMA99 KHARDON94))(POS (PAPER.INSTANCE HOWER96))(POS (PAPER.BIBTEX HOWER96 ARTICLE))(POS (PAPER.AUTHOR HOWER96 "Walter Hower and Winfried Graf"))(POS (PAPER.TITLE HOWER96 "A bibliographical survey of constraint-based approaches to CAD,
graphics, layout, visualization, and related topics"))(POS (PAPER.PUBLICATION HOWER96 "Knowledge-Based Systems
"))(POS (PAPER.VOLUME HOWER96 "9(7)"))(POS (PAPER.STARTPAGE HOWER96 449))(POS (PAPER.ENDPAGE HOWER96 464))(POS (PAPER.LINK HOWER96 "http://citeseer.ist.psu.edu/hower96bibliographical.html"))(POS (PAPER.YEAR HOWER96 1996))(POS (PAPER.RANK HOWER96 "[**]"))(POS (PAPER.DESCRIPTION HOWER96 "
Survey paper on just what the title indicates.  There are a few paragraphs
on object-oriented approaches most of which is orthogonal.
"))(POS (PAPER.TOPIC HOWER96 "Miscellaneous"))(POS (PAPER.INSTANCE JACKSON98))(POS (PAPER.BIBTEX JACKSON98 ARTICLE))(POS (PAPER.AUTHOR JACKSON98 "Daniel Jackson and Somesh Jha and Craig Damon"))(POS (PAPER.TITLE JACKSON98 "Isomorph-free model enumeration: a new method for checking relational specifications"))(POS (PAPER.PUBLICATION JACKSON98 "ACM Transactions on Programming Languages and Systems"))(POS (PAPER.LINK JACKSON98 "http://portal.acm.org/citation.cfm?id=276396&dl=ACM&coll=portal"))(POS (PAPER.YEAR JACKSON98 1998))(POS (PAPER.DESCRIPTION JACKSON98 "
Methods for building models while avoiding the enumeration of isomorphic candidates for the language Nitpick.
"))(POS (PAPER.TOPIC JACKSON98 "Model Building"))(POS (PAPER.INSTANCE JAFFAR87))(POS (PAPER.BIBTEX JAFFAR87 ARTICLE))(POS (PAPER.AUTHOR JAFFAR87 "J. Jaffar and J.L. Lassez"))(POS (PAPER.TITLE JAFFAR87 "Constraint Logic Programming"))(POS (PAPER.PUBLICATION JAFFAR87 "ACM Symposium on Principles of Programming Languages"))(POS (PAPER.STARTPAGE JAFFAR87 111))(POS (PAPER.ENDPAGE JAFFAR87 119))(POS (PAPER.LINK JAFFAR87 "http://portal.acm.org/citation.cfm?id=41635&dl=GUIDE&coll=GUIDE"))(POS (PAPER.YEAR JAFFAR87 1987))(POS (PAPER.RANK JAFFAR87 "[****]"))(POS (PAPER.DESCRIPTION JAFFAR87 "
Jaffar and Lassez introduce constraint logic programming as a class
of logic programming languages, one for each domain of discourse.  
Every rule has associated with it a set of constraints 
over that domain.  Hohfeld and Smolka in '88 generalize this 
framework, but this is the seminal paper.  Solution to a CLP problem
is a set of constraints; thus, logic programming is a special form
of CLP where those constraints must be equality constraints.
"))(POS (PAPER.TOPIC JAFFAR87 "Constraint Logic Programming"))(POS (PAPER.INSTANCE JANICIC2002))(POS (PAPER.BIBTEX JANICIC2002 ARTICLE))(POS (PAPER.AUTHOR JANICIC2002 "Predrag Janicic and Alan Bundy"))(POS (PAPER.TITLE JANICIC2002 "A General Setting for Flexibly Combining and Augmenting Decision Procedures"))(POS (PAPER.PUBLICATION JANICIC2002 "Journal of Automated Reasoning
           "))(POS (PAPER.VOLUME JANICIC2002 "28(3)"))(POS (PAPER.STARTPAGE JANICIC2002 257))(POS (PAPER.ENDPAGE JANICIC2002 305))(POS (PAPER.LINK JANICIC2002 "http://www.inf.ed.ac.uk/publications/report/0095.html"))(POS (PAPER.YEAR JANICIC2002 2002))(POS (PAPER.RANK JANICIC2002 "[***]"))(POS (PAPER.DESCRIPTION JANICIC2002 "
Janicic and Bundy invent a set of macro rewrite rules that can be used
to build a reasoner out of a set of decision procedures.  They provide
a good overview of the main influences in the field of combining
and augmenting decision procedures.  They build a prototype system
and report comparison results for Nelson-Oppen, Shostak, etc.
"))(POS (PAPER.TOPIC JANICIC2002 "Architectures"))(POS (PAPER.INSTANCE JEAVONS99))(POS (PAPER.BIBTEX JEAVONS99 ARTICLE))(POS (PAPER.AUTHOR JEAVONS99 "Peter Jeavons and David Cohen and Marc Gyssens"))(POS (PAPER.TITLE JEAVONS99 "How to Determine the Expressive Power of Constraints"))(POS (PAPER.PUBLICATION JEAVONS99 "Constraints"))(POS (PAPER.VOLUME JEAVONS99 "4"))(POS (PAPER.STARTPAGE JEAVONS99 113))(POS (PAPER.ENDPAGE JEAVONS99 131))(POS (PAPER.LINK JEAVONS99 "http://citeseer.ist.psu.edu/jeavons98how.html"))(POS (PAPER.YEAR JEAVONS99 1999))(POS (PAPER.DESCRIPTION JEAVONS99 "
The authors define expresssive power as the set of relations definable
from another set of relations.  They show how to compute which algebraic 
operators are closed for a given set of relations by solving a particular
kind of CSP for the given relations.  Then they show that the set of
relations definable from a given set is equal to the set of relations
that are closed under the same operations as that given set.  If some set
R is closed under the set of operations O and every operation in O is 
what they call essentially unary, the problem is NP-complete.  Moreover,
if O includes an operation that is not essentially unary, it includes
an operation that has arity at most max(3, the size of the domain).
Thus, this paper details sufficient conditions for checking whether
a particular CSP is NP-complete: (1) compute the set of operations
that are closed over the permissible tables in the constraints of the CSP.
(2) If that set includes just essentially-unary operations (which can
be deduced by checking for operations of arity up to max(3, size of domain), 
we are assured the problem is NP-complete.
"))(POS (PAPER.TOPIC JEAVONS99 "General"))(POS (PAPER.INSTANCE KAUTZ91))(POS (PAPER.BIBTEX KAUTZ91 INPROCEEDINGS))(POS (PAPER.AUTHOR KAUTZ91 "Henry Kautz and Bart Selman"))(POS (PAPER.TITLE KAUTZ91 "A General Framework for Knowledge Compilation"))(POS (PAPER.PUBLICATION KAUTZ91 "International Workshop on Processing Declarative Knowledge"))(POS (PAPER.LINK KAUTZ91 "http://citeseer.ist.psu.edu/kautz91general.html"))(POS (PAPER.YEAR KAUTZ91 1991))(POS (PAPER.RANK KAUTZ91 "[****]"))(POS (PAPER.DESCRIPTION KAUTZ91 "
This follows up on selman91 and generalizes the Knowledge Compilation 
idea into a framework.  It says that it lifts the algorithms for
Least Upper Bound and Greatest Lower Bound Horn approximations to first-
order, but the proofs of computability are nonexistent.  
"))(POS (PAPER.TOPIC KAUTZ91 "Knowledge Base Compilation"))(POS (PAPER.RELATED KAUTZ91 SELMAN91))(POS (PAPER.INSTANCE KAUTZ92))(POS (PAPER.BIBTEX KAUTZ92 INPROCEEDINGS))(POS (PAPER.AUTHOR KAUTZ92 "Henry Kautz and Bart Selman"))(POS (PAPER.TITLE KAUTZ92 "Forming Concepts for Fast Inference"))(POS (PAPER.PUBLICATION KAUTZ92 "ECAI-Workshop on Knowledge Representation and Reasoning
      "))(POS (PAPER.STARTPAGE KAUTZ92 200))(POS (PAPER.ENDPAGE KAUTZ92 215))(POS (PAPER.LINK KAUTZ92 "http://citeseer.ist.psu.edu/kautz92forming.html"))(POS (PAPER.YEAR KAUTZ92 1992))(POS (PAPER.RANK KAUTZ92 "[**]"))(POS (PAPER.DESCRIPTION KAUTZ92 "
Kautz and Selman show the Least Upper Bound Horn approximation to a 
propositional knowledge base can be exponential in size.  In general,
there do exist knowledge bases (quoting) whose LUBs cannot be represented 
in a form that is both small and tractable.  This paper mainly
considers the utility of learning new concepts to reduce the size
of the LUB.  
"))(POS (PAPER.TOPIC KAUTZ92 "Knowledge Base Compilation"))(POS (PAPER.RELATED KAUTZ92 SELMAN91))(POS (PAPER.INSTANCE KAUTZ93))(POS (PAPER.BIBTEX KAUTZ93 INPROCEEDINGS))(POS (PAPER.AUTHOR KAUTZ93 "Henry Kautz and Michael Kearns and Bart Selman"))(POS (PAPER.TITLE KAUTZ93 "Reasoning with Characteristic Models"))(POS (PAPER.PUBLICATION KAUTZ93 "AAAI"))(POS (PAPER.LINK KAUTZ93 "http://citeseer.ist.psu.edu/kautz93reasoning.html"))(POS (PAPER.YEAR KAUTZ93 1993))(POS (PAPER.RANK KAUTZ93 "[*****]"))(POS (PAPER.DESCRIPTION KAUTZ93 "
This is the seminal work on characteristic models.  The authors
define the characteristic models of a set M of models as those that cannot 
be derived by intersecting other models of M.  For propositional Horn
theories, these characteristic models are sufficient for computing 
entailment in time linear in the size of the characteristic models and
the conjecture.  In some cases the clausal representation requires 
exponentially more space than the characteristic representation, but
in others just the reverse is true.  Abduction using characteristic
models can be done in time polynomial in the size of the assumption set 
and the size of the characteristic set.  Very clean paper overall.
"))(POS (PAPER.TOPIC KAUTZ93 "Characteristic Models"))(POS (PAPER.INSTANCE KAUTZ95))(POS (PAPER.BIBTEX KAUTZ95 ARTICLE))(POS (PAPER.AUTHOR KAUTZ95 "Henry Kautz and Michael Kearns and Bart Selman"))(POS (PAPER.TITLE KAUTZ95 "Horn Approximations of Empirical Data"))(POS (PAPER.PUBLICATION KAUTZ95 "Artificial Intelligence"))(POS (PAPER.VOLUME KAUTZ95 "74(1)"))(POS (PAPER.STARTPAGE KAUTZ95 129))(POS (PAPER.ENDPAGE KAUTZ95 145))(POS (PAPER.LINK KAUTZ95 "http://citeseer.ist.psu.edu/kautz95horn.html"))(POS (PAPER.YEAR KAUTZ95 1995))(POS (PAPER.RANK KAUTZ95 "[****]"))(POS (PAPER.DESCRIPTION KAUTZ95 "
This paper essentially rehashes that of kautz93, except it also looks
at the problem of converting a given set of models into either clausal
form or characteristic model form.  This idea of extracting structure
from 'empirical data' was first addressed in dechter92.
"))(POS (PAPER.TOPIC KAUTZ95 "Characteristic Models"))(POS (PAPER.RELATED KAUTZ95 KAUTZ93))(POS (PAPER.RELATED KAUTZ95 DECHTER92))(POS (PAPER.INSTANCE KAVVADIAS93))(POS (PAPER.BIBTEX KAVVADIAS93 INPROCEEDINGS))(POS (PAPER.AUTHOR KAVVADIAS93 "D. Kavvadias and C. Papadimitriou and M. Sideri"))(POS (PAPER.TITLE KAVVADIAS93 "On Horn Envelopes and Hypergraph Transversals"))(POS (PAPER.PUBLICATION KAVVADIAS93 "ISAAC"))(POS (PAPER.LINK KAVVADIAS93 "http://www.aueb.gr/Users/sideri/publicat.htm"))(POS (PAPER.YEAR KAVVADIAS93 1993))(POS (PAPER.RANK KAVVADIAS93 "[**]"))(POS (PAPER.DESCRIPTION KAVVADIAS93 "
This is the seminal work relating hypergraph transversals to
characteristic models.  Kavvadias et. al. look into the complexity
of computing the Horn envelope of a set of boolean models (the minimal
set of clauses that entail all the models) and the Horn core
(the maximal set of clauses that entail a subset of the models).
"))(POS (PAPER.TOPIC KAVVADIAS93 "Characteristic Models"))(POS (PAPER.INSTANCE KHARDON94))(POS (PAPER.BIBTEX KHARDON94 INPROCEEDINGS))(POS (PAPER.AUTHOR KHARDON94 "Roni Khardon and Dan Roth"))(POS (PAPER.TITLE KHARDON94 "Reasoning with Models"))(POS (PAPER.PUBLICATION KHARDON94 "AAAI"))(POS (PAPER.LINK KHARDON94 "http://citeseer.ist.psu.edu/khardon96reasoning.html"))(POS (PAPER.YEAR KHARDON94 1994))(POS (PAPER.RANK KHARDON94 "[****]"))(POS (PAPER.DESCRIPTION KHARDON94 "
This paper describes a method for determining entailment and abduction
through model-
checking for a KB of full propositional logic over a restricted set of 
queries.   It extends the work of Kautz, et. al. who wrote the seminal
work for propositional Horn KBs.  The definition for characteristic
models relies on Monotone Theory, which describes properties of 
Boolean functions.  It is important to note that these characteristic
models are defined with respect to a class of queries; that is, given
a class of queries, one can compute the characteristic models for
a propositional KB.  That set of models is then the optimal set, 
meaning all models are needed for correct entailment and abduction.
This paper does a thorough treatment of the issues it
brings up, but it is hard to penetrate.  Section 4 is a list of definitions
of Monotone theory, with little motivation or intuition as to the
utility of each definition.  Of course, the rest of the paper relies
on these definitions.  Reread! 
"))(POS (PAPER.TOPIC KHARDON94 "Characteristic Models"))(POS (PAPER.RELATED KHARDON94 KAUTZ93))(POS (PAPER.INSTANCE KHARDON94A))(POS (PAPER.BIBTEX KHARDON94A INPROCEEDINGS))(POS (PAPER.AUTHOR KHARDON94A "Roni Khardon and Dan Roth"))(POS (PAPER.TITLE KHARDON94A "Exploiting Relevance through Model-Based Reasoning"))(POS (PAPER.PUBLICATION KHARDON94A "AAAI"))(POS (PAPER.LINK KHARDON94A "http://citeseer.ist.psu.edu/40071.html"))(POS (PAPER.YEAR KHARDON94A 1994))(POS (PAPER.RANK KHARDON94A "[*****]"))(POS (PAPER.DESCRIPTION KHARDON94A "
Khardon and Roth outline three cases when the relevance can be exploited
to reason more efficiently.  The first deals with context.  Instead of using
all models for logical entailment, use just those that are relevant to 
the current context.  The second use of relevance is in using the Least
Upper Bound approximation of a theory to determine entailment when all 
queries will be answered correctly by the LUB.  Lastly, machine learning
is used to make reasoning easier as it gains experience in the world.
"))(POS (PAPER.TOPIC KHARDON94A "Model-Based Reasoning"))(POS (PAPER.INSTANCE KHARDON95))(POS (PAPER.BIBTEX KHARDON95 ARTICLE))(POS (PAPER.AUTHOR KHARDON95 "Roni Khardon"))(POS (PAPER.TITLE KHARDON95 "Translating between Horn Representations and their Characteristic Models"))(POS (PAPER.PUBLICATION KHARDON95 "Journal of Artificial Intelligence Research"))(POS (PAPER.VOLUME KHARDON95 "3"))(POS (PAPER.STARTPAGE KHARDON95 349))(POS (PAPER.ENDPAGE KHARDON95 372))(POS (PAPER.LINK KHARDON95 "http://citeseer.ist.psu.edu/khardon95translating.html"))(POS (PAPER.YEAR KHARDON95 1995))(POS (PAPER.RANK KHARDON95 "[***]"))(POS (PAPER.DESCRIPTION KHARDON95 "
Khardon builds on the previous work in kautz93 and khardon94 and investigates
the complexity of translating between propositional 
characteristic models and their
horn representations.  He shows that translating either way is polynomial-
reducible to the other, and that both are equivalent to deciding whether
a given set of models is the set of characteristic models of a given
set of horn clauses.  All these problems are at least as hard as converting
a monotone (no negations) CNF formula into a monotone DNF formula.  This
problem has a sub-exponential time solution of n^O(log n).
This paper also gives references to equivalent work in the database 
community under the name Armstrong relations.
"))(POS (PAPER.TOPIC KHARDON95 "Characteristic Models"))(POS (PAPER.RELATED KHARDON95 KAUTZ93))(POS (PAPER.RELATED KHARDON95 KHARDON95))(POS (PAPER.INSTANCE KHARDON95B))(POS (PAPER.BIBTEX KHARDON95B ARTICLE))(POS (PAPER.AUTHOR KHARDON95B "Roni Khardon and Heikki Mannila and Dan Roth"))(POS (PAPER.TITLE KHARDON95B "Reasoning with Examples: Propositional Formulae and Database Dependencies"))(POS (PAPER.PUBLICATION KHARDON95B "Techical Report: Harvard University"))(POS (PAPER.LINK KHARDON95B "http://citeseer.ist.psu.edu/170480.html"))(POS (PAPER.YEAR KHARDON95B 1995))(POS (PAPER.RANK KHARDON95B "[***]"))(POS (PAPER.DESCRIPTION KHARDON95B "
The authors show the connection between characteristic models and Armstrong
relations, i.e. relations that are sufficient for determining logical
entailment of functional dependencies.  They strengthen some of the
results on Armstrong relations and demonstrate a connection between
finding keys and abduction.
"))(POS (PAPER.TOPIC KHARDON95B "Characteristic Models"))(POS (PAPER.RELATED KHARDON95B KAUTZ93))(POS (PAPER.RELATED KHARDON95B KHARDON95))(POS (PAPER.INSTANCE KHARDON97))(POS (PAPER.BIBTEX KHARDON97 ARTICLE))(POS (PAPER.AUTHOR KHARDON97 "Roni Khardon and Dan Roth"))(POS (PAPER.TITLE KHARDON97 "Defaults and Relevance in Model Based Reasoning"))(POS (PAPER.PUBLICATION KHARDON97 "Artificial Intelligence"))(POS (PAPER.VOLUME KHARDON97 "97(1-2)"))(POS (PAPER.STARTPAGE KHARDON97 169))(POS (PAPER.ENDPAGE KHARDON97 193))(POS (PAPER.LINK KHARDON97 "http://citeseer.ist.psu.edu/khardon97defaults.html"))(POS (PAPER.YEAR KHARDON97 1997))(POS (PAPER.RANK KHARDON97 "[****]"))(POS (PAPER.DESCRIPTION KHARDON97 "
This paper explains how model-based reasoning can be used to model reasoning
with context.  Suppose the KB is represented by a set of models M.  As the agent's
context changes, new sentences appear that define that context.  Entailment in
the context then means that the sentence holds in the subset of models M that
satisfy those new sentences.  By representing the theory as a set of models,
as context changes, that set can be reduced online.  In this paper, context
change is represented using default logic.  Algorithms are given for both
skeptical and credulous default reasoning where the knowledge base is represented
as a set of models.  Conditions are given under which these algorithms work
correctly.  Finally, the learning to reason paradigm is brought up as a third
argument for representing a KB as the set of models that satisfy it.  All three,
context, defaults, and learning to reason, sometimes produce computational
benefits because models are used to represent knowledge.
"))(POS (PAPER.TOPIC KHARDON97 "Characteristic Models"))(POS (PAPER.INSTANCE KHARDON98))(POS (PAPER.BIBTEX KHARDON98 ARTICLE))(POS (PAPER.AUTHOR KHARDON98 "Roni Khardon and Heikki Manilla and Dan Roth"))(POS (PAPER.TITLE KHARDON98 "Reasoning with Examples: Propositional Formulae and Database Dependencies"))(POS (PAPER.PUBLICATION KHARDON98 "Acta Informatica"))(POS (PAPER.VOLUME KHARDON98 "36(4)"))(POS (PAPER.STARTPAGE KHARDON98 267))(POS (PAPER.ENDPAGE KHARDON98 286))(POS (PAPER.LINK KHARDON98 "http://citeseer.ist.psu.edu/170480.html"))(POS (PAPER.YEAR KHARDON98 1998))(POS (PAPER.RANK KHARDON98 "[***]"))(POS (PAPER.DESCRIPTION KHARDON98 "
Reasoning with Examples means reasoning with enough models to correctly
determine entailment.  This technique shows up both in the database
literature under the name 'Armstrong Relations' and in the automated
reasoning literature under the name 'Characteristic Models'.  While
the latter refers to a set of examples, the former refers to a single
example.  The number of models needed in Characteristic Models for
propositional logic is bounded by |B|*|DNF(kb)|, where B is the 
basis for the knowledge base kb.  The bulk of this paper shows how the 
two concepts are closely intertwined; it goes on to show that finding 
the keys of a DB is akin to finding abductive explanations in a propositional
knowledge base. 
"))(POS (PAPER.TOPIC KHARDON98 "Characteristic Models"))(POS (PAPER.RELATED KHARDON98 FAGIN82))(POS (PAPER.RELATED KHARDON98 KHARDON95))(POS (PAPER.INSTANCE KIM87))(POS (PAPER.BIBTEX KIM87 ARTICLE))(POS (PAPER.AUTHOR KIM87 "Myung Won Kim"))(POS (PAPER.TITLE KIM87 "On Automatically Generating and Using Examples in a Computational Logic System"))(POS (PAPER.PUBLICATION KIM87 "Technical Report"))(POS (PAPER.LINK KIM87 "http://citeseer.ist.psu.edu/342499.html"))(POS (PAPER.YEAR KIM87 1987))(POS (PAPER.RANK KIM87 "[*]"))(POS (PAPER.DESCRIPTION KIM87 "
Kim's dissertation explores an algorithm for automatically generating 
examples that satisfy a particular constraint given other such examples.
He also explores how such an algorithm can be used to help prune
a theorem-proving search space.  The logic is the Boyer-Moore theory,
and the theorem prover is the Boyer Moore theorem prover.
"))(POS (PAPER.TOPIC KIM87 "Reasoning with Examples"))(POS (PAPER.INSTANCE KIM94))(POS (PAPER.BIBTEX KIM94 INPROCEEDINGS))(POS (PAPER.AUTHOR KIM94 "Sun Kim and Hantao Zhang"))(POS (PAPER.TITLE KIM94 "ModGen: Theorem Proving by Model Generation"))(POS (PAPER.PUBLICATION KIM94 "AAAI"))(POS (PAPER.LINK KIM94 "http://citeseer.ist.psu.edu/kim94modgen.html"))(POS (PAPER.YEAR KIM94 1994))(POS (PAPER.RANK KIM94 "[**]"))(POS (PAPER.DESCRIPTION KIM94 "
The authors describe a system that propositionalizes Otter sentences and then
applies model-checking.  The limitation here is the requirement of a 
finite Herbrand universe.
"))(POS (PAPER.TOPIC KIM94 "Model-Based Reasoning"))(POS (PAPER.INSTANCE KLEER84))(POS (PAPER.BIBTEX KLEER84 INPROCEEDINGS))(POS (PAPER.AUTHOR KLEER84 "Johan de Kleer"))(POS (PAPER.TITLE KLEER84 "Choices without Backtracking"))(POS (PAPER.PUBLICATION KLEER84 "AAAI"))(POS (PAPER.YEAR KLEER84 1984))(POS (PAPER.RANK KLEER84 "[**]"))(POS (PAPER.DESCRIPTION KLEER84 "
Kleer describes a method for increasing the efficiency of problem solving
by storing the assumptions of a derived fact along with that fact.  Doing
this limits the amount of backtracking necessary.  This might be applicable
when backtracking with data structures.  Here it is situated within a truth
maintenance system.
"))(POS (PAPER.TOPIC KLEER84 "Theorem Proving with Attachments"))(POS (PAPER.INSTANCE KOWALSKI69))(POS (PAPER.BIBTEX KOWALSKI69 INBOOK))(POS (PAPER.AUTHOR KOWALSKI69 "Robert Kowalski"))(POS (PAPER.TITLE KOWALSKI69 "Search Strategies for Theorem-Proving"))(POS (PAPER.PUBLICATION KOWALSKI69 "Machine Intelligence"))(POS (PAPER.VOLUME KOWALSKI69 "5"))(POS (PAPER.STARTPAGE KOWALSKI69 181))(POS (PAPER.ENDPAGE KOWALSKI69 201))(POS (PAPER.YEAR KOWALSKI69 1969))(POS (PAPER.RANK KOWALSKI69 "[***]"))(POS (PAPER.DESCRIPTION KOWALSKI69 "
Kowalski abstractly defines the theorem-proving problem in terms of an 
'abstract theorem-proving graph'.  He defines the search space by giving
a specification for each state, the operators that act on those 
states, and a termination condition.  In this case, the tp graph initially
consists of a set of nodes, one for each input axiom.  Further nodes 
(states) are reached (generated) by applying an inference rule to a set
of already reached (generated) nodes.   A search strategy is a mapping
from sets of nodes to other sets of nodes.  Kowalski gives sufficient
(abstract) conditions under which a search strategy is complete.  The
last few sections cover heuristics, their optimality and their 
admissibility.
"))(POS (PAPER.TOPIC KOWALSKI69 "Comparative Analysis"))(POS (PAPER.INSTANCE KOWALSKI79))(POS (PAPER.AUTHOR KOWALSKI79 "Robert Kowalski"))(POS (PAPER.TITLE KOWALSKI79 "Algorithm = Logic + Control"))(POS (PAPER.PUBLICATION KOWALSKI79 "Communications of the ACM"))(POS (PAPER.VOLUME KOWALSKI79 "22(7)"))(POS (PAPER.STARTPAGE KOWALSKI79 424))(POS (PAPER.ENDPAGE KOWALSKI79 436))(POS (PAPER.LINK KOWALSKI79 "http://portal.acm.org/citation.cfm?id=359136&dl=ACM&coll=portal&CFID=6287538&CFTOKEN=93143078"))(POS (PAPER.YEAR KOWALSKI79 1979))(POS (PAPER.RANK KOWALSKI79 "[*****]"))(POS (PAPER.DESCRIPTION KOWALSKI79 "
Kowalski defines an algorithm as Logic and Control.  Logic specifies what the
algorithm does or the knowledge used in
solving a problem.  Control determines the problem-solving strategies, namely
top-down, bottom -up, a combination of the two, and
orthogonally parallelization.  Ideally, the bulk of efficiency concerns
should fall under Control; however, we can improve the efficiency of an
algorithm by adjusting either the Logic or the Control.  
Quote: Computer programs
will be more often correct, more easily improved, and more readily adapted to
new problems when programming languages separate logic and control.
"))(POS (PAPER.TOPIC KOWALSKI79 "Logical Knowledge Representation"))(POS (PAPER.INSTANCE KROTZSCH2005))(POS (PAPER.BIBTEX KROTZSCH2005 TECHREPORT))(POS (PAPER.AUTHOR KROTZSCH2005 "Markus Krotzsch and Pascal Hitzler and Michael Sintek and Denny Vrandecic"))(POS (PAPER.TITLE KROTZSCH2005 "Expressive OWL Reasoning"))(POS (PAPER.PUBLISHER KROTZSCH2005 "University of Kalrsruhe"))(POS (PAPER.LINK KROTZSCH2005 "http://citeseer.ist.psu.edu/733293.html"))(POS (PAPER.YEAR KROTZSCH2005 2005))(POS (PAPER.DESCRIPTION KROTZSCH2005 "
The authors enlarge the class of formulas in OWL DL that can be reasoned
about with a logic programming engine; in addition they present
an alternative characterization of Description Logic Programming.
"))(POS (PAPER.TOPIC KROTZSCH2005 "Semantic Web"))(POS (PAPER.INSTANCE LENAT90))(POS (PAPER.BIBTEX LENAT90 BOOK))(POS (PAPER.AUTHOR LENAT90 "D.B. Lenat and R.V. Guha"))(POS (PAPER.TITLE LENAT90 "Building Large Knowledge-Based Systems: Representation and Inference in the CYC Project"))(POS (PAPER.PUBLISHER LENAT90 "Addison-Wesley"))(POS (PAPER.YEAR LENAT90 1990))(POS (PAPER.DESCRIPTION LENAT90 "
Book on Cyc, the large common-sense knowledge base in Texas.
"))(POS (PAPER.TOPIC LENAT90 "Logical Knowledge Representation"))(POS (PAPER.INSTANCE LENZ98))(POS (PAPER.BIBTEX LENZ98 BOOK))(POS (PAPER.AUTHOR LENZ98 "(ed.) Mario Lenz, et. al."))(POS (PAPER.TITLE LENZ98 "Case-Based Reasoning Technology:From Foundations to Applications (Lecture Notes in Artificial Intelligence)"))(POS (PAPER.LINK LENZ98 "http://www.amazon.com/exec/obidos/tg/detail/-/3540645721/104-6992918-7685512?vi=glance"))(POS (PAPER.YEAR LENZ98 1998))(POS (PAPER.RANK LENZ98 "[***]"))(POS (PAPER.DESCRIPTION LENZ98 "
Case-based reasoning analogically produces solutions to problems through
the use of a case library.  Chapter 1 tries to situate it in the field of
knowledge representation, explain the fundamental process, and describe
the problems to be solved.
"))(POS (PAPER.TOPIC LENZ98 "Case-Based Reasoning"))(POS (PAPER.INSTANCE LESPERANCE95))(POS (PAPER.AUTHOR LESPERANCE95 "Yves Lesperance, Hector J. Levesque, Fangzhen Lin, and Richard B.
Scherl"))(POS (PAPER.TITLE LESPERANCE95 "Ability and Knowing How in the Situation Calculus"))(POS (PAPER.LINK LESPERANCE95 "http://citeseer.ist.psu.edu/lesperance95ability.html"))(POS (PAPER.YEAR LESPERANCE95 1995))(POS (PAPER.DESCRIPTION LESPERANCE95 "
Lesperance et. al. describe 1) a formalism for showing that a given goal can or cannot be accomplished
without simply producing a plan to accomplish it.  This involves discovering whether there is a path of
actions that will lead to the goal at the metalevel.  2) In the plan space that includes sensing actions, nondeterministic
branching, nondeterministic argument-passing, and nondeterministic primitive action choice, the authors formalize the notion that a dumb execution
engine cannot execute all the same plans as an intelligent execution engine.  Building on (1), they
define DumbKnowHow (DKH) and SmartKnowHow (SKH) predicates.  Cool ideas here.  There is also a nice summary
of a formalization of these sensing actions.
"))(POS (PAPER.TOPIC LESPERANCE95 "Fundamentals"))(POS (PAPER.INSTANCE LEUSCHEL2002))(POS (PAPER.BIBTEX LEUSCHEL2002 ARTICLE))(POS (PAPER.AUTHOR LEUSCHEL2002 "Michael Leuschel and Maurice Bruynooghe"))(POS (PAPER.TITLE LEUSCHEL2002 "Logic Program Specialisation Through Partial Deduction: Control Issues"))(POS (PAPER.PUBLICATION LEUSCHEL2002 "Theory and Practice of Logic Programming"))(POS (PAPER.VOLUME LEUSCHEL2002 "2(4-5)"))(POS (PAPER.STARTPAGE LEUSCHEL2002 461))(POS (PAPER.ENDPAGE LEUSCHEL2002 515))(POS (PAPER.LINK LEUSCHEL2002 ""))(POS (PAPER.YEAR LEUSCHEL2002 2002))(POS (PAPER.DESCRIPTION LEUSCHEL2002 "
The authors go through some of the work on partial evaluation in the case
of pure logic programming, which is called partial deduction.  (It differs
from partial evaluation in LP because axioms can be partially partially 
evaluated in the case of non-ground static arguments.)  Partial deduction
means constructing a partial SLDNF tree for a query, and using the fringe
to imply the goal as the output.  Interestingly, with negation, most work 
focuses on preserving operational semantics, as the well-founded semantics
are preserved for all groundings of the goal(s).  This paper focuses on
control issues surrounding the constructing of these SLDNF trees: (1)
given a goal atom A, how do we construct a tree, the local control
problem, and (2) what is the set of all goal atoms, the global control. 
The second problem only occurs because of the desire to preserve
procedural semantics.  The process of unfolding, i.e. constructing
the tree, is difficult because applying too many resolutions can 
result in local code explosion, work duplication, and non
termination.  If the unfold function is guaranteed to produce a tree 
with at most one non-failing
branch, it is said to be determinate; determine unfolding will not
produce code explosion or work duplication.  It is undecidable to determine
whether a tree with at most one non-failing branch can be constructed.
Approximations are usually used.   To deal with termination, binding-time
analysis is used (sometimes computed using abstract interpretation), which
creates annotations that have decided whether to unfold or not.  Instead of
handling termination offline, another approach handles it online--during
specialisation.  Well-founded and well-quasi orders are popular here.  
There is also a discussion of global control issues.  Interestingly,
tabling with partial deduction can turn a terminating program into
a nonterminating program.  Long reference list.
"))(POS (PAPER.TOPIC LEUSCHEL2002 "Reformulation"))(POS (PAPER.INSTANCE LEVESQUE84))(POS (PAPER.BIBTEX LEVESQUE84 CHAPTER))(POS (PAPER.AUTHOR LEVESQUE84 "Hector J. Levesque"))(POS (PAPER.TITLE LEVESQUE84 "The Logic of Incomplete Knowledge Bases"))(POS (PAPER.PUBLISHER LEVESQUE84 "Springer-Verlag"))(POS (PAPER.PUBLICATION LEVESQUE84 "On Conceptual Modelling"))(POS (PAPER.STARTPAGE LEVESQUE84 165))(POS (PAPER.ENDPAGE LEVESQUE84 189))(POS (PAPER.LINK LEVESQUE84 ""))(POS (PAPER.YEAR LEVESQUE84 1984))(POS (PAPER.RANK LEVESQUE84 "[**]"))(POS (PAPER.DESCRIPTION LEVESQUE84 "
Levesque attacks the problem of querying an incomplete knowledge base about its
incompleteness.  How else does one know how accurately the KB represents the domain
it is modeling?  If a query is not entailed, without being able to ask whether the
query itself is known to the KB, we do not know if the query is false or whether
the KB simply doesn't know.  Levesque introduces a language, KL, based on the operator
K for dealing with this problem.  In the end, he claims the interaction of a KB
with a user should be done using this  language, but that any such query can be
translated into straight-up FOL without K.
"))(POS (PAPER.TOPIC LEVESQUE84 "Logical Knowledge Representation"))(POS (PAPER.INSTANCE LEVESQUE85))(POS (PAPER.BIBTEX LEVESQUE85 INBOOK))(POS (PAPER.AUTHOR LEVESQUE85 "Hector J. Levesque and Ronald J. Brachman"))(POS (PAPER.TITLE LEVESQUE85 "A Fundamental Tradeoff in Knowledge Representation and Reasoning"))(POS (PAPER.PUBLISHER LEVESQUE85 "Morgan Kaufmann Publishers"))(POS (PAPER.PUBLICATION LEVESQUE85 "Readings in Knowledge Representation and Reasoning
           "))(POS (PAPER.LINK LEVESQUE85 "http://citeseer.ist.psu.edu/context/54197/0"))(POS (PAPER.YEAR LEVESQUE85 1985))(POS (PAPER.RANK LEVESQUE85 "[***]"))(POS (PAPER.DESCRIPTION LEVESQUE85 "
Levesque and Brachman argue that a perfect representation language does not
exist.  Rather, languages vary in expressiveness and tractability, and some
are only more interesting than others for certain uses.  The authors examine
first-order logic, databases, semantic nets, and frame systems as examples.
"))(POS (PAPER.TOPIC LEVESQUE85 "Logical Knowledge Representation"))(POS (PAPER.INSTANCE LEVESQUE86))(POS (PAPER.AUTHOR LEVESQUE86 "Hector J. Levesque"))(POS (PAPER.TITLE LEVESQUE86 "Making Believers Out of Computers"))(POS (PAPER.PUBLICATION LEVESQUE86 "Artificial Intelligence"))(POS (PAPER.VOLUME LEVESQUE86 "30(1)"))(POS (PAPER.STARTPAGE LEVESQUE86 81))(POS (PAPER.ENDPAGE LEVESQUE86 108))(POS (PAPER.YEAR LEVESQUE86 1986))(POS (PAPER.RANK LEVESQUE86 "[***]"))(POS (PAPER.DESCRIPTION LEVESQUE86 "
Levesque argues that the combinatorial explosion of exponential-time
algorithms cannot be tolerated for AI systems, except for a 'puzzle-mode'.  
To that end, he advises building knowledge bases using languages that
only allow complete ('vivid') information and using 
reasoning methods that may at times be unsound and/or incomplete.  His
examples invoke the reader's imagination to invent a pictures that model
the example descriptions.  Such descriptions can then be considered vivid.
"))(POS (PAPER.TOPIC LEVESQUE86 "Logical Knowledge Representation"))(POS (PAPER.INSTANCE LEVESQUE96))(POS (PAPER.AUTHOR LEVESQUE96 "Hector J. Levesque"))(POS (PAPER.TITLE LEVESQUE96 "What is Planning in the presence of sensing?"))(POS (PAPER.LINK LEVESQUE96 "http://www.cs.toronto.edu/cogrobo/Papers/sensing.pdf"))(POS (PAPER.YEAR LEVESQUE96 1996))(POS (PAPER.DESCRIPTION LEVESQUE96 "

Intro: Classical planning doesn't deal with the problem of sensing or looping, e.g. it cannot produce plans that will successfully achieve the Airport or the Omlette examples.  Sensing is necessary iff there are properties of the world that cannot be deduced at plan time but that are required for achieving the goal.

<br><br>Classical Planning: Use sit calc to formally define the classical planning problem.  It is unclear to me whether the sit calc he is using would somehow allow there to be partial order plans, e.g. return something like (do (parallel a b c) (do (parallel e f) (do h s0))).  For now let's say it can't and sitcalc plans must be total orders.  We might argue that because his definition is tied to sitcalc, which produces only totally ordered plans, his 'definition' of the classical planning problem is wrong.  But it doesn't really matter for the rest of what he is going to say.

Incorporating sensing actions: gives an overview of another one of his papers which introduces sensing actions into sitcalc, and reviews some related work.

<br><br>Robot programs: introduces a language for describing plans that is more expressive than the standard sitcalc (do a (do b (do .... s0)))) and partial order languages.  Includes loops and branches.  He defines the semantics of the language in situation calculus, relying on a new second order construct for defining the semantics of a loop.  Finally, he states the first theorem, which amounts to a set of rewrite rules for each of the new constructs in the robot language, where the rewrite rules allow one to construct an interpreter for the language.  That is, the obvious interpreter for the language does the right thing, and the theorem proves that.

The revised planning task: formalize, using the machinery built up above, the planning problem as it includes loops, branches, and sensing.  Remember this is all sitcalc in first-order logic + a couple second-order constructs.  The rest of the section works through the Airport example.

<br><br>Note: Importantly, all the examples thusfar, as well as the definition of the planning task requires a _deductive_ solution.  That is, the airport example includes the axiom AtGate(a) | AtGate(b).  At plan-time we can prove that the plan (seq goto-airport (if check-gate(a) then goto-gate-a else goto-gate-b)) will work.  This is unlike our room reservation example since there may be no room to reserve, but we won't know that until plan execution time.  At plan-time, there is no plan we can prove will work.

<br><br>Are robot programs enough?: They claim the original plan language is not sufficient for expressing plans for every solvable planning problem.  The reason is that there is no memory available for the program to use.  Asking for a plan that returns the number of eggs it is given at runtime cannot be achieved without (infinite) memory.  Levesque adds 5 actions (left, right, mark, erase, read_mark) that can be used to expand the plans expressible by his robot language to include (he claims) everything that is computable.  That is, his planning language with these additional actions would force a planner to construct a Turing Machine that achieves the given goal.  Of course, that problem is undecidable.  

<br><br>A two sentence summary.  Levesque introduces a plan description language that includes branching and loops (with an extension that he claims makes the language Turing complete), for the simple reason that solving some real world planning problems requires sensing and looping.  He formalizes the planning problem as one of deduction, which has the benefit that deductive solutions will always be right but has the drawback that it eliminates plans that we might expect a machine to produce, e.g. room reservation.


"))(POS (PAPER.TOPIC LEVESQUE96 "Planning with Sensing Actions"))(POS (PAPER.INSTANCE LEVESQUE97))(POS (PAPER.AUTHOR LEVESQUE97 "Levesque, et al."))(POS (PAPER.TITLE LEVESQUE97 "Golog: A Logic Programming Language for Dynamic Domains"))(POS (PAPER.LINK LEVESQUE97 "http://citeseer.ist.psu.edu/27198.html"))(POS (PAPER.YEAR LEVESQUE97 1997))(POS (PAPER.DESCRIPTION LEVESQUE97 "
Golog does macro-replacement into situation calculus from nondeterministic parameter choice, nondeterministic action choice, nondeterministic iteration, test actions, and procedures.  This macro-replacement means answer extraction cannot be used to extract a complex plan using the above constructs.  Instead, given a complex plan, the Golog interpreter produces an equivalent situation calculus plan(I think--still fuzzy here).
"))(POS (PAPER.TOPIC LEVESQUE97 "Logic Programming"))(POS (PAPER.INSTANCE LEVESQUE98))(POS (PAPER.AUTHOR LEVESQUE98 "Hector Levesque, Fiora Pirri, and Ray Reiter"))(POS (PAPER.TITLE LEVESQUE98 "Foundations for the Situation Calculus"))(POS (PAPER.PUBLICATION LEVESQUE98 "Linkoping Electronic Articles in Computer and Information Science"))(POS (PAPER.VOLUME LEVESQUE98 "3"))(POS (PAPER.LINK LEVESQUE98 "http://citeseer.ist.psu.edu/levesque98foundations.html"))(POS (PAPER.YEAR LEVESQUE98 1998))(POS (PAPER.RANK LEVESQUE98 "[***]"))(POS (PAPER.DESCRIPTION LEVESQUE98 "
This is a rehash of Pirri99, except they add in a
section describing sensing and knowledge in Situation Calculus.  They extend
their definition of a basic action theory to include knowledge-producing
actions.  Namely, a knowledge-action theory D_e = Sigma_e U D_ss U D_ap U D_una
U D_S0 U D_sf U D_k0.  Sigma_e is an expanded set of foundational axioms; D_ss
are the successor state axioms; D_ap are the action precondition axioms;
D_una are the unique name axioms for actions; D_s0 is the initial situation;
D_k0 is an initial knowldge axiom (what the agent knows in S0).  This stuff
gets pretty messy, but eventually they provide a solution to the knowledge
frame problem, i.e. "))(POS (PAPER.TOPIC LEVESQUE98 "Fundamentals"))(POS (PAPER.INSTANCE LIFSCHITZ2002))(POS (PAPER.BIBTEX LIFSCHITZ2002 ARTICLE))(POS (PAPER.AUTHOR LIFSCHITZ2002 "V. Lifschitz"))(POS (PAPER.TITLE LIFSCHITZ2002 "Answer set programming and plan generation"))(POS (PAPER.PUBLICATION LIFSCHITZ2002 "Artificial Intelligence"))(POS (PAPER.VOLUME LIFSCHITZ2002 "138(1-2)"))(POS (PAPER.STARTPAGE LIFSCHITZ2002 39))(POS (PAPER.ENDPAGE LIFSCHITZ2002 54))(POS (PAPER.LINK LIFSCHITZ2002 "http://citeseer.ist.psu.edu/301403.html"))(POS (PAPER.YEAR LIFSCHITZ2002 2002))(POS (PAPER.DESCRIPTION LIFSCHITZ2002 "
Answer set programming paper by Lifschitz.
"))(POS (PAPER.TOPIC LIFSCHITZ2002 "Logic Programming"))(POS (PAPER.INSTANCE LIFSCHITZ85))(POS (PAPER.BIBTEX LIFSCHITZ85 ARTICLE))(POS (PAPER.AUTHOR LIFSCHITZ85 "Vladimir Lifschitz"))(POS (PAPER.TITLE LIFSCHITZ85 "Closed World Databases and Circumscription"))(POS (PAPER.PUBLICATION LIFSCHITZ85 "Artificial Intelligence"))(POS (PAPER.VOLUME LIFSCHITZ85 "27(2)"))(POS (PAPER.STARTPAGE LIFSCHITZ85 229))(POS (PAPER.ENDPAGE LIFSCHITZ85 235))(POS (PAPER.YEAR LIFSCHITZ85 1985))(POS (PAPER.DESCRIPTION LIFSCHITZ85 "
Lifschitz proves the following theorem.  If CWA is consistent,
then CWA and Circumscription produce 
equivalent theories when applied to universal, closed sentences in a
function-free, equality-free vocabulary with finitely many relation and
object constants whenever the domain closure assumption and unique
names assumption are in play.
"))(POS (PAPER.TOPIC LIFSCHITZ85 "Non-monotonic Reasoning"))(POS (PAPER.INSTANCE LIFSCHITZ87))(POS (PAPER.AUTHOR LIFSCHITZ87 "V. Lifschitz"))(POS (PAPER.TITLE LIFSCHITZ87 "On the semantics of STRIPS"))(POS (PAPER.PUBLICATION LIFSCHITZ87 "Reasoning About Actions and Plans"))(POS (PAPER.STARTPAGE LIFSCHITZ87 1))(POS (PAPER.ENDPAGE LIFSCHITZ87 9))(POS (PAPER.LINK LIFSCHITZ87 "http://www.cs.utexas.edu/users/vl/papers-old.html"))(POS (PAPER.YEAR LIFSCHITZ87 1987))(POS (PAPER.DESCRIPTION LIFSCHITZ87 "
Lifschitz gives semantics to Fike's and Nilsson's STRIPS.  He gives one definition of a STRIPS system's soundness that relies on atomic sentences for both the add and delete lists (effectively).  All non-atomic sentences must be true in all worlds.  The preconditions can still be full FOL.  Lifschitz goes on to explain how to deal with peculiarities to improve efficiency, e.g. only including nextTo(a,b) when nextTo(x,y) is symmetric.
"))(POS (PAPER.TOPIC LIFSCHITZ87 "Historical"))(POS (PAPER.INSTANCE LIFSCHITZ96))(POS (PAPER.BIBTEX LIFSCHITZ96 CHAPTER))(POS (PAPER.AUTHOR LIFSCHITZ96 "Vladimir Lifschitz"))(POS (PAPER.TITLE LIFSCHITZ96 "Foundations of Logic Programming"))(POS (PAPER.PUBLICATION LIFSCHITZ96 "Principles of Knowledge Representation"))(POS (PAPER.STARTPAGE LIFSCHITZ96 69))(POS (PAPER.ENDPAGE LIFSCHITZ96 127))(POS (PAPER.LINK LIFSCHITZ96 "http://citeseer.ist.psu.edu/lifschitz96foundations.html"))(POS (PAPER.YEAR LIFSCHITZ96 1996))(POS (PAPER.DESCRIPTION LIFSCHITZ96 "
Survey of logic programming theory.
"))(POS (PAPER.TOPIC LIFSCHITZ96 "Logic Programming"))(POS (PAPER.INSTANCE LIN94))(POS (PAPER.AUTHOR LIN94 "Fangzhen Lin and Ray Reiter"))(POS (PAPER.TITLE LIN94 "How to Progress a Database (and Why) I. Logical Foundations"))(POS (PAPER.PUBLICATION LIN94 "Principles of Knowledge Representation and Reasoning "))(POS (PAPER.STARTPAGE LIN94 425))(POS (PAPER.ENDPAGE LIN94 436))(POS (PAPER.LINK LIN94 "http://citeseer.ist.psu.edu/11152.html"))(POS (PAPER.YEAR LIN94 1994))(POS (PAPER.RANK LIN94 "[****]"))(POS (PAPER.DESCRIPTION LIN94 "
Lin and Reiter argue that STRIPS (planning) can be thought of as progressing an initial database S0 with an action sequence A to a final database SA.  They prove the general problem cannot be solved using only FOL, but in fact properly needs induction.  The special cases of 'relatively complete' initial databases and 'context-free' action theories (with certain restrictions on the initial database) yield first-order theories.
"))(POS (PAPER.TOPIC LIN94 "Theories of Action"))(POS (PAPER.INSTANCE LIN95A))(POS (PAPER.AUTHOR LIN95A "Fangzhen Lin and Ray Reiter"))(POS (PAPER.TITLE LIN95A "How to Progress a Database II: The STRIPS Connection"))(POS (PAPER.PUBLICATION LIN95A "IJCAI"))(POS (PAPER.STARTPAGE LIN95A 2001))(POS (PAPER.ENDPAGE LIN95A 2009))(POS (PAPER.LINK LIN95A "http://citeseer.ist.psu.edu/lin94how.html"))(POS (PAPER.YEAR LIN95A 1995))(POS (PAPER.RANK LIN95A "[*]"))(POS (PAPER.DESCRIPTION LIN95A "
Lin and Reiter build on the first part of this paper and give certain varieties of STRIPS semantics based on progressing a database.  
"))(POS (PAPER.TOPIC LIN95A "Theories of Action"))(POS (PAPER.RELATED LIN95A LIN94))(POS (PAPER.INSTANCE LIN95B))(POS (PAPER.AUTHOR LIN95B "Fangzhen Lin and Yoav Shoham"))(POS (PAPER.TITLE LIN95B "Provably Correct Theories of Action"))(POS (PAPER.PUBLICATION LIN95B "Journal of the ACM"))(POS (PAPER.VOLUME LIN95B "42(2)"))(POS (PAPER.STARTPAGE LIN95B 293))(POS (PAPER.ENDPAGE LIN95B 320))(POS (PAPER.LINK LIN95B "http://citeseer.ist.psu.edu/lin91provably.html"))(POS (PAPER.YEAR LIN95B 1995))(POS (PAPER.RANK LIN95B "[****]"))(POS (PAPER.DESCRIPTION LIN95B "
Lin and Shoham give a formal definition for epistemologically complete theories of action.  They explain monotonic and nonmonotonic completions of action theories; the former requires frame axioms and the latter circumscription.   They go on to extend situation calculus to handle concurrent actions by bundling primitive actions together into 'global actions'.  They extend their definition for epistemological completeness to encompass this variation of sitcalc.
"))(POS (PAPER.TOPIC LIN95B "Theories of Action"))(POS (PAPER.INSTANCE LLOYD))(POS (PAPER.BIBTEX LLOYD BOOK))(POS (PAPER.AUTHOR LLOYD "John Lloyd"))(POS (PAPER.TITLE LLOYD "Foundations of Logic Programming"))(POS (PAPER.PUBLISHER LLOYD "Springer Verlag"))(POS (PAPER.LINK LLOYD "http://www.amazon.com/Foundations-Logic-Programming-Symbolic-Computation/dp/0387181997"))(POS (PAPER.YEAR LLOYD 1984))(POS (PAPER.RANK LLOYD "[*****]"))(POS (PAPER.DESCRIPTION LLOYD "
Lloyd covers the declarative and procedural semantics of logic programming without
negation and then considers the case of an acyclic logic program with negation,
and proves soundness and completeness via predicate completion.  The classic text.
"))(POS (PAPER.TOPIC LLOYD ""))(POS (PAPER.INSTANCE LLOYD84))(POS (PAPER.BIBTEX LLOYD84 ARTICLE))(POS (PAPER.AUTHOR LLOYD84 "J. Lloyd and R. Topor"))(POS (PAPER.TITLE LLOYD84 "Making Prolog more expressive"))(POS (PAPER.PUBLICATION LLOYD84 "Journal of Logic Programming"))(POS (PAPER.VOLUME LLOYD84 "1(3)"))(POS (PAPER.STARTPAGE LLOYD84 225))(POS (PAPER.ENDPAGE LLOYD84 240))(POS (PAPER.YEAR LLOYD84 1984))(POS (PAPER.DESCRIPTION LLOYD84 "
Includes the Lloyd-Topor transformation.
"))(POS (PAPER.TOPIC LLOYD84 "Logic Programming"))(POS (PAPER.INSTANCE LOBO))(POS (PAPER.BIBTEX LOBO BOOK))(POS (PAPER.AUTHOR LOBO "Jorge Lobo and Jack Minker and Arcot Rajasekar"))(POS (PAPER.TITLE LOBO "Foundations of Disjunctive Logic Programming"))(POS (PAPER.PUBLISHER LOBO "The MIT Press"))(POS (PAPER.LINK LOBO "http://mitpress.mit.edu/catalog/item/default.asp?ttype=2&tid=5834"))(POS (PAPER.YEAR LOBO 1992))(POS (PAPER.DESCRIPTION LOBO "
Book laying the foundations of disjunctive logic programming.
"))(POS (PAPER.TOPIC LOBO ""))(POS (PAPER.INSTANCE LOCHNER02))(POS (PAPER.BIBTEX LOCHNER02 ARTICLE))(POS (PAPER.AUTHOR LOCHNER02 "Bernd Loechner and Thomas Hillenbrand"))(POS (PAPER.TITLE LOCHNER02 "A phytography of Waldmeister"))(POS (PAPER.PUBLICATION LOCHNER02 "AI Communications"))(POS (PAPER.VOLUME LOCHNER02 "15"))(POS (PAPER.STARTPAGE LOCHNER02 127))(POS (PAPER.ENDPAGE LOCHNER02 133))(POS (PAPER.LINK LOCHNER02 "http://citeseer.ist.psu.edu/558093.html"))(POS (PAPER.YEAR LOCHNER02 2002))(POS (PAPER.RANK LOCHNER02 ""))(POS (PAPER.DESCRIPTION LOCHNER02 "
Waldmeister is a unit equation theorem prover based on
unfailing completion.  Its architecture is the same
Discount algorithm found in Vampire and E.  Written in C,
it uses perfect discrimination trees (a variation on the trie)
to index terms.  It also includes automated tuning of 
its parameters, based on TPTP experience.
"))(POS (PAPER.TOPIC LOCHNER02 "System Designs"))(POS (PAPER.INSTANCE LOECHNER2004))(POS (PAPER.AUTHOR LOECHNER2004 "Bernd Loechner"))(POS (PAPER.TITLE LOECHNER2004 "Things to know when implementing LPO"))(POS (PAPER.PUBLICATION LOECHNER2004 "Workshop on Empirically Successful First Ordering Reasoning"))(POS (PAPER.LINK LOECHNER2004 ""))(POS (PAPER.YEAR LOECHNER2004 2004))(POS (PAPER.DESCRIPTION LOECHNER2004 "
Loechner explains that the naive implementation of Lexicographic Path
Ordering is exponential but then goes on to show how to make it
multiplicative in the size of the two terms.  
"))(POS (PAPER.TOPIC LOECHNER2004 "Orderings"))(POS (PAPER.INSTANCE LOPEZGARCIA2004))(POS (PAPER.BIBTEX LOPEZGARCIA2004 ARTICLE))(POS (PAPER.AUTHOR LOPEZGARCIA2004 "P. Lopez-Garcia and F. Bueno and M. Hermenegildo"))(POS (PAPER.TITLE LOPEZGARCIA2004 "Determinacy Analysis for Logic Programs Using Mode and Type Information"))(POS (PAPER.PUBLICATION LOPEZGARCIA2004 "14th International Symposium, Logic Based Program Synthesis and Trnasformation (LOPSTR)"))(POS (PAPER.STARTPAGE LOPEZGARCIA2004 19))(POS (PAPER.ENDPAGE LOPEZGARCIA2004 35))(POS (PAPER.LINK LOPEZGARCIA2004 "http://wotan.liu.edu/docis/dbl/lopstr/index.html"))(POS (PAPER.YEAR LOPEZGARCIA2004 2004))(POS (PAPER.DESCRIPTION LOPEZGARCIA2004 "
In the context of Logic programming, the authors consider two problems:
(1) detecting whether a relation will ever return more than one answer
through all control paths, i.e. whether the relation is determinate,
 and (2) determining whether more than one
rule with for a relation will ever be satisfied for
the same query, i.e. whether the rules defining that relation
are mutually exclusive.  Addressing these questions relies on type
information, i.e. all the possible queries asked for a relation, and
mode information, i.e. whether a variable is used for validation or
for generation.  For r to be determinate, it is sufficient
that every relation that is a subgoal of r be mutually exclusive.
Thus an approximation of (1) can be accomplished by computing (2).  The test
for mutual exclusion offered here will return true only when all the 
rules for a relation contain procedural attachments that can be shown
to be mutually exclusive for all the types of the relation.  Experimental
results are shown for the case where the procedural attachments are
equality/distinction/inequality.
"))(POS (PAPER.TOPIC LOPEZGARCIA2004 "Reformulation"))(POS (PAPER.INSTANCE MANNA86))(POS (PAPER.AUTHOR MANNA86 "Zohar Manna"))(POS (PAPER.TITLE MANNA86 "How to Clear a Block: A Theory of Plans"))(POS (PAPER.LINK MANNA86 "http://library.stanford.edu/depts/mathcs/mathcscoll/techreports.html"))(POS (PAPER.YEAR MANNA86 1986))(POS (PAPER.DESCRIPTION MANNA86 "
This is the recursive plan paper everyone cites; not surprisingly, it shows up in the context of
program synthesis.  Manna uses Deductive Tableaux to produce programs that contain conditionals
(via a special inference rule) and recursion (using a well-founded mathematical
induction axiom).  The problem with Manna's recursion lies in the need for what he calls
Generalization, i.e. automatically strengthening the stated goal.  Manna also deals
with equality by building it into the unification algorithm.
"))(POS (PAPER.TOPIC MANNA86 "Recursive Plan Generation"))(POS (PAPER.INSTANCE MANNA94))(POS (PAPER.BIBTEX MANNA94 INBOOK))(POS (PAPER.AUTHOR MANNA94 "Zohar Manna et. al."))(POS (PAPER.TITLE MANNA94 "STeP: the Stanford Temporal Prover"))(POS (PAPER.PUBLICATION MANNA94 "TAPSOFT"))(POS (PAPER.LINK MANNA94 "http://citeseer.ist.psu.edu/manna94step.html"))(POS (PAPER.YEAR MANNA94 1994))(POS (PAPER.RANK MANNA94 "[*]"))(POS (PAPER.DESCRIPTION MANNA94 "
STeP is a verification system that proves first order temporal 
formulas valid in concurrent, reactive systems described in SPL.  
It combines equational and arithmetic simplification, model 
checking, interactive first-order theorem proving, and automatic
invariant generation.  The model checking is done through 
Streett automaton and behavior automaton.  The first-order
theorem proving is automated with non-clausal resolution
and paramodulation and utilizes lemmas.  The interactive
theorem proving is handled with a Gentzen-style prover:
both first-order and temporal first-order.  Propositional
temporal formulas can be automatically verified.
This paper is well-written and clear, but assumes knowledge
of temporal logic and transition systems.
"))(POS (PAPER.TOPIC MANNA94 "Model Checking"))(POS (PAPER.INSTANCE MANTHEY88))(POS (PAPER.BIBTEX MANTHEY88 INPROCEEDINGS))(POS (PAPER.AUTHOR MANTHEY88 "Rainer Manthey and Francois Bry"))(POS (PAPER.TITLE MANTHEY88 "SATCHMO: A Theorem Prover Implemented in Prolog"))(POS (PAPER.PUBLICATION MANTHEY88 "Proceedings of the Conference on Automated Deduction"))(POS (PAPER.STARTPAGE MANTHEY88 415))(POS (PAPER.ENDPAGE MANTHEY88 434))(POS (PAPER.YEAR MANTHEY88 1988))(POS (PAPER.DESCRIPTION MANTHEY88 "
Tableaux-style prover implemented in Prolog, using assert and retract.
"))(POS (PAPER.TOPIC MANTHEY88 "Calculi"))(POS (PAPER.INSTANCE MARRAFA91))(POS (PAPER.BIBTEX MARRAFA91 ARTICLE))(POS (PAPER.AUTHOR MARRAFA91 "Palmira Marrafa and Patrick Saint-Dizier"))(POS (PAPER.TITLE MARRAFA91 "Reversibility in a Constraint and Type based Logic Grammar"))(POS (PAPER.LINK MARRAFA91 "http://acl.ldc.upenn.edu/W/W91/W91-0102.pdf"))(POS (PAPER.YEAR MARRAFA91 1991))(POS (PAPER.RANK MARRAFA91 "[***]"))(POS (PAPER.DESCRIPTION MARRAFA91 "
In the topic of reversible grammars.
Marrafa and Saint-Dizier introduce a mathematical language for 
describing natural languages.  The mathematical language includes certain
object-oriented concepts. In addition, abstract machines for parsing and
generating languages so described are given.
"))(POS (PAPER.TOPIC MARRAFA91 "Natural Language Processing"))(POS (PAPER.INSTANCE MASTERS2003))(POS (PAPER.BIBTEX MASTERS2003 ARTICLE))(POS (PAPER.AUTHOR MASTERS2003 "James Masters and Zelai Gungordu"))(POS (PAPER.TITLE MASTERS2003 "Semantic Knowledge Source Integration: A Progress Report"))(POS (PAPER.PUBLICATION MASTERS2003 "Integration of Knowledge Intensive Multi-Agent Systems"))(POS (PAPER.YEAR MASTERS2003 2003))(POS (PAPER.RANK MASTERS2003 ""))(POS (PAPER.DESCRIPTION MASTERS2003 "
Paper on using a database to speed up theorem proving.  Here they want togive a TP access to the information contained in several databases.
"))(POS (PAPER.TOPIC MASTERS2003 "Theorem Proving with Attachments"))(POS (PAPER.INSTANCE MATZINGER97))(POS (PAPER.BIBTEX MATZINGER97 TECHREPORT))(POS (PAPER.AUTHOR MATZINGER97 "Robert Matzinger"))(POS (PAPER.TITLE MATZINGER97 "Comparing Computational Representations of Herbrand Models"))(POS (PAPER.LINK MATZINGER97 "http://www.kr.tuwien.ac.at/guests/matzi/publications.html"))(POS (PAPER.YEAR MATZINGER97 1997))(POS (PAPER.RANK MATZINGER97 "[*****]"))(POS (PAPER.DESCRIPTION MATZINGER97 "
Matzinger investigates various representations of models and
answers three complexity questions for each representation:
ground atom entailment, clause entailment, model equivalence.
The two representations of finite models examined are
context-free grammers and atom representations.  Both CFGs
and ground atoms plus ground equations are equivalent
to finite models, i.e. both representations have an associated
finite model and every finite model has a submodel that
is equivalent to both representations.
Different subsets of all infinite models can be represented by 
term schematizations and constrained atoms.  They seem to be
incomparable.  This paper is pretty dense, but also very important.
"))(POS (PAPER.TOPIC MATZINGER97 "Model-Based Reasoning"))(POS (PAPER.INSTANCE MCCARTHY59))(POS (PAPER.AUTHOR MCCARTHY59 "John McCarthy"))(POS (PAPER.TITLE MCCARTHY59 "Programs with Common Sense"))(POS (PAPER.PUBLICATION MCCARTHY59 "Proceedings of the Teddington Conference on the
                Mechanization of Thought Processes"))(POS (PAPER.STARTPAGE MCCARTHY59 77))(POS (PAPER.ENDPAGE MCCARTHY59 81))(POS (PAPER.LINK MCCARTHY59 "http://www-formal.stanford.edu/jmc/mcc59.html"))(POS (PAPER.YEAR MCCARTHY59 1958))(POS (PAPER.RANK MCCARTHY59 "[*****]"))(POS (PAPER.DESCRIPTION MCCARTHY59 "
Most likely the first paper on logical AI, i.e. the advice taker paper.
It describes a system(the advice taker) that can be told sentences in logic
and can draw conclusions about the world from its knowledge base.
"))(POS (PAPER.TOPIC MCCARTHY59 "Logical Knowledge Representation"))(POS (PAPER.INSTANCE MCCARTHY80))(POS (PAPER.BIBTEX MCCARTHY80 ARTICLE))(POS (PAPER.AUTHOR MCCARTHY80 "John McCarthy"))(POS (PAPER.TITLE MCCARTHY80 "Circumscription -- a form of non-monotonic reasoning"))(POS (PAPER.PUBLICATION MCCARTHY80 "Artificial Intelligence"))(POS (PAPER.VOLUME MCCARTHY80 "13"))(POS (PAPER.STARTPAGE MCCARTHY80 27))(POS (PAPER.ENDPAGE MCCARTHY80 39))(POS (PAPER.YEAR MCCARTHY80 1988))(POS (PAPER.DESCRIPTION MCCARTHY80 "
Circumscription.
"))(POS (PAPER.TOPIC MCCARTHY80 "Non-monotonic Reasoning"))(POS (PAPER.INSTANCE MCCARTHY82))(POS (PAPER.BIBTEX MCCARTHY82 TECHREPORT))(POS (PAPER.AUTHOR MCCARTHY82 "John McCarthy"))(POS (PAPER.TITLE MCCARTHY82 "Coloring Maps and the Kowalski Doctrine"))(POS (PAPER.PUBLISHER MCCARTHY82 "Stanford University"))(POS (PAPER.YEAR MCCARTHY82 1982))(POS (PAPER.DESCRIPTION MCCARTHY82 "
Paper that analyzes various formulations of the map coloring problem
written in Prolog.  Looks at various reorderings of subgoals.
"))(POS (PAPER.TOPIC MCCARTHY82 "Logic Programming"))(POS (PAPER.INSTANCE MCCHAY69))(POS (PAPER.AUTHOR MCCHAY69 "John McCarthy and Patrick J. Hayes"))(POS (PAPER.TITLE MCCHAY69 "Some Philosophical Problems from the Standpoint of Artificial Intelligence"))(POS (PAPER.PUBLICATION MCCHAY69 "Machine Intelligence 4"))(POS (PAPER.STARTPAGE MCCHAY69 463))(POS (PAPER.ENDPAGE MCCHAY69 502))(POS (PAPER.LINK MCCHAY69 "http://www-formal.stanford.edu/jmc/mcchay69.html"))(POS (PAPER.YEAR MCCHAY69 1969))(POS (PAPER.DESCRIPTION MCCHAY69 "
The basic situation calculus paper.  McCarthy and Hayes consider not only the classic planning environment (fully-observable), but also a partially-observable one, introducing what are now referred to as 'sensing actions'.  They attempt a self-proclaimed ad-hoc approach to handling these sensing actions.  They also point out the frame problem, alluding to a state vector as a possible solution.  The qualification problem (though they don't name it that) shows up here, along with the introduction of the modal operators consistent(phi), probably(phi), and normally(phi) as a tentative solution avenue.  Finally, McCarthy and Hayes look into embedding Modal Logic, Logic of Knowledge (Hintikka), Tense Logics, and a couple of others into situation calculus.
"))(POS (PAPER.TOPIC MCCHAY69 "Historical"))(POS (PAPER.INSTANCE MCCUNE2001))(POS (PAPER.BIBTEX MCCUNE2001 MISC))(POS (PAPER.AUTHOR MCCUNE2001 "William McCune"))(POS (PAPER.TITLE MCCUNE2001 "Mace 2.0 Reference Manual and Guide"))(POS (PAPER.LINK MCCUNE2001 "http://citeseer.ist.psu.edu/464179.html"))(POS (PAPER.YEAR MCCUNE2001 2001))(POS (PAPER.DESCRIPTION MCCUNE2001 "
Manual for Mace 2.0, a finite model builder that grounds out formulas
and relies on a SAT solver.
"))(POS (PAPER.TOPIC MCCUNE2001 "Model Building"))(POS (PAPER.INSTANCE MCCUNE2003))(POS (PAPER.BIBTEX MCCUNE2003 TECHREPORT))(POS (PAPER.AUTHOR MCCUNE2003 "William McCune"))(POS (PAPER.TITLE MCCUNE2003 "Mace4 Reference Manual and Guide"))(POS (PAPER.PUBLISHER MCCUNE2003 "Argonne National Laboratory"))(POS (PAPER.LINK MCCUNE2003 "http://www-unix.mcs.anl.gov/AR/mace4/July-2005/doc/mace4.pdf"))(POS (PAPER.YEAR MCCUNE2003 2003))(POS (PAPER.DESCRIPTION MCCUNE2003 "
The reference manual for Mace4.  Unlike its predecessors, which flattened
formulas, ground them, and used a SAT solver, Mace4 incrementally constructs
a model and after each instantiation computes the consequences of the
instantiation wrt the sentences of interest.
"))(POS (PAPER.TOPIC MCCUNE2003 "Model Building"))(POS (PAPER.INSTANCE MCDONALD91))(POS (PAPER.BIBTEX MCDONALD91 ARTICLE))(POS (PAPER.AUTHOR MCDONALD91 "D. McDonald"))(POS (PAPER.TITLE MCDONALD91 "Reversible NLP by Deriving the Grammars from the Knowledge Base"))(POS (PAPER.LINK MCDONALD91 "http://acl.ldc.upenn.edu/W/W91/W91-0106.pdf"))(POS (PAPER.YEAR MCDONALD91 1991))(POS (PAPER.RANK MCDONALD91 "[***]"))(POS (PAPER.DESCRIPTION MCDONALD91 "
Reversible grammars.
McDonald presents an architecture for constructing a parsing grammar and
an acceptance grammar from a single knowledge base and semantic model.  Thus
the strongest techniques for both parsing and generation can be used without
losing the simplicity of maintenance derived from  using a single, 
reversible grammar.
"))(POS (PAPER.TOPIC MCDONALD91 "Natural Language Processing"))(POS (PAPER.INSTANCE MCILRAITH98))(POS (PAPER.BIBTEX MCILRAITH98 ARTICLE))(POS (PAPER.AUTHOR MCILRAITH98 "Sheila McIlraith"))(POS (PAPER.TITLE MCILRAITH98 "Logic-based Abductive Inference"))(POS (PAPER.PUBLICATION MCILRAITH98 "Knowledge Systems Lab Technical Report KSL98-19"))(POS (PAPER.LINK MCILRAITH98 "http://citeseer.ist.psu.edu/mcilraith98logicbased.html"))(POS (PAPER.YEAR MCILRAITH98 1998))(POS (PAPER.DESCRIPTION MCILRAITH98 "
McIlraith covers various ways to operationalize abduction, i.e. finding
an augmentation to a logical knowledge base such that a given query
is entailed. 
"))(POS (PAPER.TOPIC MCILRAITH98 "Abduction"))(POS (PAPER.INSTANCE MCKENZIE97))(POS (PAPER.BIBTEX MCKENZIE97 TECHREPORT))(POS (PAPER.AUTHOR MCKENZIE97 "Bruce McKenzie"))(POS (PAPER.TITLE MCKENZIE97 "Generating Strings at Random from a Context Free Grammar"))(POS (PAPER.LINK MCKENZIE97 "http://coscweb2.cosc.canterbury.ac.nz/research/reports/TechReps/#year1997"))(POS (PAPER.YEAR MCKENZIE97 1997))(POS (PAPER.RANK MCKENZIE97 "[***]"))(POS (PAPER.DESCRIPTION MCKENZIE97 "
McKenzie gives an algorithm for generating strings of length n from a CFG 
so that all strings of length n are equally likely.  The preprocessing
portion of the algorithm requires O(n^2) time and O(n^2) space.  The
generation portion requires O(n) time and space.
"))(POS (PAPER.TOPIC MCKENZIE97 "Context Free Grammars"))(POS (PAPER.INSTANCE MENG20067))(POS (PAPER.AUTHOR MENG20067 "Jia Meng and L.C. Paulson"))(POS (PAPER.TITLE MENG20067 "Lightweight Relevance Filtering for Machine-Generated Resolution Problems"))(POS (PAPER.PUBLICATION MENG20067 "ESCoR: Empirically Successful Computerized Reasoning"))(POS (PAPER.LINK MENG20067 "http://www.cl.cam.ac.uk/~lp15/papers/frameset.html"))(POS (PAPER.YEAR MENG20067 2006))(POS (PAPER.DESCRIPTION MENG20067 "
The authors argue for the case that large axiom sets are the norm when
an entailment query is constructed by a machine; moreover, it is often the
case that only a small fraction of those axioms are relevant to the query
at hand, and thus determining which clauses are relevant is a good first
step toward solving the problem.  The criteria for relevance they use
is based on the presence of function symbols in the clauses.
"))(POS (PAPER.TOPIC MENG20067 "Transformations"))(POS (PAPER.INSTANCE MERZ2001))(POS (PAPER.BIBTEX MERZ2001 INBOOK))(POS (PAPER.AUTHOR MERZ2001 "Stephan Merz"))(POS (PAPER.TITLE MERZ2001 "Model Checking: A Tutorial Overview"))(POS (PAPER.PUBLISHER MERZ2001 "Springer-Verlag"))(POS (PAPER.PUBLICATION MERZ2001 "Modeling and Verification of Parallel Processes"))(POS (PAPER.VOLUME MERZ2001 "2067"))(POS (PAPER.STARTPAGE MERZ2001 3))(POS (PAPER.ENDPAGE MERZ2001 38))(POS (PAPER.LINK MERZ2001 "http://www.loria.fr/~merz/papers/mc-tutorial.html"))(POS (PAPER.YEAR MERZ2001 2001))(POS (PAPER.RANK MERZ2001 "[****]"))(POS (PAPER.DESCRIPTION MERZ2001 "
The model checking problem is to determine if a sentence s is entailed
by a model M.  It is mainly used to analyze reactive systems, i.e. systems
that continually interact with their environment.  These systems are usually
modelled with a Kripke structure or an omega(Buchi)-Automaton.  The sentence s 
is usually written in Propositional Temporal Logic (PTL) (which allows only
universal statements), Computation Tree Logic (CTL) (which allows 
universal and existential statements), CTL*, or propositional mu-calculus.
PTL and CTL are not comparable (neither is more expressive than the other).
CTL* is strictly more expressive than CTL and PTL, and propositional
mu-calculus subsumes CTL*.  Model checking algorithms can either be local
(PTL), global (CTL), or symbolic.  Symbolic formulas can be represented
with ordered binary decision diagrams.
"))(POS (PAPER.TOPIC MERZ2001 "Model Checking"))(POS (PAPER.INSTANCE MILLER94))(POS (PAPER.AUTHOR MILLER94 "Rob Miller and Muray Shanahan"))(POS (PAPER.TITLE MILLER94 "Narratives in the Situation Calculus"))(POS (PAPER.PUBLICATION MILLER94 "Journal of Logic and Computation"))(POS (PAPER.VOLUME MILLER94 "4(5)"))(POS (PAPER.STARTPAGE MILLER94 513))(POS (PAPER.ENDPAGE MILLER94 530))(POS (PAPER.LINK MILLER94 "http://citeseer.ist.psu.edu/miller94narratives.html"))(POS (PAPER.YEAR MILLER94 1994))(POS (PAPER.RANK MILLER94 "[*]"))(POS (PAPER.DESCRIPTION MILLER94 "
Miller and Shanahan take a first crack at embedding narratives in the Situation calculus.  They use a new sort for times, define Happens(action, time), and define Duration(action).  Using these, they can represent narratives, noninstantaneous actions, and overlapping actions.   Miller and Shanahan rely heavily on circumscription.  
"))(POS (PAPER.TOPIC MILLER94 "Behavioral Goals"))(POS (PAPER.INSTANCE MITTAL90))(POS (PAPER.BIBTEX MITTAL90 ARTICLE))(POS (PAPER.AUTHOR MITTAL90 "Sanjay Mittal and Brian Falkenhainer"))(POS (PAPER.TITLE MITTAL90 "Dynamic Constraint Satisfaction Problems "))(POS (PAPER.PUBLICATION MITTAL90 "AAAI 90 "))(POS (PAPER.STARTPAGE MITTAL90 25))(POS (PAPER.ENDPAGE MITTAL90 32))(POS (PAPER.YEAR MITTAL90 1990))(POS (PAPER.RANK MITTAL90 "[****]"))(POS (PAPER.DESCRIPTION MITTAL90 "
Mittal and Falkenhainer describe a version of CSPs where the 
number of variables is partially determined by the values of other
variables.  To accomplish this they provide a constraint language that
can express conditions under which variables must be assigned values
and conditions under which variables need not be assigned values.  For 
every variable vi there is a propositional constant active:vi.  If 
active:vi must hold given the values of other variables, vi must
be assigned a value.  If ~active:vi must hold, vi need not be assigned
a value.  It is unclear what happens if neither active:vi nor ~active:vi 
holds.  They use an assumption-based truth maintenance system to build
a Dynamic CSP solver. 
"))(POS (PAPER.TOPIC MITTAL90 "Various Forms of Constraint Satisfaction"))(POS (PAPER.INSTANCE MOORE77))(POS (PAPER.AUTHOR MOORE77 "Robert C. Moore"))(POS (PAPER.TITLE MOORE77 "Reasoning about knowledge and action"))(POS (PAPER.PUBLICATION MOORE77 "Proceedings of the 5th International Joint
Conference on Artificial Intelligence (IJCAI-77, MIT)"))(POS (PAPER.STARTPAGE MOORE77 223))(POS (PAPER.ENDPAGE MOORE77 227))(POS (PAPER.YEAR MOORE77 1977))(POS (PAPER.DESCRIPTION MOORE77 "
Moore contributes the following formalization (after a little tweaking):
1. T(p, s): p is true in world s.
2. K(Agent, s, s'): Given what Agent knows in s, s' would be another possible world.
3. As,a,p.(True(Know(a, p), s) =def= As'.(K(a, s, s') => T(p, s')): "))(POS (PAPER.TOPIC MOORE77 "Planning with Sensing Actions"))(POS (PAPER.INSTANCE MOORE82))(POS (PAPER.BIBTEX MOORE82 ARTICLE))(POS (PAPER.AUTHOR MOORE82 "Robert C. Moore"))(POS (PAPER.TITLE MOORE82 "The Role of Logic in Knowledge Representation and Commonsense Reasoning"))(POS (PAPER.PUBLICATION MOORE82 "AAAI 82"))(POS (PAPER.LINK MOORE82 ""))(POS (PAPER.YEAR MOORE82 1982))(POS (PAPER.RANK MOORE82 "[**]"))(POS (PAPER.DESCRIPTION MOORE82 "
Moore tries to convince AI researchers that logic can be a useful method for reasoning and not just the analysis of systems.  He points out that some of the early experiments that supposedly showed logical reasoning too inefficient only showed that a particular method of inference and control were too inefficient to be used for every reasoning task.
"))(POS (PAPER.TOPIC MOORE82 "Logical Knowledge Representation"))(POS (PAPER.INSTANCE MOSES96))(POS (PAPER.BIBTEX MOSES96 ARTICLE))(POS (PAPER.AUTHOR MOSES96 "Yoram Moses and Moshe Tennenholtz"))(POS (PAPER.TITLE MOSES96 "Off-line reasoning for on-line efficiency: knowledge bases"))(POS (PAPER.PUBLICATION MOSES96 "Artificial Intelligence"))(POS (PAPER.VOLUME MOSES96 "83(2)"))(POS (PAPER.STARTPAGE MOSES96 229))(POS (PAPER.ENDPAGE MOSES96 239))(POS (PAPER.LINK MOSES96 "http://citeseer.ist.psu.edu/moses96offline.html"))(POS (PAPER.YEAR MOSES96 1996))(POS (PAPER.RANK MOSES96 "[***]"))(POS (PAPER.DESCRIPTION MOSES96 "
Moses and Tennenholtz give conditions under which compiling a KB is
worthwhile.  The results given focus almost entirely on propositional
logic.  If a KB has a basis under which all queries
can be computed via conjunctions of the basis, compilation is a good
idea if the basis can be computed in polynomial time.  The process
of compilation essentially stores all the elements of the basis
in a binary tree.  Thus, any query can be answered in (log n)*|query|.
"))(POS (PAPER.TOPIC MOSES96 "Knowledge Base Compilation"))(POS (PAPER.INSTANCE MOSKEWICZ2001))(POS (PAPER.BIBTEX MOSKEWICZ2001 ARTICLE))(POS (PAPER.AUTHOR MOSKEWICZ2001 "Matthew Moskewicz and Conor Madigan and Ying Zhao and Lintao Zhang and Sharad Malik"))(POS (PAPER.TITLE MOSKEWICZ2001 "Chaff: Engineering an Efficient SAT Solver"))(POS (PAPER.PUBLICATION MOSKEWICZ2001 "39th Design Automation Conference"))(POS (PAPER.LINK MOSKEWICZ2001 "http://citeseer.csail.mit.edu/moskewicz01chaff.html"))(POS (PAPER.YEAR MOSKEWICZ2001 2001))(POS (PAPER.DESCRIPTION MOSKEWICZ2001 "
The authors give an overview of DPLL and how it is implemented in Chaff.
Nice read.
"))(POS (PAPER.TOPIC MOSKEWICZ2001 "Solvers"))(POS (PAPER.INSTANCE MOTIK2007BRIDGING))(POS (PAPER.BIBTEX MOTIK2007BRIDGING INPROCEEDINGS))(POS (PAPER.AUTHOR MOTIK2007BRIDGING "Boris Motik and Ian Horrocks and Ulrike Sattler"))(POS (PAPER.TITLE MOTIK2007BRIDGING "Bridging the Gap Between OWL and Relational Databases"))(POS (PAPER.PUBLICATION MOTIK2007BRIDGING "Proceedings of the 16th Conference on the World Wide Web "))(POS (PAPER.LINK MOTIK2007BRIDGING ""))(POS (PAPER.YEAR MOTIK2007BRIDGING 2007))(POS (PAPER.DESCRIPTION MOTIK2007BRIDGING "
The paper attempts to implement integrity constraints as defined in the 
database literature into OWL.
"))(POS (PAPER.TOPIC MOTIK2007BRIDGING "Semantic Web"))(POS (PAPER.INSTANCE MOTIK2007FAITHFUL))(POS (PAPER.BIBTEX MOTIK2007FAITHFUL INPROCEEDINGS))(POS (PAPER.AUTHOR MOTIK2007FAITHFUL "Boris Motik and Riccardo Rosati"))(POS (PAPER.TITLE MOTIK2007FAITHFUL "A Faithful Integration of Description Logics with Logic Programming"))(POS (PAPER.PUBLICATION MOTIK2007FAITHFUL "Proceedings of International Joint Conference on Artificial Intelligence"))(POS (PAPER.LINK MOTIK2007FAITHFUL ""))(POS (PAPER.YEAR MOTIK2007FAITHFUL 2007))(POS (PAPER.DESCRIPTION MOTIK2007FAITHFUL "
The paper introduces hybrid MKNF knowledge bases, a formalism that integrates
logic programming and description logics, which reduces to LP semantics
when the DL portion is empty and to DL semantics when the LP portion is empty.
Also gives complexity results for certain classes of the logic.
"))(POS (PAPER.TOPIC MOTIK2007FAITHFUL "Semantic Web"))(POS (PAPER.INSTANCE MOTTA91))(POS (PAPER.BIBTEX MOTTA91 ARTICLE))(POS (PAPER.AUTHOR MOTTA91 "Enrico Motta and Arthur Stutt"))(POS (PAPER.TITLE MOTTA91 "An Architecture for the Integration of Heterogenous Inference Systems"))(POS (PAPER.PUBLICATION MOTTA91 "Open University Technical Report"))(POS (PAPER.LINK MOTTA91 "http://citeseer.ist.psu.edu/motta91architecture.html"))(POS (PAPER.YEAR MOTTA91 1991))(POS (PAPER.RANK MOTTA91 "[*]"))(POS (PAPER.DESCRIPTION MOTTA91 "
The authors describe an architecture for integrating specialized reasoners
where each reasoner is known to handle a particular vocabulary.
"))(POS (PAPER.TOPIC MOTTA91 "Architectures"))(POS (PAPER.INSTANCE MUHAMMED2006))(POS (PAPER.BIBTEX MUHAMMED2006 INPROCEEDINGS))(POS (PAPER.AUTHOR MUHAMMED2006 "R. Muhammed and P.J. Stuckey"))(POS (PAPER.TITLE MUHAMMED2006 "A stochastic Non-CNF SAT Solver"))(POS (PAPER.PUBLICATION MUHAMMED2006 "In Proceedings 9th Biennial Pacific Rim International Conference on Artificial Intelligence"))(POS (PAPER.STARTPAGE MUHAMMED2006 120))(POS (PAPER.ENDPAGE MUHAMMED2006 129))(POS (PAPER.LINK MUHAMMED2006 "http://www.cs.mu.oz.au/~pjs/papers.html"))(POS (PAPER.YEAR MUHAMMED2006 2006))(POS (PAPER.DESCRIPTION MUHAMMED2006 "
Paper on a stochastic SAT solver whose input is allowed to be 
in something other than CNF.
"))(POS (PAPER.TOPIC MUHAMMED2006 "SAT Solving"))(POS (PAPER.INSTANCE MYERS90))(POS (PAPER.BIBTEX MYERS90 INPROCEEDINGS))(POS (PAPER.AUTHOR MYERS90 "Karen Myers"))(POS (PAPER.TITLE MYERS90 "Automatically Generating Universal Attachments through Compilation"))(POS (PAPER.PUBLICATION MYERS90 "AAAI"))(POS (PAPER.LINK MYERS90 "http://www.ai.sri.com/~myers/"))(POS (PAPER.YEAR MYERS90 1990))(POS (PAPER.RANK MYERS90 "[**]"))(POS (PAPER.DESCRIPTION MYERS90 "
Myers describes a method for generating new universal attachments.
"))(POS (PAPER.TOPIC MYERS90 "Theorem Proving with Attachments"))(POS (PAPER.INSTANCE MYERS90T))(POS (PAPER.BIBTEX MYERS90T PHDTHESIS))(POS (PAPER.AUTHOR MYERS90T "Karen Myers"))(POS (PAPER.TITLE MYERS90T "Universal Attachments: A Logical Framework for Hybrid Reasoning"))(POS (PAPER.PUBLISHER MYERS90T "Stanford University"))(POS (PAPER.LINK MYERS90T "http://library.stanford.edu/depts/mathcs/mathcscoll/techreports.html"))(POS (PAPER.YEAR MYERS90T 1990))(POS (PAPER.RANK MYERS90T "[***]"))(POS (PAPER.DESCRIPTION MYERS90T "
"))(POS (PAPER.TOPIC MYERS90T "Theorem Proving with Attachments"))(POS (PAPER.INSTANCE NAREYEK99))(POS (PAPER.BIBTEX NAREYEK99 ARTICLE))(POS (PAPER.AUTHOR NAREYEK99 "Alexander Nareyek"))(POS (PAPER.TITLE NAREYEK99 "Structural Constraint Satisfaction"))(POS (PAPER.PUBLICATION NAREYEK99 "AAAI Workshop on Configurations"))(POS (PAPER.STARTPAGE NAREYEK99 76))(POS (PAPER.ENDPAGE NAREYEK99 82))(POS (PAPER.LINK NAREYEK99 "http://citeseer.ist.psu.edu/nareyek99structural.html"))(POS (PAPER.YEAR NAREYEK99 1999))(POS (PAPER.RANK NAREYEK99 "[***]"))(POS (PAPER.DESCRIPTION NAREYEK99 "
It is a little hard to follow what's happening here.  Nareyek seems
to be introducing generalization of CSPs where in addition to constraints
on tuples of variables, there are constraints on the structure of those
constraints.  These meta constraints are implemented via Graph Grammars.
Narayek states that solving these problems is undecidable, but gives
no proof.
"))(POS (PAPER.TOPIC NAREYEK99 "Various Forms of Constraint Satisfaction"))(POS (PAPER.INSTANCE NAYAK95))(POS (PAPER.BIBTEX NAYAK95 PROCEEDINGS))(POS (PAPER.AUTHOR NAYAK95 "P. Nayak and Alon Levy"))(POS (PAPER.TITLE NAYAK95 "A Semantic Theory of Abstractions"))(POS (PAPER.PUBLICATION NAYAK95 "IJCAI"))(POS (PAPER.LINK NAYAK95 "http://citeseer.ist.psu.edu/nayak94semantic.html"))(POS (PAPER.YEAR NAYAK95 1995))(POS (PAPER.RANK NAYAK95 "[***]"))(POS (PAPER.DESCRIPTION NAYAK95 "
Nayak and Levy explain a new approach to producing abstractions of
axioms.  Instead of simply mapping axioms to axioms as is done in
previous work, first abstract the axioms to an intended domain
model, and then find sentences that capture that model.  The
theoretical component of this paper, which accounts for the
majority of it, is very clean.  It gives model-theoretic
explainations for good (allowing no 'false proofs') and bad
(allowing 'false proofs') abstractions.
"))(POS (PAPER.TOPIC NAYAK95 "Abstraction"))(POS (PAPER.INSTANCE NELSON79))(POS (PAPER.BIBTEX NELSON79 INPROCEEDINGS))(POS (PAPER.AUTHOR NELSON79 "Greg Nelson and Derek Oppen"))(POS (PAPER.TITLE NELSON79 "Simplification by Cooperating Decision Procedures"))(POS (PAPER.PUBLICATION NELSON79 "ACM Transactions on Programming Languages and Systems
           "))(POS (PAPER.VOLUME NELSON79 "1(2)"))(POS (PAPER.STARTPAGE NELSON79 245))(POS (PAPER.ENDPAGE NELSON79 257))(POS (PAPER.LINK NELSON79 ""))(POS (PAPER.YEAR NELSON79 1979))(POS (PAPER.RANK NELSON79 "[****]"))(POS (PAPER.DESCRIPTION NELSON79 "
Nelson and Oppen describe a method for combining decision procedures
for disjoint equational theories.
To determine the satisfiability of a set of quantifier-free formulas,
partition based on the theory to which the vocabulary belongs.  If 
a term from one theory is embedded in a relation from another theory,
introduce a new variable, replace the term with that variable, and include
the sentence where that variable is set to the term in the appropriate
partition.  If any of the partitions are unsatisfiable, the entire thing
is unsatisfiable.  Otherwise, compute all the strongest equality theorems
including only variables for each of the partitions and pass to all the 
other partitions.  If the theory is nonconvex, case analysis is
necessary.
Check for unsatisfiability and repeat.  Nelson and Oppen prove correctness
and termination.
"))(POS (PAPER.TOPIC NELSON79 "Nelson-Oppen and Shostak"))(POS (PAPER.INSTANCE NEWELL63))(POS (PAPER.AUTHOR NEWELL63 "Allen Newell and H.A. Simon"))(POS (PAPER.TITLE NEWELL63 "GPS, A Program that Simulates Human Thought"))(POS (PAPER.PUBLICATION NEWELL63 "Computers and Thought, Feigenbaum and Feldman (eds.)"))(POS (PAPER.STARTPAGE NEWELL63 279))(POS (PAPER.ENDPAGE NEWELL63 293))(POS (PAPER.YEAR NEWELL63 1963))(POS (PAPER.DESCRIPTION NEWELL63 "
Description of probably the first planner. Newell et. al. compare an inexperienced student doing a logic proof to how GPS solves the same problem.  GPS takes a goal and can perform any of four operations: transform object A into object B (unification?), reduce the difference D between object A and object B (satisfaction of a subgoal of A?), and apply operator Q to object A (reduction of A to subgoals?).
"))(POS (PAPER.TOPIC NEWELL63 "Historical"))(POS (PAPER.INSTANCE NIEUWENHUIS2003))(POS (PAPER.AUTHOR NIEUWENHUIS2003 "Robert Nieuwenhuis and Thomas Hillenbrand and Alexandre Riazanov and Andrei Voronkov"))(POS (PAPER.TITLE NIEUWENHUIS2003 "On the Evaluation of Indexing Techniques for Theorem Proving"))(POS (PAPER.LINK NIEUWENHUIS2003 "http://citeseer.ist.psu.edu/nieuwenhuis03evaluation.html"))(POS (PAPER.YEAR NIEUWENHUIS2003 2003))(POS (PAPER.DESCRIPTION NIEUWENHUIS2003 "
Nieuwenhuis, et. al. describe a methodology for comparing indexing schemes.
To demonstrate it, they compare Waldmeister's discrimination trees,
Context trees, and Vampire's code trees for term indexing.  The scenario tested
involved both additions and deletions from the index and queries where
only one answer need be reported (e.g. for forward subsumption).  They
reported both space and time results.
"))(POS (PAPER.TOPIC NIEUWENHUIS2003 "Indexing"))(POS (PAPER.INSTANCE NILES2001))(POS (PAPER.BIBTEX NILES2001 INPROCEEDINGS))(POS (PAPER.AUTHOR NILES2001 "Ian Niles and Adam Pease"))(POS (PAPER.TITLE NILES2001 "Formal Ontology in Information Systems"))(POS (PAPER.PUBLICATION NILES2001 "Proceedings of the International Conference on Formal Ontology in Information Systems"))(POS (PAPER.STARTPAGE NILES2001 2))(POS (PAPER.ENDPAGE NILES2001 9))(POS (PAPER.LINK NILES2001 "http://portal.acm.org/citation.cfm?id=505170"))(POS (PAPER.YEAR NILES2001 2001))(POS (PAPER.DESCRIPTION NILES2001 "
Primary paper on SUMO, the Suggested Upper Merged Ontology.
"))(POS (PAPER.TOPIC NILES2001 "Logical Knowledge Representation"))(POS (PAPER.INSTANCE ORMAN98))(POS (PAPER.BIBTEX ORMAN98 ARTICLE))(POS (PAPER.AUTHOR ORMAN98 "Levent Orman"))(POS (PAPER.TITLE ORMAN98 "Differential Relational Calculus for Integrity Maintenance"))(POS (PAPER.PUBLICATION ORMAN98 "IEEE Transactions of Knowledge and Data Engineering"))(POS (PAPER.VOLUME ORMAN98 "10(2)"))(POS (PAPER.STARTPAGE ORMAN98 328))(POS (PAPER.ENDPAGE ORMAN98 341))(POS (PAPER.LINK ORMAN98 "http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=683760&isnumber=15039"))(POS (PAPER.YEAR ORMAN98 1998))(POS (PAPER.RANK ORMAN98 "[****]"))(POS (PAPER.DESCRIPTION ORMAN98 "
Orman defines differential relational calculus.  Given a 
database constraint V such that V is true if and only if there is an integrity
constraint violation and a transaction T, what are the necessary and
sufficient conditions for computing whether there is would be an integrity
violation after execution T, assuming there was no violation to start with?
"))(POS (PAPER.TOPIC ORMAN98 "Databases"))(POS (PAPER.INSTANCE OWRE96))(POS (PAPER.BIBTEX OWRE96 INPROCEEDINGS))(POS (PAPER.AUTHOR OWRE96 "S. Owre et. al."))(POS (PAPER.TITLE OWRE96 "PVS: Combining Specification, Proof Checking, and Model Checking"))(POS (PAPER.PUBLICATION OWRE96 "Computer Aided Verification"))(POS (PAPER.STARTPAGE OWRE96 411))(POS (PAPER.ENDPAGE OWRE96 414))(POS (PAPER.LINK OWRE96 "http://citeseer.ist.psu.edu/246180.html"))(POS (PAPER.YEAR OWRE96 1996))(POS (PAPER.RANK OWRE96 "[*]"))(POS (PAPER.DESCRIPTION OWRE96 "
PVS (Prototype Verification System) allows a user to construct a
machine-verified proof.  It combines interactive theorem
proving, typechecking, a set of decision procedures including
a model checker, and strategies to avoid tedious proof step 
repetitions for the user.   The strategies can be extended
if necessary.
"))(POS (PAPER.TOPIC OWRE96 "Model Checking"))(POS (PAPER.INSTANCE PALTRINIERI94))(POS (PAPER.BIBTEX PALTRINIERI94 ARTICLE))(POS (PAPER.AUTHOR PALTRINIERI94 "Massimo Paltrinieri"))(POS (PAPER.TITLE PALTRINIERI94 "Some Remarks on the Design of Constraint Satisfaction
Problems"))(POS (PAPER.PUBLICATION PALTRINIERI94 "Second International Workshop on the Principles
and Practice of Constraint Programming"))(POS (PAPER.STARTPAGE PALTRINIERI94 299))(POS (PAPER.ENDPAGE PALTRINIERI94 311))(POS (PAPER.LINK PALTRINIERI94 "http://citeseer.ist.psu.edu/paltrinieri94some.html"))(POS (PAPER.YEAR PALTRINIERI94 1994))(POS (PAPER.RANK PALTRINIERI94 "[****]"))(POS (PAPER.DESCRIPTION PALTRINIERI94 "
Paltrinieri gives a loose definition for an object-oriented constraint
satisfaction problem and goes on to show its utility for modelling
some CSPs.  His formulation of an OOCSP is no more expressive than
a standard CSP; solving an OOCSP then amounts to translating it into
a CSP.  To do this, find all the instances of objects needed to solve
the OOCSP and replicate the class constraints for each instance.
"))(POS (PAPER.TOPIC PALTRINIERI94 "Object Oriented Constraint Satisfaction"))(POS (PAPER.INSTANCE PALTRINIERI95))(POS (PAPER.BIBTEX PALTRINIERI95 ARTICLE))(POS (PAPER.AUTHOR PALTRINIERI95 "Massimo Paltrinieri"))(POS (PAPER.TITLE PALTRINIERI95 "A Visual Environment for Constraint Programming"))(POS (PAPER.PUBLICATION PALTRINIERI95 "Proceedings 11th International IEEE Symposium on Visual
Langauges"))(POS (PAPER.STARTPAGE PALTRINIERI95 118))(POS (PAPER.ENDPAGE PALTRINIERI95 119))(POS (PAPER.LINK PALTRINIERI95 "
http://citeseer.ist.psu.edu/paltrinieri95visual.html"))(POS (PAPER.YEAR PALTRINIERI95 1995))(POS (PAPER.RANK PALTRINIERI95 "[****]"))(POS (PAPER.DESCRIPTION PALTRINIERI95 "
Paltrinieri gives a 2-page description of a generalization of CSPs to
object-oriented CSPs.  He also describes a visual environment for 
dealing with OOCSPs.
"))(POS (PAPER.TOPIC PALTRINIERI95 "Object Oriented Constraint Satisfaction"))(POS (PAPER.INSTANCE PASTRE78))(POS (PAPER.BIBTEX PASTRE78 ARTICLE))(POS (PAPER.AUTHOR PASTRE78 "D. Pastre"))(POS (PAPER.TITLE PASTRE78 "Automatic Theorem Proving in Set Theory"))(POS (PAPER.PUBLICATION PASTRE78 "Artificial Intelligence"))(POS (PAPER.VOLUME PASTRE78 "10(1)"))(POS (PAPER.STARTPAGE PASTRE78 1))(POS (PAPER.ENDPAGE PASTRE78 27))(POS (PAPER.LINK PASTRE78 ""))(POS (PAPER.YEAR PASTRE78 1978))(POS (PAPER.RANK PASTRE78 "[**]"))(POS (PAPER.DESCRIPTION PASTRE78 "
Pastre describes PROVER, a theorem prover for set theory that builds
diagrams from axioms in order to prune the search space of theorem proving.
Pastre admits the methods to be incomplete, but claims an incomplete
method may prove more theorems than a complete one in practice.
"))(POS (PAPER.TOPIC PASTRE78 "Graphical Reasoning Techniques"))(POS (PAPER.INSTANCE PELTIER2000))(POS (PAPER.BIBTEX PELTIER2000 ARTICLE))(POS (PAPER.AUTHOR PELTIER2000 "Nicolas Peltier"))(POS (PAPER.TITLE PELTIER2000 "Model Building with Ordered Resolution"))(POS (PAPER.PUBLICATION PELTIER2000 "International Workshop on First Order Theorem Proving (FTP)"))(POS (PAPER.LINK PELTIER2000 "http://citeseer.ist.psu.edu/peltier00model.html"))(POS (PAPER.YEAR PELTIER2000 2000))(POS (PAPER.RANK PELTIER2000 "[****]"))(POS (PAPER.DESCRIPTION PELTIER2000 "
Peltier describes two algorithms that can be used after an ordered
resolution proof has failed: (1) to extract from the resolution closure
a set of formulas that have a single Herbrand model where that model
satisfies the original clauseset and (2) to turn those formulas into
a set of clauses.  Peltier's Herbrand model is represented by a clauseset,
and since the clauseset is guaranteed to have exactly one Herbrand model,
proof by consistency can be used to check whether that model satisfies
a particular sentence; moreover, for ground literals, satisfaction is decidable
since either the literal or its negation must be consistent and the 
clauseset is satisfiable, exactly one is consistent, which ensures one
is inconsistent.  Any off-the- shelf first-order entailment algorithm will 
find an inconsistency.  The technique is based on predicate completion,
which only works when there is a strict ordering among the clauses. 
"))(POS (PAPER.TOPIC PELTIER2000 "Model Building"))(POS (PAPER.INSTANCE PEREIRA80))(POS (PAPER.BIBTEX PEREIRA80 INPROCEEDINGS))(POS (PAPER.AUTHOR PEREIRA80 "Pereira and Porto"))(POS (PAPER.TITLE PEREIRA80 "Selective Backtracking for Logic Programs"))(POS (PAPER.PUBLICATION PEREIRA80 "In Proceedings of the Conference on Automated Deduction"))(POS (PAPER.YEAR PEREIRA80 1980))(POS (PAPER.DESCRIPTION PEREIRA80 "
One of the papers that uses the Logic Programming formulation of map coloring.
"))(POS (PAPER.TOPIC PEREIRA80 "Logic Programming"))(POS (PAPER.INSTANCE PETERSON98))(POS (PAPER.BIBTEX PETERSON98 INPROCEEDINGS))(POS (PAPER.AUTHOR PETERSON98 "Brian Peterson and William Anderson and Joshua Engel"))(POS (PAPER.TITLE PETERSON98 "Knowledge Bus: Generating Application-focused Databases from Large Ontologies"))(POS (PAPER.PUBLICATION PETERSON98 "Knowledge Representation Meets Databases"))(POS (PAPER.LINK PETERSON98 "http://citeseer.ist.psu.edu/peterson98knowledge.html"))(POS (PAPER.YEAR PETERSON98 1998))(POS (PAPER.DESCRIPTION PETERSON98 "
The authors attempt to construct a logic program from Cyc for answering a
given set of queries.  Their transformation is lossy, and it is unclear
to what extent the logical consequences are preserved.
"))(POS (PAPER.TOPIC PETERSON98 "Reformulation"))(POS (PAPER.INSTANCE PETRIE2004))(POS (PAPER.BIBTEX PETRIE2004 ARTICLE))(POS (PAPER.AUTHOR PETRIE2004 "Charles J. Petrie, Michael R. Genesereth, Hans Bjornsson, Rada Chirkova, Martin Ekstrom, Hidehito Gomi, Tim Hinrichs, Rob Hoskins, Michael Kassoff, Daishi Kato, Kyohei Kawazoe, Jung Ung Min, and Waqar Mohsin"))(POS (PAPER.TITLE PETRIE2004 "Adding AI to Web Services"))(POS (PAPER.PUBLICATION PETRIE2004 "Lecture Notes in Artificial Intelligence"))(POS (PAPER.VOLUME PETRIE2004 "2926"))(POS (PAPER.STARTPAGE PETRIE2004 322))(POS (PAPER.ENDPAGE PETRIE2004 338))(POS (PAPER.LINK PETRIE2004 "papers/petrie2004adding.pdf"))(POS (PAPER.YEAR PETRIE2004 2004))(POS (PAPER.DESCRIPTION PETRIE2004 "
The FX-Agents project consisted of members of the Stanford Logic Group 
and industrial visitors from NEC and Intec Web and Genome working together 
to develop new technologies based upon the combination of Web services and 
techniques from artificial intelligence, using our experience in AI-based 
software agents. This two-year project ran from April 2001 until March 2002 
and explored the then emerging functionality of Web services. This paper is 
a result of our findings. In particular, this paper discusses the shortcomings 
of current Web service standards like WSDL and how logical AI techniques 
like declarative commands, agents, and planning can be used to address some 
of these shortcomings. The primary problems that we address are automated 
Web service discovery and composition of Web services. 
"))(POS (PAPER.TOPIC PETRIE2004 "References"))(POS (PAPER.INSTANCE PICHLER2000))(POS (PAPER.BIBTEX PICHLER2000 ARTICLE))(POS (PAPER.AUTHOR PICHLER2000 "Reinhard Pichler"))(POS (PAPER.TITLE PICHLER2000 "On the Complexity of Equational Problems in CNF over a Finite Domain"))(POS (PAPER.LINK PICHLER2000 "http://citeseer.ist.psu.edu/478741.html"))(POS (PAPER.YEAR PICHLER2000 2000))(POS (PAPER.RANK PICHLER2000 "[**]"))(POS (PAPER.DESCRIPTION PICHLER2000 "
Pichler shows that the complexity of satisfiability of a purely equational 
Herbrand logic sentence E*A*.M, where M is in CNF, is Sigma_2^p-complete.
"))(POS (PAPER.TOPIC PICHLER2000 "Herbrand Logic"))(POS (PAPER.INSTANCE PINTO94))(POS (PAPER.AUTHOR PINTO94 "Javier Pinto"))(POS (PAPER.TITLE PINTO94 "Temporal Reasoning in the Situation Calculus"))(POS (PAPER.LINK PINTO94 "http://citeseer.ist.psu.edu/pinto94temporal.html"))(POS (PAPER.YEAR PINTO94 1994))(POS (PAPER.RANK PINTO94 "[**]"))(POS (PAPER.DESCRIPTION PINTO94 "
Pinto's thesis extends situation calculus to cover temporal reasoning.  He includes ACTUAL PATHS (narratives), concurrent actions, and continuous time with natural events.  He goes on to compare his situation calculus with interval temporal logic, the calculus of events, and modal temporal logics.  He later reworked his approach to narratives in [pinto98], which does not call for circumscription.  Reiter published a paper on 'Natural Actions, Concurrency, and Continuous Time' [reiter96] after Pinto--should probably read that one instead.
"))(POS (PAPER.TOPIC PINTO94 "Behavioral Goals"))(POS (PAPER.RELATED PINTO94 REITER96))(POS (PAPER.RELATED PINTO94 PINTO98))(POS (PAPER.INSTANCE PINTO98))(POS (PAPER.AUTHOR PINTO98 "Javier Pinto"))(POS (PAPER.TITLE PINTO98 "Occurrences and Narratives as Constraints in the Branching Structure of the Situation Calculus"))(POS (PAPER.PUBLICATION PINTO98 "Journal of Logic and Computation"))(POS (PAPER.VOLUME PINTO98 "8(6)"))(POS (PAPER.STARTPAGE PINTO98 777))(POS (PAPER.ENDPAGE PINTO98 808))(POS (PAPER.LINK PINTO98 "http://citeseer.ist.psu.edu/pinto96occurrences.html"))(POS (PAPER.YEAR PINTO98 1998))(POS (PAPER.RANK PINTO98 "[*****]"))(POS (PAPER.DESCRIPTION PINTO98 "
Pinto tackles the problem of expressing occurrences in situation calculus.  Occurrences are sequences of events that really do happen in every hypothetical branch of the situation tree.  In deductive plan synthesis via the Green method, we want all plans returned to include all the occurrences given.  Pinto names two specific types of occurrences: narratives (a partial specification of a sequence of events known to happen) and triggers (as in the database sense).  His formulation assigns time values to situations, a second order induction axiom, along with an extension to the sitcalc ontology to define 'nonpreventable occurrences', 'conditional occurrences', and 'simple occurrences'.  He defines 'legal(s)' in terms of these 3 occurrence types to mean that a situation s includes all the mentioned occurrences and is a valid sitcalc situation.  Pinto goes on to define when one situation is preferred to another: s preferred-to s' iff s' has the same actions as s with extra actions appended to the end.  For planning, Pinto shows that instead of finding an s s.t. goal(s) is true, we can find an s s.t. goal(s) ^ legal(s) is true. 
"))(POS (PAPER.TOPIC PINTO98 "Behavioral Goals"))(POS (PAPER.INSTANCE PIRRI99))(POS (PAPER.AUTHOR PIRRI99 "Fiora Pirri and Ray Reiter"))(POS (PAPER.TITLE PIRRI99 "Some Contributions to the Metatheory of the Situation Calculus"))(POS (PAPER.PUBLICATION PIRRI99 "Journal of the ACM"))(POS (PAPER.VOLUME PIRRI99 "46(3)"))(POS (PAPER.STARTPAGE PIRRI99 325))(POS (PAPER.ENDPAGE PIRRI99 361))(POS (PAPER.LINK PIRRI99 "http://citeseer.ist.psu.edu/pirri99some.html"))(POS (PAPER.YEAR PIRRI99 1999))(POS (PAPER.RANK PIRRI99 "[****]"))(POS (PAPER.DESCRIPTION PIRRI99 "
Pirri and Reiter formalize the theory of situation calculus and define basic
action theories as D = Sigma U D_ss U D_ap U D_una U D_s0.  Sigma are the
foundational axioms (induction, situation ordering, equality, unique names
for situations); D_ss are
successor state axioms; D_ap are action precondition axioms; D_una are unique
name axioms for actions; D_s0 are initial state axioms.  This definition
appears throughout later work on the situation calculus.  Well written.
They also define Regression (in a clearer way than reiter91--the
Frame problem...), which means rewriting a regressable formula so that the only
situations referenced are S0.  Entailment of a regressed formula requires
only knowledge
of D_s0 and D_una.  Pirri and Reiter also give conditions when induction is
not needed for entailment, as well as when other components of Sigma are
unnecessary.  They go on to show that Sigma is unnecessary for GOLOG programs.
"))(POS (PAPER.TOPIC PIRRI99 "Fundamentals"))(POS (PAPER.INSTANCE PLAISTED81))(POS (PAPER.BIBTEX PLAISTED81 ARTICLE))(POS (PAPER.AUTHOR PLAISTED81 "David Plaisted"))(POS (PAPER.TITLE PLAISTED81 "Theorem Proving with Abstraction"))(POS (PAPER.PUBLICATION PLAISTED81 "Artificial Intelligence"))(POS (PAPER.VOLUME PLAISTED81 "16(1)"))(POS (PAPER.STARTPAGE PLAISTED81 47))(POS (PAPER.ENDPAGE PLAISTED81 107))(POS (PAPER.LINK PLAISTED81 ""))(POS (PAPER.YEAR PLAISTED81 1981))(POS (PAPER.DESCRIPTION PLAISTED81 "
Plaisted defines the notion of an abstraction of a literal and a clause and
shows that under this definition, the union and composition of two
abstractions is another abstraction.  He also gives local conditions
under which a mapping is an abstraction, which can be practically used.
He goes on to discuss abstract resolution proofs and multi-clauses (which
admit simpler proof procedures than regular clauses).  He discusses
using more than one abstraction at a time.  Using these abstractions admits
a complete proof procedure.  Finally, he introduces a variant
of the multi-clause notion and considers a version of completeness for it.
"))(POS (PAPER.TOPIC PLAISTED81 "Abstraction"))(POS (PAPER.INSTANCE PLAISTED94))(POS (PAPER.BIBTEX PLAISTED94 INPROCEEDINGS))(POS (PAPER.AUTHOR PLAISTED94 "David Plaisted"))(POS (PAPER.TITLE PLAISTED94 "The Search Efficiency of Theorem Proving Strategies: An Analytical Comparison"))(POS (PAPER.PUBLICATION PLAISTED94 "CADE"))(POS (PAPER.STARTPAGE PLAISTED94 1))(POS (PAPER.ENDPAGE PLAISTED94 40))(POS (PAPER.LINK PLAISTED94 "http://citeseer.ist.psu.edu/plaisted94search.html"))(POS (PAPER.YEAR PLAISTED94 1994))(POS (PAPER.RANK PLAISTED94 "[***]"))(POS (PAPER.DESCRIPTION PLAISTED94 "
Plaisted does a comparison of a slew of clausal, refutation 
theorem-proving strategies for
propositional Horn clauses.  He gives three measures for the search
spaces generated by each strategy: iterated duplication, case-analysis
duplication, and combination duplication, the produce of which bounds
the total size of the search space.  The first measures the longest path,
the second measures the number of paths, and the third measures the
maximum size of clauses generated in any state. 
"))(POS (PAPER.TOPIC PLAISTED94 "Comparative Analysis"))(POS (PAPER.INSTANCE PLAISTED97))(POS (PAPER.BIBTEX PLAISTED97 INPROCEEDINGS))(POS (PAPER.AUTHOR PLAISTED97 "David Plaisted and Yunshan Zhu"))(POS (PAPER.TITLE PLAISTED97 "Ordered Semantic Hyper Linking"))(POS (PAPER.PUBLICATION PLAISTED97 "AAAI"))(POS (PAPER.LINK PLAISTED97 "http://citeseer.ist.psu.edu/218207.html"))(POS (PAPER.YEAR PLAISTED97 1997))(POS (PAPER.RANK PLAISTED97 "[***]"))(POS (PAPER.DESCRIPTION PLAISTED97 "
Ordered Semantic Hyper Linking is a proof procedure based on
model-building.  In includes a total ordering on
formulae to remove redundant interpretations.  OSHL allows the user
to give an initial interpretation to guide the search.
It propositionalizes first order theories to build its models.  
The paper claims soundness and completeness, but no proofs are
supplied (probably due to lack of space).
"))(POS (PAPER.TOPIC PLAISTED97 "Resolution Variants"))(POS (PAPER.INSTANCE PLUMMER95))(POS (PAPER.BIBTEX PLUMMER95 MISC))(POS (PAPER.AUTHOR PLUMMER95 "Dave Barker-Plummer and Sidney Bailin"))(POS (PAPER.TITLE PLUMMER95 "Proofs and Pictures: Proving the Diamond lemma with the GROVER Theorem Proving System"))(POS (PAPER.LINK PLUMMER95 "http://citeseer.ist.psu.edu/193199.html"))(POS (PAPER.YEAR PLUMMER95 1995))(POS (PAPER.RANK PLUMMER95 "[*]"))(POS (PAPER.DESCRIPTION PLUMMER95 "
The authors describe a theorem proving system that takes a set of axioms, Delta,
a diagram, D, and a conjecture phi.  It proves Delta |= phi by 1) examining D and 
determining that D |= phi, and 2) proving Delta |= D.  The method seems to be 
ad hoc with no guarantees of soundness or completeness; however, given enough
hints, GROVER was able to prove the Diamond Lemma.
"))(POS (PAPER.TOPIC PLUMMER95 "Graphical Reasoning Techniques"))(POS (PAPER.INSTANCE PRASAD2005))(POS (PAPER.BIBTEX PRASAD2005 ARTICLE))(POS (PAPER.AUTHOR PRASAD2005 "Mukul Prasad and Armin Biere and Aarti Gupta"))(POS (PAPER.TITLE PRASAD2005 "A Survey of Recent Advances in SAT-Based Formal Verification"))(POS (PAPER.PUBLICATION PRASAD2005 "Software Tools for Technology Transfer"))(POS (PAPER.VOLUME PRASAD2005 "7(2)"))(POS (PAPER.STARTPAGE PRASAD2005 156))(POS (PAPER.ENDPAGE PRASAD2005 173))(POS (PAPER.LINK PRASAD2005 "http://www.cerc.utexas.edu/~jay/fv_surveys/"))(POS (PAPER.YEAR PRASAD2005 2005))(POS (PAPER.DESCRIPTION PRASAD2005 "
A survey paper discussing how boolean SAT solvers are being used
for formal verification.
"))(POS (PAPER.TOPIC PRASAD2005 "Formal Verification"))(POS (PAPER.INSTANCE PUEBLA2004))(POS (PAPER.BIBTEX PUEBLA2004 ARTICLE))(POS (PAPER.AUTHOR PUEBLA2004 "G. Puebla and E. Albert and M. Hermenegildo"))(POS (PAPER.TITLE PUEBLA2004 "Efficient Local Unfolding with Ancestor Stacks for Full Prolog"))(POS (PAPER.PUBLICATION PUEBLA2004 "14th International Symposium, Logic Based Program Synthesis and Transformation (LOPSTR)"))(POS (PAPER.STARTPAGE PUEBLA2004 1))(POS (PAPER.ENDPAGE PUEBLA2004 18))(POS (PAPER.LINK PUEBLA2004 "http://wotan.liu.edu/docis/dbl/lopstr/index.html"))(POS (PAPER.YEAR PUEBLA2004 2004))(POS (PAPER.DESCRIPTION PUEBLA2004 "
In the context of Horn prolog with built-ins, the authors address the
problem of efficiently unfolding of recursive relations.  That is,
one implementation of partial evaluation/partial deduction is to produce
a partial SLD tree and using the fringe as the body of a rule for proving
the goal.  The problem with this approach is that the recursive relations 
produce infinite SLD trees, unless the recursion is cut off.  To determine
when the recursion should be cut off, a common practice is to apply a
recursive rule only when the subgoal is smaller, according to some
ordering, e.g. well-founded, well-quasi, than all its ancestors.  To
implement that, all the ancestors of each goal have in the past 
been stored, which is expensive both in time to check and in space
to store.  This paper tackles this problem by expanding the tree in a 
variant of depth-first search so that only the current call stack need
be stored.  They also consider the case of built-in predicates.
"))(POS (PAPER.TOPIC PUEBLA2004 "Reformulation"))(POS (PAPER.INSTANCE RAMACHANDRAN2005))(POS (PAPER.BIBTEX RAMACHANDRAN2005 ARTICLE))(POS (PAPER.AUTHOR RAMACHANDRAN2005 "D. Ramachandran and E. Amir"))(POS (PAPER.TITLE RAMACHANDRAN2005 "Compact Propositional Encodings of First-Order Theories"))(POS (PAPER.PUBLICATION RAMACHANDRAN2005 "20th National Conference on Artificial Intelligence"))(POS (PAPER.LINK RAMACHANDRAN2005 "http://reason.cs.uiuc.edu/eyal/paper.html"))(POS (PAPER.YEAR RAMACHANDRAN2005 2005))(POS (PAPER.DESCRIPTION RAMACHANDRAN2005 "
The authors introduce polynomial-time algorithms for converting
first-order logic (sometimes with a DCA) into propositional logic,
where the goal is a small output size.  Relies on a certain
structure within the FOL theory.
"))(POS (PAPER.TOPIC RAMACHANDRAN2005 "Reformulation"))(POS (PAPER.INSTANCE RAO2004))(POS (PAPER.BIBTEX RAO2004 ARTICLE))(POS (PAPER.AUTHOR RAO2004 "M.R.K. Krishna Rao"))(POS (PAPER.TITLE RAO2004 "Input-Termination of Logic Programs"))(POS (PAPER.PUBLICATION RAO2004 "14th International Symposium, Logic Based Program Synthesis and Transformation (LOPSTR)"))(POS (PAPER.STARTPAGE RAO2004 215))(POS (PAPER.ENDPAGE RAO2004 230))(POS (PAPER.LINK RAO2004 "http://wotan.liu.edu/docis/dbl/lopstr/index.html"))(POS (PAPER.YEAR RAO2004 2004))(POS (PAPER.DESCRIPTION RAO2004 "
Rao defines a class of logic programs, linear bounded programs,
and show that such programs are input-terminating under Prolog's 
selection rule.  Rao also shows that all simply-moded linear bounded
programs are input-terminating.  Importantly, determining whether
a program is linearly bounded is decidable, unlike previous work
which gave necessary and sufficient conditions for a class of 
decidable programs, but checking those conditions is undecidable.  Input-
consuming derivations do not instantiate variables that only occur
in the input positions of the initial query, and input-termination is the
property that all input-consuming derivations are finite.
"))(POS (PAPER.TOPIC RAO2004 "Reformulation"))(POS (PAPER.INSTANCE REITER2000))(POS (PAPER.AUTHOR REITER2000 "Ray Reiter"))(POS (PAPER.TITLE REITER2000 "Narratives as Programs"))(POS (PAPER.PUBLICATION REITER2000 "Principles of Knowledge Representation and Reasoning"))(POS (PAPER.STARTPAGE REITER2000 99))(POS (PAPER.ENDPAGE REITER2000 108))(POS (PAPER.LINK REITER2000 "http://citeseer.ist.psu.edu/reiter00narratives.html"))(POS (PAPER.YEAR REITER2000 2000))(POS (PAPER.RANK REITER2000 "[*]"))(POS (PAPER.DESCRIPTION REITER2000 "
Reiter argues that narratives (a sequence of events known to occur) are actually programs.  He uses GOLOG to represent narratives and shows that making a query Q(s) over a narrative is identical to proving a property about a program, as in program verification.  In GOLOG terms, we want to ask whether Q holds on a program v; we simply show that SitcalcAxioms |= As.(Do(v,S0,s)=>Q(s)).
"))(POS (PAPER.TOPIC REITER2000 "Behavioral Goals"))(POS (PAPER.INSTANCE REITER73))(POS (PAPER.BIBTEX REITER73 INPROCEEDINGS))(POS (PAPER.AUTHOR REITER73 "Ray Reiter"))(POS (PAPER.TITLE REITER73 "A Semantically Guided Deductive System for Automatic Theorem-Proving"))(POS (PAPER.PUBLICATION REITER73 "IJCAI"))(POS (PAPER.YEAR REITER73 1973))(POS (PAPER.RANK REITER73 "[**]"))(POS (PAPER.DESCRIPTION REITER73 "
Reiter describes a system for natural deduction that intertwines model-
building and deduction, where each affects the other.  The system itself
is composed of 12 inference rules which manipulate both axioms and 
models.  This may have been the seminal work on using an explicit 
model to aid theorem-proving; previous work used heuristics, which
Reiter characterized as implicit semantics. 
"))(POS (PAPER.TOPIC REITER73 "Model-Guided Proof Techniques"))(POS (PAPER.INSTANCE REITER78))(POS (PAPER.BIBTEX REITER78 INPROCEEDINGS))(POS (PAPER.AUTHOR REITER78 "Ray Reiter"))(POS (PAPER.TITLE REITER78 "On Closed World Databases"))(POS (PAPER.PUBLICATION REITER78 "In proceedings of 1978 ACM SIGMOD International Conference on Management of Data"))(POS (PAPER.YEAR REITER78 1978))(POS (PAPER.DESCRIPTION REITER78 "
The closed world assumption (CWA).
"))(POS (PAPER.TOPIC REITER78 "Logical Knowledge Representation"))(POS (PAPER.INSTANCE REITER80))(POS (PAPER.BIBTEX REITER80 ARTICLE))(POS (PAPER.AUTHOR REITER80 "Raymond Reiter"))(POS (PAPER.TITLE REITER80 "Equality and Domain Closure in First-Order Databases"))(POS (PAPER.PUBLICATION REITER80 "Journal of the ACM"))(POS (PAPER.VOLUME REITER80 "27(2)"))(POS (PAPER.STARTPAGE REITER80 235))(POS (PAPER.ENDPAGE REITER80 249))(POS (PAPER.LINK REITER80 "http://portal.acm.org/citation.cfm?id=322189"))(POS (PAPER.YEAR REITER80 1980))(POS (PAPER.RANK REITER80 "[**]"))(POS (PAPER.DESCRIPTION REITER80 "
Reiter explores techniques for doing first-order reasoning with 
a Domain Closure Axiom
(x=a1 | x=a2 | ... | x=an).  He focuses on axiom sets for which there
are a finite number of object constants, no function constants, and when
written in prenex form include no existential quantifiers.
To do so he (1) shows that existential queries will never require
the DCA, for algorithms exploiting Herbrand's theorem, and 
(2) how to build on this fact 
to answer any kind of query by peeling away quantifiers to build an 
existential query.  The second step uses a generalization of the 
relational database division operator for universal quantifiers and a 
generalization of the projection operator for existential quantifiers. 
Next it is shown that Horn databases and positive existential queries never 
require computing disjunctive answers. 
Then conditions are given for the removal of all but the x=x equality axiom: 
E-saturation, i.e.
unique names over all the constants.  Lastly it is
shown that extending DCA to include infinitely many constants can result in
an infinite disjunction as an answer to a query.  Very thorough, as always.
"))(POS (PAPER.TOPIC REITER80 "Logical Knowledge Representation"))(POS (PAPER.INSTANCE REITER84))(POS (PAPER.BIBTEX REITER84 CHAPTER))(POS (PAPER.AUTHOR REITER84 "Raymond Reiter"))(POS (PAPER.TITLE REITER84 "Towards a Logical Reconstruction of Relational Database Theory"))(POS (PAPER.PUBLISHER REITER84 "Springer-Verlag"))(POS (PAPER.PUBLICATION REITER84 "On Conceptual Modelling"))(POS (PAPER.STARTPAGE REITER84 191))(POS (PAPER.ENDPAGE REITER84 238))(POS (PAPER.LINK REITER84 ""))(POS (PAPER.YEAR REITER84 1984))(POS (PAPER.RANK REITER84 "[***]"))(POS (PAPER.DESCRIPTION REITER84 "
Reiter formalizes Database theory from a logical perspective.  Databases in this view are first-order models, and integrity constraints are sentences that such a model satisfies.  A relational theory (the set of sentences entailed by a relational database) can be defined as the set of ground atoms in the DB, a completion axiom for each table ensuring that those ground atoms not in the table are false, unique-names axioms, a domain closure axiom, and equality/substitution axioms.   Proof is provided.  Next Reiter goes on to generalize this definition to handle positive disjunction, which requires altering the completion axioms.  Lastly he shows how to deal with null values by changing the DCA and the completion axioms. 
"))(POS (PAPER.TOPIC REITER84 "Logical Knowledge Representation"))(POS (PAPER.INSTANCE REITER91))(POS (PAPER.AUTHOR REITER91 "Raymond Reiter"))(POS (PAPER.TITLE REITER91 "The Frame Problem in the Situation Calculus: A Simple Solution (Sometimes) and a Completeness Result for Goal Regression"))(POS (PAPER.PUBLICATION REITER91 "Artificial Intelligence and Mathematical Theory of Computation: Papers in Honor of John McCarthy"))(POS (PAPER.LINK REITER91 "http://ftp.cs.toronto.edu/pub/cogrob/README.html"))(POS (PAPER.YEAR REITER91 1991))(POS (PAPER.RANK REITER91 "[**]"))(POS (PAPER.DESCRIPTION REITER91 "
Reiter describes his solution to the frame problem, namely successor state
axioms of the form
Poss(a,s)=>[R(do(a,s)) =def= r_pos(a,s) V R(s) ^ ~r_neg(a,s)].  Poss(a,s) is
the action precondition axiom; R(do(a,s)) is the fluent, r_pos(a,s) is the
positive effect axiom for R; r_neg(a,s) is the negative effect axiom for R.
This works when also given a single definition for Poss(A,s) for each action A,
unique naming axioms for actions and states.  This technique requires F+A
axioms instead of 2*A*F axioms to describe frame and effect axioms for a
domain, where F is the number of fluents and A the number of actions.
Reiter also discusses a regression operator, which does deductive plan synthesis by taking a normal situation calculus axiomitization (using successor state axioms) and rewrites it so that every fluent only mentions S0.  Under certain conditions, Reiter shows that the rewriting can be done iff Es.G(s).
"))(POS (PAPER.TOPIC REITER91 "Fundamentals"))(POS (PAPER.INSTANCE REITER93))(POS (PAPER.AUTHOR REITER93 "Raymond Reiter"))(POS (PAPER.TITLE REITER93 "Proving Properties of States in the Situation Calculus"))(POS (PAPER.PUBLICATION REITER93 "Artificial Intelligence"))(POS (PAPER.VOLUME REITER93 "64(2)"))(POS (PAPER.STARTPAGE REITER93 337))(POS (PAPER.ENDPAGE REITER93 351))(POS (PAPER.LINK REITER93 "http://citeseer.ist.psu.edu/reiter93proving.html"))(POS (PAPER.YEAR REITER93 1993))(POS (PAPER.RANK REITER93 "[****]"))(POS (PAPER.DESCRIPTION REITER93 "
Reiter motivates the need to prove properties about states by citing the examples in the physical world (once broken, an object stays that way), planning (showing there is no plan to achieve a goal), and integrity constraints on a database.  He formulates an induction axiom sufficient for proving P(s) for all states s>=S0.  He relies on explanation closure axioms, proposed by Schubert and Haas, which are logically equivalent to frame axioms.
"))(POS (PAPER.TOPIC REITER93 "Theories of Action"))(POS (PAPER.INSTANCE REITER95))(POS (PAPER.AUTHOR REITER95 "Ray Reiter"))(POS (PAPER.TITLE REITER95 "On Specifying Database Updates"))(POS (PAPER.PUBLICATION REITER95 "Journal of Logic Programming"))(POS (PAPER.VOLUME REITER95 "25(1)"))(POS (PAPER.STARTPAGE REITER95 53))(POS (PAPER.ENDPAGE REITER95 91))(POS (PAPER.LINK REITER95 "http://citeseer.ist.psu.edu/reiter92specifying.html"))(POS (PAPER.YEAR REITER95 1995))(POS (PAPER.RANK REITER95 "[*]"))(POS (PAPER.DESCRIPTION REITER95 "
Reiter summarizes several previous pieces of work including proving properties of states in Situation Calculus and formalizing the querying of a database transaction.  He also compares this approach to other database query techniques.
"))(POS (PAPER.TOPIC REITER95 "Hypothetical Temporal DB Queries"))(POS (PAPER.INSTANCE REITER96))(POS (PAPER.AUTHOR REITER96 "Ray Reiter"))(POS (PAPER.TITLE REITER96 "Natural Actions, Concurrency and Continuous Time in the Situation Calculus"))(POS (PAPER.PUBLICATION REITER96 "Principles of Knowledge Representation and Reasoning: Proceedings of the Fifth International Conference"))(POS (PAPER.STARTPAGE REITER96 2))(POS (PAPER.ENDPAGE REITER96 13))(POS (PAPER.LINK REITER96 "http://ftp.cs.toronto.edu/pub/cogrob/README.html"))(POS (PAPER.YEAR REITER96 1996))(POS (PAPER.RANK REITER96 "[*****]"))(POS (PAPER.DESCRIPTION REITER96 "
Reiter gives an axiomitization for Concurrent, Temporal Situation Calculus.  He mentions any solution to the Precondition Interaction Problem (where two actions preconditions may both be satisfied yet the 2 actions are mutually exclusive) works within the given framework.  The axiomitization allows actions following the laws of physics to occur at the same time an agent is acting in the world.  Plans can consequently be produced that take these laws into account.
"))(POS (PAPER.TOPIC REITER96 "Behavioral Goals"))(POS (PAPER.INSTANCE RIAZANOV02))(POS (PAPER.BIBTEX RIAZANOV02 ARTICLE))(POS (PAPER.AUTHOR RIAZANOV02 "Alexandre Riazanov and Andrei Voronkov"))(POS (PAPER.TITLE RIAZANOV02 "The design and implementation of Vampire"))(POS (PAPER.PUBLICATION RIAZANOV02 "AI Communications"))(POS (PAPER.VOLUME RIAZANOV02 "15"))(POS (PAPER.STARTPAGE RIAZANOV02 91))(POS (PAPER.ENDPAGE RIAZANOV02 110))(POS (PAPER.LINK RIAZANOV02 ""))(POS (PAPER.YEAR RIAZANOV02 2002))(POS (PAPER.RANK RIAZANOV02 ""))(POS (PAPER.DESCRIPTION RIAZANOV02 "
Riazanov and Voronkov describe Vampire v2.0.  They first give an overview
of the high-level functionality, then give a more detailed discussion
of the architecture based on DISCOUNT, talk about term-indexing, 
and delve into representational
issues (e.g. shared terms) along with memory management.  
"))(POS (PAPER.TOPIC RIAZANOV02 "System Designs"))(POS (PAPER.INSTANCE RIAZANOV2001))(POS (PAPER.AUTHOR RIAZANOV2001 "Alexandre Riazanov and Andrei Voronkov"))(POS (PAPER.TITLE RIAZANOV2001 "Splitting without Backtracking"))(POS (PAPER.PUBLICATION RIAZANOV2001 "IJCAI"))(POS (PAPER.STARTPAGE RIAZANOV2001 611))(POS (PAPER.ENDPAGE RIAZANOV2001 617))(POS (PAPER.LINK RIAZANOV2001 "http://rpc25.cs.man.ac.uk/voronkov/all_publications.html"))(POS (PAPER.YEAR RIAZANOV2001 2001))(POS (PAPER.DESCRIPTION RIAZANOV2001 "
The authors describe a technique for resolution that allows resolution
to break a clause apart when variables are not shared between pieces.
Suppose the clause C can be partitioned into 2 parts D and E, where each
part shares no variables with any other part.  Splitting replaces
C with the clauses D | p and E | -p.  This only makes sense when there
is an ordering imposed on the literals so that p and -p are not immediately
resolved together undoing the work of splitting.  The authors investigate
two orders: blocking and parallel.  In blocking, the -p literals 
are ranked highest; the non p literals are ranked next with negative
bigger than positive; the p atoms are ranked lowest.  In parallel,
the p literals (positive or negative) are ranked last.  Also, 
these p literals are considered names.  If there is another clause 
C' with partition D and F, then C' is split into F | -p.  Some
experimental results from TPTP show that splitting is a bad idea
with equality but that Parallel ordering with Naming is a good idea
without equaity. 
"))(POS (PAPER.TOPIC RIAZANOV2001 "Calculi"))(POS (PAPER.INSTANCE RIAZANOV2003))(POS (PAPER.AUTHOR RIAZANOV2003 "Alexandre Riazanov and Andrei Voronkov"))(POS (PAPER.TITLE RIAZANOV2003 "Efficient Instance Retrieval with Standard and Relational Path Indexing
"))(POS (PAPER.LINK RIAZANOV2003 "http://citeseer.ist.psu.edu/594779.html"))(POS (PAPER.YEAR RIAZANOV2003 2003))(POS (PAPER.DESCRIPTION RIAZANOV2003 "
Riazanov and Voronkov follow on their first indexing paper with this one.
They compare discrimination trees and path indexing for the case of instance
retrieval.  Given a term t, find all terms u and substitutions sigma such that 
t.sigma = u.  Discrimination trees represent terms as strings; path
indexing represents terms as trees.  The authors show that with the
standard implementation of path indexing is slower than DT.  Then
they augment PI with skip lists, early cleaning to more closely
approximate perfect filtering, and a couple of other improvements.  Then
they argue for relational path indexing, utilizing database theory
to conceptualize the integration of cleaning after imperfect filtering
into the imperfect filtering.  They show how this idea makes
commutative indexing and backward subsumption on multiliteral
clauses.
"))(POS (PAPER.TOPIC RIAZANOV2003 "Indexing"))(POS (PAPER.INSTANCE ROBINSON))(POS (PAPER.BIBTEX ROBINSON BOOK))(POS (PAPER.AUTHOR ROBINSON "Alan Robinson and Andrei Voronkov"))(POS (PAPER.TITLE ROBINSON "Handbook of Automated Reasoning"))(POS (PAPER.PUBLISHER ROBINSON "MIT Press and Elsevier Science"))(POS (PAPER.LINK ROBINSON "http://www.amazon.com/Handbook-Automated-Reasoning-Alan-Robinson/dp/0262182238"))(POS (PAPER.YEAR ROBINSON 2001))(POS (PAPER.RANK ROBINSON "[*****]"))(POS (PAPER.DESCRIPTION ROBINSON "
Robinson and Voronkov edit this two volume handbook.  The first volume covers
a history of the field, methods for first-order logic, methods for equality and
other built-in theories, and induction.  The second volume covers higher-order
logics, nonclassical logics, decidable classes and model building, and implementational
details.
"))(POS (PAPER.TOPIC ROBINSON ""))(POS (PAPER.INSTANCE ROBINSON65MACHINE))(POS (PAPER.BIBTEX ROBINSON65MACHINE ARTICLE))(POS (PAPER.AUTHOR ROBINSON65MACHINE "J.A. Robinson"))(POS (PAPER.TITLE ROBINSON65MACHINE "A Machine-Oriented Logic Based on the Resolution Principle"))(POS (PAPER.PUBLICATION ROBINSON65MACHINE "Journal of the ACM"))(POS (PAPER.VOLUME ROBINSON65MACHINE "12(1)"))(POS (PAPER.STARTPAGE ROBINSON65MACHINE 23))(POS (PAPER.ENDPAGE ROBINSON65MACHINE 41))(POS (PAPER.YEAR ROBINSON65MACHINE 1965))(POS (PAPER.RANK ROBINSON65MACHINE ""))(POS (PAPER.DESCRIPTION ROBINSON65MACHINE "
The resolution paper.
"))(POS (PAPER.TOPIC ROBINSON65MACHINE "Theorem Proving"))(POS (PAPER.INSTANCE ROY2000))(POS (PAPER.BIBTEX ROY2000 ARTICLE))(POS (PAPER.AUTHOR ROY2000 "Pierre Roy, Anne Liret, Francois Pachet"))(POS (PAPER.TITLE ROY2000 "The Framework Approach for Constraint Satisfaction"))(POS (PAPER.PUBLICATION ROY2000 "ACM Computing Surveys"))(POS (PAPER.VOLUME ROY2000 "32"))(POS (PAPER.STARTPAGE ROY2000 13))(POS (PAPER.ENDPAGE ROY2000 16))(POS (PAPER.LINK ROY2000 "http://citeseer.ist.psu.edu/roy00framework.html"))(POS (PAPER.YEAR ROY2000 2000))(POS (PAPER.RANK ROY2000 "[**]"))(POS (PAPER.DESCRIPTION ROY2000 "
The authors argue that a Framework is a better paradigm for
allowing a user to solve CSPs than either a Library of generic
constraints or a Language built for writing solvers of CSPs. 
The former approach is too coarsely-grained, and the latter is
too finely-grained.  The framework approach sits nicely in the
middle. 
"))(POS (PAPER.TOPIC ROY2000 "OO Languages with Native Constraint Satisfaction"))(POS (PAPER.INSTANCE ROY97))(POS (PAPER.AUTHOR ROY97 "Pierre Roy, Francois Pachet"))(POS (PAPER.TITLE ROY97 "Reifying Constraint Satisfaction in Smalltalk"))(POS (PAPER.PUBLICATION ROY97 "Journal of Object-Oriented Programming"))(POS (PAPER.VOLUME ROY97 "10(4)"))(POS (PAPER.STARTPAGE ROY97 43))(POS (PAPER.ENDPAGE ROY97 51))(POS (PAPER.LINK ROY97 "http://citeseer.ist.psu.edu/roy97reifying.html"))(POS (PAPER.YEAR ROY97 1997))(POS (PAPER.RANK ROY97 "[**]"))(POS (PAPER.DESCRIPTION ROY97 "
Roy describes Backtalk, a system that allows a library of
generic CSP algorithms to be written.
Doing so requires reifying
the notion of a constraint, a CSP problem, a solution, etc..
"))(POS (PAPER.TOPIC ROY97 "OO Languages with Native Constraint Satisfaction"))(POS (PAPER.INSTANCE RUEB2000DECONSTRUCTING))(POS (PAPER.BIBTEX RUEB2000DECONSTRUCTING INPROCEEDINGS))(POS (PAPER.AUTHOR RUEB2000DECONSTRUCTING "Harald Rueb and Nataranjan Shankar"))(POS (PAPER.TITLE RUEB2000DECONSTRUCTING "Deconstructing Shostak"))(POS (PAPER.PUBLICATION RUEB2000DECONSTRUCTING "17th International Conference on Automated Deduction
           "))(POS (PAPER.LINK RUEB2000DECONSTRUCTING "http://citeseer.ist.psu.edu/290082.html"))(POS (PAPER.YEAR RUEB2000DECONSTRUCTING 2000))(POS (PAPER.RANK RUEB2000DECONSTRUCTING "[****]"))(POS (PAPER.DESCRIPTION RUEB2000DECONSTRUCTING "
Rueb and Shankar show the crisply outlined Shostak procedure outlined
in cyrluk96shostaks and all its variants to date are incomplete.  They
go further and give a complete version of the Shostak procedure and
finally give soundness and completeness proofs.
"))(POS (PAPER.TOPIC RUEB2000DECONSTRUCTING "Nelson-Oppen and Shostak"))(POS (PAPER.RELATED RUEB2000DECONSTRUCTING CYRLUK96SHOSTAKS))(POS (PAPER.RELATED RUEB2000DECONSTRUCTING SHOSTAK84))(POS (PAPER.INSTANCE SABIN96))(POS (PAPER.BIBTEX SABIN96 ARTICLE))(POS (PAPER.AUTHOR SABIN96 "D. Sabin and E. Freuder"))(POS (PAPER.TITLE SABIN96 "Configuration as Composite Constraint Satisfaction"))(POS (PAPER.PUBLICATION SABIN96 " AAAI Configuration Workshop"))(POS (PAPER.STARTPAGE SABIN96 28))(POS (PAPER.ENDPAGE SABIN96 36))(POS (PAPER.LINK SABIN96 "http://citeseer.ist.psu.edu/sabin96configuration.html"))(POS (PAPER.YEAR SABIN96 1996))(POS (PAPER.RANK SABIN96 "[****]"))(POS (PAPER.DESCRIPTION SABIN96 "
Sabin and Freuder define a new form of CSP which generalizes 
Meta CSPs, conditional CSPs, and hierarchical domain CSPs.
Composite CSP domain values are the set of solutions to an
entire subproblem.
"))(POS (PAPER.TOPIC SABIN96 "Various Forms of Constraint Satisfaction"))(POS (PAPER.INSTANCE SACERDOTI74))(POS (PAPER.AUTHOR SACERDOTI74 "Earl D. Sacerdoti"))(POS (PAPER.TITLE SACERDOTI74 "Planning in a Hierarchy of Abstraction Spaces"))(POS (PAPER.PUBLICATION SACERDOTI74 "Artificial Intelligence"))(POS (PAPER.VOLUME SACERDOTI74 "5"))(POS (PAPER.STARTPAGE SACERDOTI74 115))(POS (PAPER.ENDPAGE SACERDOTI74 135))(POS (PAPER.YEAR SACERDOTI74 1974))(POS (PAPER.DESCRIPTION SACERDOTI74 "
The ABSTRIPS (Abstraction-based STRIPS) paper.  In 1969, McCarthy and Hayes' asserted that knowledge representation should be epistemologically adequate and also define heuristic adequacy.  Sufficiently complex problems contain too many details to be epistemologically adequate and have adequeate heuristics.  To that end, Sacerdoti first plans through an abstract plan space and then refines a solution in that space to ensure the details support the abstraction.  To implement this idea, Sacerdoti extends STRIPS by assigning 'criticality' measures to each precondition of an action.  These measures define a hierarchy of abstraction spaces.  The planner finds a solution at the highest level of abstraction, and proceeds recursively to the next highest level.  Control of the search (i.e. the cost assigned to nodes in the search space) changes based on the level of abstraction.
"))(POS (PAPER.TOPIC SACERDOTI74 "Historical"))(POS (PAPER.INSTANCE SACERDOTI75))(POS (PAPER.AUTHOR SACERDOTI75 "Earl D. Sacerdoti"))(POS (PAPER.TITLE SACERDOTI75 "The Nonlinear Nature of Plans"))(POS (PAPER.PUBLICATION SACERDOTI75 "Aritificial Intelligence"))(POS (PAPER.VOLUME SACERDOTI75 "32"))(POS (PAPER.STARTPAGE SACERDOTI75 333))(POS (PAPER.ENDPAGE SACERDOTI75 377))(POS (PAPER.YEAR SACERDOTI75 1975))(POS (PAPER.DESCRIPTION SACERDOTI75 "
Sacerdoti describes NOAH (Nets Of Action Hierarchies), the first partial order
planner that relies heavily on the concept of a procedural net.  A 'procedural
net' is the data structure that maintains the
partially-ordered plan.  Much like his earlier work on
Hierarchical Planning, NOAH begins with an abstract
plan and continually refines it, alleviating conflicts through the use of
critics, until the plan consists of primitive actions.
"))(POS (PAPER.TOPIC SACERDOTI75 "Historical"))(POS (PAPER.INSTANCE SAGONAS94))(POS (PAPER.BIBTEX SAGONAS94 INPROCEEDINGS))(POS (PAPER.AUTHOR SAGONAS94 "K. Sagonas and T. Swift and D. S. Warren"))(POS (PAPER.TITLE SAGONAS94 "XSB as an Efficient Deductive Database Engine"))(POS (PAPER.PUBLICATION SAGONAS94 "Proceedings of the ACM SIGMOD International Conference on the Management of Data>"))(POS (PAPER.STARTPAGE SAGONAS94 442))(POS (PAPER.ENDPAGE SAGONAS94 453))(POS (PAPER.YEAR SAGONAS94 1994))(POS (PAPER.DESCRIPTION SAGONAS94 "
XSB is Warren's current Prolog implementation, which includes tabling.
"))(POS (PAPER.TOPIC SAGONAS94 "Logic Programming"))(POS (PAPER.INSTANCE SAIS94))(POS (PAPER.BIBTEX SAIS94 INPROCEEDINGS))(POS (PAPER.AUTHOR SAIS94 "Lakhdar Sais"))(POS (PAPER.TITLE SAIS94 "Characterization of the Set of Models by Means of Symmetries"))(POS (PAPER.PUBLICATION SAIS94 "Second International Workshop on Principles and Practice of Constraint Programming"))(POS (PAPER.LINK SAIS94 "http://citeseer.ist.psu.edu/162645.html"))(POS (PAPER.YEAR SAIS94 1994))(POS (PAPER.RANK SAIS94 "[**]"))(POS (PAPER.DESCRIPTION SAIS94 "
Sais gives an algorithm that seems to compute the characteristic models
of a given propositional, CNF theory.  There is no proof that the models
generated are exactly a set of characteristic models, but rather that
the models generated are non-symmetric.  [Maybe the equivalence is obvious,
but there is no theorem stating it.]
"))(POS (PAPER.TOPIC SAIS94 "Characteristic Models"))(POS (PAPER.INSTANCE SANDFORD80))(POS (PAPER.BIBTEX SANDFORD80 ARTICLE))(POS (PAPER.AUTHOR SANDFORD80 "David Sandford"))(POS (PAPER.TITLE SANDFORD80 "Using Sophisticated Models in Resolution Theorem Proving"))(POS (PAPER.PUBLISHER SANDFORD80 "Springer-Verlag"))(POS (PAPER.PUBLICATION SANDFORD80 "Lecture Notes in Computer Science"))(POS (PAPER.VOLUME SANDFORD80 "90"))(POS (PAPER.LINK SANDFORD80 ""))(POS (PAPER.YEAR SANDFORD80 1980))(POS (PAPER.RANK SANDFORD80 "[**]"))(POS (PAPER.DESCRIPTION SANDFORD80 "
Sandford describes a new refinement of semantic resolution, hereditary 
lock resolution, and a new approach for representing models as required 
in semantic resolution.  The pertinent part of the work is the model 
representation.  Semantic resolution puts clauses into two bins throughout 
the resolution process.  Part of the input to the procedure is a model, 
any model, and those clauses that are satisfied by the model are put into 
bin 1 while clauses not satisfied by the model are put into bin 2.  
This partitioning of clauses shrinks the search space since every resolution 
must use at least one clause from the set of unsatisfied clauses.  
Sandford describes a method for using a set of sentences to define that 
model (in possibly a totally different language) and using a satisfaction 
test to determine whether a clause belongs in bin 1 or 2.   Of course, 
the computational and complexity properties could be horrible, but so 
long as the satisfaction test is sound (only returns true when the sentences 
and clause are satisfiable), we retain completeness. 
"))(POS (PAPER.TOPIC SANDFORD80 "Model-Guided Proof Techniques"))(POS (PAPER.INSTANCE SCHULZ2001))(POS (PAPER.BIBTEX SCHULZ2001 INPROCEEDINGS))(POS (PAPER.AUTHOR SCHULZ2001 "S. Schulz"))(POS (PAPER.TITLE SCHULZ2001 "A Comparison of Different Techniques for Grounding Near-Propositional CNF Formulae"))(POS (PAPER.PUBLICATION SCHULZ2001 "Proc. 15th International FLAIRS Conference"))(POS (PAPER.STARTPAGE SCHULZ2001 72))(POS (PAPER.ENDPAGE SCHULZ2001 76))(POS (PAPER.LINK SCHULZ2001 "http://citeseer.ist.psu.edu/565512.html"))(POS (PAPER.YEAR SCHULZ2001 2002))(POS (PAPER.DESCRIPTION SCHULZ2001 "
Paper comparing various approaches for grounding a set of first-order, function-free clauses.  Won best-paper at FLAIR 2002.
"))(POS (PAPER.TOPIC SCHULZ2001 "Reformulation"))(POS (PAPER.INSTANCE SCHULZ2002))(POS (PAPER.BIBTEX SCHULZ2002 INPROCEEDINGS))(POS (PAPER.BIBTEX SCHULZ2002 ARTICLE))(POS (PAPER.AUTHOR SCHULZ2002 "Stephan Schulz"))(POS (PAPER.AUTHOR SCHULZ2002 "Stephan Schulz"))(POS (PAPER.TITLE SCHULZ2002 "A Comparison of Different Techniques for Grounding Near-Propositional CNF Formulae"))(POS (PAPER.TITLE SCHULZ2002 "E - A brainiac theorem prover"))(POS (PAPER.PUBLICATION SCHULZ2002 "Proceedings, 15th International FLAIRS Conference"))(POS (PAPER.PUBLICATION SCHULZ2002 "AI Communications"))(POS (PAPER.VOLUME SCHULZ2002 "15"))(POS (PAPER.STARTPAGE SCHULZ2002 72))(POS (PAPER.STARTPAGE SCHULZ2002 111))(POS (PAPER.ENDPAGE SCHULZ2002 76))(POS (PAPER.ENDPAGE SCHULZ2002 126))(POS (PAPER.LINK SCHULZ2002 "http://citeseer.ist.psu.edu/565512.html"))(POS (PAPER.LINK SCHULZ2002 "http://citeseer.ist.psu.edu/560030.html"))(POS (PAPER.YEAR SCHULZ2002 2002))(POS (PAPER.YEAR SCHULZ2002 2002))(POS (PAPER.RANK SCHULZ2002 ""))(POS (PAPER.DESCRIPTION SCHULZ2002 "
Schulz compares three techniques for reducing the cost of generating 
the grounding of universal clause sets without function symbols.  The
first is hypersplitting, a generalization of which is (now) used in
the model builders that ground and use SAT solvers, structural constraints,
restricting instantiations to avoid the creation of pure literals, and 
post-processing the grounded sentences via unit subsumption, unit
propagation, and tautology deletion.  The combination of all three
outperformed any one of the techniques.
"))(POS (PAPER.DESCRIPTION SCHULZ2002 "
Schulz describes E, a full first-order theorem prover with
equality.  It is a saturation-based prover from a purely 
equational view. It is based on the superposition calculus
with literal selection and was one of the first to use
the DISCOUNT algorithm.  The paper first describes the 
calculus, gives the proof search algorithm, discusses
search control by way of clause and literal selection,
term orderings, and auto configuration.  It delves into
implementation details: shared terms and indexing.
"))(POS (PAPER.TOPIC SCHULZ2002 "Herbrand Logic"))(POS (PAPER.TOPIC SCHULZ2002 "System Designs"))(POS (PAPER.INSTANCE SCHUTZ96))(POS (PAPER.BIBTEX SCHUTZ96 ARTICLE))(POS (PAPER.AUTHOR SCHUTZ96 "Heribert Schutz"))(POS (PAPER.TITLE SCHUTZ96 "Comparison of Two Complementary Herbrand Model Generators"))(POS (PAPER.LINK SCHUTZ96 "http://citeseer.ist.psu.edu/122874.html"))(POS (PAPER.YEAR SCHUTZ96 1996))(POS (PAPER.RANK SCHUTZ96 "[**]"))(POS (PAPER.DESCRIPTION SCHUTZ96 "
Schutz describes and analyzes two different Herbrand model-building 
techniques built on hyperresolution.  He shows that some of the 
strengths of one can be used to help on cases where the other is weak
and vice versa.  
"))(POS (PAPER.TOPIC SCHUTZ96 "Model Building"))(POS (PAPER.INSTANCE SELMAN91))(POS (PAPER.BIBTEX SELMAN91 INPROCEEDINGS))(POS (PAPER.AUTHOR SELMAN91 "Bart Selman and Henry Kautz"))(POS (PAPER.TITLE SELMAN91 "Knowledge Compilation Using Horn Approximations"))(POS (PAPER.PUBLICATION SELMAN91 "AAAI"))(POS (PAPER.LINK SELMAN91 "http://citeseer.ist.psu.edu/selman91knowledge.html"))(POS (PAPER.YEAR SELMAN91 1991))(POS (PAPER.RANK SELMAN91 "[****]"))(POS (PAPER.DESCRIPTION SELMAN91 "
This seems to be the seminal work on Knowledge Compilation.  Selman and
Kautz investigate finding two Horn approximations for a propositional 
knowledge base: one that is too strong and one that is too weak.  The 
algorithms for computing those approximations are anytime algorithms. 
To determine whether a given sentence p is entailed by the original
knowledge base, return yes if the strong approximation entails it and
no if the weak one doesn't.  If neither of these two cases hold, resort
to the original knowledge base.  Since entailment for propositional Horn
requires linear time, the worst case wastes O(2n) computation time, but
the best case might save exponential time.
"))(POS (PAPER.TOPIC SELMAN91 "Knowledge Base Compilation"))(POS (PAPER.INSTANCE SELMAN96))(POS (PAPER.BIBTEX SELMAN96 ARTICLE))(POS (PAPER.AUTHOR SELMAN96 "Bart Selman and Henry Kautz"))(POS (PAPER.TITLE SELMAN96 "Knowledge Compilation and Theory Approximation"))(POS (PAPER.PUBLICATION SELMAN96 "Journal of the ACM "))(POS (PAPER.VOLUME SELMAN96 "43(2)"))(POS (PAPER.STARTPAGE SELMAN96 193))(POS (PAPER.ENDPAGE SELMAN96 224))(POS (PAPER.LINK SELMAN96 "http://citeseer.ist.psu.edu/41052.html"))(POS (PAPER.YEAR SELMAN96 1996))(POS (PAPER.RANK SELMAN96 "[*****]"))(POS (PAPER.DESCRIPTION SELMAN96 "
This paper essentially glues together the work of kautz91, selman91,
kautz92,  and kautz95.  Especially noteworthy is the thorough related
work section.  It also brought together the fact that the Greatest
Upper Bound approximation of a propositional theory is always linear
in the size of the theory, but the Least Upper Bound can be exponential
in the size of the theory.
"))(POS (PAPER.TOPIC SELMAN96 "Knowledge Base Compilation"))(POS (PAPER.RELATED SELMAN96 SELMAN91))(POS (PAPER.RELATED SELMAN96 KAUTZ91))(POS (PAPER.RELATED SELMAN96 KAUTZ92))(POS (PAPER.RELATED SELMAN96 KAUTZ95))(POS (PAPER.INSTANCE SHERL93))(POS (PAPER.AUTHOR SHERL93 "R. Sherl and H. Levesque"))(POS (PAPER.TITLE SHERL93 "The frame problem and knowledge-producing actions"))(POS (PAPER.LINK SHERL93 "http://citeseer.ist.psu.edu/scherl93frame.html"))(POS (PAPER.YEAR SHERL93 1993))(POS (PAPER.DESCRIPTION SHERL93 "None yet.
"))(POS (PAPER.TOPIC SHERL93 "Planning with Sensing Actions"))(POS (PAPER.INSTANCE SHOSTAK84))(POS (PAPER.BIBTEX SHOSTAK84 ARTICLE))(POS (PAPER.AUTHOR SHOSTAK84 "Robert Shostak"))(POS (PAPER.TITLE SHOSTAK84 "Deciding Combinations of Theories"))(POS (PAPER.PUBLICATION SHOSTAK84 "Journal of the ACM
           "))(POS (PAPER.VOLUME SHOSTAK84 "31"))(POS (PAPER.STARTPAGE SHOSTAK84 1))(POS (PAPER.ENDPAGE SHOSTAK84 12))(POS (PAPER.LINK SHOSTAK84 "http://portal.acm.org/citation.cfm?id=322411&dl=ACM&coll=portal"))(POS (PAPER.YEAR SHOSTAK84 1984))(POS (PAPER.RANK SHOSTAK84 "[****]"))(POS (PAPER.DESCRIPTION SHOSTAK84 "
Shostak describes what is now commonly known as Shostak's decision procedure.
The decision procedure works on algebraically solvable and canonizable 
equational theories.  It functions by computing the congruence closure of 
the terms in the language representing each one by their canonical forms.  
The canonization takes into account both interpreted and unintepreted
functions.  Unlike Nelson Oppen, Shostak shows how to merge the decision
procedures for two theories by taking a solver and canonizer for each and
building a single solver and canonizer pair for the union of the theories.
"))(POS (PAPER.TOPIC SHOSTAK84 "Nelson-Oppen and Shostak"))(POS (PAPER.RELATED SHOSTAK84 NELSON79))(POS (PAPER.INSTANCE SIKKA96))(POS (PAPER.BIBTEX SIKKA96 PHDTHESIS))(POS (PAPER.AUTHOR SIKKA96 "Vishal Sikka"))(POS (PAPER.TITLE SIKKA96 "Integrating Specialized Procedures into Proof Systems"))(POS (PAPER.PUBLISHER SIKKA96 "Stanford University"))(POS (PAPER.LINK SIKKA96 "http://library.stanford.edu/depts/mathcs/mathcscoll/techreports.html"))(POS (PAPER.YEAR SIKKA96 1996))(POS (PAPER.RANK SIKKA96 "[*****]"))(POS (PAPER.DESCRIPTION SIKKA96 "
Compiled code can be used by a theorem prover to expedite a proof.  
Sikka describes a general method for integrating such specialized 
procedures into proof systems using function constants, data 
structure constants, and the 'apply' operator.  
"))(POS (PAPER.TOPIC SIKKA96 "Theorem Proving with Attachments"))(POS (PAPER.INSTANCE SIPSER))(POS (PAPER.BIBTEX SIPSER BOOK))(POS (PAPER.AUTHOR SIPSER "Michael Sipser"))(POS (PAPER.TITLE SIPSER "Introduction to the Theory of Computation"))(POS (PAPER.PUBLISHER SIPSER "Brooks Cole"))(POS (PAPER.LINK SIPSER "http://www.amazon.com/exec/obidos/tg/detail/-/053494728X/qid=1062605920/sr=1-1/ref=sr_1_1/102-6107129-2481765?v=glance&s=books"))(POS (PAPER.YEAR SIPSER 1996))(POS (PAPER.RANK SIPSER "[*****]"))(POS (PAPER.DESCRIPTION SIPSER "
One of the two definitive introductions to the theory of computation.  Sipser
covers automata and languages, computability theory, and complexity theory.
"))(POS (PAPER.TOPIC SIPSER ""))(POS (PAPER.INSTANCE SLANEY93))(POS (PAPER.BIBTEX SLANEY93 INPROCEEDINGS))(POS (PAPER.AUTHOR SLANEY93 "John Slaney"))(POS (PAPER.TITLE SLANEY93 "SCOTT: A Model-Guided Theorem Prover"))(POS (PAPER.PUBLICATION SLANEY93 "IJCAI"))(POS (PAPER.LINK SLANEY93 "http://citeseer.ist.psu.edu/slaney93scott.html"))(POS (PAPER.YEAR SLANEY93 1993))(POS (PAPER.RANK SLANEY93 "[***]"))(POS (PAPER.DESCRIPTION SLANEY93 "
Slaney describes a case study of SCOTT (Semantically Constrained
Otter).  SCOTT consists of OTTER augmented with a model-generator
FINDER.  It restricts the resolutions done by Otter to include one
parent clause not true in the model being generated.  A new model
is generated every time a new clause is generated that is false
in the current model (up to 100 clauses).  If no new model can 
be found, the old one is used.  SCOTT retains completeness
for binary resolution since every model generated is a model of the
usable list (those axioms assumed to be consistent).  
"))(POS (PAPER.TOPIC SLANEY93 "Model-Guided Proof Techniques"))(POS (PAPER.INSTANCE SLANEY94))(POS (PAPER.BIBTEX SLANEY94 INPROCEEDINGS))(POS (PAPER.BIBTEX SLANEY94 INPROCEEDINGS))(POS (PAPER.AUTHOR SLANEY94 "John Slaney"))(POS (PAPER.AUTHOR SLANEY94 "John Slaney"))(POS (PAPER.TITLE SLANEY94 "Finder: Finite Domain Enumerator System Description"))(POS (PAPER.TITLE SLANEY94 "The Crisis in Finite Mathematics: Automated Reasoning as Cause and Cure"))(POS (PAPER.PUBLICATION SLANEY94 "In proceedings, CADE-12"))(POS (PAPER.PUBLICATION SLANEY94 "CADE"))(POS (PAPER.LINK SLANEY94 "http://citeseer.ist.psu.edu/252758.html"))(POS (PAPER.LINK SLANEY94 "http://arp.anu.edu.au/~jks/constraints.html"))(POS (PAPER.YEAR SLANEY94 1994))(POS (PAPER.YEAR SLANEY94 1994))(POS (PAPER.RANK SLANEY94 ""))(POS (PAPER.DESCRIPTION SLANEY94 "
Very short description of Finder, a model builder for FOL.  It grounds and
then uses a combination of tableaux and negative hyperresolution.  Used
in SCOTT to constrain the search space of Otter.
"))(POS (PAPER.DESCRIPTION SLANEY94 "
Slaney describes the problems associated with using machines to exhaustively
check a solution space as proof of the non-existence of a solution.  Is that
really a proof?  Afterall, no one will actually verify such a proof.
But, if a theorem prover outputs a trace, we can check the trace with an
independent proof checker.  This trace-checking may be much easier than
proving the correctness of a theorem prover.
"))(POS (PAPER.TOPIC SLANEY94 "Model Building"))(POS (PAPER.TOPIC SLANEY94 "Theorem Proving"))(POS (PAPER.INSTANCE SOUTCHANSKI2000))(POS (PAPER.AUTHOR SOUTCHANSKI2000 "Mikhail Soutchanski"))(POS (PAPER.TITLE SOUTCHANSKI2000 "An On-line Decision-Theoretic Golog Interpreter"))(POS (PAPER.PUBLICATION SOUTCHANSKI2000 "AAAI"))(POS (PAPER.LINK SOUTCHANSKI2000 "http://www.cs.toronto.edu/~cebly/papers.html"))(POS (PAPER.YEAR SOUTCHANSKI2000 2000))(POS (PAPER.DESCRIPTION SOUTCHANSKI2000 "
Building on previous work, Southchanski couples Golog with a decision-theoretic planner based on Markov decision processes.  The original work found a optimal conditional policy, the probability that the policy could be executed, and the expected utility of the policy all offline.  This is really only possible in an environment without sensing actions with continuous return values.  Soutchanski also points out that only a single policy can be computed for an entire program, even if the program could be easily partitioned into two independent portions.  Soutchanski introduces optimize(p1);p2 to indicate that a single policy should be found for program p1 and another for program p2.  He also gives a new formulation of sensing actions of the form sense(act, value, s), meaning the result of executing the action act is value in situation s.  Since Golog is an online interpreter, sensing actions with continuous return values can be handled.
"))(POS (PAPER.TOPIC SOUTCHANSKI2000 "Logic Programming"))(POS (PAPER.INSTANCE SQALLI2001))(POS (PAPER.AUTHOR SQALLI2001 "Mohammed Sqalli and Eugene Freuder"))(POS (PAPER.TITLE SQALLI2001 "Solving InterOperability Problems Using Object-Oriented CSP 
 Modeling"))(POS (PAPER.LINK SQALLI2001 "http://citeseer.ist.psu.edu/487285.html"))(POS (PAPER.YEAR SQALLI2001 2001))(POS (PAPER.RANK SQALLI2001 "[**]"))(POS (PAPER.DESCRIPTION SQALLI2001 "
Sqalli and Freuder describe a combination of Case-based reasoning
and constraint satisfaction.  They use Paltrinieri's OOCSP definition
except that they add methods to classes.  To solve an OOCSP, they
convert it to a standard CSP.  
"))(POS (PAPER.TOPIC SQALLI2001 "Object Oriented Constraint Satisfaction"))(POS (PAPER.INSTANCE STICKEL85))(POS (PAPER.BIBTEX STICKEL85 ARTICLE))(POS (PAPER.AUTHOR STICKEL85 "Mark Stickel"))(POS (PAPER.TITLE STICKEL85 "Automated Deduction by Theory Resolution"))(POS (PAPER.PUBLICATION STICKEL85 "Journal of Automated Reasoning"))(POS (PAPER.VOLUME STICKEL85 "1"))(POS (PAPER.STARTPAGE STICKEL85 333))(POS (PAPER.ENDPAGE STICKEL85 356))(POS (PAPER.LINK STICKEL85 "http://citeseer.ist.psu.edu/stickel85automated.html"))(POS (PAPER.YEAR STICKEL85 1985))(POS (PAPER.RANK STICKEL85 "[***]"))(POS (PAPER.DESCRIPTION STICKEL85 "
The theory resolution paper.
"))(POS (PAPER.TOPIC STICKEL85 "Theorem Proving with Attachments"))(POS (PAPER.INSTANCE STICKEL87))(POS (PAPER.AUTHOR STICKEL87 "Mark Stickel"))(POS (PAPER.TITLE STICKEL87 "A Prolog Technology Theorem Prover"))(POS (PAPER.LINK STICKEL87 "http://citeseer.ist.psu.edu/stickel87prolog.html"))(POS (PAPER.YEAR STICKEL87 1987))(POS (PAPER.DESCRIPTION STICKEL87 "
"))(POS (PAPER.TOPIC STICKEL87 "Calculi"))(POS (PAPER.INSTANCE STICKEL94))(POS (PAPER.BIBTEX STICKEL94 ARTICLE))(POS (PAPER.AUTHOR STICKEL94 "Mark Stickel and Richard Waldinger and Michael Lowry and Thomas Pressburger and Ian Underwood"))(POS (PAPER.TITLE STICKEL94 "Deductive Composition of Astronomical Software from Subroutine Libraries"))(POS (PAPER.PUBLICATION STICKEL94 "Conference on Automated Deduction"))(POS (PAPER.STARTPAGE STICKEL94 341))(POS (PAPER.ENDPAGE STICKEL94 355))(POS (PAPER.LINK STICKEL94 "http://citeseer.ist.psu.edu/67907.html"))(POS (PAPER.YEAR STICKEL94 1994))(POS (PAPER.RANK STICKEL94 "[*]"))(POS (PAPER.DESCRIPTION STICKEL94 "
The authors describe a system that allows a user to graphically describe
a specification for a system relying on subroutine libraries and then uses
automated deduction techniques to produce a proof of the specification from
axioms describing the library.  That proof is then translated into a 
Fortran program.
"))(POS (PAPER.TOPIC STICKEL94 "Miscellaneous"))(POS (PAPER.INSTANCE STONE))(POS (PAPER.BIBTEX STONE ARTICLE))(POS (PAPER.AUTHOR STONE "Nicholas Stone"))(POS (PAPER.TITLE STONE "Object-Oriented Constraint Satisfaction Planning for Whole Farm
Management"))(POS (PAPER.PUBLICATION STONE "AI Applications"))(POS (PAPER.LINK STONE "http://everest.ento.vt.edu/Publications/NDS-Paper-.html"))(POS (PAPER.YEAR STONE NIL))(POS (PAPER.RANK STONE "[*]"))(POS (PAPER.DESCRIPTION STONE "
Stone describes an Object-oriented approach to writing a planner.
"))(POS (PAPER.TOPIC STONE "Miscellaneous"))(POS (PAPER.INSTANCE STRZALKOWSKI91))(POS (PAPER.BIBTEX STRZALKOWSKI91 ARTICLE))(POS (PAPER.AUTHOR STRZALKOWSKI91 "Tomek Strzalkowski"))(POS (PAPER.TITLE STRZALKOWSKI91 "A General Computational Method for Grammar Inversion"))(POS (PAPER.LINK STRZALKOWSKI91 "http://acl.ldc.upenn.edu/W/W91/W91-0112.pdf"))(POS (PAPER.YEAR STRZALKOWSKI91 1991))(POS (PAPER.RANK STRZALKOWSKI91 "[***]"))(POS (PAPER.DESCRIPTION STRZALKOWSKI91 "
Strzalkowski describes a procedure for converting a unification grammar defined in Prolog, which was built for sentence parsing, into another set of Prolog rules for sentence generation.
"))(POS (PAPER.TOPIC STRZALKOWSKI91 "Natural Language Processing"))(POS (PAPER.INSTANCE SUCHENEK93))(POS (PAPER.BIBTEX SUCHENEK93 ARTICLE))(POS (PAPER.AUTHOR SUCHENEK93 "Marek Suchenek"))(POS (PAPER.TITLE SUCHENEK93 "First-Order Syntactic Characterizations of Minimal Entailment, Domain-Minimal Entailment, and Herbrand Entailment"))(POS (PAPER.LINK SUCHENEK93 "www.springerlink.com/index/L14483241892Q613.pdf"))(POS (PAPER.YEAR SUCHENEK93 1993))(POS (PAPER.RANK SUCHENEK93 "[***]"))(POS (PAPER.DESCRIPTION SUCHENEK93 "
Suchenek treats formally three types of minimal-model theory: minimal
entailment (cwa), Herbrand entailment (only the Herbrand models exist),
and domain-minimal entailment (only elements in the domain are those
that must be in the domain).  Touches on domain closure, unique-names,
deductive databases, closed world, non-mon.
"))(POS (PAPER.TOPIC SUCHENEK93 "Herbrand Logic"))(POS (PAPER.INSTANCE SUSSMAN74))(POS (PAPER.AUTHOR SUSSMAN74 "Gerald J. Sussman"))(POS (PAPER.TITLE SUSSMAN74 "The Virtuous Nature of Bugs"))(POS (PAPER.YEAR SUSSMAN74 1974))(POS (PAPER.DESCRIPTION SUSSMAN74 "
Sussman describes HACKER, a total-order planner that composes stored subroutines to achieve its goal.  If subgoals conflict, HACKER identifies a bug in the plan it has generated and debugs it.  To do so, it matches a model of the behavior of the misbehaving plan with prototypes of bugs.  Once a match is found, a 'critic' is compiled with what HACKER has learned from the debugging.  In future plans, critics are used to avoid pitfalls already seen.
"))(POS (PAPER.TOPIC SUSSMAN74 "Historical"))(POS (PAPER.INSTANCE SUTCLIFFE98))(POS (PAPER.BIBTEX SUTCLIFFE98 ARTICLE))(POS (PAPER.AUTHOR SUTCLIFFE98 "G. Sutcliffe and C.B. Suttner"))(POS (PAPER.TITLE SUTCLIFFE98 "The TPTP Problem Library: CNF Release v1.2.1"))(POS (PAPER.PUBLICATION SUTCLIFFE98 "Journal of Automated Reasoning"))(POS (PAPER.VOLUME SUTCLIFFE98 "21(2)"))(POS (PAPER.STARTPAGE SUTCLIFFE98 177))(POS (PAPER.ENDPAGE SUTCLIFFE98 203))(POS (PAPER.LINK SUTCLIFFE98 "http://citeseer.ist.psu.edu/30379.html"))(POS (PAPER.YEAR SUTCLIFFE98 1998))(POS (PAPER.RANK SUTCLIFFE98 ""))(POS (PAPER.DESCRIPTION SUTCLIFFE98 "
Paper on the TPTP library.
"))(POS (PAPER.TOPIC SUTCLIFFE98 "Theorem Proving"))(POS (PAPER.INSTANCE SUTCLIFFE98CADE))(POS (PAPER.BIBTEX SUTCLIFFE98CADE ARTICLE))(POS (PAPER.AUTHOR SUTCLIFFE98CADE "Christian Suttner and Geoff Sutcliffe"))(POS (PAPER.TITLE SUTCLIFFE98CADE "The CADE-14 ATP System Competition"))(POS (PAPER.PUBLICATION SUTCLIFFE98CADE "Journal of Automated Reasoning"))(POS (PAPER.VOLUME SUTCLIFFE98CADE "21(1)"))(POS (PAPER.STARTPAGE SUTCLIFFE98CADE 99))(POS (PAPER.ENDPAGE SUTCLIFFE98CADE 134))(POS (PAPER.LINK SUTCLIFFE98CADE "http://citeseer.ist.psu.edu/87162.html"))(POS (PAPER.YEAR SUTCLIFFE98CADE 1998))(POS (PAPER.RANK SUTCLIFFE98CADE ""))(POS (PAPER.DESCRIPTION SUTCLIFFE98CADE "
Paper on the results of one of the CASC competitions: the yearly first-order theorem proving competition held at CADE.
"))(POS (PAPER.TOPIC SUTCLIFFE98CADE "Theorem Proving"))(POS (PAPER.INSTANCE SWAMY2000))(POS (PAPER.BIBTEX SWAMY2000 PHDTHESIS))(POS (PAPER.AUTHOR SWAMY2000 "Nikhil Swamy"))(POS (PAPER.TITLE SWAMY2000 "A Study in Automated Reasoning about Abstract Algebra"))(POS (PAPER.LINK SWAMY2000 "http://www.cs.umd.edu/~nswamy/thesis/ch2-IntroToATP.ps"))(POS (PAPER.YEAR SWAMY2000 2000))(POS (PAPER.RANK SWAMY2000 ""))(POS (PAPER.DESCRIPTION SWAMY2000 "
Swamy's second chapter (Advanced theorem proving techniques) gives a good
overview of resolution-style theorem-proving and definitions/proofs
of UR-Resolution, Hyperresolution, factoring, paramodulation,
subsumption, demodulation, set of support, and Knuth-Bendix completion.
Link goes to said chapter.
"))(POS (PAPER.TOPIC SWAMY2000 "Theorem Proving"))(POS (PAPER.INSTANCE TAMMET2001))(POS (PAPER.BIBTEX TAMMET2001 MISC))(POS (PAPER.AUTHOR TAMMET2001 "Tanel Tammet"))(POS (PAPER.TITLE TAMMET2001 "Finite model building: improvements and comparisons"))(POS (PAPER.LINK TAMMET2001 "http://citeseer.ist.psu.edu/675660.html"))(POS (PAPER.YEAR TAMMET2001 2001))(POS (PAPER.DESCRIPTION TAMMET2001 "
Comparison of Mace 2.0 and Falcon-style finite model builders, along
with some enhancements to Falcon to produce Gandolf.  Mace 2.0 used flattening,
grounding, and boolean sat solvers.  Falcon used consequence finding during
incremental model generation, much like arc consistency in CSPs.
"))(POS (PAPER.TOPIC TAMMET2001 "Model Building"))(POS (PAPER.INSTANCE TAMMET2002))(POS (PAPER.BIBTEX TAMMET2002 ARTICLE))(POS (PAPER.AUTHOR TAMMET2002 "Tanel Tammete"))(POS (PAPER.TITLE TAMMET2002 "Finite model building: improvements and comparisons"))(POS (PAPER.LINK TAMMET2002 "http://citeseer.ist.psu.edu/675660.html"))(POS (PAPER.YEAR TAMMET2002 2002))(POS (PAPER.RANK TAMMET2002 ""))(POS (PAPER.DESCRIPTION TAMMET2002 "
Tammet gives an overview of two different styles of finite model builders
after situating the topic in the context of automated reasoning: Mace and
Falcon.  Mace operates by reducing the problem to one of propositional 
satisfiability and employing a SAT solver.  Tammet describes an augmentation
of Mace (nonground splitting) to reduce the number of distinct variables
in a clause (suboptimally).  Falcon works almost as a naive model builder
but makes certain inferences to prune the search.  Both the Mace-style
and Falcon-style builder were implemented  in Gandalf, a theorem-prover/
model checker written in Scheme and compiled into C.  Various versions
of the two builders were run over the 2002 satisfiable CASC problems,
and some conclusions were drawn.
"))(POS (PAPER.TOPIC TAMMET2002 "Model Building"))(POS (PAPER.INSTANCE THIFFAULT2004))(POS (PAPER.BIBTEX THIFFAULT2004 INPROCEEDINGS))(POS (PAPER.AUTHOR THIFFAULT2004 "Christian Thiffault and Fahiem Bacchus and Toby Walsh"))(POS (PAPER.TITLE THIFFAULT2004 "Solving Non-clausal Formulas with DPLL Search"))(POS (PAPER.PUBLICATION THIFFAULT2004 "Proceedings of the 10th International Conference on Principles and Practice of Constraint Programming"))(POS (PAPER.STARTPAGE THIFFAULT2004 663))(POS (PAPER.ENDPAGE THIFFAULT2004 678))(POS (PAPER.LINK THIFFAULT2004 "http://www.satisfiability.org/SAT04/accepted/71.html"))(POS (PAPER.YEAR THIFFAULT2004 2004))(POS (PAPER.DESCRIPTION THIFFAULT2004 "
A paper that adopts DPLL to handle Non-CNF directly.
"))(POS (PAPER.TOPIC THIFFAULT2004 "SAT Solving"))(POS (PAPER.INSTANCE TIN94))(POS (PAPER.BIBTEX TIN94 ARTICLE))(POS (PAPER.AUTHOR TIN94 "Erkan Tin and Varol Akman"))(POS (PAPER.TITLE TIN94 "Computatinal Situation Theory"))(POS (PAPER.PUBLICATION TIN94 "SIGART Bulletin"))(POS (PAPER.VOLUME TIN94 "5(4)"))(POS (PAPER.STARTPAGE TIN94 4))(POS (PAPER.ENDPAGE TIN94 17))(POS (PAPER.LINK TIN94 "http://portal.acm.org/citation.cfm?id=191604.191608"))(POS (PAPER.YEAR TIN94 1994))(POS (PAPER.RANK TIN94 "[*]"))(POS (PAPER.DESCRIPTION TIN94 "
Tin and Akman give an overview of Situation Theory, which allows
one to describe states of the world relative to spatio and temporal
positions.  This theory is used to give semantics to natural language
utterances.  The authors then overview several systems that deal
with situation theory.
"))(POS (PAPER.TOPIC TIN94 "Miscellaneous"))(POS (PAPER.INSTANCE TINELLI2000))(POS (PAPER.BIBTEX TINELLI2000 INPROCEEDINGS))(POS (PAPER.AUTHOR TINELLI2000 "Cesare Tinelli"))(POS (PAPER.TITLE TINELLI2000 "Cooperation of Background Reasoners in Theory Reasoning by
Residue Sharing"))(POS (PAPER.PUBLICATION TINELLI2000 "International Workshop on First Order Theorem Proving (FTP)
           "))(POS (PAPER.LINK TINELLI2000 "http://citeseer.ist.psu.edu/572497.html"))(POS (PAPER.YEAR TINELLI2000 2000))(POS (PAPER.RANK TINELLI2000 "[****]"))(POS (PAPER.DESCRIPTION TINELLI2000 "
Tinelli shows how to use theory reasoning to combine specialized reasoners in
a sound and complete way in the context of semantic tableaus.  The theories
those reasoners embody must be universal, a requirement for theory reasoning.
Tinelli's results hinge on an interpolation lemma that
requires all the background theory signatures to include all the
same functions.   This lemma shows that determining unsatisfiability of
wrt a set of theories requires only passing disjunctions of literals in
the common signature among the theories.  One can thus alter the tableau
procedure by allowing a new type of derivation: hand off a subset of the
literals on a particular branch which are of the appropriate signature
to the corresponding background reasoner.  If the reasoner returns
'unsatisfiable', close the branch; otherwise, add the residue to the
end of the branch.
"))(POS (PAPER.TOPIC TINELLI2000 "Theorem Proving with Attachments"))(POS (PAPER.INSTANCE TORLAK2006))(POS (PAPER.BIBTEX TORLAK2006 TECHREPORT))(POS (PAPER.AUTHOR TORLAK2006 "Emina Torlak and Daniel Jackson"))(POS (PAPER.TITLE TORLAK2006 "The Design of a Relational Engine"))(POS (PAPER.PUBLISHER TORLAK2006 "MIT-CSAIL"))(POS (PAPER.LINK TORLAK2006 "http://web.mit.edu/emina/www/kodkod.html"))(POS (PAPER.YEAR TORLAK2006 2006))(POS (PAPER.DESCRIPTION TORLAK2006 "
The authors describe a model-builder for a relational logic with transitive
closure and a finite domain.  The system does symmetry detection, compresses
expressions using compact boolean circuits, and
translates to propositional logic to answer queries using a SAT solver.
"))(POS (PAPER.TOPIC TORLAK2006 "Model Building"))(POS (PAPER.INSTANCE ULLMAN))(POS (PAPER.BIBTEX ULLMAN BOOK))(POS (PAPER.AUTHOR ULLMAN "J. Hopcroft and J. Ullman"))(POS (PAPER.TITLE ULLMAN "Introduction to Automata Theory, Languages, and Computation"))(POS (PAPER.PUBLISHER ULLMAN "Addison Wesley"))(POS (PAPER.LINK ULLMAN "http://www-db.stanford.edu/~ullman/ialc.html"))(POS (PAPER.YEAR ULLMAN 1979))(POS (PAPER.RANK ULLMAN "[*****]"))(POS (PAPER.DESCRIPTION ULLMAN "
One of the two definitive introductions to the theory of computation. Hopcroft
and Ullman--the classic.
"))(POS (PAPER.TOPIC ULLMAN ""))(POS (PAPER.INSTANCE ULLMAN96))(POS (PAPER.BIBTEX ULLMAN96 ARTICLE))(POS (PAPER.AUTHOR ULLMAN96 "Jeffrey Ullman"))(POS (PAPER.TITLE ULLMAN96 "The Database Approach to Knowledge Representation"))(POS (PAPER.PUBLICATION ULLMAN96 "AAAI"))(POS (PAPER.LINK ULLMAN96 "http://citeseer.ist.psu.edu/ullman96database.html"))(POS (PAPER.YEAR ULLMAN96 1996))(POS (PAPER.RANK ULLMAN96 "[****]"))(POS (PAPER.DESCRIPTION ULLMAN96 "
Ullman explains to the AI community the database perspective on
knowledge representation: start at low expressiveness and efficient computation
and work your way up.  Datalog (prolog w/o negation or functions)
is given the fixed-point semantics.  When extended with negation,
the least-fixed-point semantics are troublesome; stratified negation
and well-founded semantics have been developed to handle this.
Query containment of conjunctive queries is NP complete in general,
but is linear if no predicate appears more than twice in any
query.  Whether a conjunctive query is contained in a Datalog
program is exponential, and the reverse is decidable.  Rewriting
a query in terms of views has been done when the views are 
conjunctive queries as well as when the views are described
by Datalog programs.  
"))(POS (PAPER.TOPIC ULLMAN96 "Logical Knowledge Representation"))(POS (PAPER.INSTANCE ULLMANDB))(POS (PAPER.BIBTEX ULLMANDB BOOK))(POS (PAPER.AUTHOR ULLMANDB "Jeffrey Ullman"))(POS (PAPER.TITLE ULLMANDB "Principles of Database and Knowledge-Base Systems"))(POS (PAPER.PUBLISHER ULLMANDB "Computer Science Press"))(POS (PAPER.LINK ULLMANDB "http://www.amazon.com/exec/obidos/tg/detail/-/0716781581/qid=1110684085/sr=8-3/ref=sr_8_xs_ap_i3_xgl14/104-0791189-4759116?v=glance&s=books&n=507846"))(POS (PAPER.YEAR ULLMANDB 1989))(POS (PAPER.RANK ULLMANDB "[*****]"))(POS (PAPER.DESCRIPTION ULLMANDB "
This two-volume set describes how database principles can be applied to 
produce knowledge-based systems.
"))(POS (PAPER.TOPIC ULLMANDB ""))(POS (PAPER.INSTANCE URIBE2000))(POS (PAPER.BIBTEX URIBE2000 INPROCEEDINGS))(POS (PAPER.AUTHOR URIBE2000 "Tomas Uribe"))(POS (PAPER.TITLE URIBE2000 "Combinations of Model Checking and Theorem Proving"))(POS (PAPER.PUBLICATION URIBE2000 "Frontiers of Combining Systems (FroCoS)"))(POS (PAPER.STARTPAGE URIBE2000 151))(POS (PAPER.ENDPAGE URIBE2000 170))(POS (PAPER.LINK URIBE2000 "http://citeseer.ist.psu.edu/uribe00combinations.html"))(POS (PAPER.YEAR URIBE2000 2000))(POS (PAPER.RANK URIBE2000 "[****]"))(POS (PAPER.DESCRIPTION URIBE2000 "
Uribe surveys combinations of model checkers and theorem provers in the
context of formal verification.  The paper is pretty much self-contained,
explaining transition systems, fair transition systems,
finite-state model checking, deductive verification, abstraction, and
invariant generation.   Then Uribe discusses loosely coupled systems,
which treat the model checker/theorem prover as a black box. Modularity
and abstraction, general deductive environments (debugging, incremental
verification, and formal decomposition), and abstraction generation using
theorem proving have all been investigated in this loosely-coupled way.  
Lastly he considers tightly coupled systems.  Diagram-based
formalisms provide abstractions.  Model checking infinite-state systems
can also be attacked with abstraction.  A handful of tightly integrated
systems are also mentioned.  This survey feels like it is made up of a
hodge-podge of attempts--whether that is characteristic of the field
or the paper is unclear.
"))(POS (PAPER.TOPIC URIBE2000 "Model Checking"))(POS (PAPER.INSTANCE VANGELDER91))(POS (PAPER.BIBTEX VANGELDER91 ARTICLE))(POS (PAPER.AUTHOR VANGELDER91 "Allen van Gelder and Kenneth Ross and John Schlipf"))(POS (PAPER.TITLE VANGELDER91 "The Well-Founded Semantics for General Logic Programs"))(POS (PAPER.PUBLICATION VANGELDER91 "Journal of the ACM"))(POS (PAPER.VOLUME VANGELDER91 "38(3)"))(POS (PAPER.STARTPAGE VANGELDER91 620))(POS (PAPER.ENDPAGE VANGELDER91 650))(POS (PAPER.LINK VANGELDER91 "http://citeseer.ist.psu.edu/gelder91wellfounded.html"))(POS (PAPER.YEAR VANGELDER91 1991))(POS (PAPER.DESCRIPTION VANGELDER91 "
Well-founded semantics for logic programming.
"))(POS (PAPER.TOPIC VANGELDER91 "Logic Programming"))(POS (PAPER.INSTANCE VANHOOF2004))(POS (PAPER.BIBTEX VANHOOF2004 ARTICLE))(POS (PAPER.AUTHOR VANHOOF2004 "Wim Vanhoof"))(POS (PAPER.TITLE VANHOOF2004 "Searching Semantically Equivalent Code Fragments in Logic Programs"))(POS (PAPER.PUBLICATION VANHOOF2004 "14th International Symposium, Logic Based Program Synthesis and Trnasformation (LOPSTR)"))(POS (PAPER.STARTPAGE VANHOOF2004 1))(POS (PAPER.ENDPAGE VANHOOF2004 18))(POS (PAPER.LINK VANHOOF2004 "http://wotan.liu.edu/docis/dbl/lopstr/index.html"))(POS (PAPER.YEAR VANHOOF2004 2004))(POS (PAPER.DESCRIPTION VANHOOF2004 "
In the context of logic programming over Horn rules, 
Vanhoof considers three problems: (1) determining when some portion
of a rule body is equivalent to a portion of another rule body, (2) 
determining when two relations are identical up to argument permutation,
and (3) whether two portions of rule bodies share enough functionality
to be generalized as a higher-order rule, e.g. mapcar.  The nice
part about this topic of semantic equivalence in LP is that two
relations/conjunctions are equivalent iff they have the same extensions.
Vanhoof gives approximation algorithms, i.e. algorithms that are 
sufficient, for determining various kinds of semantic equivalences.
"))(POS (PAPER.TOPIC VANHOOF2004 "Reformulation"))(POS (PAPER.INSTANCE VARDI82))(POS (PAPER.BIBTEX VARDI82 INPROCEEDINGS))(POS (PAPER.AUTHOR VARDI82 "Moshe Vardi"))(POS (PAPER.TITLE VARDI82 "The complexity of relational query languages"))(POS (PAPER.PUBLICATION VARDI82 "Proceedings of the fourteenth annual ACM symposium on Theory of computing"))(POS (PAPER.STARTPAGE VARDI82 137))(POS (PAPER.ENDPAGE VARDI82 146))(POS (PAPER.LINK VARDI82 "http://portal.acm.org/citation.cfm?id=802186&dl=ACM&coll=GUIDE"))(POS (PAPER.YEAR VARDI82 1982))(POS (PAPER.DESCRIPTION VARDI82 "
Data and expression complexity results for various database query languages.
"))(POS (PAPER.TOPIC VARDI82 "Databases"))(POS (PAPER.INSTANCE VOROBYOV98))(POS (PAPER.BIBTEX VOROBYOV98 INPROCEEDINGS))(POS (PAPER.AUTHOR VOROBYOV98 "Sergei Vorobyov and Andrei Voronkov"))(POS (PAPER.TITLE VOROBYOV98 "Complexity of Nonrecursive Logic Programs with Complex Values"))(POS (PAPER.PUBLICATION VOROBYOV98 "Proceedings of the Seventeenth ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems"))(POS (PAPER.STARTPAGE VOROBYOV98 244))(POS (PAPER.ENDPAGE VOROBYOV98 253))(POS (PAPER.LINK VOROBYOV98 "http://citeseer.ist.psu.edu/258671.html"))(POS (PAPER.YEAR VOROBYOV98 1998))(POS (PAPER.DESCRIPTION VOROBYOV98 "
Breaks down the complexity of nonrecursive logic programs based on the 
signature/vocabulary of the program.
"))(POS (PAPER.TOPIC VOROBYOV98 "Logic Programming"))(POS (PAPER.INSTANCE WAAL93))(POS (PAPER.BIBTEX WAAL93 ARTICLE))(POS (PAPER.AUTHOR WAAL93 "D.A. de Waal and J. Gallagher"))(POS (PAPER.TITLE WAAL93 "The Applicability of Logic Program Analysis and Transformation to Theorem Proving"))(POS (PAPER.PUBLICATION WAAL93 "CADE"))(POS (PAPER.LINK WAAL93 "http://citeseer.ist.psu.edu/dewaal93applicability.html"))(POS (PAPER.YEAR WAAL93 1993))(POS (PAPER.RANK WAAL93 "[****]"))(POS (PAPER.DESCRIPTION WAAL93 "
de Waal and Gallagher show how to employ the results of (1) approximation
of logic programs and (2) partial evaluation to produce strategies
for pruning the search space of theorem proving procedures.  They model
a theorem proving algorithm as a logic program, add in the theory and query
in question, and run approximation techniques after partially evaluating
the constructed logic program.  Regular unary clauses (r(f(x1,...,xn) <= 
t1(x1) ^ ... ^ tn(xn))are used to
do the approximations, but the technique can be applied to different
approximations as well.  The authors demonstrate this technique on
a model-elimination procedure and a Naive nH-Prolog proof system.
"))(POS (PAPER.TOPIC WAAL93 "Metalevel Reasoning"))(POS (PAPER.INSTANCE WALDINGER75))(POS (PAPER.AUTHOR WALDINGER75 "R. Waldinger"))(POS (PAPER.TITLE WALDINGER75 "Achieving several goals simultaneously"))(POS (PAPER.PUBLICATION WALDINGER75 "Machine Intelligence 8"))(POS (PAPER.STARTPAGE WALDINGER75 94))(POS (PAPER.ENDPAGE WALDINGER75 138))(POS (PAPER.YEAR WALDINGER75 1975))(POS (PAPER.DESCRIPTION WALDINGER75 "
Waldinger examines planning where sugoals interfere with one another.  He introduces regression  planning, where totally ordered plan steps are reordered.  A solution is constructed incrementally for each subgoal, but when a later subgoal interferes, the position of that subgoal is moved earlier in the plan.  He also touches on the ramification problem (but doesn't call it that) in an effort to show the STRIPS assumption as an unsatisfactory solution to the frame problem.
"))(POS (PAPER.TOPIC WALDINGER75 "Historical"))(POS (PAPER.INSTANCE WALSH2000))(POS (PAPER.BIBTEX WALSH2000 ARTICLE))(POS (PAPER.AUTHOR WALSH2000 "Toby Walsh"))(POS (PAPER.TITLE WALSH2000 "Reformulating Propositional Satisfiability as Constraint Satisfaction"))(POS (PAPER.PUBLICATION WALSH2000 "Symposium on Abstraction, Reformulation, and Approximation (SARA)"))(POS (PAPER.STARTPAGE WALSH2000 233))(POS (PAPER.ENDPAGE WALSH2000 246))(POS (PAPER.LINK WALSH2000 "http://citeseer.ifi.unizh.ch/walsh00reformulating.html"))(POS (PAPER.YEAR WALSH2000 2000))(POS (PAPER.DESCRIPTION WALSH2000 "
Walsh gives an overview of various approaches to encoding propositional
satisfiability as CSPs.  Then he goes on to discuss how various
algorithms operate on those CSPs.
"))(POS (PAPER.TOPIC WALSH2000 "Reformulation"))(POS (PAPER.INSTANCE WAM))(POS (PAPER.BIBTEX WAM BOOK))(POS (PAPER.AUTHOR WAM "Hassan Ait-Kaci"))(POS (PAPER.TITLE WAM "Warren's Abstract Machine: A Tutorial Reconstruction"))(POS (PAPER.PUBLISHER WAM "MIT Press"))(POS (PAPER.LINK WAM "http://mitpress.mit.edu/catalog/item/default.asp?ttype=2&tid=7292"))(POS (PAPER.YEAR WAM 1991))(POS (PAPER.RANK WAM "[*****]"))(POS (PAPER.DESCRIPTION WAM "
Description of the original Prolog compiler.
"))(POS (PAPER.TOPIC WAM ""))(POS (PAPER.INSTANCE WANG85))(POS (PAPER.BIBTEX WANG85 INPROCEEDINGS))(POS (PAPER.AUTHOR WANG85 "Tie Cheng Wang"))(POS (PAPER.TITLE WANG85 "Designing Examples for Semantically Guided Hierarchical Deduction"))(POS (PAPER.PUBLICATION WANG85 "IJCAI"))(POS (PAPER.YEAR WANG85 1985))(POS (PAPER.RANK WANG85 "[*]"))(POS (PAPER.DESCRIPTION WANG85 "
This paper describes a hierarchical theorem prover guided by a model
and gives guidelines for humans to pick a good model.
"))(POS (PAPER.TOPIC WANG85 "Model-Guided Proof Techniques"))(POS (PAPER.INSTANCE WARREN74))(POS (PAPER.AUTHOR WARREN74 "D.H.D. Warren"))(POS (PAPER.TITLE WARREN74 "Extract from APIC Studies in Data Processing"))(POS (PAPER.YEAR WARREN74 1974))(POS (PAPER.DESCRIPTION WARREN74 "
Quick synopsis of the Prolog implementation of Warren's WARPLAN.  WARPLAN was the first planner implemented in Prolog.  It was not optimal, sometimes finding longer plans than needed.
"))(POS (PAPER.TOPIC WARREN74 "Historical"))(POS (PAPER.INSTANCE WEYHRAUCH80))(POS (PAPER.BIBTEX WEYHRAUCH80 ARTICLE))(POS (PAPER.AUTHOR WEYHRAUCH80 "Richard Weyhrauch"))(POS (PAPER.TITLE WEYHRAUCH80 "Prolegomena to a theory of mechanized formal reasoning"))(POS (PAPER.PUBLICATION WEYHRAUCH80 "Artificial Intelligence"))(POS (PAPER.VOLUME WEYHRAUCH80 "13"))(POS (PAPER.STARTPAGE WEYHRAUCH80 133))(POS (PAPER.ENDPAGE WEYHRAUCH80 170))(POS (PAPER.YEAR WEYHRAUCH80 1980))(POS (PAPER.RANK WEYHRAUCH80 "[***]"))(POS (PAPER.DESCRIPTION WEYHRAUCH80 "
Weyhrauch describes the FOL system.  FOL allows rules to be written that
produce semantic attachments, i.e. attaching Lisp addition to the function
symbol '+'.  It also allows rules that rewrite expressions.  FOL includes
an evaluator for first order logic that combines the rewrite rules with
the semantic attachments to do proofs.  FOL is a system that operates on
'LS pairs': a set of logical sentences, a set of attachments, and a set
of facts.  Because this is done uniformly, FOL allows multiple LS pairs
to be defined at the same time.  A special LS pair, Meta, is a theory
of LS pairs; reflection is achieved in FOL by allowing Meta to
operate on another LS pair.   Metametalevel reasoning
can be accomplished in the same way.  Self-reflection is another special
case of this mechanism--give Meta the LS pair Meta to operate on.
"))(POS (PAPER.TOPIC WEYHRAUCH80 "Theorem Proving with Attachments"))(POS (PAPER.INSTANCE YAMATOMOTO2000))(POS (PAPER.AUTHOR YAMATOMOTO2000 "Akihiro Yamatomoto, Bertram Fronhofer"))(POS (PAPER.TITLE YAMATOMOTO2000 "Hypothesis Finding via Residue Hypotheses with the Resolution Principle"))(POS (PAPER.LINK YAMATOMOTO2000 "http://link.springer.de/link/service/series/0558/bibs/1968/19680156.htm"))(POS (PAPER.YEAR YAMATOMOTO2000 2000))(POS (PAPER.DESCRIPTION YAMATOMOTO2000 "
Given a set of background sentences B that do not entail a positive example E, we want to find a hypothesis H such that
B and H entail E.  The authors argue for the use of anti-subsumption over anti-instantiation as a method for
finding residue hypotheses.
"))(POS (PAPER.TOPIC YAMATOMOTO2000 "Theorem Proving Applications"))(POS (PAPER.INSTANCE ZHANG90))(POS (PAPER.BIBTEX ZHANG90 ARTICLE))(POS (PAPER.AUTHOR ZHANG90 "Weining Zhang and Clement Yu and Daniel Troy"))(POS (PAPER.TITLE ZHANG90 "Necessary and Sufficient Conditions to Linearize Doubly Recursive Programs in Logic Databases"))(POS (PAPER.PUBLICATION ZHANG90 "ACM Transactions on Database Systems"))(POS (PAPER.VOLUME ZHANG90 "15(3)"))(POS (PAPER.STARTPAGE ZHANG90 459))(POS (PAPER.ENDPAGE ZHANG90 482))(POS (PAPER.LINK ZHANG90 "http://portal.acm.org/citation.cfm?coll=GUIDE&dl=GUIDE&id=89237"))(POS (PAPER.YEAR ZHANG90 1990))(POS (PAPER.DESCRIPTION ZHANG90 "
The authors examine conditions under which a doubly recursive program, i.e. a program of the form r(xbar) if s(xbar) and r(xbar) if r(ybar) ^ q(ybar') ^ r(ybar''), can be expressed as a linear recursive program, i.e. where the first recursive r definition is resolved with s(xbar).  The only assumption is that 
all the variables in the head appear somewhere in the body.  This result
strengthens previous results.  All rules are horn, and the semantics are LP. 
The necessary and sufficient conditions are nasty, as you might expect.
"))(POS (PAPER.TOPIC ZHANG90 "Reformulation"))(POS (PAPER.INSTANCE ZHANG95))(POS (PAPER.BIBTEX ZHANG95 INPROCEEDINGS))(POS (PAPER.AUTHOR ZHANG95 "J. Zhang and H. Zhang"))(POS (PAPER.TITLE ZHANG95 "SEM: A System for Enumerating Models"))(POS (PAPER.PUBLICATION ZHANG95 "In proceedings, IJCAI-95, Morgan Kaufmann"))(POS (PAPER.LINK ZHANG95 "http://citeseer.ist.psu.edu/context/34167/0"))(POS (PAPER.YEAR ZHANG95 1995))(POS (PAPER.DESCRIPTION ZHANG95 "
Model builder based on searching for a model directly and using the Least Number Heuristic, a method for reducing symmetry in the search space.
"))(POS (PAPER.TOPIC ZHANG95 "Model Building"))(POS (PAPER.INSTANCE ZHANG96))(POS (PAPER.BIBTEX ZHANG96 ARTICLE))(POS (PAPER.AUTHOR ZHANG96 "J. Zhang"))(POS (PAPER.TITLE ZHANG96 "Constructing Finite Algebras with FALCON"))(POS (PAPER.PUBLICATION ZHANG96 "Journal of Automated Reasoning"))(POS (PAPER.VOLUME ZHANG96 "17(1)"))(POS (PAPER.STARTPAGE ZHANG96 1))(POS (PAPER.ENDPAGE ZHANG96 22))(POS (PAPER.LINK ZHANG96 "http://citeseer.ist.psu.edu/context/254103/0"))(POS (PAPER.YEAR ZHANG96 1996))(POS (PAPER.DESCRIPTION ZHANG96 "
Model builder based on searching for a model directly, the so-called
Falcon-style approach.
"))(POS (PAPER.TOPIC ZHANG96 "Model Building"))(POS (PAPER.INSTANCE ZHANG97))(POS (PAPER.BIBTEX ZHANG97 ARTICLE))(POS (PAPER.AUTHOR ZHANG97 "Yan Zhang and Norman Foo"))(POS (PAPER.TITLE ZHANG97 "Deriving Invariants and Constraints from Action Theories"))(POS (PAPER.PUBLICATION ZHANG97 "Fundamenta Informaticae"))(POS (PAPER.VOLUME ZHANG97 "30(1)"))(POS (PAPER.STARTPAGE ZHANG97 109))(POS (PAPER.ENDPAGE ZHANG97 123))(POS (PAPER.LINK ZHANG97 "http://citeseer.ist.psu.edu/zhang96deriving.html"))(POS (PAPER.YEAR ZHANG97 1997))(POS (PAPER.RANK ZHANG97 "[*****]"))(POS (PAPER.DESCRIPTION ZHANG97 "
Zhang and Foo describe an approach to the construction of action invariants
(statements that hold in the predecessor and successor states when
executing a particular action) and state constraints (statements
true in all states reachable from an initial state).   It is based
on a state-based persistence formalism (Zhang's work), and assumes
a domain-closure axiom.  It considers actions with disjunctive effects
and preconditions, but does not provide complete results for those
cases.  It relies on the use of induction to prove a candidate
state constraint is actually a state constraint, but the generation
of these candidates is done algorithmically.
"))(POS (PAPER.TOPIC ZHANG97 "Theories of Action"))(POS (PAPER.INSTANCE ZHU98))(POS (PAPER.BIBTEX ZHU98 PHDTHESIS))(POS (PAPER.AUTHOR ZHU98 "Yunshan Zhu"))(POS (PAPER.TITLE ZHU98 "Efficient First-Order Semantic Deduction Techniques"))(POS (PAPER.LINK ZHU98 "http://citeseer.ist.psu.edu/zhu98efficient.html"))(POS (PAPER.YEAR ZHU98 1998))(POS (PAPER.RANK ZHU98 "[*]"))(POS (PAPER.DESCRIPTION ZHU98 "
This is Zhu's thesis on Ordered Semantic Hyperlinking, complexity
measures of theorem proving, and OSHL applied to planning.
Contains some good citations to semantically driven proof techniques
in section 2.1.
"))(POS (PAPER.TOPIC ZHU98 "Resolution Variants"))(POS (PAPER.RELATED ZHU98 PLAISTED97))(POS (EXAMPLE.INSTANCE DRESDENQUEENS))(POS (EXAMPLE.DATEENTERED DRESDENQUEENS 3355255579))(POS (EXAMPLE.DATEMODIFIED DRESDENQUEENS 3355255579))(POS (EXAMPLE.TECHNIQUE DRESDENQUEENS DATAEXTRACTION))(POS (EXAMPLE.TECHNIQUE DRESDENQUEENS GENERATEOVERGUESS))(POS (EXAMPLE.DESCRIPTION DRESDENQUEENS "We extracted the data out of the rules and relied on generation instead of guess and check."))(POS (EXAMPLE.SOURCE DRESDENQUEENS "  (<= (goal player ?s)
      (attacks ?n)
      (mapnum2val ?n ?s))
  (mapnum2val s0 100)
  (mapnum2val s2 90)
  (mapnum2val s3 80)
  (mapnum2val s4 70)
  (mapnum2val s5 60)
  (mapnum2val s6 50)
  (mapnum2val s7 40)
  (mapnum2val s8 0)
  (mapnum2val s9 0)
  (mapnum2val s10 0)
"))(POS (EXAMPLE.TARGET DRESDENQUEENS "  (<= (goal player 100)
      (attacks s0))
  (<= (goal player 90)
      (attacks s2))
  (<= (goal player 80)
      (attacks s3))
  (<= (goal player 70)
      (attacks s4))
  (<= (goal player 60)
      (attacks s5))
  (<= (goal player 50)
      (attacks s6))
  (<= (goal player 40)
      (attacks s7))
  (<= (goal player 0)
      (attacks s8))
  (<= (goal player 0)
      (attacks s9))
  (<= (goal player 0)
      (attacks s10))
"))(POS (EXAMPLE.INSTANCE TOETICTAC))(POS (EXAMPLE.DATEENTERED TOETICTAC 3355255669))(POS (EXAMPLE.DATEMODIFIED TOETICTAC 3355255669))(POS (EXAMPLE.TECHNIQUE TOETICTAC RELATIONALIZING))(POS (EXAMPLE.DESCRIPTION TOETICTAC "The old: each of the 9 cells is labelled with an x, an o, or a b: cell(x,y,label).  The new: each of the 9 cells (a,b,c,d,e,f,g,h,i) is either true of ecks or ohs or blank, each of which is a unary relation. "))(POS (EXAMPLE.EFFICIENCYGAINS TOETICTAC "Notes: tictactoe is the original theory and toetictac is the new one.
? (time (brute-force-playable tictactoe))
(BRUTE-FORCE-PLAYABLE TICTACTOE) took 56,488 milliseconds (56.488 seconds) to run.
Of that, 2,602 milliseconds (2.602 seconds) were spent in The Cooperative Multitasking Experience.
 88,240,736 bytes of memory allocated.
T
? (time (brute-force-playable toetictac))
;Compiler warnings :
;   Undeclared free variable TOETICTAC, in an anonymous lambda form.
(BRUTE-FORCE-PLAYABLE TOETICTAC) took 38,920 milliseconds (38.920 seconds) to run.
Of that, 1,514 milliseconds (1.514 seconds) were spent in The Cooperative Multitasking Experience.
 48,237,344 bytes of memory allocated.
T
"))(POS (EXAMPLE.SOURCE TOETICTAC "    (role white)
    (role black)
    (init (cell 1 1 b))
    (init (cell 1 2 b))
    (init (cell 1 3 b))
    (init (cell 2 1 b))
    (init (cell 2 2 b))
    (init (cell 2 3 b))
    (init (cell 3 1 b))
    (init (cell 3 2 b))
    (init (cell 3 3 b))
    (init (control white))
    (<= (next (cell ?m ?n x))
        (does white (mark ?m ?n))
        (true (cell ?m ?n b)))
    (<= (next (cell ?m ?n o))
        (does black (mark ?m ?n))
        (true (cell ?m ?n b)))
    (<= (next (cell ?m ?n ?w))
        (true (cell ?m ?n ?w))
        (distinct ?w b))
    (<= (next (cell ?m ?n b))
        (does ?w (mark ?j ?k))
        (true (cell ?m ?n b))
        (or (distinct ?m ?j) (distinct ?n ?k)))
    (<= (next (control white))
        (true (control black)))
    (<= (next (control black))
        (true (control white)))
    (<= (row ?m ?x)
        (true (cell ?m 1 ?x))
        (true (cell ?m 2 ?x))
        (true (cell ?m 3 ?x)))
    (<= (column ?n ?x)
        (true (cell 1 ?n ?x))
        (true (cell 2 ?n ?x))
        (true (cell 3 ?n ?x)))
    (<= (diagonal ?x)
        (true (cell 1 1 ?x))
        (true (cell 2 2 ?x))
        (true (cell 3 3 ?x)))
    (<= (diagonal ?x)
        (true (cell 1 3 ?x))
        (true (cell 2 2 ?x))
        (true (cell 3 1 ?x)))
    (<= (line ?x)
        (row ?m ?x))
    (<= (line ?x)
        (column ?m ?x))
    (<= (line ?x)
        (diagonal ?x))
    (<= open
        (true (cell ?m ?n b)))
    (<= (legal ?w (mark ?x ?y))
        (true (cell ?x ?y b))
        (true (control ?w)))
    (<= (legal white noop)
        (true (cell ?x ?y b))
        (true (control black)))
    (<= (legal black noop)
        (true (cell ?x ?y b))
        (true (control white)))
    (<= (goal white 100)
        (line x))
    (<= (goal white 50)
        (not (line x))
        (not (line o))
        (not open))
    (<= (goal white 0)
        (line o))
    (<= (goal black 100)
        (line o))
    (<= (goal black 50)
        (not (line x))
        (not (line o))
        (not open))
    (<= (goal black 0)
        (line x))
    (<= terminal
        (line x))
    (<= terminal
        (line o))
    (<= terminal
        (not open))
"))(POS (EXAMPLE.TARGET TOETICTAC "    (role xplayer)
    (role oplayer)
    (init (blank a))
    (init (blank b))
    (init (blank c))
    (init (blank d))
    (init (blank e))
    (init (blank f))
    (init (blank g))
    (init (blank h))
    (init (blank i))
    (init (control xplayer))
    (<= (next (ecks ?m))
        (does xplayer (mark ?m))
        (true (blank ?m)))
    (<= (next (oh ?m))
        (does oplayer (mark ?m))
        (true (blank ?m)))
    (<= (next (ecks ?m))
        (true (ecks ?m)))
    (<= (next (oh ?m))
        (true (oh ?m)))
    (<= (next (blank ?m))
        (does ?w (mark ?n))
        (true (blank ?m))
        (distinct ?m ?n))
    (<= (next (control xplayer))
        (true (control oplayer)))
    (<= (next (control oplayer))
        (true (control xplayer)))
    (line a b c)
    (line a d g)
    (line d e f)
    (line b e h)
    (line g h i)
    (line c f i)
    (line a e i)
    (line c e g)
    (<= xline
        (line ?a ?b ?c)
        (true (ecks ?a))
        (true (ecks ?b))
        (true (ecks ?c)))
    (<= oline
        (line ?a ?b ?c)
        (true (oh ?a))
        (true (oh ?b))
        (true (oh ?c)))
    (<= open
        (true (blank ?m)))
    (<= (legal ?player (mark ?y))
        (true (blank ?y))
        (true (control ?player)))
    (<= (legal oplayer noop)
        (true (control xplayer)))
    (<= (legal xplayer noop)
        (true (control oplayer)))
    (<= (goal xplayer 100)
        xline)
    (<= (goal xplayer 50)
        (not xline)
        (not oline)
        (not open))
    (<= (goal xplayer 0)
        oline)
    (<= (goal oplayer 100)
        oline)
    (<= (goal oplayer 50)
        (not xline)
        (not oline)
        (not open))
    (<= (goal oplayer 0)
        xline)
    (<= terminal
        xline)
    (<= terminal
        oline)
    (<= terminal
        (not open))
"))(POS (EXAMPLE.INSTANCE MAZEWORLD))(POS (EXAMPLE.DATEENTERED MAZEWORLD 3355255765))(POS (EXAMPLE.DATEMODIFIED MAZEWORLD 3355255765))(POS (EXAMPLE.TECHNIQUE MAZEWORLD CONSISTENCY2DEDUCTION))(POS (EXAMPLE.TECHNIQUE MAZEWORLD UNNAMED))(POS (EXAMPLE.DESCRIPTION MAZEWORLD "Original maze world is an incomplete information game.  The new maze world is a complete information game, where all the uncertainty has been built into the role world.  When building the game tree for a 2-player incomplete game, the branching factor for your opponent is all possible moves since we don't necessarily know what moves that player can legally make.  Sometimes, some of those moves are inconsistent with the current state of the world.  By compiling the incompleteness into the world player, we can enumerate just the legal moves that are consistent with the state of the game."))(POS (EXAMPLE.SOURCE MAZEWORLD "  (role robot)

    (initial 1)
    (successor 1 2)
    (successor 2 3)
    (successor 3 4)
    (successor 4 5)
    (successor 5 6)
    (successor 6 7)
    (successor 7 8)
    (successor 8 9)
    (successor 9 10)

    (adjacent a b)
    (adjacent b c)
    (adjacent c d)
    (adjacent d a)

    (percept robot bright)

    ;;;;

    (<= (legal robot move ?n))
    (<= (legal robot noop ?n))

    (<= (goal robot 100 ?n)
        (true (cell ?x) ?n)
        (true (gold ?x) ?n))
    
    (<= (goal robot 0 ?n)
        (true (cell ?x) ?n)
	(true (gold ?y) ?n)
        (distinct ?x ?y))
        
    (terminal 7)

    ;;;;
    
    ; state
    (true (cell a) 1)
    (not (true (gold a) 1))

    ; effector
    (<= (true (cell ?y) ?n)
        (successor ?m ?n)
        (does robot move ?m)
        (true (cell ?x) ?m)
        (adjacent ?x ?y))

    (<= (true (cell ?y) ?n)
        (successor ?m ?n)
        (does robot noop ?m)
        (true (cell ?y) ?n))
		
    
    ; state
    (<= (true (gold d) ?n)
        (not (true (gold a) ?n))
        (not (true (gold b) ?n))
        (not (true (gold c) ?n))
        (not (true (gold i) ?n)))

    
    ; gold sensor
    (<= (true (gold ?x) ?n)
        (sees robot bright ?n)
        (true (cell ?x) ?n))

    (<= (not (true (gold ?x) ?n))
        (not (sees robot bright ?n)) 
        (true (cell ?x) ?n))
    

    ; frame: monotonicity of gold
    (<= (true (gold ?x) ?n)
        (successor ?m ?n)
        (true (gold ?x) ?m))

    (<= (not (true (gold ?x) ?n))
        (successor ?m ?n)
        (not (true (gold ?x) ?m)))
"))(POS (EXAMPLE.TARGET MAZEWORLD "  (role robot)
  (role world)
  
  (successor 1 2)
  (successor 2 3)
  (successor 3 4)
  (successor 4 5)
  (successor 5 6)
  (successor 6 7)
  (successor 7 8)
  (successor 8 9)
  (successor 9 10)
  
  (adjacent a b)
  (adjacent b c)
  (adjacent c d)
  (adjacent d a)
  
  (percept robot bright)

  ;;;;

  (init (step 1))
  (init (listof * * *))
  (init (cell a))
  
  ;;;;
  
  (<= (legal robot move))
  (<= (legal robot noop))
  
  (<= (legal world (listof ?x ?u ?v))
      (true (listof * ?u ?v))
      (bit3 ?x ?u ?v))
  (<= (legal world (listof ?x ?u ?v))
      (true (listof ?x * ?v))
      (bit3 ?x ?u ?v))
  (<= (legal world (listof ?x ?u ?v))
      (true (listof ?x ?u *))
      (bit3 ?x ?u ?v))
  (<= (legal world (listof ?x ?u ?v))
      (true (listof * * ?v))
      (bit3 ?x ?u ?v))
  (<= (legal world (listof ?x ?u ?v))
      (true (listof * ?u *))
      (bit3 ?x ?u ?v))
  (<= (legal world (listof ?x ?u ?v))
      (true (listof ?x * *))
      (bit3 ?x ?u ?v))
  (<= (legal world (listof ?x ?u ?v))
      (true (listof * * *))
      (bit3 ?x ?u ?v))
  
  
  (<= (bit3 ?x ?y ?z) (bit ?x) (bit ?y) (bit ?z))
  (bit 1) 
  (bit 0)
  
  (<= (goal robot 100)
      (true (cell ?x))
      (true (real (gold ?x))))
  
  (<= (goal robot 0)
      (true (cell ?x))
      (true (real ?y))
      (distinct ?x ?y))
  
  ;;;;
  
  ; counter
  (<= (next (step ?x))
      (true (step ?y))
      (successor ?y ?x))
  
  ; effector: world
  (<= (next (real ?x))
      (does world ?y)
      (item-true ?x ?y))
  
  (<= (item-true (gold b) (listof 1 ?y ?z)))
  (<= (item-true (gold c) (listof ?x 1 ?z)))
  (<= (item-true (gold d) (listof ?x ?y 1)))
  (<= (item-false (gold b) (listof 0 ?y ?z)))
  (<= (item-false (gold c) (listof ?x 0 ?z)))
  (<= (item-false (gold d) (listof ?x ?y 0)))
  
  ; effector: robot
  (<= (next (cell ?y))
      (does robot move)
      (true (cell ?x))
      (adjacent ?x ?y))
  
  (<= (next (cell ?y))
      (does robot noop)
      (true (cell ?y)))
  
  
  ; frame and sensor: skolem
  (<= (next (listof ?x ?y ?z))
      (val (gold b) ?x)
      (val (gold c) ?y)
      (val (gold d) ?z))
  
  (<= (val ?x 1)
      (tru ?x))
  (<= (val ?x 1)
      (true (listof @y))
      (item-true ?x (listof @y)))

  (<= (val ?x 0)
      (nottru ?x))
  (<= (val ?x 0)
      (true (listof @y))
      (item-false ?x (listof @y)))

  (<= (val ?x *)
      (true (listof @y))
      (not (item-true ?x (listof @y)))
      (not (item-false ?x (listof @y)))
      (not  (tru ?x))
      (not (nottru ?x)))

  
  (<= (nottru (gold ?y))
      (does robot move)
      (true (cell ?x))
      (adjacent ?x ?y)
      (does world ?wm)
      (item-false (gold ?y) ?wm)) 
  
  (<= (tru (gold ?y))
      (does robot move)
      (true (cell ?x))
      (adjacent ?x ?y)
      (does world ?wm)
      (item-true (gold ?y) ?wm)) 
"))(POS (EXAMPLE.INSTANCE MAPCOLORING))(POS (EXAMPLE.DATEENTERED MAPCOLORING 3355255875))(POS (EXAMPLE.DATEMODIFIED MAPCOLORING 3355255875))(POS (EXAMPLE.TECHNIQUE MAPCOLORING CONSISTENCY2DEDUCTION))(POS (EXAMPLE.TECHNIQUE MAPCOLORING CHIRKOVAREFORMULATION))(POS (EXAMPLE.SOURCE MAPCOLORING "  (<= (not (color ?r ?c))
      (not (region ?r)))

  (<= (not (color ?r ?c))
      (not (hue ?c)))

  (<= (not (color ?r1 ?c))
      (adjacent ?r1 ?r2)
      (color ?r2 ?c))

  (region r1)
  (region r2)
  (region r3)

  (hue red)
  (hue blue)

  (adjacent r1 r2)
  (adjacent r2 r1)
  (adjacent r2 r3)
  (adjacent r3 r2)
"))(POS (EXAMPLE.SOURCEQUERY MAPCOLORING "(and (color r1 ?x) (color r2 ?y) (color r3 ?z))
"))(POS (EXAMPLE.TARGET MAPCOLORING "(next red blue)
(next blue red)"))(POS (EXAMPLE.TARGETQUERY MAPCOLORING "(and (next ?x ?y) (next ?y ?z))"))(POS (EXAMPLE.DESCRIPTION MAPCOLORING "The first version is not deductive; in fact, it entails which colorings are invalid.  The second version is deductive.  The first can be separated from region, hue, adjacent, but the second version builds all 3 into the formulation.  The first is more natural, but the second seems to be more efficient. Instead of building an arbitrary model for the axioms, we can use CSP/LP techniques to find an answer.  Actually, it is unclear to what extent the second formulation is faster than the first."))(POS (EXAMPLE.INSTANCE EXAMPLE.3355256133))(POS (EXAMPLE.DATEENTERED EXAMPLE.3355256133 3355256133))(POS (EXAMPLE.DATEMODIFIED EXAMPLE.3355256133 3355256133))(POS (EXAMPLE.DESCRIPTION EXAMPLE.3355256133 "test description"))(NEG (EXAMPLE.DESCRIPTION EXAMPLE.3355256133 "test description"))(POS (EXAMPLE.DESCRIPTION EXAMPLE.3355256133 "test description 2"))(NEG (EXAMPLE.EFFICIENCYGAINS TOETICTAC "Notes: tictactoe is the original theory and toetictac is the new one.
? (time (brute-force-playable tictactoe))
(BRUTE-FORCE-PLAYABLE TICTACTOE) took 56,488 milliseconds (56.488 seconds) to run.
Of that, 2,602 milliseconds (2.602 seconds) were spent in The Cooperative Multitasking Experience.
 88,240,736 bytes of memory allocated.
T
? (time (brute-force-playable toetictac))
;Compiler warnings :
;   Undeclared free variable TOETICTAC, in an anonymous lambda form.
(BRUTE-FORCE-PLAYABLE TOETICTAC) took 38,920 milliseconds (38.920 seconds) to run.
Of that, 1,514 milliseconds (1.514 seconds) were spent in The Cooperative Multitasking Experience.
 48,237,344 bytes of memory allocated.
T
"))(POS (EXAMPLE.EFFICIENCYGAINS TOETICTAC "(brute-force-playable source) takes 56.5 seconds.
(brute-force-playable target) takes 39 seconds."))(NEG (EXAMPLE.DATEENTERED EXAMPLE.3355256133 3355256133))(NEG (EXAMPLE.DATEMODIFIED EXAMPLE.3355256133 3355256133))(NEG (EXAMPLE.DESCRIPTION EXAMPLE.3355256133 "test description 2"))(NEG (EXAMPLE.INSTANCE EXAMPLE.3355256133))(POS (EXAMPLE.EFFICIENCYGAINS DRESDENQUEENS "(reward player ?x)
Source: 425 seconds, Target: 3 seconds"))(POS (PRETTYNAME DRESDENQUEENS "Dresden Queens"))(POS (PRETTYNAME MAPCOLORING "Map Coloring"))(POS (PRETTYNAME MAZEWORLD "Maze World"))(POS (PRETTYNAME TOETICTAC "Toetictac"))(POS (PRETTYNAME CHIRKOVAREFORMULATION "Chirkova"))(POS (PRETTYNAME CONSISTENCY2DEDUCTION "Consistency2Deduction"))(NEG (PRETTYNAME CHIRKOVAREFORMULATION "Chirkova"))(POS (PRETTYNAME CHIRKOVAREFORMULATION "Chirkova Reformulation"))(POS (PRETTYNAME DATAEXTRACTION "Data Extraction"))(POS (PRETTYNAME DATAINFUSION "Data Infusion"))(POS (PRETTYNAME GENERATEOVERGUESS "Generate Over Guess"))(POS (PRETTYNAME OBJECTIFYING "Objectifying"))(POS (PRETTYNAME REIFICATION "Reification"))(POS (PRETTYNAME RELATIONALIZING "Relationalizing"))(POS (PRETTYNAME UNNAMED "Unnamed"))(POS (SHORTNAME CHIRKOVAREFORMULATION "Chirkova"))(POS (SHORTNAME CONSISTENCY2DEDUCTION "C2D"))(POS (SHORTNAME DATAEXTRACTION "Extraction"))(POS (SHORTNAME DATAINFUSION "Infusion"))(POS (SHORTNAME GENERATEOVERGUESS "GOG"))(POS (SHORTNAME OBJECTIFYING "2Obj"))(POS (SHORTNAME REIFICATION "Reification"))(POS (SHORTNAME RELATIONALIZING "2Reln"))(POS (SHORTNAME UNNAMED "?"))(POS (COMPLETENESS.INSTANCE COMPLETE))(POS (COMPLETENESS.INSTANCE INCOMPLETE))(POS (EXAMPLE.COMPLETE DRESDENQUEENS COMPLETE))(POS (EXAMPLE.COMPLETE TOETICTAC COMPLETE))(POS (EXAMPLE.COMPLETE MAZEWORLD INCOMPLETE))(POS (EXAMPLE.COMPLETE MAPCOLORING INCOMPLETE))(POS (EXAMPLE.TECHNIQUE TOETICTAC UNNAMED))(NEG (EXAMPLE.DESCRIPTION DRESDENQUEENS "We extracted the data out of the rules and relied on generation instead of guess and check."))(POS (EXAMPLE.DESCRIPTION DRESDENQUEENS "When a GGP class was taught in Dresden, the 8-queens puzzle was used at some point.  The original axioms they wrote ran slowly when asking the query for the reward a player earned after having placed the 8 queens on the board.  The formulation was propositional: check if there are 8 queens that are attacked by some other queen; if so, award 0 points.  Then check if there are 7 queens that are attacked, and award 40 points.  And so on.  Nat changed the axioms so that first they compute how many queens are attacked and then use a lookup table to compute the points awarded."))(NEG (EXAMPLE.DESCRIPTION TOETICTAC "The old: each of the 9 cells is labelled with an x, an o, or a b: cell(x,y,label).  The new: each of the 9 cells (a,b,c,d,e,f,g,h,i) is either true of ecks or ohs or blank, each of which is a unary relation. "))(POS (EXAMPLE.DESCRIPTION TOETICTAC "Toetictac is a reconceptualization of the original axioms for tictactoe.  In the original version each of the 9 cells is labelled with an x, an o, or a b: cell(x,y,label).  In the new version each of the 9 cells (a,b,c,d,e,f,g,h,i) is either true of ecks or ohs or blank, each of which is a unary relation."))(POS (TECHNIQUE.INSTANCE NAF))(POS (TECHNIQUE.DESCRIPTION NAF "Negation as failure is a meta-inference rule: if the closed sentence p is not entailed (cannot be proven) then infer -p.  We've found it useful for performing iteration, and it is also useful in complete theories when failing to prove p in the positive space is easier than proving -p directly.  "))(POS (PRETTYNAME NAF "Negation as Failure"))(POS (SHORTNAME NAF "NAF"))(POS (BOOLEAN.INSTANCE TRUE))(POS (PRETTYNAME TRUE "True"))(POS (SHORTNAME TRUE "T"))(POS (BOOLEAN.INSTANCE FALSE))(POS (PRETTYNAME FALSE "False"))(POS (SHORTNAME FALSE "F"))(POS (MATRIXSHOW CONSISTENCY2DEDUCTION TRUE))(POS (MATRIXSHOW DRESDENQUEENS TRUE))(POS (MATRIXSHOW REIFICATION TRUE))(POS (MATRIXSHOW UNNAMED TRUE))(POS (MATRIXSHOW RELATIONALIZING FALSE))(POS (MATRIXSHOW OBJECTIFYING FALSE))(POS (MATRIXSHOW GENERATEOVERGUESS TRUE))(POS (MATRIXSHOW DATAEXTRACTION TRUE))(POS (MATRIXSHOW DATAINFUSION TRUE))(POS (MATRIXSHOW CHIRKOVAREFORMULATION TRUE))(POS (MATRIXSHOW NAF TRUE))(POS (MATRIXSHOW TOETICTAC TRUE))(POS (MATRIXSHOW MAZEWORLD TRUE))(POS (MATRIXSHOW MAPCOLORING TRUE))(POS (EXAMPLE.INSTANCE EXAMPLE.3355774383))(POS (PRETTYNAME EXAMPLE.3355774383 "Exponential negation"))(POS (SHORTNAME EXAMPLE.3355774383 "ExpNeg"))(POS (EXAMPLE.COMPLETE EXAMPLE.3355774383 COMPLETE))(POS (EXAMPLE.TECHNIQUE EXAMPLE.3355774383 NAF))(POS (EXAMPLE.DESCRIPTION EXAMPLE.3355774383 "An iff can be used to compactly define a complete relation; however, when converting an iff to clausal form, negating the body can produce a large number of rules.  This example shows that an exponential number of rules can be produced.  In general, if this example is generalized to include n disjuncts of conjunctions of length m, there are m^n rules of length m for defining the negative space.  There would be n rules of length m for defining the positive space."))(POS (EXAMPLE.EFFICIENCYGAINS EXAMPLE.3355774383 "6/4 unis/infs to explore positive space versus 54/28 unis/infs to explore negative space"))(POS (MATRIXSHOW EXAMPLE.3355774383 TRUE))(POS (EXAMPLE.SOURCEQUERY EXAMPLE.3355774383 "(not illegal)"))(POS (EXAMPLE.SOURCE EXAMPLE.3355774383 "(<=> illegal (or (and p1 p2 p3) (and q1 q2 q3) (and r1 r2 r3)))
"))(POS (EXAMPLE.TARGETQUERY EXAMPLE.3355774383 "(not illegal)"))(POS (EXAMPLE.TARGET EXAMPLE.3355774383 "(<= illegal (or (and p1 p2 p3) (and q1 q2 q3) (and r1 r2 r3)))
"))(POS (EXAMPLE.INSTANCE EXPONENTIALNEGATION))(POS (PRETTYNAME EXPONENTIALNEGATION "Exponential negation"))(POS (SHORTNAME EXPONENTIALNEGATION "ExpNeg"))(POS (EXAMPLE.COMPLETE EXPONENTIALNEGATION COMPLETE))(POS (EXAMPLE.TECHNIQUE EXPONENTIALNEGATION NAF))(POS (EXAMPLE.DESCRIPTION EXPONENTIALNEGATION "An iff can be used to compactly define a complete relation; however, when converting an iff to clausal form, negating the body can produce a large number of rules.  This example shows that an exponential number of rules can be produced.  In general, if this example is generalized to include n disjuncts of conjunctions of length m, there are m^n rules of length m for defining the negative space.  There would be n rules of length m for defining the positive space."))(POS (EXAMPLE.EFFICIENCYGAINS EXPONENTIALNEGATION "6/4 unis/infs to explore positive space versus 54/28 unis/infs to explore negative space"))(POS (MATRIXSHOW EXPONENTIALNEGATION TRUE))(POS (EXAMPLE.SOURCEQUERY EXPONENTIALNEGATION "(not illegal)"))(POS (EXAMPLE.SOURCE EXPONENTIALNEGATION "(<=> illegal (or (and p1 p2 p3) (and q1 q2 q3) (and r1 r2 r3)))
"))(POS (EXAMPLE.TARGETQUERY EXPONENTIALNEGATION "(not illegal)"))(POS (EXAMPLE.TARGET EXPONENTIALNEGATION "(<= illegal (or (and p1 p2 p3) (and q1 q2 q3) (and r1 r2 r3)))
"))(NEG (EXAMPLE.INSTANCE EXAMPLE.3355774383))(POS (EXAMPLE.INSTANCE JIGSAW))(POS (PRETTYNAME JIGSAW "Jigsaw"))(POS (SHORTNAME JIGSAW "Jigsaw"))(POS (EXAMPLE.COMPLETE JIGSAW INCOMPLETE))(POS (EXAMPLE.TECHNIQUE JIGSAW UNNAMED))(POS (EXAMPLE.DESCRIPTION JIGSAW "This is a 4-piece jigsaw puzzle.  The original jigsaw axioms are complicated, and converting them into clausal form is expensive.  Moreover, finding an answer after conversion takes a very, very long time.  Lastly, the relations included have modular definitions--they could be picked up and moved to other theories without (much) modification.  The new axioms include less information, but they include sufficient information to answer the query goal.  The new axioms find all answers in less than a second."))(POS (EXAMPLE.EFFICIENCYGAINS JIGSAW "13000x speedup"))(POS (MATRIXSHOW JIGSAW TRUE))(POS (EXAMPLE.SOURCEQUERY JIGSAW "(goal ?x ?y ?z ?w)"))(POS (EXAMPLE.SOURCE JIGSAW "  (<=> (cardinal ?x) (or (= ?x north) (= ?x south) (= ?x west) (= ?x east)))
  (<=> (piece ?x) (or (= ?x p1) (= ?x p2) (= ?x p3) (= ?x p4) (= ?x p0)))
  (<=> (orientation ?x) (or (= ?x 0) (= ?x 90) (= ?x 180) (= ?x 270)))

  ;(or (piece ?x) (orientation ?x) (cardinal ?x))

  (<=> (edge ?x ?y) 
       (or (and (= ?x p1) (or (= ?y east) (= ?y north)))
           (and (= ?x p2) (or (= ?y west) (= ?y north)))
           (and (= ?x p3) (or (= ?y west) (= ?y south)))
           (and (= ?x p4) (or (= ?y north) (= ?y east)))) )

  (<=> (rotate ?x ?amt ?y) 
       (or (and (= ?x north) (= ?amt 0) (= ?y north)) 
           (and (= ?x north) (= ?amt 90) (= ?y east))
           (and (= ?x north) (= ?amt 180) (= ?y south))
           (and (= ?x north) (= ?amt 270) (= ?y west))
           
           (and (= ?x south) (= ?amt 0) (= ?y south)) 
           (and (= ?x south) (= ?amt 90) (= ?y west))
           (and (= ?x south) (= ?amt 180) (= ?y north))
           (and (= ?x south) (= ?amt 270) (= ?y east))

           (and (= ?x east) (= ?amt 0) (= ?y east)) 
           (and (= ?x east) (= ?amt 90) (= ?y south))
           (and (= ?x east) (= ?amt 180) (= ?y west))
           (and (= ?x east) (= ?amt 270) (= ?y north))

           (and (= ?x west) (= ?amt 0) (= ?y west)) 
           (and (= ?x west) (= ?amt 90) (= ?y north))
           (and (= ?x west) (= ?amt 180) (= ?y east))
           (and (= ?x west) (= ?amt 270) (= ?y south))
           ))

  (<=> (orientededge ?x ?o ?e)
       (and (piece ?x) 
            (orientation ?o)
            (cardinal ?e)
            (or (and (edge ?x north)
                     (rotate north ?o ?e))
                (and (edge ?x south)
                     (rotate south ?o ?e))
                (and (edge ?x east)
                     (rotate east ?o ?e))
                (and (edge ?x west)
                     (rotate west ?o ?e)) )))

  (<=> (connectedh ?x ?xo ?y ?yo)
       (and (piece ?x)
            (orientation ?xo)
            (piece ?y)
            (orientation ?yo)
            (or (and (orientededge ?x ?xo east)
                     (orientededge ?y ?yo west))
                (and (not (orientededge ?x ?xo east))
                     (not (orientededge ?y ?yo west))) )))
 
  (<=> (connectedv ?x ?xo ?y ?yo)
       (and (piece ?x)
            (orientation ?xo)
            (piece ?y)
            (orientation ?yo)
            (or (and (orientededge ?x ?xo south)
                     (orientededge ?y ?yo north))
                (and (not (orientededge ?x ?xo south))
                     (not (orientededge ?y ?yo north))) )))

  ; border uses p0, a piece with no edges
  (<=> (border ?o1 ?o2 ?o3 ?o4)
       (and (connectedh p0 0 p1 ?o1)
            (connectedv p0 0 p1 ?o1)
            (connectedv p0 0 p2 ?o2)
            (connectedh p2 ?o2 p0 0)
            (connectedh p4 ?o4 p0 0)
            (connectedv p4 ?o4 p0 0)
            (connectedv p3 ?o3 p0 0)
            (connectedh p0 0 p3 ?o3)))

  (<=> (connected ?o1 ?o2 ?o3 ?o4)
       (and (connectedh p1 ?o1 p2 ?o2)
            (connectedh p3 ?o3 p4 ?o4)
            (connectedv p1 ?o1 p3 ?o3)
            (connectedv p2 ?o2 p4 ?o4)
            (border ?o1 ?o2 ?o3 ?o4)))

  (<= (goal ?o1 ?o2 ?o3 ?o4)
      (connected ?o1 ?o2 ?o3 ?o4))
 
"))(POS (EXAMPLE.TARGETQUERY JIGSAW "(goal ?x ?y ?z ?w)"))(POS (EXAMPLE.TARGET JIGSAW "  (piece p1) 
  (piece p2) 
  (piece p3) 
  (piece p4) 
   
  (rotation 0) 
  (rotation 90) 
  (rotation 180) 
  (rotation 270) 
   
  (cardinal north) 
  (cardinal south) 
  (cardinal east) 
  (cardinal west) 
   
  (edge p1 north) 
  (edge p1 east) 
  (edge p2 north) 
  (edge p2 west) 
  (edge p3 south) 
  (edge p3 west) 
  (edge p4 north) 
  (edge p4 east) 
   
  (<= (east ?p ?rot) 
      (or (and (edge ?p east) (same ?rot 0)) 
          (and (edge ?p north) (same ?rot 90)) 
          (and (edge ?p west) (same ?rot 180)) 
          (and (edge ?p south) (same ?rot 270)))) 
   
  (<= (west ?p ?rot) 
      (or (and (edge ?p west) (same ?rot 0)) 
          (and (edge ?p south) (same ?rot 90)) 
          (and (edge ?p east) (same ?rot 180)) 
          (and (edge ?p north) (same ?rot 270)))) 
   
  (<= (north ?p ?rot) 
      (or (and (edge ?p north) (same ?rot 0)) 
          (and (edge ?p west) (same ?rot 90)) 
          (and (edge ?p south) (same ?rot 180)) 
          (and (edge ?p east) (same ?rot 270)))) 
   
  (<= (south ?p ?rot) 
      (or (and (edge ?p south) (same ?rot 0)) 
          (and (edge ?p east) (same ?rot 90)) 
          (and (edge ?p north) (same ?rot 180)) 
          (and (edge ?p west) (same ?rot 270)))) 
   
   
  (<= (goal ?nw ?ne ?sw ?se) 
      (rotation ?nw) 
      (rotation ?ne) 
      (rotation ?sw) 
      (rotation ?se) 
      (east p1 ?nw) 
      (west p2 ?ne) 
      (east p3 ?sw) 
      (west p4 ?se) 
      (south p1 ?nw) 
      (north p3 ?sw) 
      (south p2 ?ne) 
      (north p4 ?se))
"))(POS (TECHNIQUE.INSTANCE RESIDUESREWRITE))(POS (PRETTYNAME RESIDUESREWRITE "Rewrite with Residues"))(POS (SHORTNAME RESIDUESREWRITE "Residue"))(POS (MATRIXSHOW RESIDUESREWRITE TRUE))(POS (TECHNIQUE.DESCRIPTION RESIDUESREWRITE "Given a query phi, a set of sentences Delta, and a set of relations R, find all residues for phi in Delta wrt R.  Turn the result into a disjunction and simplify it."))(NEG (EXAMPLE.TECHNIQUE JIGSAW UNNAMED))(NEG (EXAMPLE.TECHNIQUE JIGSAW UNNAMED))(POS (EXAMPLE.TECHNIQUE JIGSAW RESIDUESREWRITE))(POS (EXAMPLE.TECHNIQUE JIGSAW UNNAMED))(NEG (EXAMPLE.TARGET JIGSAW "  (piece p1) 
  (piece p2) 
  (piece p3) 
  (piece p4) 
   
  (rotation 0) 
  (rotation 90) 
  (rotation 180) 
  (rotation 270) 
   
  (cardinal north) 
  (cardinal south) 
  (cardinal east) 
  (cardinal west) 
   
  (edge p1 north) 
  (edge p1 east) 
  (edge p2 north) 
  (edge p2 west) 
  (edge p3 south) 
  (edge p3 west) 
  (edge p4 north) 
  (edge p4 east) 
   
  (<= (east ?p ?rot) 
      (or (and (edge ?p east) (same ?rot 0)) 
          (and (edge ?p north) (same ?rot 90)) 
          (and (edge ?p west) (same ?rot 180)) 
          (and (edge ?p south) (same ?rot 270)))) 
   
  (<= (west ?p ?rot) 
      (or (and (edge ?p west) (same ?rot 0)) 
          (and (edge ?p south) (same ?rot 90)) 
          (and (edge ?p east) (same ?rot 180)) 
          (and (edge ?p north) (same ?rot 270)))) 
   
  (<= (north ?p ?rot) 
      (or (and (edge ?p north) (same ?rot 0)) 
          (and (edge ?p west) (same ?rot 90)) 
          (and (edge ?p south) (same ?rot 180)) 
          (and (edge ?p east) (same ?rot 270)))) 
   
  (<= (south ?p ?rot) 
      (or (and (edge ?p south) (same ?rot 0)) 
          (and (edge ?p east) (same ?rot 90)) 
          (and (edge ?p north) (same ?rot 180)) 
          (and (edge ?p west) (same ?rot 270)))) 
   
   
  (<= (goal ?nw ?ne ?sw ?se) 
      (rotation ?nw) 
      (rotation ?ne) 
      (rotation ?sw) 
      (rotation ?se) 
      (east p1 ?nw) 
      (west p2 ?ne) 
      (east p3 ?sw) 
      (west p4 ?se) 
      (south p1 ?nw) 
      (north p3 ?sw) 
      (south p2 ?ne) 
      (north p4 ?se))
"))(POS (EXAMPLE.TARGET JIGSAW "  (piece p1) 
  (piece p2) 
  (piece p3) 
  (piece p4) 
   
  (rotation 0) 
  (rotation 90) 
  (rotation 180) 
  (rotation 270) 
   
  (cardinal north) 
  (cardinal south) 
  (cardinal east) 
  (cardinal west) 
   
  (edge p1 north) 
  (edge p1 east) 
  (edge p2 north) 
  (edge p2 west) 
  (edge p3 south) 
  (edge p3 west) 
  (edge p4 north) 
  (edge p4 east) 
   
  (<= (rotate ?p ?rot east) 
      (or (and (edge ?p east) (same ?rot 0)) 
          (and (edge ?p north) (same ?rot 90)) 
          (and (edge ?p west) (same ?rot 180)) 
          (and (edge ?p south) (same ?rot 270)))) 
   
  (<= (rotate ?p ?rot west) 
      (or (and (edge ?p west) (same ?rot 0)) 
          (and (edge ?p south) (same ?rot 90)) 
          (and (edge ?p east) (same ?rot 180)) 
          (and (edge ?p north) (same ?rot 270)))) 
   
  (<= (rotate ?p ?rot north) 
      (or (and (edge ?p north) (same ?rot 0)) 
          (and (edge ?p west) (same ?rot 90)) 
          (and (edge ?p south) (same ?rot 180)) 
          (and (edge ?p east) (same ?rot 270)))) 
   
  (<= (rotate ?p ?rot south) 
      (or (and (edge ?p south) (same ?rot 0)) 
          (and (edge ?p east) (same ?rot 90)) 
          (and (edge ?p north) (same ?rot 180)) 
          (and (edge ?p west) (same ?rot 270)))) 
   
   
  (<= (goal ?nw ?ne ?sw ?se) 
      (rotation ?nw) 
      (rotation ?ne) 
      (rotation ?sw) 
      (rotation ?se) 
      (rotate p1 ?nw east) 
      (rotate p2 ?ne west) 
      (rotate p3 ?sw east) 
      (rotate p4 ?se west) 
      (rotate p1 ?nw south) 
      (rotate p3 ?sw north) 
      (rotate p2 ?ne south) 
      (rotate p4 ?se north))
"))(NEG (EXAMPLE.TECHNIQUE JIGSAW UNNAMED))(POS (EXAMPLE.TECHNIQUE JIGSAW NAF))(POS (EXAMPLE.TECHNIQUE JIGSAW UNNAMED))(POS (TECHNIQUE.INSTANCE STATICCONJORDERING))(POS (PRETTYNAME STATICCONJORDERING "Static Conjunct Ordering"))(POS (SHORTNAME STATICCONJORDERING "statconjorder"))(POS (MATRIXSHOW STATICCONJORDERING TRUE))(POS (TECHNIQUE.DESCRIPTION STATICCONJORDERING "For model elimination, ordering conjuncts statically requires simply changing the sequence of literals in the body of the rules."))(POS (EXAMPLE.INSTANCE GUESS))(POS (PRETTYNAME GUESS "Guess"))(POS (SHORTNAME GUESS "Guess"))(POS (EXAMPLE.COMPLETE GUESS COMPLETE))(POS (EXAMPLE.TECHNIQUE GUESS STATICCONJORDERING))(POS (EXAMPLE.DESCRIPTION GUESS "Example where a bad conjunct ordering requires non-zero work to find legal moves because the ground conjuncts are not moved all the way to the front."))(POS (EXAMPLE.EFFICIENCYGAINS GUESS "In this game, search space shrinks from 64^2 to 1 per rule."))(POS (MATRIXSHOW GUESS TRUE))(POS (EXAMPLE.COMMENTS GUESS "There may be a bug in the game -- something about greater than."))(POS (EXAMPLE.SOURCEQUERY GUESS "(legal chooser ?x)"))(POS (EXAMPLE.SOURCE GUESS "  (role guesser)
  (role chooser)
  (<= (legal guesser ?g)
      (true (possible ?g))
      (true (control guesser))
  (<= (legal guesser wait)
      (true (control chooser))
  (<= (next (control guesser))
      (true (control chooser))
  (<= (next (control chooser))
      (true (control guesser))
  (<= (next (guess ?x))
      (does guesser ?x)
      (true (possible ?x))
  (<= (legal chooser higher)
      (true (possible ?n))
      (greater ?n ?x)
      (true (guess ?x))
      (true (control chooser))
  (<= (legal chooser lower)
      (true (possible ?n))
      (greater ?x ?n)
      (true (guess ?x))
      (true (control chooser))
  (<= (legal chooser wait)
      (true (control guesser))
  (<= (next (possible ?x))
      (true (possible ?x))
      (true (control guesser))
  (<= (next (possible ?x))
      (true (possible ?x))
      (greater ?x ?y)
      (true (guess ?y))
      (does chooser higher)
  (<= (next (possible ?x))
      (true (possible ?x))
      (greater ?y ?x)
      (true (guess ?y))
      (does chooser lower)
  (<= (next (step ?x))
      (true (step ?y))
      (succ ?y ?x)
  (<= (goal guesser 100)
      (not unfinished)
  (<= (goal guesser 0)
      unfinished
  (<= (goal chooser 100)
      unfinished
  (<= (goal chooser 0)
      (not unfinished)
  (<= terminal
      (not unfinished)
  (<= terminal
      (true (step 12))
  (<= unfinished
      (true (possible ?x))
      (true (possible ?y))
      (distinct ?x ?y)
  (<= (greater ?x ?y)
      (succ ?y ?x)
  (<= (greater ?x ?y)
      (succ ?x ?z)
      (greater ?z ?y)
  (init (step 1))
  (init (control guesser))
  (init (possible 1))
  (init (possible 2))
  (init (possible 3))
  (init (possible 4))
  (init (possible 5))
  (init (possible 6))
  (init (possible 7))
  (init (possible 8))
  (init (possible 9))
  (init (possible 10))
  (init (possible 11))
  (init (possible 12))
  (init (possible 13))
  (init (possible 14))
  (init (possible 15))
  (init (possible 16))
  (init (possible 17))
  (init (possible 18))
  (init (possible 19))
  (init (possible 20))
  (init (possible 21))
  (init (possible 22))
  (init (possible 23))
  (init (possible 24))
  (init (possible 25))
  (init (possible 26))
  (init (possible 27))
  (init (possible 28))
  (init (possible 29))
  (init (possible 30))
  (init (possible 31))
  (init (possible 32))
  (init (possible 33))
  (init (possible 34))
  (init (possible 35))
  (init (possible 36))
  (init (possible 37))
  (init (possible 38))
  (init (possible 39))
  (init (possible 40))
  (init (possible 41))
  (init (possible 42))
  (init (possible 43))
  (init (possible 44))
  (init (possible 45))
  (init (possible 46))
  (init (possible 47))
  (init (possible 48))
  (init (possible 49))
  (init (possible 50))
  (init (possible 51))
  (init (possible 52))
  (init (possible 53))
  (init (possible 54))
  (init (possible 55))
  (init (possible 56))
  (init (possible 57))
  (init (possible 58))
  (init (possible 59))
  (init (possible 60))
  (init (possible 61))
  (init (possible 62))
  (init (possible 63))
  (succ 1 2)
  (succ 2 3)
  (succ 3 4)
  (succ 4 5)
  (succ 5 6)
  (succ 6 7)
  (succ 7 8)
  (succ 8 9)
  (succ 9 10)
  (succ 10 11)
  (succ 11 12)
  (succ 12 13)
  (succ 13 14)
  (succ 14 15)
  (succ 15 16)
  (succ 16 17)
  (succ 17 18)
  (succ 18 19)
  (succ 19 20)
  (succ 20 21)
  (succ 21 22)
  (succ 22 23)
  (succ 23 24)
  (succ 24 25)
  (succ 25 26)
  (succ 26 27)
  (succ 27 28)
  (succ 28 29)
  (succ 29 30)
  (succ 30 31)
  (succ 31 32)
  (succ 32 33)
  (succ 33 34)
  (succ 34 35)
  (succ 35 36)
  (succ 36 37)
  (succ 37 38)
  (succ 38 39)
  (succ 39 40)
  (succ 40 41)
  (succ 41 42)
  (succ 42 43)
  (succ 43 44)
  (succ 44 45)
  (succ 45 46)
  (succ 46 47)
  (succ 47 48)
  (succ 48 49)
  (succ 49 50)
  (succ 50 51)
  (succ 51 52)
  (succ 52 53)
  (succ 53 54)
  (succ 54 55)
  (succ 55 56)
  (succ 56 57)
  (succ 57 58)
  (succ 58 59)
  (succ 59 60)
  (succ 60 61)
  (succ 61 62)
  (succ 62 63)"))(POS (EXAMPLE.TARGETQUERY GUESS "(legal chooser ?x)"))(POS (EXAMPLE.TARGET GUESS "  (role guesser)
  (role chooser)

  (<= (legal guesser ?g)
      (true (control guesser))
      (true (possible ?g)))

  (<= (legal guesser wait)
      (true (control chooser)))

  (<= (next (control guesser))
      (true (control chooser)))

  (<= (next (control chooser))
      (true (control guesser)))

  (<= (next (guess ?x))
      (does guesser ?x)
      (true (possible ?x)))

  (<= (legal chooser higher)
      (true (control chooser))
      (true (possible ?n))
      (greater ?n ?x)
      (true (guess ?x)))

  (<= (legal chooser lower)
      (true (control chooser))
      (true (possible ?n))
      (greater ?x ?n)
      (true (guess ?x)))

  (<= (legal chooser wait)
      (true (control guesser)))

  (<= (next (possible ?x))
      (true (control guesser))
      (true (possible ?x)))

  (<= (next (possible ?x))
      (does chooser higher)
      (true (possible ?x))
      (greater ?x ?y)
      (true (guess ?y)))

  (<= (next (possible ?x))
      (does chooser lower)
      (true (possible ?x))
      (greater ?y ?x)
      (true (guess ?y)))

  (<= (next (step ?x))
      (true (step ?y))
      (succ ?y ?x))

  (<= (goal guesser 100)
      (not unfinished))
  (<= (goal guesser 0)
      unfinished)
  (<= (goal chooser 100)
      unfinished)
  (<= (goal chooser 0)
      (not unfinished))
  (<= terminal
      (not unfinished))
  (<= terminal
      (true (step 12)))
  (<= unfinished
      (true (possible ?x))
      (true (possible ?y))
      (distinct ?x ?y))
  (<= (greater ?x ?y)
      (succ ?y ?x))
  (<= (greater ?x ?y)
      (succ ?x ?z)
      (greater ?z ?y))
  (init (step 1))
  (init (control guesser))
  (init (possible 1))
  (init (possible 2))
  (init (possible 3))
  (init (possible 4))
  (init (possible 5))
  (init (possible 6))
  (init (possible 7))
  (init (possible 8))
  (init (possible 9))
  (init (possible 10))
  (init (possible 11))
  (init (possible 12))
  (init (possible 13))
  (init (possible 14))
  (init (possible 15))
  (init (possible 16))
  (init (possible 17))
  (init (possible 18))
  (init (possible 19))
  (init (possible 20))
  (init (possible 21))
  (init (possible 22))
  (init (possible 23))
  (init (possible 24))
  (init (possible 25))
  (init (possible 26))
  (init (possible 27))
  (init (possible 28))
  (init (possible 29))
  (init (possible 30))
  (init (possible 31))
  (init (possible 32))
  (init (possible 33))
  (init (possible 34))
  (init (possible 35))
  (init (possible 36))
  (init (possible 37))
  (init (possible 38))
  (init (possible 39))
  (init (possible 40))
  (init (possible 41))
  (init (possible 42))
  (init (possible 43))
  (init (possible 44))
  (init (possible 45))
  (init (possible 46))
  (init (possible 47))
  (init (possible 48))
  (init (possible 49))
  (init (possible 50))
  (init (possible 51))
  (init (possible 52))
  (init (possible 53))
  (init (possible 54))
  (init (possible 55))
  (init (possible 56))
  (init (possible 57))
  (init (possible 58))
  (init (possible 59))
  (init (possible 60))
  (init (possible 61))
  (init (possible 62))
  (init (possible 63))
  (succ 1 2)
  (succ 2 3)
  (succ 3 4)
  (succ 4 5)
  (succ 5 6)
  (succ 6 7)
  (succ 7 8)
  (succ 8 9)
  (succ 9 10)
  (succ 10 11)
  (succ 11 12)
  (succ 12 13)
  (succ 13 14)
  (succ 14 15)
  (succ 15 16)
  (succ 16 17)
  (succ 17 18)
  (succ 18 19)
  (succ 19 20)
  (succ 20 21)
  (succ 21 22)
  (succ 22 23)
  (succ 23 24)
  (succ 24 25)
  (succ 25 26)
  (succ 26 27)
  (succ 27 28)
  (succ 28 29)
  (succ 29 30)
  (succ 30 31)
  (succ 31 32)
  (succ 32 33)
  (succ 33 34)
  (succ 34 35)
  (succ 35 36)
  (succ 36 37)
  (succ 37 38)
  (succ 38 39)
  (succ 39 40)
  (succ 40 41)
  (succ 41 42)
  (succ 42 43)
  (succ 43 44)
  (succ 44 45)
  (succ 45 46)
  (succ 46 47)
  (succ 47 48)
  (succ 48 49)
  (succ 49 50)
  (succ 50 51)
  (succ 51 52)
  (succ 52 53)
  (succ 53 54)
  (succ 54 55)
  (succ 55 56)
  (succ 56 57)
  (succ 57 58)
  (succ 58 59)
  (succ 59 60)
  (succ 60 61)
  (succ 61 62)
  (succ 62 63)"))(NEG (SHORTNAME STATICCONJORDERING "statconjorder"))(POS (SHORTNAME STATICCONJORDERING "StatCO"))(NEG (EXAMPLE.COMPLETE JIGSAW INCOMPLETE))(POS (EXAMPLE.COMPLETE JIGSAW COMPLETE))(POS (TECHNIQUE.INSTANCE BILEVEL))(POS (PRETTYNAME BILEVEL "Bilevel Reasoning"))(POS (SHORTNAME BILEVEL "Bi"))(POS (MATRIXSHOW BILEVEL TRUE))(POS (TECHNIQUE.DESCRIPTION BILEVEL "Split the problem into two pieces: the data and the axioms."))(POS (EXAMPLE.INSTANCE 4QUEENS))(POS (PRETTYNAME 4QUEENS "4-Queens"))(POS (SHORTNAME 4QUEENS "4queens"))(POS (EXAMPLE.COMPLETE 4QUEENS INCOMPLETE))(POS (EXAMPLE.TECHNIQUE 4QUEENS CONSISTENCY2DEDUCTION))(POS (EXAMPLE.TECHNIQUE 4QUEENS BILEVEL))(POS (EXAMPLE.TECHNIQUE 4QUEENS NAF))(POS (EXAMPLE.DESCRIPTION 4QUEENS "The traditional 8-queens puzzle, shrunken to a 4x4 board with 4 queens.  Two solutions exist to what is usually a CSP.  But in this example, we are asking an entailment query about those solutions: is the upper left square always blank?"))(POS (MATRIXSHOW 4QUEENS TRUE))(POS (EXAMPLE.COMMENTS 4QUEENS "Add in UNA and DCA for all object constants, i.e. this is finite Herbrand logic."))(POS (EXAMPLE.SOURCEQUERY 4QUEENS "      (forall (?x1 ?y1 ?x2 ?y2 ?x3 ?y3 ?x4 ?y4) 
              (=> (ans ?x1 ?y1 ?x2 ?y2 ?x3 ?y3 ?x4 ?y4)
                  (and (not (= ?x1 1))
                       (not (= ?y1 1))
                       (not (= ?x2 1))
                       (not (= ?y2 1))
                       (not (= ?x3 1))
                       (not (= ?y3 1))
                       (not (= ?x4 1))
                       (not (= ?y4 1))))"))(POS (EXAMPLE.SOURCE 4QUEENS "  (<= (ans ?x1 ?y1 ?x2 ?y2 ?x3 ?y3 ?x4 ?y4)
      (and (row q1 ?x1) (col q1 ?y1) (row q2 ?x2) (col q2 ?y2) (row q3 ?x3) (col q3 ?y3) (row q4 ?x4) (col q4 ?y4)))

  ; all the queens have different rows
  (<= (not (row ?x ?c))
      (row ?y ?c)
      (not (= ?x ?y)))

  ; all the queens have different columns
  (<= (not (col ?x ?c))
      (col ?y ?c)
      (not (= ?x ?y)))

  ; given a row and column, we can compute the two diagonals it is on.
  (<= (d ?q pos ?z) (row ?q ?x) (col ?q ?y) (sub ?y ?x ?z))
  (<= (d ?q neg ?z) (row ?q ?x) (col ?q ?y) (add ?y ?x ?z))

  ; all the queens have different diagonals
  (<= (not (d ?q1 ?sign ?z))
      (d ?q2 ?sign ?z)
      (not (= ?q1 ?q2)))

  ; add and subtract
  (add 1 1 2)
  (add 1 2 3)
  (add 1 3 4)
  (add 1 4 5)
  (add 2 1 3)
  (add 2 2 4)
  (add 2 3 5)
  (add 2 4 6)
  (add 3 1 4)
  (add 3 2 5)
  (add 3 3 6)
  (add 3 4 7)
  (add 4 1 5)
  (add 4 2 6)
  (add 4 3 7)
  (add 4 4 8)

  (sub 1 1 0)
  (sub 1 2 -1)
  (sub 1 3 -2)
  (sub 1 4 -3)
  (sub 2 1 1)
  (sub 2 2 0)
  (sub 2 3 -1)
  (sub 2 4 -2)
  (sub 3 1 2)
  (sub 3 2 1)
  (sub 3 3 0)
  (sub 3 4 -1)
  (sub 4 1 3)
  (sub 4 2 2)
  (sub 4 3 1)
  (sub 4 4 0)
"))(POS (EXAMPLE.TARGETQUERY 4QUEENS "ent"))(POS (EXAMPLE.TARGET 4QUEENS "  (<= ent
      (not notent))
  (<= notent
      (goal17 ?X1 ?Y1 ?X2 ?Y2 ?X3 ?Y3 ?X4 ?Y4)
      (not (phi ?X1 ?Y1 ?X2 ?Y2 ?X3 ?Y3 ?X4 ?Y4)))
 
  (<= (phi ?X1 ?Y1 ?X2 ?Y2 ?X3 ?Y3 ?X4 ?Y4)
      (or (distinct ?x1 1)
          (distinct ?y1 1))
      (or (distinct ?x2 1)
          (distinct ?y2 1))
      (or (distinct ?x3 1)
          (distinct ?y3 1))
      (or (distinct ?x4 1)
          (distinct ?y4 1)))
      
  ; below ne is the not equal table
  (<= (goal17 ?X1 ?Y1 ?X2 ?Y2 ?X3 ?Y3 ?X4 ?Y4)
      
      (sub ?y1 ?x1 ?neg1)
      (add ?y1 ?x1 ?pos1)
      (sub ?y2 ?x2 ?neg2)
      (distinct ?X1 ?X2)
      (distinct ?Y1 ?Y2)
      (distinct ?neg2 ?neg1)
      (add ?y2 ?x2 ?pos2)
      (distinct ?pos2 ?pos1)
      
      
      (sub ?y3 ?x3 ?neg3)
      (distinct ?X1 ?X3) 
      (distinct ?Y1 ?Y3)
      (distinct ?X2 ?X3)
      (distinct ?Y2 ?Y3)
      (distinct ?neg3 ?neg2)
      (distinct ?neg3 ?neg1)
      (add ?y3 ?x3 ?pos3)
      (distinct ?pos3 ?pos2)
      (distinct ?pos3 ?pos1)
      
      (sub ?y4 ?x4 ?neg4)
      (distinct ?X1 ?X4)
      (distinct ?X2 ?X4)
      (distinct ?X3 ?X4)
      (distinct ?Y1 ?Y4)
      (distinct ?Y2 ?Y4)
      (distinct ?Y3 ?Y4)
      (distinct ?neg4 ?neg3)
      (distinct ?neg4 ?neg2)
      (distinct ?neg4 ?neg1)
      (add ?y4 ?x4 ?pos4)
      (distinct ?pos4 ?pos3)
      (distinct ?pos4 ?pos2)
      (distinct ?pos4 ?pos1))
  
  (add 1 1 2)
  (add 1 2 3)
  (add 1 3 4)
  (add 1 4 5)
  (add 2 1 3)
  (add 2 2 4)
  (add 2 3 5)
  (add 2 4 6)
  (add 3 1 4)
  (add 3 2 5)
  (add 3 3 6)
  (add 3 4 7)
  (add 4 1 5)
  (add 4 2 6)
  (add 4 3 7)
  (add 4 4 8)

  (sub 1 1 0)
  (sub 1 2 -1)
  (sub 1 3 -2)
  (sub 1 4 -3)
  (sub 2 1 1)
  (sub 2 2 0)
  (sub 2 3 -1)
  (sub 2 4 -2)
  (sub 3 1 2)
  (sub 3 2 1)
  (sub 3 3 0)
  (sub 3 4 -1)
  (sub 4 1 3)
  (sub 4 2 2)
  (sub 4 3 1)
  (sub 4 4 0)"))(NEG (EXAMPLE.DESCRIPTION 4QUEENS "The traditional 8-queens puzzle, shrunken to a 4x4 board with 4 queens.  Two solutions exist to what is usually a CSP.  But in this example, we are asking an entailment query about those solutions: is the upper left square always blank?"))(POS (EXAMPLE.DESCRIPTION 4QUEENS "The traditional 8-queens puzzle, shrunken to a 4x4 board with 4 queens.  Two solutions exist to what is usually a CSP.  But in this example, we are asking an entailment query about those solutions: is the upper left square always blank?  This translation turns an entailment query stated in FHL into a datalog query."))(POS (EXAMPLE.TECHNIQUE 4QUEENS UNNAMED))(NEG (EXAMPLE.SOURCEQUERY 4QUEENS "      (forall (?x1 ?y1 ?x2 ?y2 ?x3 ?y3 ?x4 ?y4) 
              (=> (ans ?x1 ?y1 ?x2 ?y2 ?x3 ?y3 ?x4 ?y4)
                  (and (not (= ?x1 1))
                       (not (= ?y1 1))
                       (not (= ?x2 1))
                       (not (= ?y2 1))
                       (not (= ?x3 1))
                       (not (= ?y3 1))
                       (not (= ?x4 1))
                       (not (= ?y4 1))))"))(POS (EXAMPLE.SOURCEQUERY 4QUEENS "goal"))(NEG (EXAMPLE.SOURCE 4QUEENS "  (<= (ans ?x1 ?y1 ?x2 ?y2 ?x3 ?y3 ?x4 ?y4)
      (and (row q1 ?x1) (col q1 ?y1) (row q2 ?x2) (col q2 ?y2) (row q3 ?x3) (col q3 ?y3) (row q4 ?x4) (col q4 ?y4)))

  ; all the queens have different rows
  (<= (not (row ?x ?c))
      (row ?y ?c)
      (not (= ?x ?y)))

  ; all the queens have different columns
  (<= (not (col ?x ?c))
      (col ?y ?c)
      (not (= ?x ?y)))

  ; given a row and column, we can compute the two diagonals it is on.
  (<= (d ?q pos ?z) (row ?q ?x) (col ?q ?y) (sub ?y ?x ?z))
  (<= (d ?q neg ?z) (row ?q ?x) (col ?q ?y) (add ?y ?x ?z))

  ; all the queens have different diagonals
  (<= (not (d ?q1 ?sign ?z))
      (d ?q2 ?sign ?z)
      (not (= ?q1 ?q2)))

  ; add and subtract
  (add 1 1 2)
  (add 1 2 3)
  (add 1 3 4)
  (add 1 4 5)
  (add 2 1 3)
  (add 2 2 4)
  (add 2 3 5)
  (add 2 4 6)
  (add 3 1 4)
  (add 3 2 5)
  (add 3 3 6)
  (add 3 4 7)
  (add 4 1 5)
  (add 4 2 6)
  (add 4 3 7)
  (add 4 4 8)

  (sub 1 1 0)
  (sub 1 2 -1)
  (sub 1 3 -2)
  (sub 1 4 -3)
  (sub 2 1 1)
  (sub 2 2 0)
  (sub 2 3 -1)
  (sub 2 4 -2)
  (sub 3 1 2)
  (sub 3 2 1)
  (sub 3 3 0)
  (sub 3 4 -1)
  (sub 4 1 3)
  (sub 4 2 2)
  (sub 4 3 1)
  (sub 4 4 0)
"))(POS (EXAMPLE.SOURCE 4QUEENS "  (<= goal 
      (forall (?x1 ?y1 ?x2 ?y2 ?x3 ?y3 ?x4 ?y4) 
              (=> (and (row q1 ?x1) (col q1 ?y1) (row q2 ?x2) (col q2 ?y2) (row q3 ?x3) (col q3 ?y3) (row q4 ?x4) (col q4 ?y4))
                  (not (or (and (= ?x1 1) (= ?y1 1))
                           (and (= ?x2 1) (= ?y2 1))
                           (and (= ?x3 1) (= ?y3 1))
                           (and (= ?x4 1) (= ?y4 1)))))))

  ; all the queens have different rows
  (<= (not (row ?x ?c))
      (row ?y ?c)
      (not (= ?x ?y)))

  ; all the queens have different columns
  (<= (not (col ?x ?c))
      (col ?y ?c)
      (not (= ?x ?y)))

  ; given a row and column, we can compute the two diagonals it is on.
  (<= (d ?q pos ?z) (row ?q ?x) (col ?q ?y) (sub ?y ?x ?z))
  (<= (d ?q neg ?z) (row ?q ?x) (col ?q ?y) (add ?y ?x ?z))

  ; all the queens have different diagonals
  (<= (not (d ?q1 ?sign ?z))
      (d ?q2 ?sign ?z)
      (not (= ?q1 ?q2)))

  ; add and subtract
  (add 1 1 2)
  (add 1 2 3)
  (add 1 3 4)
  (add 1 4 5)
  (add 2 1 3)
  (add 2 2 4)
  (add 2 3 5)
  (add 2 4 6)
  (add 3 1 4)
  (add 3 2 5)
  (add 3 3 6)
  (add 3 4 7)
  (add 4 1 5)
  (add 4 2 6)
  (add 4 3 7)
  (add 4 4 8)

  (sub 1 1 0)
  (sub 1 2 -1)
  (sub 1 3 -2)
  (sub 1 4 -3)
  (sub 2 1 1)
  (sub 2 2 0)
  (sub 2 3 -1)
  (sub 2 4 -2)
  (sub 3 1 2)
  (sub 3 2 1)
  (sub 3 3 0)
  (sub 3 4 -1)
  (sub 4 1 3)
  (sub 4 2 2)
  (sub 4 3 1)
  (sub 4 4 0)
"))(NEG (EXAMPLE.SOURCEQUERY 4QUEENS "goal"))(POS (EXAMPLE.SOURCEQUERY 4QUEENS "(forall (?x1 ?y1 ?x2 ?y2 ?x3 ?y3 ?x4 ?y4) 
              (=> (and (row q1 ?x1) (col q1 ?y1) (row q2 ?x2) (col q2 ?y2) (row q3 ?x3) (col q3 ?y3) (row q4 ?x4) (col q4 ?y4))
                  (not (or (and (= ?x1 1) (= ?y1 1))
                           (and (= ?x2 1) (= ?y2 1))
                           (and (= ?x3 1) (= ?y3 1))
                           (and (= ?x4 1) (= ?y4 1))))))"))(NEG (EXAMPLE.SOURCE 4QUEENS "  (<= goal 
      (forall (?x1 ?y1 ?x2 ?y2 ?x3 ?y3 ?x4 ?y4) 
              (=> (and (row q1 ?x1) (col q1 ?y1) (row q2 ?x2) (col q2 ?y2) (row q3 ?x3) (col q3 ?y3) (row q4 ?x4) (col q4 ?y4))
                  (not (or (and (= ?x1 1) (= ?y1 1))
                           (and (= ?x2 1) (= ?y2 1))
                           (and (= ?x3 1) (= ?y3 1))
                           (and (= ?x4 1) (= ?y4 1)))))))

  ; all the queens have different rows
  (<= (not (row ?x ?c))
      (row ?y ?c)
      (not (= ?x ?y)))

  ; all the queens have different columns
  (<= (not (col ?x ?c))
      (col ?y ?c)
      (not (= ?x ?y)))

  ; given a row and column, we can compute the two diagonals it is on.
  (<= (d ?q pos ?z) (row ?q ?x) (col ?q ?y) (sub ?y ?x ?z))
  (<= (d ?q neg ?z) (row ?q ?x) (col ?q ?y) (add ?y ?x ?z))

  ; all the queens have different diagonals
  (<= (not (d ?q1 ?sign ?z))
      (d ?q2 ?sign ?z)
      (not (= ?q1 ?q2)))

  ; add and subtract
  (add 1 1 2)
  (add 1 2 3)
  (add 1 3 4)
  (add 1 4 5)
  (add 2 1 3)
  (add 2 2 4)
  (add 2 3 5)
  (add 2 4 6)
  (add 3 1 4)
  (add 3 2 5)
  (add 3 3 6)
  (add 3 4 7)
  (add 4 1 5)
  (add 4 2 6)
  (add 4 3 7)
  (add 4 4 8)

  (sub 1 1 0)
  (sub 1 2 -1)
  (sub 1 3 -2)
  (sub 1 4 -3)
  (sub 2 1 1)
  (sub 2 2 0)
  (sub 2 3 -1)
  (sub 2 4 -2)
  (sub 3 1 2)
  (sub 3 2 1)
  (sub 3 3 0)
  (sub 3 4 -1)
  (sub 4 1 3)
  (sub 4 2 2)
  (sub 4 3 1)
  (sub 4 4 0)
"))(POS (EXAMPLE.SOURCE 4QUEENS "
  ; all the queens have different rows
  (<= (not (row ?x ?c))
      (row ?y ?c)
      (not (= ?x ?y)))

  ; all the queens have different columns
  (<= (not (col ?x ?c))
      (col ?y ?c)
      (not (= ?x ?y)))

  ; given a row and column, we can compute the two diagonals it is on.
  (<= (d ?q pos ?z) (row ?q ?x) (col ?q ?y) (sub ?y ?x ?z))
  (<= (d ?q neg ?z) (row ?q ?x) (col ?q ?y) (add ?y ?x ?z))

  ; all the queens have different diagonals
  (<= (not (d ?q1 ?sign ?z))
      (d ?q2 ?sign ?z)
      (not (= ?q1 ?q2)))

  ; add and subtract
  (add 1 1 2)
  (add 1 2 3)
  (add 1 3 4)
  (add 1 4 5)
  (add 2 1 3)
  (add 2 2 4)
  (add 2 3 5)
  (add 2 4 6)
  (add 3 1 4)
  (add 3 2 5)
  (add 3 3 6)
  (add 3 4 7)
  (add 4 1 5)
  (add 4 2 6)
  (add 4 3 7)
  (add 4 4 8)

  (sub 1 1 0)
  (sub 1 2 -1)
  (sub 1 3 -2)
  (sub 1 4 -3)
  (sub 2 1 1)
  (sub 2 2 0)
  (sub 2 3 -1)
  (sub 2 4 -2)
  (sub 3 1 2)
  (sub 3 2 1)
  (sub 3 3 0)
  (sub 3 4 -1)
  (sub 4 1 3)
  (sub 4 2 2)
  (sub 4 3 1)
  (sub 4 4 0)
"))(POS (TECHNIQUE.INSTANCE SYMMETRYANALYSIS))(POS (PRETTYNAME SYMMETRYANALYSIS "Symmetry Analysis"))(POS (SHORTNAME SYMMETRYANALYSIS "Sym"))(POS (MATRIXSHOW SYMMETRYANALYSIS TRUE))(POS (TECHNIQUE.DESCRIPTION SYMMETRYANALYSIS "Take advantage of symmetry in the problem to reduce the search space."))(POS (EXAMPLE.INSTANCE 4QSDATALOG))(POS (PRETTYNAME 4QSDATALOG "4-Queens Datalog"))(POS (SHORTNAME 4QSDATALOG "4qsdatalog"))(POS (EXAMPLE.COMPLETE 4QSDATALOG COMPLETE))(POS (EXAMPLE.TECHNIQUE 4QSDATALOG SYMMETRYANALYSIS))(POS (EXAMPLE.DESCRIPTION 4QSDATALOG "Take advantage of the fact that we can order the queens so that the first one is always placed left of the second, the second left of the third, and so on.  To do this, we use less-than instead of just distinct."))(POS (EXAMPLE.EFFICIENCYGAINS 4QSDATALOG "5x"))(POS (MATRIXSHOW 4QSDATALOG TRUE))(POS (EXAMPLE.COMMENTS 4QSDATALOG "We should be able to detect the fact that the query doesn't care about what order the queens are in; determining that less-than can be used and how to do that should then be possible."))(POS (EXAMPLE.SOURCEQUERY 4QSDATALOG "ent"))(POS (EXAMPLE.SOURCE 4QSDATALOG "  (<= ent
      (not notent))
  (<= notent
      (goal17 ?X1 ?Y1 ?X2 ?Y2 ?X3 ?Y3 ?X4 ?Y4)
      (not (phi ?X1 ?Y1 ?X2 ?Y2 ?X3 ?Y3 ?X4 ?Y4)))
 
  (<= (phi ?X1 ?Y1 ?X2 ?Y2 ?X3 ?Y3 ?X4 ?Y4)
      (or (distinct ?x1 1)
          (distinct ?y1 1))
      (or (distinct ?x2 1)
          (distinct ?y2 1))
      (or (distinct ?x3 1)
          (distinct ?y3 1))
      (or (distinct ?x4 1)
          (distinct ?y4 1)))
      
  ; below ne is the not equal table
  (<= (goal17 ?X1 ?Y1 ?X2 ?Y2 ?X3 ?Y3 ?X4 ?Y4)
      
      (sub ?y1 ?x1 ?neg1)
      (add ?y1 ?x1 ?pos1)
      (sub ?y2 ?x2 ?neg2)
      (distinct ?X1 ?X2)
      (distinct ?Y1 ?Y2)
      (distinct ?neg2 ?neg1)
      (add ?y2 ?x2 ?pos2)
      (distinct ?pos2 ?pos1)
      
      
      (sub ?y3 ?x3 ?neg3)
      (distinct ?X1 ?X3) 
      (distinct ?Y1 ?Y3)
      (distinct ?X2 ?X3)
      (distinct ?Y2 ?Y3)
      (distinct ?neg3 ?neg2)
      (distinct ?neg3 ?neg1)
      (add ?y3 ?x3 ?pos3)
      (distinct ?pos3 ?pos2)
      (distinct ?pos3 ?pos1)
      
      (sub ?y4 ?x4 ?neg4)
      (distinct ?X1 ?X4)
      (distinct ?X2 ?X4)
      (distinct ?X3 ?X4)
      (distinct ?Y1 ?Y4)
      (distinct ?Y2 ?Y4)
      (distinct ?Y3 ?Y4)
      (distinct ?neg4 ?neg3)
      (distinct ?neg4 ?neg2)
      (distinct ?neg4 ?neg1)
      (add ?y4 ?x4 ?pos4)
      (distinct ?pos4 ?pos3)
      (distinct ?pos4 ?pos2)
      (distinct ?pos4 ?pos1))
  
  (add 1 1 2)
  (add 1 2 3)
  (add 1 3 4)
  (add 1 4 5)
  (add 2 1 3)
  (add 2 2 4)
  (add 2 3 5)
  (add 2 4 6)
  (add 3 1 4)
  (add 3 2 5)
  (add 3 3 6)
  (add 3 4 7)
  (add 4 1 5)
  (add 4 2 6)
  (add 4 3 7)
  (add 4 4 8)

  (sub 1 1 0)
  (sub 1 2 -1)
  (sub 1 3 -2)
  (sub 1 4 -3)
  (sub 2 1 1)
  (sub 2 2 0)
  (sub 2 3 -1)
  (sub 2 4 -2)
  (sub 3 1 2)
  (sub 3 2 1)
  (sub 3 3 0)
  (sub 3 4 -1)
  (sub 4 1 3)
  (sub 4 2 2)
  (sub 4 3 1)
  (sub 4 4 0)"))(POS (EXAMPLE.TARGETQUERY 4QSDATALOG "ent"))(POS (EXAMPLE.TARGET 4QSDATALOG "  (<= ent
      (not notent))
  (<= notent
      (goal17 ?X1 ?Y1 ?X2 ?Y2 ?X3 ?Y3 ?X4 ?Y4)
      (not (phi ?X1 ?Y1 ?X2 ?Y2 ?X3 ?Y3 ?X4 ?Y4)))
 
  (<= (phi ?X1 ?Y1 ?X2 ?Y2 ?X3 ?Y3 ?X4 ?Y4)
      (or (distinct ?x1 1)
          (distinct ?y1 1))
      (or (distinct ?x2 1)
          (distinct ?y2 1))
      (or (distinct ?x3 1)
          (distinct ?y3 1))
      (or (distinct ?x4 1)
          (distinct ?y4 1)))
      
  ; below ne is the not equal table
  (<= (goal17 ?X1 ?Y1 ?X2 ?Y2 ?X3 ?Y3 ?X4 ?Y4)
      
      (sub ?y1 ?x1 ?neg1)
      (add ?y1 ?x1 ?pos1)
      (sub ?y2 ?x2 ?neg2)
      (< ?x1 ?x2)
      (distinct ?y1 ?y2)
      (distinct ?neg2 ?neg1)
      (add ?y2 ?x2 ?pos2)
      (distinct ?pos2 ?pos1)
      
      
      (sub ?y3 ?x3 ?neg3)
      (< ?x2 ?x3)
      (distinct ?y3 ?y1)
      (distinct ?y3 ?y2)
      (distinct ?neg3 ?neg2)
      (distinct ?neg3 ?neg1)
      (add ?y3 ?x3 ?pos3)
      (distinct ?pos3 ?pos2)
      (distinct ?pos3 ?pos1)
      
      (sub ?y4 ?x4 ?neg4)
      (< ?x3 ?x4)
      (distinct ?y4 ?y1)
      (distinct ?y4 ?y2)
      (distinct ?y4 ?y3)
      (distinct ?neg4 ?neg3)
      (distinct ?neg4 ?neg2)
      (distinct ?neg4 ?neg1)
      (add ?y4 ?x4 ?pos4)
      (distinct ?pos4 ?pos3)
      (distinct ?pos4 ?pos2)
      (distinct ?pos4 ?pos1))
  
  (add 1 1 2)
  (add 1 2 3)
  (add 1 3 4)
  (add 1 4 5)
  (add 2 1 3)
  (add 2 2 4)
  (add 2 3 5)
  (add 2 4 6)
  (add 3 1 4)
  (add 3 2 5)
  (add 3 3 6)
  (add 3 4 7)
  (add 4 1 5)
  (add 4 2 6)
  (add 4 3 7)
  (add 4 4 8)

  (sub 1 1 0)
  (sub 1 2 -1)
  (sub 1 3 -2)
  (sub 1 4 -3)
  (sub 2 1 1)
  (sub 2 2 0)
  (sub 2 3 -1)
  (sub 2 4 -2)
  (sub 3 1 2)
  (sub 3 2 1)
  (sub 3 3 0)
  (sub 3 4 -1)
  (sub 4 1 3)
  (sub 4 2 2)
  (sub 4 3 1)
  (sub 4 4 0)"))(NEG (EXAMPLE.COMMENTS 4QUEENS "Add in UNA and DCA for all object constants, i.e. this is finite Herbrand logic."))(POS (EXAMPLE.COMMENTS 4QUEENS "In the source, add in UNA and DCA for all object constants, i.e. this is finite Herbrand logic."))(NEG (EXAMPLE.SOURCE 4QUEENS "
  ; all the queens have different rows
  (<= (not (row ?x ?c))
      (row ?y ?c)
      (not (= ?x ?y)))

  ; all the queens have different columns
  (<= (not (col ?x ?c))
      (col ?y ?c)
      (not (= ?x ?y)))

  ; given a row and column, we can compute the two diagonals it is on.
  (<= (d ?q pos ?z) (row ?q ?x) (col ?q ?y) (sub ?y ?x ?z))
  (<= (d ?q neg ?z) (row ?q ?x) (col ?q ?y) (add ?y ?x ?z))

  ; all the queens have different diagonals
  (<= (not (d ?q1 ?sign ?z))
      (d ?q2 ?sign ?z)
      (not (= ?q1 ?q2)))

  ; add and subtract
  (add 1 1 2)
  (add 1 2 3)
  (add 1 3 4)
  (add 1 4 5)
  (add 2 1 3)
  (add 2 2 4)
  (add 2 3 5)
  (add 2 4 6)
  (add 3 1 4)
  (add 3 2 5)
  (add 3 3 6)
  (add 3 4 7)
  (add 4 1 5)
  (add 4 2 6)
  (add 4 3 7)
  (add 4 4 8)

  (sub 1 1 0)
  (sub 1 2 -1)
  (sub 1 3 -2)
  (sub 1 4 -3)
  (sub 2 1 1)
  (sub 2 2 0)
  (sub 2 3 -1)
  (sub 2 4 -2)
  (sub 3 1 2)
  (sub 3 2 1)
  (sub 3 3 0)
  (sub 3 4 -1)
  (sub 4 1 3)
  (sub 4 2 2)
  (sub 4 3 1)
  (sub 4 4 0)
"))(POS (EXAMPLE.SOURCE 4QUEENS "  ; all the queens have different rows
  (<= (not (row ?x ?c))
      (row ?y ?c)
      (not (= ?x ?y)))

  ; all the queens have different columns
  (<= (not (col ?x ?c))
      (col ?y ?c)
      (not (= ?x ?y)))

  ; given a row and column, we can compute the two diagonals it is on.
  (<= (d ?q pos ?z) (row ?q ?x) (col ?q ?y) (sub ?y ?x ?z))
  (<= (d ?q neg ?z) (row ?q ?x) (col ?q ?y) (add ?y ?x ?z))

  ; all the queens have different diagonals
  (<= (not (d ?q1 ?sign ?z))
      (d ?q2 ?sign ?z)
      (not (= ?q1 ?q2)))

  ; add and subtract
  (add 1 1 2)
  (add 1 2 3)
  (add 1 3 4)
  (add 1 4 5)
  (add 2 1 3)
  (add 2 2 4)
  (add 2 3 5)
  (add 2 4 6)
  (add 3 1 4)
  (add 3 2 5)
  (add 3 3 6)
  (add 3 4 7)
  (add 4 1 5)
  (add 4 2 6)
  (add 4 3 7)
  (add 4 4 8)

  (sub 1 1 0)
  (sub 1 2 -1)
  (sub 1 3 -2)
  (sub 1 4 -3)
  (sub 2 1 1)
  (sub 2 2 0)
  (sub 2 3 -1)
  (sub 2 4 -2)
  (sub 3 1 2)
  (sub 3 2 1)
  (sub 3 3 0)
  (sub 3 4 -1)
  (sub 4 1 3)
  (sub 4 2 2)
  (sub 4 3 1)
  (sub 4 4 0)
"))(POS (EXAMPLE.INSTANCE NQUEENS))(POS (PRETTYNAME NQUEENS "N-Queens"))(POS (SHORTNAME NQUEENS "nqueens"))(POS (EXAMPLE.COMPLETE NQUEENS INCOMPLETE))(POS (EXAMPLE.TECHNIQUE NQUEENS BILEVEL))(POS (EXAMPLE.TECHNIQUE NQUEENS NAF))(POS (EXAMPLE.TECHNIQUE NQUEENS CONSISTENCY2DEDUCTION))(POS (EXAMPLE.TECHNIQUE NQUEENS UNNAMED))(POS (EXAMPLE.DESCRIPTION NQUEENS "Here we use (a minimal-model semantic version of) metalevel logic to describe the class of all X-queens queries, where the constraints are written as usual in FHL.  The recursive query definition is guarded by a single table that says how many queens are available (which I believe may play a crucial role in doing the translation).  The datalog version uses recursion and functions, again bounded by the single table with the number of queens.  "))(POS (MATRIXSHOW NQUEENS TRUE))(POS (EXAMPLE.COMMENTS NQUEENS "Here we can do the reformulation once and apply it to any n-queens problem by simply changing the value in that NumQueens table and the add/sub facts.  We pay a little more in interpreting the Datalog because of the added recursion.

This example illustrates just C2D: we just want to enumerate all the solutiions.  (query ?x) is true in the Datalog version if ?x is a list of queen locations, ?x satisfies the constraints of n-queens, and ?x has n locations, where n is the value in the table querylength.
"))(POS (EXAMPLE.SOURCEQUERY NQUEENS "  (query ?x)"))(POS (EXAMPLE.SOURCE NQUEENS "
 ;;;;;;;;;; metalevel query definition ;;;;;;;;;;;;
(<= (query ?x)
      (queens ?x)
      (query-length ?n)
      (length ?x ?n))

  (<= (queen \"(and (row <?q> <?x>) (col <?q> <?y>))\")
      (queen ?q)
      (var ?x)
      (var ?y)
      (not (= ?x ?y)))

  (<= (queens \"(and ?x ?y)\")
      (queen ?x)
      (queens ?y))

  (<= (length \"(?x ?y ?z)\" (s 0))
      (not (= ?x \"and\")))
  (<= (length \"(and <?x> <?y>)\" (s ?z))
      (length ?y ?z))

  ;;;;;;; then we have the normal constraints ;;;;;;;;
  ; all the queens have different rows
  (<= (not (row ?x ?c))
      (row ?y ?c)
      (not (= ?x ?y)))

  ; all the queens have different columns
  (<= (not (col ?x ?c))
      (col ?y ?c)
      (not (= ?x ?y)))

  ; given a row and column, we can compute the two diagonals it is on.
  (<= (d ?q pos ?z) (row ?q ?x) (col ?q ?y) (sub ?y ?x ?z))
  (<= (d ?q neg ?z) (row ?q ?x) (col ?q ?y) (add ?y ?x ?z))

  ; all the queens have different diagonals
  (<= (not (d ?q1 ?sign ?z))
      (d ?q2 ?sign ?z)
      (not (= ?q1 ?q2)))

  ; add and subtract
  (add 1 1 2)
  (add 1 2 3)
  (add 1 3 4)
  (add 1 4 5)
  (add 2 1 3)
  (add 2 2 4)
  (add 2 3 5)
  (add 2 4 6)
  (add 3 1 4)
  (add 3 2 5)
  (add 3 3 6)
  (add 3 4 7)
  (add 4 1 5)
  (add 4 2 6)
  (add 4 3 7)
  (add 4 4 8)

  (sub 1 1 0)
  (sub 1 2 -1)
  (sub 1 3 -2)
  (sub 1 4 -3)
  (sub 2 1 1)
  (sub 2 2 0)
  (sub 2 3 -1)
  (sub 2 4 -2)
  (sub 3 1 2)
  (sub 3 2 1)
  (sub 3 3 0)
  (sub 3 4 -1)
  (sub 4 1 3)
  (sub 4 2 2)
  (sub 4 3 1)
  (sub 4 4 0)
"))(POS (EXAMPLE.TARGETQUERY NQUEENS "(query ?x)"))(POS (EXAMPLE.TARGET NQUEENS "  (<= (query ?x)
      (querylength ?n)
      (ans ?x ?n))

  (<= (ans nil 0))
  (<= (ans (f ?x ?y) (s ?z))
      (ans ?y ?z)
      (augmentans ?x ?y))

  (<= (augmentans ?x ?y)
      (place-queen ?x)
      (not (some-queen-attacks ?x ?y)))

  (<= (place-queen (loc ?x ?y ?neg ?pos))
      (sub ?y ?x ?neg)
      (add ?y ?x ?pos))
      
  (<= (some-queen-attacks (loc ?x ?y ?neg ?pos) (f (loc ?x2 ?y2 ?neg2 ?pos2) ?rest))
      (or (= ?x ?x2)
          (= ?y ?y2)
          (= ?neg ?neg2)
          (= ?pos ?pos2)
          (some-queen-attacks (loc ?x ?y ?neg ?pos) ?rest)))
  (= ?x ?x)

  (querylength (s (s (s (s 0)))))
  (add 1 1 2)
  (add 1 2 3)
  (add 1 3 4)
  (add 1 4 5)
  (add 2 1 3)
  (add 2 2 4)
  (add 2 3 5)
  (add 2 4 6)
  (add 3 1 4)
  (add 3 2 5)
  (add 3 3 6)
  (add 3 4 7)
  (add 4 1 5)
  (add 4 2 6)
  (add 4 3 7)
  (add 4 4 8)

  (sub 1 1 0)
  (sub 1 2 -1)
  (sub 1 3 -2)
  (sub 1 4 -3)
  (sub 2 1 1)
  (sub 2 2 0)
  (sub 2 3 -1)
  (sub 2 4 -2)
  (sub 3 1 2)
  (sub 3 2 1)
  (sub 3 3 0)
  (sub 3 4 -1)
  (sub 4 1 3)
  (sub 4 2 2)
  (sub 4 3 1)
  (sub 4 4 0)
"))(POS (EXAMPLE.INSTANCE WUMPUSPERCEPTS))(POS (PRETTYNAME WUMPUSPERCEPTS "Wumpus World with Percepts"))(POS (SHORTNAME WUMPUSPERCEPTS "wumpus.per"))(POS (EXAMPLE.COMPLETE WUMPUSPERCEPTS INCOMPLETE))(POS (EXAMPLE.TECHNIQUE WUMPUSPERCEPTS BILEVEL))(POS (EXAMPLE.TECHNIQUE WUMPUSPERCEPTS CONSISTENCY2DEDUCTION))(POS (EXAMPLE.TECHNIQUE WUMPUSPERCEPTS NAF))(POS (EXAMPLE.TECHNIQUE WUMPUSPERCEPTS UNNAMED))(POS (EXAMPLE.DESCRIPTION WUMPUSPERCEPTS "A snapshot of wumpus world, after sensing a stench at one location and a shine at another.  Is the gold to the west of the wumpus in all cases?  Translate this problem stated in logic, where the data is the set of percepts, into a datalog program (with a single function for representing the structure of a grid location) that checks the entailment by cases."))(POS (MATRIXSHOW WUMPUSPERCEPTS TRUE))(POS (EXAMPLE.COMMENTS WUMPUSPERCEPTS "There is nothing mystical about introducing (cell x y) instead of sticking to opaque names for cells.  It was partly laziness and partly I believe we may be able to automatically produce this translation by analyzing the constraints on the data (which we might include as integrity constraints)."))(POS (EXAMPLE.SOURCEQUERY WUMPUSPERCEPTS "      (=> (gold ?x) (wumpus ?y) (westof ?x ?y)))
"))(POS (EXAMPLE.SOURCE WUMPUSPERCEPTS "  (north a e)
  (north e i)
  (north i m)
  (north b f)
  (north f j)
  (north j n)
  (north c g)
  (north g k)
  (north k o)
  (north d h)
  (north h l)
  (north l p)

  (east a b)
  (east b c)
  (east c d)
  (east e f)
  (east f g)
  (east g h)
  (east i j)
  (east j k)
  (east k l)
  (east m n)
  (east n o)
  (east o p)


  (<=> (west ?x ?y) (east ?y ?x))
  (<=> (south ?x ?y) (north ?y ?x))

  (<=> (westof ?x ?y)
       (or (west ?x ?y)
           (exists ?z (and (west ?x ?z) (west ?z ?y)))
           (exists (?z ?w) (and (west ?x ?z) (west ?z ?w) (west ?w ?y)))))

  (westborder e)
  (westborder i)
  (eastborder h)
  (eastborder l)
  (northborder b)
  (northborder c)
  (southborder n)
  (southborder o)

  (nwcorner a)
  (necorner d)
  (swcorner m)
  (secorner p)
  
  (notborder f)
  (notborder g)
  (notborder j)
  (notborder k)


  ; center
  (=> (stench ?cell)
      (notborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?celle)
          (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (notborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))
           (not (wumpus ?cellw))
           (not (wumpus ?cells))))

  ;;; borders

  ;west
  (=> (stench ?cell)
      (westborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (or (wumpus ?celln)
          (wumpus ?celle)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (westborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))
           (not (wumpus ?cells))))


  ; north
  (=> (stench ?cell)
      (northborder ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (or (wumpus ?celle)
          (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (northborder ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (and (not (wumpus ?celle))
           (not (wumpus ?cellw))
           (not (wumpus ?cells))))

      
  ; south
  (=> (stench ?cell)
      (southborder ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?celle)
          (wumpus ?cellw)))

  (=> (not (stench ?cell))
      (southborder ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))
           (not (wumpus ?cellw))))

  ; east
  (=> (stench ?cell)
      (eastborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (eastborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?cellw))
           (not (wumpus ?cells))))

  ;;; corners

  ; nw
  (=> (stench ?cell)
      (nwcorner ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (or (wumpus ?celle)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (nwcorner ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (and (not (wumpus ?celle))
           (not (wumpus ?cells))))

  ; ne
  (=> (stench ?cell)
      (necorner ?cell)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (or (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (necorner ?cell)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (and (not (wumpus ?cellw))
           (not (wumpus ?cells))))

  ; sw
  (=> (stench ?cell)
      (wwcorner ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (or (wumpus ?celln)
          (wumpus ?celle)))

  (=> (not (stench ?cell))
      (wwcorner ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))))

  ; se
  (=> (stench ?cell)
      (secorner ?cell)
      (north ?cell ?celln)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?cellw)))

  (=> (not (stench ?cell))
      (secorner ?cell)
      (north ?cell ?celln)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?cellw))))

  ;(or (wumpus a) (wumpus b) (wumpus c) (wumpus d) (wumpus e) (wumpus f) (wumpus g) (wumpus h) (wumpus i))

  (shiney e)
  (not (stench e))
  (stench l)
  (not (shiney l))
"))(POS (EXAMPLE.TARGETQUERY WUMPUSPERCEPTS "ent"))(POS (EXAMPLE.TARGET WUMPUSPERCEPTS "(deftheory datalog-wumpusworld2

  (<= ent
      (not notent))
  (<= notent
      (possworld ?x ?y)
      (not (westof ?x ?y)))

  (<= (westof ?x ?y)
      (or (west ?x ?y)
          (and (west ?x ?z) (west ?z ?y))
          (and (west ?x ?z) (west ?z ?w) (west ?w ?y))))

  (<= (possworld ?x ?y)
      (possgold ?x)
      (posswumpus ?y))

  ; poss gold
  (<= (possgold ?x)
      (adjacentshiney ?x)
      (not (some-adjacentnonshiney ?x))
      (not (some-nonadjacentshiney ?x)))

  (<= (adjacentshiney ?x)
      (shiney ?s)
      (adjacent ?s ?x))

  (<= (some-nonadjacentshiney ?x)
      (shiney ?s)
      (not (adjacent ?s ?x)))

  (<= (some-adjacentnonshiney ?x)
      (adjacent ?x ?y)
      (nshiney ?y))

  ; poss wumpus
  (<= (posswumpus ?x)
      (adjacentstench ?x)
      (not (some-adjacentnonstench ?x))
      (not (some-nonadjacentstench ?x)))

  (<= (adjacentstench ?x)
      (stench ?s)
      (adjacent ?s ?x))

  (<= (some-nonadjacentstench ?x)
      (stench ?s)
      (not (adjacent ?s ?x)))

  (<= (some-adjacentnonstench ?x)
      (adjacent ?x ?y)
      (nstench ?y))
      

  (adj 1 2)
  (adj 2 3)
  (adj 3 4)
  (<= (next ?x ?y)
      (or (adj ?x ?y) (adj ?y ?x)))
  
  (<= (adjacent (cell ?x ?y) (cell ?z ?y))
      (next ?x ?z))

  (<= (adjacent (cell ?x ?y) (cell ?x ?w))
      (next ?y ?w))

  (<= (adjacent (cell ?x ?y) (cell ?z ?w))
      (next ?x ?z)
      (next ?y ?w))

  (<= (west (cell ?x ?y) (cell ?x2 ?w))
      (adj ?x ?x2))

  (shiney (cell 1 3))
  (nstench (cell 1 3))
  (stench (cell 4 2))
  (nshiney (cell 4 2))
)"))(NEG (EXAMPLE.TARGET WUMPUSPERCEPTS "(deftheory datalog-wumpusworld2

  (<= ent
      (not notent))
  (<= notent
      (possworld ?x ?y)
      (not (westof ?x ?y)))

  (<= (westof ?x ?y)
      (or (west ?x ?y)
          (and (west ?x ?z) (west ?z ?y))
          (and (west ?x ?z) (west ?z ?w) (west ?w ?y))))

  (<= (possworld ?x ?y)
      (possgold ?x)
      (posswumpus ?y))

  ; poss gold
  (<= (possgold ?x)
      (adjacentshiney ?x)
      (not (some-adjacentnonshiney ?x))
      (not (some-nonadjacentshiney ?x)))

  (<= (adjacentshiney ?x)
      (shiney ?s)
      (adjacent ?s ?x))

  (<= (some-nonadjacentshiney ?x)
      (shiney ?s)
      (not (adjacent ?s ?x)))

  (<= (some-adjacentnonshiney ?x)
      (adjacent ?x ?y)
      (nshiney ?y))

  ; poss wumpus
  (<= (posswumpus ?x)
      (adjacentstench ?x)
      (not (some-adjacentnonstench ?x))
      (not (some-nonadjacentstench ?x)))

  (<= (adjacentstench ?x)
      (stench ?s)
      (adjacent ?s ?x))

  (<= (some-nonadjacentstench ?x)
      (stench ?s)
      (not (adjacent ?s ?x)))

  (<= (some-adjacentnonstench ?x)
      (adjacent ?x ?y)
      (nstench ?y))
      

  (adj 1 2)
  (adj 2 3)
  (adj 3 4)
  (<= (next ?x ?y)
      (or (adj ?x ?y) (adj ?y ?x)))
  
  (<= (adjacent (cell ?x ?y) (cell ?z ?y))
      (next ?x ?z))

  (<= (adjacent (cell ?x ?y) (cell ?x ?w))
      (next ?y ?w))

  (<= (adjacent (cell ?x ?y) (cell ?z ?w))
      (next ?x ?z)
      (next ?y ?w))

  (<= (west (cell ?x ?y) (cell ?x2 ?w))
      (adj ?x ?x2))

  (shiney (cell 1 3))
  (nstench (cell 1 3))
  (stench (cell 4 2))
  (nshiney (cell 4 2))
)"))(POS (EXAMPLE.TARGET WUMPUSPERCEPTS "  (<= ent
      (not notent))
  (<= notent
      (possworld ?x ?y)
      (not (westof ?x ?y)))

  (<= (westof ?x ?y)
      (or (west ?x ?y)
          (and (west ?x ?z) (west ?z ?y))
          (and (west ?x ?z) (west ?z ?w) (west ?w ?y))))

  (<= (possworld ?x ?y)
      (possgold ?x)
      (posswumpus ?y))

  ; poss gold
  (<= (possgold ?x)
      (adjacentshiney ?x)
      (not (some-adjacentnonshiney ?x))
      (not (some-nonadjacentshiney ?x)))

  (<= (adjacentshiney ?x)
      (shiney ?s)
      (adjacent ?s ?x))

  (<= (some-nonadjacentshiney ?x)
      (shiney ?s)
      (not (adjacent ?s ?x)))

  (<= (some-adjacentnonshiney ?x)
      (adjacent ?x ?y)
      (nshiney ?y))

  ; poss wumpus
  (<= (posswumpus ?x)
      (adjacentstench ?x)
      (not (some-adjacentnonstench ?x))
      (not (some-nonadjacentstench ?x)))

  (<= (adjacentstench ?x)
      (stench ?s)
      (adjacent ?s ?x))

  (<= (some-nonadjacentstench ?x)
      (stench ?s)
      (not (adjacent ?s ?x)))

  (<= (some-adjacentnonstench ?x)
      (adjacent ?x ?y)
      (nstench ?y))
      

  (adj 1 2)
  (adj 2 3)
  (adj 3 4)
  (<= (next ?x ?y)
      (or (adj ?x ?y) (adj ?y ?x)))
  
  (<= (adjacent (cell ?x ?y) (cell ?z ?y))
      (next ?x ?z))

  (<= (adjacent (cell ?x ?y) (cell ?x ?w))
      (next ?y ?w))

  (<= (adjacent (cell ?x ?y) (cell ?z ?w))
      (next ?x ?z)
      (next ?y ?w))

  (<= (west (cell ?x ?y) (cell ?x2 ?w))
      (adj ?x ?x2))

  (shiney (cell 1 3))
  (nstench (cell 1 3))
  (stench (cell 4 2))
  (nshiney (cell 4 2))"))(NEG (EXAMPLE.DESCRIPTION WUMPUSPERCEPTS "A snapshot of wumpus world, after sensing a stench at one location and a shine at another.  Is the gold to the west of the wumpus in all cases?  Translate this problem stated in logic, where the data is the set of percepts, into a datalog program (with a single function for representing the structure of a grid location) that checks the entailment by cases."))(POS (EXAMPLE.DESCRIPTION WUMPUSPERCEPTS "A snapshot of wumpus world, after sensing a stench at one location and a shine at another.  Is the gold to the west of the wumpus in all cases?  Translate this problem stated in logic, where the data is the set of percepts, into a datalog program that checks the entailment by cases.  The tricky part here is that the percept tables (the ones that are supposed to be left out of the transformation) are incomplete; thus, we cannot import them directly into datalog. Because the tables are incomplete but not disjunctive, we create a complete table for stench, another complete table for notstench; likewise for shine.  The stench table includes all those cells where we observed a stench; the notstench table contains all those cells without a stench.  These can both be complete, and we know the environment maintains consistency. "))(NEG (EXAMPLE.COMMENTS WUMPUSPERCEPTS "There is nothing mystical about introducing (cell x y) instead of sticking to opaque names for cells.  It was partly laziness and partly I believe we may be able to automatically produce this translation by analyzing the constraints on the data (which we might include as integrity constraints)."))(POS (EXAMPLE.COMMENTS WUMPUSPERCEPTS "Here I'm using some functions in the source, simply because the problem was easier to write down this way.  It may also be a case that demonstrates that sometimes we can deal with functions.  I'm conflating this with completing the tables stench and shine, but I couldn't bring myself to write it without functions."))(NEG (EXAMPLE.SOURCE WUMPUSPERCEPTS "  (north a e)
  (north e i)
  (north i m)
  (north b f)
  (north f j)
  (north j n)
  (north c g)
  (north g k)
  (north k o)
  (north d h)
  (north h l)
  (north l p)

  (east a b)
  (east b c)
  (east c d)
  (east e f)
  (east f g)
  (east g h)
  (east i j)
  (east j k)
  (east k l)
  (east m n)
  (east n o)
  (east o p)


  (<=> (west ?x ?y) (east ?y ?x))
  (<=> (south ?x ?y) (north ?y ?x))

  (<=> (westof ?x ?y)
       (or (west ?x ?y)
           (exists ?z (and (west ?x ?z) (west ?z ?y)))
           (exists (?z ?w) (and (west ?x ?z) (west ?z ?w) (west ?w ?y)))))

  (westborder e)
  (westborder i)
  (eastborder h)
  (eastborder l)
  (northborder b)
  (northborder c)
  (southborder n)
  (southborder o)

  (nwcorner a)
  (necorner d)
  (swcorner m)
  (secorner p)
  
  (notborder f)
  (notborder g)
  (notborder j)
  (notborder k)


  ; center
  (=> (stench ?cell)
      (notborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?celle)
          (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (notborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))
           (not (wumpus ?cellw))
           (not (wumpus ?cells))))

  ;;; borders

  ;west
  (=> (stench ?cell)
      (westborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (or (wumpus ?celln)
          (wumpus ?celle)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (westborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))
           (not (wumpus ?cells))))


  ; north
  (=> (stench ?cell)
      (northborder ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (or (wumpus ?celle)
          (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (northborder ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (and (not (wumpus ?celle))
           (not (wumpus ?cellw))
           (not (wumpus ?cells))))

      
  ; south
  (=> (stench ?cell)
      (southborder ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?celle)
          (wumpus ?cellw)))

  (=> (not (stench ?cell))
      (southborder ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))
           (not (wumpus ?cellw))))

  ; east
  (=> (stench ?cell)
      (eastborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (eastborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?cellw))
           (not (wumpus ?cells))))

  ;;; corners

  ; nw
  (=> (stench ?cell)
      (nwcorner ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (or (wumpus ?celle)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (nwcorner ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (and (not (wumpus ?celle))
           (not (wumpus ?cells))))

  ; ne
  (=> (stench ?cell)
      (necorner ?cell)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (or (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (necorner ?cell)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (and (not (wumpus ?cellw))
           (not (wumpus ?cells))))

  ; sw
  (=> (stench ?cell)
      (wwcorner ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (or (wumpus ?celln)
          (wumpus ?celle)))

  (=> (not (stench ?cell))
      (wwcorner ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))))

  ; se
  (=> (stench ?cell)
      (secorner ?cell)
      (north ?cell ?celln)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?cellw)))

  (=> (not (stench ?cell))
      (secorner ?cell)
      (north ?cell ?celln)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?cellw))))

  ;(or (wumpus a) (wumpus b) (wumpus c) (wumpus d) (wumpus e) (wumpus f) (wumpus g) (wumpus h) (wumpus i))

  (shiney e)
  (not (stench e))
  (stench l)
  (not (shiney l))
"))(POS (EXAMPLE.SOURCE WUMPUSPERCEPTS "
  (succ 1 2)
  (succ 2 3)
  (succ 3 4)

  (<=> (next ?x ?y)
       (or (succ ?x ?y)
           (succ ?y ?x)))

  (<=> (west (cell ?x ?y) (cell ?x2 ?y))
       (succ ?x2 ?x))
  (<=> (north (cell ?x ?y) (cell ?x ?y2))
       (succ ?y2 ?y))
  
  (<=> (east ?x ?y) (west ?y ?x))
  (<=> (south ?x ?y) (north ?y ?x))

  (<=> (westof (cell ?x ?y) (cell ?x2 ?y2))
       (or (adj ?x ?x2)
           (exists ?z (and (adj ?x ?z) (adj ?z ?x2)))
           (exists (?z ?w) (and (adj ?x ?z) (adj ?z ?w) (adj ?w ?x2)))))

  (<=> (westborder (cell 1 ?x))
       (not (= ?x 1))
       (not (= ?x 4)))

  (<=> (eastborder (cell 4 ?x))
       (not (= ?x 1))
       (not (= ?x 4)))

  (<=> (southborder (cell ?x 1))
       (not (= ?x 1))
       (not (= ?x 4)))

  (<=> (northborder (cell ?x 4))
       (not (= ?x 1))
       (not (= ?x 4)))

  (nwcorner (cell 1 4))
  (necorner (cell 4 4))
  (swcorner (cell 1 1))
  (secorner (cell 4 1))
  
  (<=> (notborder (cell ?x ?y))
       (and (not (= ?x 1))
            (not (= ?x 4))
            (not (= ?y 1))
            (not (= ?y 4))))

  ; center
  (=> (stench ?cell)
      (notborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?celle)
          (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (notborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))
           (not (wumpus ?cellw))
           (not (wumpus ?cells))))

  ;;; borders

  ;west
  (=> (stench ?cell)
      (westborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (or (wumpus ?celln)
          (wumpus ?celle)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (westborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))
           (not (wumpus ?cells))))


  ; north
  (=> (stench ?cell)
      (northborder ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (or (wumpus ?celle)
          (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (northborder ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (and (not (wumpus ?celle))
           (not (wumpus ?cellw))
           (not (wumpus ?cells))))

      
  ; south
  (=> (stench ?cell)
      (southborder ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?celle)
          (wumpus ?cellw)))

  (=> (not (stench ?cell))
      (southborder ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))
           (not (wumpus ?cellw))))

  ; east
  (=> (stench ?cell)
      (eastborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (eastborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?cellw))
           (not (wumpus ?cells))))

  ;;; corners

  ; nw
  (=> (stench ?cell)
      (nwcorner ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (or (wumpus ?celle)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (nwcorner ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (and (not (wumpus ?celle))
           (not (wumpus ?cells))))

  ; ne
  (=> (stench ?cell)
      (necorner ?cell)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (or (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (necorner ?cell)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (and (not (wumpus ?cellw))
           (not (wumpus ?cells))))

  ; sw
  (=> (stench ?cell)
      (wwcorner ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (or (wumpus ?celln)
          (wumpus ?celle)))

  (=> (not (stench ?cell))
      (wwcorner ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))))

  ; se
  (=> (stench ?cell)
      (secorner ?cell)
      (north ?cell ?celln)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?cellw)))

  (=> (not (stench ?cell))
      (secorner ?cell)
      (north ?cell ?celln)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?cellw))))

  (exists (?x ?y) (wumpus (cell ?x ?y)))

  (shiney (cell 1 3))
  (not (stench (cell 1 3)))
  (stench (cell 4 2))
  (not (shiney (cell 4 2)))
"))(NEG (EXAMPLE.SOURCEQUERY WUMPUSPERCEPTS "      (=> (gold ?x) (wumpus ?y) (westof ?x ?y)))
"))(POS (EXAMPLE.SOURCEQUERY WUMPUSPERCEPTS "      (=> (gold ?x) (wumpus ?y) (westof ?x ?y))
"))(NEG (EXAMPLE.SOURCE WUMPUSPERCEPTS "
  (succ 1 2)
  (succ 2 3)
  (succ 3 4)

  (<=> (next ?x ?y)
       (or (succ ?x ?y)
           (succ ?y ?x)))

  (<=> (west (cell ?x ?y) (cell ?x2 ?y))
       (succ ?x2 ?x))
  (<=> (north (cell ?x ?y) (cell ?x ?y2))
       (succ ?y2 ?y))
  
  (<=> (east ?x ?y) (west ?y ?x))
  (<=> (south ?x ?y) (north ?y ?x))

  (<=> (westof (cell ?x ?y) (cell ?x2 ?y2))
       (or (adj ?x ?x2)
           (exists ?z (and (adj ?x ?z) (adj ?z ?x2)))
           (exists (?z ?w) (and (adj ?x ?z) (adj ?z ?w) (adj ?w ?x2)))))

  (<=> (westborder (cell 1 ?x))
       (not (= ?x 1))
       (not (= ?x 4)))

  (<=> (eastborder (cell 4 ?x))
       (not (= ?x 1))
       (not (= ?x 4)))

  (<=> (southborder (cell ?x 1))
       (not (= ?x 1))
       (not (= ?x 4)))

  (<=> (northborder (cell ?x 4))
       (not (= ?x 1))
       (not (= ?x 4)))

  (nwcorner (cell 1 4))
  (necorner (cell 4 4))
  (swcorner (cell 1 1))
  (secorner (cell 4 1))
  
  (<=> (notborder (cell ?x ?y))
       (and (not (= ?x 1))
            (not (= ?x 4))
            (not (= ?y 1))
            (not (= ?y 4))))

  ; center
  (=> (stench ?cell)
      (notborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?celle)
          (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (notborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))
           (not (wumpus ?cellw))
           (not (wumpus ?cells))))

  ;;; borders

  ;west
  (=> (stench ?cell)
      (westborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (or (wumpus ?celln)
          (wumpus ?celle)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (westborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))
           (not (wumpus ?cells))))


  ; north
  (=> (stench ?cell)
      (northborder ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (or (wumpus ?celle)
          (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (northborder ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (and (not (wumpus ?celle))
           (not (wumpus ?cellw))
           (not (wumpus ?cells))))

      
  ; south
  (=> (stench ?cell)
      (southborder ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?celle)
          (wumpus ?cellw)))

  (=> (not (stench ?cell))
      (southborder ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))
           (not (wumpus ?cellw))))

  ; east
  (=> (stench ?cell)
      (eastborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (eastborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?cellw))
           (not (wumpus ?cells))))

  ;;; corners

  ; nw
  (=> (stench ?cell)
      (nwcorner ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (or (wumpus ?celle)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (nwcorner ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (and (not (wumpus ?celle))
           (not (wumpus ?cells))))

  ; ne
  (=> (stench ?cell)
      (necorner ?cell)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (or (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (necorner ?cell)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (and (not (wumpus ?cellw))
           (not (wumpus ?cells))))

  ; sw
  (=> (stench ?cell)
      (wwcorner ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (or (wumpus ?celln)
          (wumpus ?celle)))

  (=> (not (stench ?cell))
      (wwcorner ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))))

  ; se
  (=> (stench ?cell)
      (secorner ?cell)
      (north ?cell ?celln)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?cellw)))

  (=> (not (stench ?cell))
      (secorner ?cell)
      (north ?cell ?celln)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?cellw))))

  (exists (?x ?y) (wumpus (cell ?x ?y)))

  (shiney (cell 1 3))
  (not (stench (cell 1 3)))
  (stench (cell 4 2))
  (not (shiney (cell 4 2)))
"))(POS (EXAMPLE.SOURCE WUMPUSPERCEPTS "  (succ 1 2)
  (succ 2 3)
  (succ 3 4)

  (<=> (next ?x ?y)
       (or (succ ?x ?y)
           (succ ?y ?x)))

  (<=> (west (cell ?x ?y) (cell ?x2 ?y))
       (succ ?x2 ?x))
  (<=> (north (cell ?x ?y) (cell ?x ?y2))
       (succ ?y2 ?y))
  
  (<=> (east ?x ?y) (west ?y ?x))
  (<=> (south ?x ?y) (north ?y ?x))

  (<=> (westof (cell ?x ?y) (cell ?x2 ?y2))
       (or (adj ?x ?x2)
           (exists ?z (and (adj ?x ?z) (adj ?z ?x2)))
           (exists (?z ?w) (and (adj ?x ?z) (adj ?z ?w) (adj ?w ?x2)))))

  (<=> (westborder (cell 1 ?x))
       (not (= ?x 1))
       (not (= ?x 4)))

  (<=> (eastborder (cell 4 ?x))
       (not (= ?x 1))
       (not (= ?x 4)))

  (<=> (southborder (cell ?x 1))
       (not (= ?x 1))
       (not (= ?x 4)))

  (<=> (northborder (cell ?x 4))
       (not (= ?x 1))
       (not (= ?x 4)))

  (nwcorner (cell 1 4))
  (necorner (cell 4 4))
  (swcorner (cell 1 1))
  (secorner (cell 4 1))
  
  (<=> (notborder (cell ?x ?y))
       (and (not (= ?x 1))
            (not (= ?x 4))
            (not (= ?y 1))
            (not (= ?y 4))))

  ; center
  (=> (stench ?cell)
      (notborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?celle)
          (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (notborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))
           (not (wumpus ?cellw))
           (not (wumpus ?cells))))

  ;;; borders

  ;west
  (=> (stench ?cell)
      (westborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (or (wumpus ?celln)
          (wumpus ?celle)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (westborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))
           (not (wumpus ?cells))))


  ; north
  (=> (stench ?cell)
      (northborder ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (or (wumpus ?celle)
          (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (northborder ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (and (not (wumpus ?celle))
           (not (wumpus ?cellw))
           (not (wumpus ?cells))))

      
  ; south
  (=> (stench ?cell)
      (southborder ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?celle)
          (wumpus ?cellw)))

  (=> (not (stench ?cell))
      (southborder ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))
           (not (wumpus ?cellw))))

  ; east
  (=> (stench ?cell)
      (eastborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (eastborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?cellw))
           (not (wumpus ?cells))))

  ;;; corners

  ; nw
  (=> (stench ?cell)
      (nwcorner ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (or (wumpus ?celle)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (nwcorner ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (and (not (wumpus ?celle))
           (not (wumpus ?cells))))

  ; ne
  (=> (stench ?cell)
      (necorner ?cell)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (or (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (necorner ?cell)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (and (not (wumpus ?cellw))
           (not (wumpus ?cells))))

  ; sw
  (=> (stench ?cell)
      (wwcorner ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (or (wumpus ?celln)
          (wumpus ?celle)))

  (=> (not (stench ?cell))
      (wwcorner ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))))

  ; se
  (=> (stench ?cell)
      (secorner ?cell)
      (north ?cell ?celln)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?cellw)))

  (=> (not (stench ?cell))
      (secorner ?cell)
      (north ?cell ?celln)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?cellw))))

  (exists (?x ?y) (wumpus (cell ?x ?y)))

  (shiney (cell 1 3))
  (not (stench (cell 1 3)))
  (stench (cell 4 2))
  (not (shiney (cell 4 2)))
"))(NEG (EXAMPLE.SOURCE WUMPUSPERCEPTS "  (succ 1 2)
  (succ 2 3)
  (succ 3 4)

  (<=> (next ?x ?y)
       (or (succ ?x ?y)
           (succ ?y ?x)))

  (<=> (west (cell ?x ?y) (cell ?x2 ?y))
       (succ ?x2 ?x))
  (<=> (north (cell ?x ?y) (cell ?x ?y2))
       (succ ?y2 ?y))
  
  (<=> (east ?x ?y) (west ?y ?x))
  (<=> (south ?x ?y) (north ?y ?x))

  (<=> (westof (cell ?x ?y) (cell ?x2 ?y2))
       (or (adj ?x ?x2)
           (exists ?z (and (adj ?x ?z) (adj ?z ?x2)))
           (exists (?z ?w) (and (adj ?x ?z) (adj ?z ?w) (adj ?w ?x2)))))

  (<=> (westborder (cell 1 ?x))
       (not (= ?x 1))
       (not (= ?x 4)))

  (<=> (eastborder (cell 4 ?x))
       (not (= ?x 1))
       (not (= ?x 4)))

  (<=> (southborder (cell ?x 1))
       (not (= ?x 1))
       (not (= ?x 4)))

  (<=> (northborder (cell ?x 4))
       (not (= ?x 1))
       (not (= ?x 4)))

  (nwcorner (cell 1 4))
  (necorner (cell 4 4))
  (swcorner (cell 1 1))
  (secorner (cell 4 1))
  
  (<=> (notborder (cell ?x ?y))
       (and (not (= ?x 1))
            (not (= ?x 4))
            (not (= ?y 1))
            (not (= ?y 4))))

  ; center
  (=> (stench ?cell)
      (notborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?celle)
          (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (notborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))
           (not (wumpus ?cellw))
           (not (wumpus ?cells))))

  ;;; borders

  ;west
  (=> (stench ?cell)
      (westborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (or (wumpus ?celln)
          (wumpus ?celle)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (westborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))
           (not (wumpus ?cells))))


  ; north
  (=> (stench ?cell)
      (northborder ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (or (wumpus ?celle)
          (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (northborder ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (and (not (wumpus ?celle))
           (not (wumpus ?cellw))
           (not (wumpus ?cells))))

      
  ; south
  (=> (stench ?cell)
      (southborder ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?celle)
          (wumpus ?cellw)))

  (=> (not (stench ?cell))
      (southborder ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))
           (not (wumpus ?cellw))))

  ; east
  (=> (stench ?cell)
      (eastborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (eastborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?cellw))
           (not (wumpus ?cells))))

  ;;; corners

  ; nw
  (=> (stench ?cell)
      (nwcorner ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (or (wumpus ?celle)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (nwcorner ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (and (not (wumpus ?celle))
           (not (wumpus ?cells))))

  ; ne
  (=> (stench ?cell)
      (necorner ?cell)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (or (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (necorner ?cell)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (and (not (wumpus ?cellw))
           (not (wumpus ?cells))))

  ; sw
  (=> (stench ?cell)
      (wwcorner ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (or (wumpus ?celln)
          (wumpus ?celle)))

  (=> (not (stench ?cell))
      (wwcorner ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))))

  ; se
  (=> (stench ?cell)
      (secorner ?cell)
      (north ?cell ?celln)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?cellw)))

  (=> (not (stench ?cell))
      (secorner ?cell)
      (north ?cell ?celln)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?cellw))))

  (exists (?x ?y) (wumpus (cell ?x ?y)))

  (shiney (cell 1 3))
  (not (stench (cell 1 3)))
  (stench (cell 4 2))
  (not (shiney (cell 4 2)))
"))(POS (EXAMPLE.SOURCE WUMPUSPERCEPTS "
  (succ 1 2)
  (succ 2 3)
  (succ 3 4)

  (<=> (next ?x ?y)
       (or (succ ?x ?y)
           (succ ?y ?x)))

  (<=> (west (cell ?x ?y) (cell ?x2 ?y))
       (succ ?x2 ?x))
  (<=> (north (cell ?x ?y) (cell ?x ?y2))
       (succ ?y2 ?y))
  
  (<=> (east ?x ?y) (west ?y ?x))
  (<=> (south ?x ?y) (north ?y ?x))

  (<=> (westof (cell ?x ?y) (cell ?x2 ?y2))
       (or (succ ?x ?x2)
           (exists ?z (and (succ ?x ?z) (succ ?z ?x2)))
           (exists (?z ?w) (and (succ ?x ?z) (succ ?z ?w) (succ ?w ?x2)))))

  (<=> (westborder (cell 1 ?x))
       (not (= ?x 1))
       (not (= ?x 4)))

  (<=> (eastborder (cell 4 ?x))
       (not (= ?x 1))
       (not (= ?x 4)))

  (<=> (southborder (cell ?x 1))
       (not (= ?x 1))
       (not (= ?x 4)))

  (<=> (northborder (cell ?x 4))
       (not (= ?x 1))
       (not (= ?x 4)))

  (nwcorner (cell 1 4))
  (necorner (cell 4 4))
  (swcorner (cell 1 1))
  (secorner (cell 4 1))
  
  (<=> (notborder (cell ?x ?y))
       (and (not (= ?x 1))
            (not (= ?x 4))
            (not (= ?y 1))
            (not (= ?y 4))))

  ; center
  (=> (stench ?cell)
      (notborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?celle)
          (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (notborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))
           (not (wumpus ?cellw))
           (not (wumpus ?cells))))

  ;;; borders

  ;west
  (=> (stench ?cell)
      (westborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (or (wumpus ?celln)
          (wumpus ?celle)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (westborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))
           (not (wumpus ?cells))))


  ; north
  (=> (stench ?cell)
      (northborder ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (or (wumpus ?celle)
          (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (northborder ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (and (not (wumpus ?celle))
           (not (wumpus ?cellw))
           (not (wumpus ?cells))))

      
  ; south
  (=> (stench ?cell)
      (southborder ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?celle)
          (wumpus ?cellw)))

  (=> (not (stench ?cell))
      (southborder ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))
           (not (wumpus ?cellw))))

  ; east
  (=> (stench ?cell)
      (eastborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (eastborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?cellw))
           (not (wumpus ?cells))))

  ;;; corners

  ; nw
  (=> (stench ?cell)
      (nwcorner ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (or (wumpus ?celle)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (nwcorner ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (and (not (wumpus ?celle))
           (not (wumpus ?cells))))

  ; ne
  (=> (stench ?cell)
      (necorner ?cell)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (or (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (necorner ?cell)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (and (not (wumpus ?cellw))
           (not (wumpus ?cells))))

  ; sw
  (=> (stench ?cell)
      (wwcorner ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (or (wumpus ?celln)
          (wumpus ?celle)))

  (=> (not (stench ?cell))
      (wwcorner ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))))

  ; se
  (=> (stench ?cell)
      (secorner ?cell)
      (north ?cell ?celln)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?cellw)))

  (=> (not (stench ?cell))
      (secorner ?cell)
      (north ?cell ?celln)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?cellw))))

  (exists (?x ?y) (wumpus (cell ?x ?y)))

  (shiney (cell 1 3))
  (not (stench (cell 1 3)))
  (stench (cell 4 2))
  (not (shiney (cell 4 2)))
"))(POS (EXAMPLE.INSTANCE WUMPUSDISJUNCTIVE))(POS (PRETTYNAME WUMPUSDISJUNCTIVE "Disjunctive Wumpus World"))(POS (SHORTNAME WUMPUSDISJUNCTIVE "wumpus.disj"))(POS (EXAMPLE.COMPLETE WUMPUSDISJUNCTIVE INCOMPLETE))(POS (EXAMPLE.TECHNIQUE WUMPUSDISJUNCTIVE BILEVEL))(POS (EXAMPLE.TECHNIQUE WUMPUSDISJUNCTIVE CONSISTENCY2DEDUCTION))(POS (EXAMPLE.TECHNIQUE WUMPUSDISJUNCTIVE NAF))(POS (EXAMPLE.TECHNIQUE WUMPUSDISJUNCTIVE UNNAMED))(POS (EXAMPLE.DESCRIPTION WUMPUSDISJUNCTIVE "In this snapshot version of wumpus world, at each step of the game, we write down what the percepts we have received mean.  For example, if we sense a stench then we write down that the wumpus is in one of the surrounding squares.  This incomplete theory is built on top of incomplete and, more to the point, disjunctive base tables.  The reformulation must then take into account that those base tables must be completed each time new info is added.  The way we complete the tables is to introduce new object constants into the language, that is at least what we would have done had we used object constants to name each cell instead of functional terms.  This example illustrates the need to change the universe of discourse."))(POS (MATRIXSHOW WUMPUSDISJUNCTIVE TRUE))(POS (EXAMPLE.COMMENTS WUMPUSDISJUNCTIVE "This example definitely illustrates the issues of starting with DISJUNCTIVE base tables can produce.  One way to deal with that is to increase the size of the universe, as indicated in the description.  Another way is to add functional terms, as is done in the actual example below.

The only reason this example might be problematic for Otter/Vampire is that the query is a universal statement, and we have a DCA to worry about."))(POS (EXAMPLE.SOURCEQUERY WUMPUSDISJUNCTIVE "(=> (gold ?x) (wumpus ?y) (westof ?x ?y))"))(POS (EXAMPLE.SOURCE WUMPUSDISJUNCTIVE "  (succ 1 2)
  (succ 2 3)
  (succ 3 4)

  (<=> (westof (cell ?x ?y) (cell ?x2 ?y2))
       (or (succ ?x ?x2)
           (exists ?z (and (succ ?x ?z) (succ ?z ?x2)))
           (exists (?z ?w) (and (succ ?x ?z) (succ ?z ?w) (succ ?w ?x2)))))


  (or (gold (cell 1 4)) (gold (cell 1 2)) (gold (cell 2 2)) (gold (cell 2 3)) (gold (cell 2 4)))
  (not (wumpus (cell 1 4)))
  (not (wumpus (cell 1 2)))
  (not (wumpus (cell 2 2)))
  (not (wumpus (cell 2 3)))
  (not (wumpus (cell 2 4)))

  (or (wumpus (cell 3 1)) (wumpus (cell 3 2)) (wumpus (cell 3 3)) (wumpus (cell 4 1)) (wumpus (cell 4 3)))
  (not (gold (cell 3 1)))
  (not (gold (cell 3 2)))
  (not (gold (cell 3 3)))
  (not (gold (cell 4 1)))
  (not (gold (cell 4 3)))
"))(POS (EXAMPLE.TARGETQUERY WUMPUSDISJUNCTIVE "ent"))(POS (EXAMPLE.TARGET WUMPUSDISJUNCTIVE " (<= ent
      (not notent))
  (<= notent
      (possgold ?x)
      (posswumpus ?y)
      (not (westof ?x ?y)))
      
  (<= (possgold ?x)
      (gold ?y)
      (part ?y ?x)
      (not (ngold ?x))
      (not (some-goldnotin ?x)))

  (<= (some-goldnotin ?x)
      (gold ?y)
      (not (part ?y ?x)))

  (<= (posswumpus ?x)
      (wumpus ?y)
      (part ?y ?x)
      (not (nwumpus ?x))
      (not (some-wumpusnotin ?x)))
  
  (<= (some-wumpusnotin ?x)
      (wumpus ?y)
      (not (part ?y ?x)))

  (<= (part (listof ?x @y) ?x))
  (<= (part (listof ?z @y) ?x)
      (part (listof @y) ?x))

  (adj 1 2)
  (adj 2 3)
  (adj 3 4)

  (<= (west (cell ?x ?y) (cell ?x2 ?w))
      (adj ?x ?x2))

  (<= (westof ?x ?y)
      (or (west ?x ?y)
          (and (west ?x ?z) (west ?z ?y))
          (and (west ?x ?z) (west ?z ?w) (west ?w ?y))))

  (gold (listof (cell 1 4) (cell 1 2) (cell 2 2) (cell 2 3) (cell 2 4)))
  (ngold (cell 3 1))
  (ngold (cell 3 2))
  (ngold (cell 3 3))
  (ngold (cell 4 1))
  (ngold (cell 4 3))

  (wumpus (listof (cell 3 1) (cell 3 2) (cell 3 3) (cell 4 1) (cell 4 3)))
  (nwumpus (cell 1 4))
  (nwumpus (cell 1 2))
  (nwumpus (cell 2 2))
  (nwumpus (cell 2 3))
  (nwumpus (cell 2 4))
"))(NEG (EXAMPLE.DESCRIPTION WUMPUSDISJUNCTIVE "In this snapshot version of wumpus world, at each step of the game, we write down what the percepts we have received mean.  For example, if we sense a stench then we write down that the wumpus is in one of the surrounding squares.  This incomplete theory is built on top of incomplete and, more to the point, disjunctive base tables.  The reformulation must then take into account that those base tables must be completed each time new info is added.  The way we complete the tables is to introduce new object constants into the language, that is at least what we would have done had we used object constants to name each cell instead of functional terms.  This example illustrates the need to change the universe of discourse."))(POS (EXAMPLE.DESCRIPTION WUMPUSDISJUNCTIVE "In this snapshot version of wumpus world, at each step of the game, we write down what the percepts we have received mean.  For example, if we sense a stench then we write down that the wumpus is in one of the surrounding squares.  This incomplete theory is built on top of incomplete and, more to the point, disjunctive base tables.  The reformulation must then take into account that those base tables must be completed each time new info is added.  The way we complete the tables is to introduce new object constants into the language.  This example illustrates the problem of disjunctive base tables and a solution: the introduction of new object constants."))(NEG (EXAMPLE.COMMENTS WUMPUSDISJUNCTIVE "This example definitely illustrates the issues of starting with DISJUNCTIVE base tables can produce.  One way to deal with that is to increase the size of the universe, as indicated in the description.  Another way is to add functional terms, as is done in the actual example below.

The only reason this example might be problematic for Otter/Vampire is that the query is a universal statement, and we have a DCA to worry about."))(POS (EXAMPLE.COMMENTS WUMPUSDISJUNCTIVE "The only reason this example might be problematic for Otter/Vampire is that the query is a universal statement, and we have a DCA to worry about.

Add UNA/DCA to the source."))(NEG (EXAMPLE.SOURCEQUERY WUMPUSDISJUNCTIVE "(=> (gold ?x) (wumpus ?y) (westof ?x ?y))"))(POS (EXAMPLE.SOURCEQUERY WUMPUSDISJUNCTIVE "(forall (?x ?y) (=> (gold ?x) (wumpus ?y) (westof ?x ?y)))"))(NEG (EXAMPLE.SOURCE WUMPUSDISJUNCTIVE "  (succ 1 2)
  (succ 2 3)
  (succ 3 4)

  (<=> (westof (cell ?x ?y) (cell ?x2 ?y2))
       (or (succ ?x ?x2)
           (exists ?z (and (succ ?x ?z) (succ ?z ?x2)))
           (exists (?z ?w) (and (succ ?x ?z) (succ ?z ?w) (succ ?w ?x2)))))


  (or (gold (cell 1 4)) (gold (cell 1 2)) (gold (cell 2 2)) (gold (cell 2 3)) (gold (cell 2 4)))
  (not (wumpus (cell 1 4)))
  (not (wumpus (cell 1 2)))
  (not (wumpus (cell 2 2)))
  (not (wumpus (cell 2 3)))
  (not (wumpus (cell 2 4)))

  (or (wumpus (cell 3 1)) (wumpus (cell 3 2)) (wumpus (cell 3 3)) (wumpus (cell 4 1)) (wumpus (cell 4 3)))
  (not (gold (cell 3 1)))
  (not (gold (cell 3 2)))
  (not (gold (cell 3 3)))
  (not (gold (cell 4 1)))
  (not (gold (cell 4 3)))
"))(POS (EXAMPLE.SOURCE WUMPUSDISJUNCTIVE "  (or (gold a) (gold i) (gold b) (gold f) (gold j))
  (not (wumpus a))
  (not (wumpus i))
  (not (wumpus b))
  (not (wumpus f))
  (not (wumpus j))

  (or (wumpus g) (wumpus k) (wumpus o) (wumpus h) (wumpus p))
  (not (gold g))
  (not (gold k))
  (not (gold o))
  (not (gold h))
  (not (gold p))

(westof A B)
(westof A F)
(westof A J)
(westof A N)
(westof A C)
(westof A G)
(westof A K)
(westof A O)
(westof A D)
(westof A H)
(westof A L)
(westof A P)
(westof E B)
(westof E F)
(westof E J)
(westof E N)
(westof E C)
(westof E G)
(westof E K)
(westof E O)
(westof E D)
(westof E H)
(westof E L)
(westof E P)
(westof I B)
(westof I F)
(westof I J)
(westof I N)
(westof I C)
(westof I G)
(westof I K)
(westof I O)
(westof I D)
(westof I H)
(westof I L)
(westof I P)
(westof M B)
(westof M F)
(westof M J)
(westof M N)
(westof M C)
(westof M G)
(westof M K)
(westof M O)
(westof M D)
(westof M H)
(westof M L)
(westof M P)
(westof B C)
(westof B G)
(westof B K)
(westof B O)
(westof B D)
(westof B H)
(westof B L)
(westof B P)
(westof F C)
(westof F G)
(westof F K)
(westof F O)
(westof F D)
(westof F H)
(westof F L)
(westof F P)
(westof J C)
(westof J G)
(westof J K)
(westof J O)
(westof J D)
(westof J H)
(westof J L)
(westof J P)
(westof N C)
(westof N G)
(westof N K)
(westof N O)
(westof N D)
(westof N H)
(westof N L)
(westof N P)
(westof C D)
(westof C H)
(westof C L)
(westof C P)
(westof G D)
(westof G H)
(westof G L)
(westof G P)
(westof K D)
(westof K H)
(westof K L)
(westof K P)
(westof O D)
(westof O H)
(westof O L)
(westof O P)"))(NEG (EXAMPLE.TARGET WUMPUSDISJUNCTIVE " (<= ent
      (not notent))
  (<= notent
      (possgold ?x)
      (posswumpus ?y)
      (not (westof ?x ?y)))
      
  (<= (possgold ?x)
      (gold ?y)
      (part ?y ?x)
      (not (ngold ?x))
      (not (some-goldnotin ?x)))

  (<= (some-goldnotin ?x)
      (gold ?y)
      (not (part ?y ?x)))

  (<= (posswumpus ?x)
      (wumpus ?y)
      (part ?y ?x)
      (not (nwumpus ?x))
      (not (some-wumpusnotin ?x)))
  
  (<= (some-wumpusnotin ?x)
      (wumpus ?y)
      (not (part ?y ?x)))

  (<= (part (listof ?x @y) ?x))
  (<= (part (listof ?z @y) ?x)
      (part (listof @y) ?x))

  (adj 1 2)
  (adj 2 3)
  (adj 3 4)

  (<= (west (cell ?x ?y) (cell ?x2 ?w))
      (adj ?x ?x2))

  (<= (westof ?x ?y)
      (or (west ?x ?y)
          (and (west ?x ?z) (west ?z ?y))
          (and (west ?x ?z) (west ?z ?w) (west ?w ?y))))

  (gold (listof (cell 1 4) (cell 1 2) (cell 2 2) (cell 2 3) (cell 2 4)))
  (ngold (cell 3 1))
  (ngold (cell 3 2))
  (ngold (cell 3 3))
  (ngold (cell 4 1))
  (ngold (cell 4 3))

  (wumpus (listof (cell 3 1) (cell 3 2) (cell 3 3) (cell 4 1) (cell 4 3)))
  (nwumpus (cell 1 4))
  (nwumpus (cell 1 2))
  (nwumpus (cell 2 2))
  (nwumpus (cell 2 3))
  (nwumpus (cell 2 4))
"))(POS (EXAMPLE.TARGET WUMPUSDISJUNCTIVE "  (<= ent
      (not notent))
  (<= notent
      (possgold ?x)
      (posswumpus ?y)
      (not (westof ?x ?y)))
      
  (<= (possgold ?x)
      (gold ?y)
      (part ?y ?x)
      (not (ngold ?x))
      (not (some-goldnotin ?x)))

  (<= (some-goldnotin ?x)
      (gold ?y)
      (not (part ?y ?x)))

  (<= (posswumpus ?x)
      (wumpus ?y)
      (part ?y ?x)
      (not (nwumpus ?x))
      (not (some-wumpusnotin ?x)))
  
  (<= (some-wumpusnotin ?x)
      (wumpus ?y)
      (not (part ?y ?x)))

  (gold aibfj)
  (ngold g)
  (ngold k)
  (ngold o)
  (ngold h)
  (ngold p)

  (wumpus gkohp)
  (nwumpus a)
  (nwumpus i)
  (nwumpus b)
  (nwumpus f)
  (nwumpus j)

  (part aibfj a)
  (part aibfj i)
  (part aibfj b)
  (part aibfj f)
  (part aibfj j)

  (part gkohp g)
  (part gkohp k)
  (part gkohp o)
  (part gkohp h)
  (part gkohp p)

(westof A B)
(westof A F)
(westof A J)
(westof A N)
(westof A C)
(westof A G)
(westof A K)
(westof A O)
(westof A D)
(westof A H)
(westof A L)
(westof A P)
(westof E B)
(westof E F)
(westof E J)
(westof E N)
(westof E C)
(westof E G)
(westof E K)
(westof E O)
(westof E D)
(westof E H)
(westof E L)
(westof E P)
(westof I B)
(westof I F)
(westof I J)
(westof I N)
(westof I C)
(westof I G)
(westof I K)
(westof I O)
(westof I D)
(westof I H)
(westof I L)
(westof I P)
(westof M B)
(westof M F)
(westof M J)
(westof M N)
(westof M C)
(westof M G)
(westof M K)
(westof M O)
(westof M D)
(westof M H)
(westof M L)
(westof M P)
(westof B C)
(westof B G)
(westof B K)
(westof B O)
(westof B D)
(westof B H)
(westof B L)
(westof B P)
(westof F C)
(westof F G)
(westof F K)
(westof F O)
(westof F D)
(westof F H)
(westof F L)
(westof F P)
(westof J C)
(westof J G)
(westof J K)
(westof J O)
(westof J D)
(westof J H)
(westof J L)
(westof J P)
(westof N C)
(westof N G)
(westof N K)
(westof N O)
(westof N D)
(westof N H)
(westof N L)
(westof N P)
(westof C D)
(westof C H)
(westof C L)
(westof C P)
(westof G D)
(westof G H)
(westof G L)
(westof G P)
(westof K D)
(westof K H)
(westof K L)
(westof K P)
(westof O D)
(westof O H)
(westof O L)
(westof O P)
"))(NEG (EXAMPLE.COMMENTS WUMPUSPERCEPTS "Here I'm using some functions in the source, simply because the problem was easier to write down this way.  It may also be a case that demonstrates that sometimes we can deal with functions.  I'm conflating this with completing the tables stench and shine, but I couldn't bring myself to write it without functions."))(POS (EXAMPLE.COMMENTS WUMPUSPERCEPTS "There is a version using functions to name cells.  Add UNA and DCA to the source."))(NEG (EXAMPLE.SOURCEQUERY WUMPUSPERCEPTS "      (=> (gold ?x) (wumpus ?y) (westof ?x ?y))
"))(POS (EXAMPLE.SOURCEQUERY WUMPUSPERCEPTS "     (forall (?x ?y) (=> (gold ?x) (wumpus ?y) (westof ?x ?y)))
"))(NEG (EXAMPLE.SOURCE WUMPUSPERCEPTS "
  (succ 1 2)
  (succ 2 3)
  (succ 3 4)

  (<=> (next ?x ?y)
       (or (succ ?x ?y)
           (succ ?y ?x)))

  (<=> (west (cell ?x ?y) (cell ?x2 ?y))
       (succ ?x2 ?x))
  (<=> (north (cell ?x ?y) (cell ?x ?y2))
       (succ ?y2 ?y))
  
  (<=> (east ?x ?y) (west ?y ?x))
  (<=> (south ?x ?y) (north ?y ?x))

  (<=> (westof (cell ?x ?y) (cell ?x2 ?y2))
       (or (succ ?x ?x2)
           (exists ?z (and (succ ?x ?z) (succ ?z ?x2)))
           (exists (?z ?w) (and (succ ?x ?z) (succ ?z ?w) (succ ?w ?x2)))))

  (<=> (westborder (cell 1 ?x))
       (not (= ?x 1))
       (not (= ?x 4)))

  (<=> (eastborder (cell 4 ?x))
       (not (= ?x 1))
       (not (= ?x 4)))

  (<=> (southborder (cell ?x 1))
       (not (= ?x 1))
       (not (= ?x 4)))

  (<=> (northborder (cell ?x 4))
       (not (= ?x 1))
       (not (= ?x 4)))

  (nwcorner (cell 1 4))
  (necorner (cell 4 4))
  (swcorner (cell 1 1))
  (secorner (cell 4 1))
  
  (<=> (notborder (cell ?x ?y))
       (and (not (= ?x 1))
            (not (= ?x 4))
            (not (= ?y 1))
            (not (= ?y 4))))

  ; center
  (=> (stench ?cell)
      (notborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?celle)
          (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (notborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))
           (not (wumpus ?cellw))
           (not (wumpus ?cells))))

  ;;; borders

  ;west
  (=> (stench ?cell)
      (westborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (or (wumpus ?celln)
          (wumpus ?celle)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (westborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))
           (not (wumpus ?cells))))


  ; north
  (=> (stench ?cell)
      (northborder ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (or (wumpus ?celle)
          (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (northborder ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (and (not (wumpus ?celle))
           (not (wumpus ?cellw))
           (not (wumpus ?cells))))

      
  ; south
  (=> (stench ?cell)
      (southborder ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?celle)
          (wumpus ?cellw)))

  (=> (not (stench ?cell))
      (southborder ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))
           (not (wumpus ?cellw))))

  ; east
  (=> (stench ?cell)
      (eastborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (eastborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?cellw))
           (not (wumpus ?cells))))

  ;;; corners

  ; nw
  (=> (stench ?cell)
      (nwcorner ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (or (wumpus ?celle)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (nwcorner ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (and (not (wumpus ?celle))
           (not (wumpus ?cells))))

  ; ne
  (=> (stench ?cell)
      (necorner ?cell)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (or (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (necorner ?cell)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (and (not (wumpus ?cellw))
           (not (wumpus ?cells))))

  ; sw
  (=> (stench ?cell)
      (wwcorner ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (or (wumpus ?celln)
          (wumpus ?celle)))

  (=> (not (stench ?cell))
      (wwcorner ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))))

  ; se
  (=> (stench ?cell)
      (secorner ?cell)
      (north ?cell ?celln)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?cellw)))

  (=> (not (stench ?cell))
      (secorner ?cell)
      (north ?cell ?celln)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?cellw))))

  (exists (?x ?y) (wumpus (cell ?x ?y)))

  (shiney (cell 1 3))
  (not (stench (cell 1 3)))
  (stench (cell 4 2))
  (not (shiney (cell 4 2)))
"))(POS (EXAMPLE.SOURCE WUMPUSPERCEPTS "  ; complete tables
  (north a e)
  (north e i)
  (north i m)
  (north b f)
  (north f j)
  (north j n)
  (north c g)
  (north g k)
  (north k o)
  (north d h)
  (north h l)
  (north l p)

  (west a b)
  (west b c)
  (west c d)
  (west e f)
  (west f g)
  (west g h)
  (west i j)
  (west j k)
  (west k l)
  (west m n)
  (west n o)
  (west o p)
  
  (<=> (east ?x ?y) (west ?y ?x))
  (<=> (south ?x ?y) (north ?y ?x))

  ; more complete tables
  (westborder e)
  (westborder i)
  (northborder b)
  (northborder c)
  (eastborder h)
  (eastborder l)
  (southborder n)
  (southborder o)

  (nwcorner a)
  (necorner d)
  (swcorner m)
  (swcorner p)

  (notborder f)
  (notborder g)
  (notborder j)
  (notborder k)
  
  ; center
  (=> (stench ?cell)
      (notborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?celle)
          (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (notborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))
           (not (wumpus ?cellw))
           (not (wumpus ?cells))))

  ;;; borders

  ;west
  (=> (stench ?cell)
      (westborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (or (wumpus ?celln)
          (wumpus ?celle)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (westborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))
           (not (wumpus ?cells))))


  ; north
  (=> (stench ?cell)
      (northborder ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (or (wumpus ?celle)
          (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (northborder ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (and (not (wumpus ?celle))
           (not (wumpus ?cellw))
           (not (wumpus ?cells))))

      
  ; south
  (=> (stench ?cell)
      (southborder ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?celle)
          (wumpus ?cellw)))

  (=> (not (stench ?cell))
      (southborder ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))
           (not (wumpus ?cellw))))

  ; east
  (=> (stench ?cell)
      (eastborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (eastborder ?cell)
      (north ?cell ?celln)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?cellw))
           (not (wumpus ?cells))))

  ;;; corners

  ; nw
  (=> (stench ?cell)
      (nwcorner ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (or (wumpus ?celle)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (nwcorner ?cell)
      (south ?cell ?cells)
      (east ?cell ?celle)
      (and (not (wumpus ?celle))
           (not (wumpus ?cells))))

  ; ne
  (=> (stench ?cell)
      (necorner ?cell)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (or (wumpus ?cellw)
          (wumpus ?cells)))

  (=> (not (stench ?cell))
      (necorner ?cell)
      (south ?cell ?cells)
      (west ?cell ?cellw)
      (and (not (wumpus ?cellw))
           (not (wumpus ?cells))))

  ; sw
  (=> (stench ?cell)
      (wwcorner ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (or (wumpus ?celln)
          (wumpus ?celle)))

  (=> (not (stench ?cell))
      (wwcorner ?cell)
      (north ?cell ?celln)
      (east ?cell ?celle)
      (and (not (wumpus ?celln))
           (not (wumpus ?celle))))

  ; se
  (=> (stench ?cell)
      (secorner ?cell)
      (north ?cell ?celln)
      (west ?cell ?cellw)
      (or (wumpus ?celln)
          (wumpus ?cellw)))

  (=> (not (stench ?cell))
      (secorner ?cell)
      (north ?cell ?celln)
      (west ?cell ?cellw)
      (and (not (wumpus ?celln))
           (not (wumpus ?cellw))))


  (exists ?x (wumpus ?x))
  (exists ?x (gold ?x))

  (shiney e)
  (not (stench e))
  (stench l)
  (not (shiney l))



; a complete table
(westof A B)
(westof A F)
(westof A J)
(westof A N)
(westof A C)
(westof A G)
(westof A K)
(westof A O)
(westof A D)
(westof A H)
(westof A L)
(westof A P)
(westof E B)
(westof E F)
(westof E J)
(westof E N)
(westof E C)
(westof E G)
(westof E K)
(westof E O)
(westof E D)
(westof E H)
(westof E L)
(westof E P)
(westof I B)
(westof I F)
(westof I J)
(westof I N)
(westof I C)
(westof I G)
(westof I K)
(westof I O)
(westof I D)
(westof I H)
(westof I L)
(westof I P)
(westof M B)
(westof M F)
(westof M J)
(westof M N)
(westof M C)
(westof M G)
(westof M K)
(westof M O)
(westof M D)
(westof M H)
(westof M L)
(westof M P)
(westof B C)
(westof B G)
(westof B K)
(westof B O)
(westof B D)
(westof B H)
(westof B L)
(westof B P)
(westof F C)
(westof F G)
(westof F K)
(westof F O)
(westof F D)
(westof F H)
(westof F L)
(westof F P)
(westof J C)
(westof J G)
(westof J K)
(westof J O)
(westof J D)
(westof J H)
(westof J L)
(westof J P)
(westof N C)
(westof N G)
(westof N K)
(westof N O)
(westof N D)
(westof N H)
(westof N L)
(westof N P)
(westof C D)
(westof C H)
(westof C L)
(westof C P)
(westof G D)
(westof G H)
(westof G L)
(westof G P)
(westof K D)
(westof K H)
(westof K L)
(westof K P)
(westof O D)
(westof O H)
(westof O L)
(westof O P)
"))(NEG (EXAMPLE.TARGET WUMPUSPERCEPTS "  (<= ent
      (not notent))
  (<= notent
      (possworld ?x ?y)
      (not (westof ?x ?y)))

  (<= (westof ?x ?y)
      (or (west ?x ?y)
          (and (west ?x ?z) (west ?z ?y))
          (and (west ?x ?z) (west ?z ?w) (west ?w ?y))))

  (<= (possworld ?x ?y)
      (possgold ?x)
      (posswumpus ?y))

  ; poss gold
  (<= (possgold ?x)
      (adjacentshiney ?x)
      (not (some-adjacentnonshiney ?x))
      (not (some-nonadjacentshiney ?x)))

  (<= (adjacentshiney ?x)
      (shiney ?s)
      (adjacent ?s ?x))

  (<= (some-nonadjacentshiney ?x)
      (shiney ?s)
      (not (adjacent ?s ?x)))

  (<= (some-adjacentnonshiney ?x)
      (adjacent ?x ?y)
      (nshiney ?y))

  ; poss wumpus
  (<= (posswumpus ?x)
      (adjacentstench ?x)
      (not (some-adjacentnonstench ?x))
      (not (some-nonadjacentstench ?x)))

  (<= (adjacentstench ?x)
      (stench ?s)
      (adjacent ?s ?x))

  (<= (some-nonadjacentstench ?x)
      (stench ?s)
      (not (adjacent ?s ?x)))

  (<= (some-adjacentnonstench ?x)
      (adjacent ?x ?y)
      (nstench ?y))
      

  (adj 1 2)
  (adj 2 3)
  (adj 3 4)
  (<= (next ?x ?y)
      (or (adj ?x ?y) (adj ?y ?x)))
  
  (<= (adjacent (cell ?x ?y) (cell ?z ?y))
      (next ?x ?z))

  (<= (adjacent (cell ?x ?y) (cell ?x ?w))
      (next ?y ?w))

  (<= (adjacent (cell ?x ?y) (cell ?z ?w))
      (next ?x ?z)
      (next ?y ?w))

  (<= (west (cell ?x ?y) (cell ?x2 ?w))
      (adj ?x ?x2))

  (shiney (cell 1 3))
  (nstench (cell 1 3))
  (stench (cell 4 2))
  (nshiney (cell 4 2))"))(POS (EXAMPLE.TARGET WUMPUSPERCEPTS "  (<= ent
      (not notent))
  (<= notent
      (possworld ?x ?y)
      (not (westof ?x ?y)))


  (<= (possworld ?x ?y)
      (possgold ?x)
      (posswumpus ?y))

  ; poss gold
  (<= (possgold ?x)
      (adjacentshiney ?x)
      (not (some-adjacentnonshiney ?x))
      (not (some-nonadjacentshiney ?x)))

  (<= (adjacentshiney ?x)
      (shiney ?s)
      (adjacent ?s ?x))

  (<= (some-nonadjacentshiney ?x)
      (shiney ?s)
      (not (adjacent ?s ?x)))

  (<= (some-adjacentnonshiney ?x)
      (adjacent ?x ?y)
      (nshiney ?y))

  ; poss wumpus
  (<= (posswumpus ?x)
      (adjacentstench ?x)
      (not (some-adjacentnonstench ?x))
      (not (some-nonadjacentstench ?x)))

  (<= (adjacentstench ?x)
      (stench ?s)
      (adjacent ?s ?x))

  (<= (some-nonadjacentstench ?x)
      (stench ?s)
      (not (adjacent ?s ?x)))

  (<= (some-adjacentnonstench ?x)
      (adjacent ?x ?y)
      (nstench ?y))
      
#|
 --- --- --- ---
| a | b | c | d |
 --- --- --- ---
| e | f | g | h |
 --- --- --- ---
| i | j | k | l |
 --- --- --- ---
| m | n | o | p |
 --- --- --- ---
Shine: e
Stench: l

|#

  (<= (adjacent ?x ?y)
      (or (north ?x ?y)
          (north ?y ?x)
          (west ?x ?y)
          (west ?y ?x)
          (and (west ?z ?x) (north ?y ?z))
          (and (west ?z ?x) (north ?z ?y))
          (and (west ?x ?z) (north ?y ?z))
          (and (west ?x ?z) (north ?z ?y))))

  (north a e)
  (north e i)
  (north i m)
  (north b f)
  (north f j)
  (north j n)
  (north c g)
  (north g k)
  (north k o)
  (north d h)
  (north h l)
  (north l p)

  (west a b)
  (west b c)
  (west c d)
  (west e f)
  (west f g)
  (west g h)
  (west i j)
  (west j k)
  (west k l)
  (west m n)
  (west n o)
  (west o p)
  
  (<= (east ?x ?y) (west ?y ?x))
  (<= (south ?x ?y) (north ?y ?x))


  (shiney e)
  (nstench e)
  (stench l)
  (nshiney l)

(westof A B)
(westof A F)
(westof A J)
(westof A N)
(westof A C)
(westof A G)
(westof A K)
(westof A O)
(westof A D)
(westof A H)
(westof A L)
(westof A P)
(westof E B)
(westof E F)
(westof E J)
(westof E N)
(westof E C)
(westof E G)
(westof E K)
(westof E O)
(westof E D)
(westof E H)
(westof E L)
(westof E P)
(westof I B)
(westof I F)
(westof I J)
(westof I N)
(westof I C)
(westof I G)
(westof I K)
(westof I O)
(westof I D)
(westof I H)
(westof I L)
(westof I P)
(westof M B)
(westof M F)
(westof M J)
(westof M N)
(westof M C)
(westof M G)
(westof M K)
(westof M O)
(westof M D)
(westof M H)
(westof M L)
(westof M P)
(westof B C)
(westof B G)
(westof B K)
(westof B O)
(westof B D)
(westof B H)
(westof B L)
(westof B P)
(westof F C)
(westof F G)
(westof F K)
(westof F O)
(westof F D)
(westof F H)
(westof F L)
(westof F P)
(westof J C)
(westof J G)
(westof J K)
(westof J O)
(westof J D)
(westof J H)
(westof J L)
(westof J P)
(westof N C)
(westof N G)
(westof N K)
(westof N O)
(westof N D)
(westof N H)
(westof N L)
(westof N P)
(westof C D)
(westof C H)
(westof C L)
(westof C P)
(westof G D)
(westof G H)
(westof G L)
(westof G P)
(westof K D)
(westof K H)
(westof K L)
(westof K P)
(westof O D)
(westof O H)
(westof O L)
(westof O P)"))(POS (LANGUAGE.INSTANCE IKIF))(POS (LANGUAGE.INSTANCE KIF))(POS (LANGUAGE.INSTANCE XML))(POS (TECHNIQUE.INSTANCE CONSISTENCY2DEDUCTION))(POS (TECHNIQUE.DESCRIPTION CONSISTENCY2DEDUCTION "Consistency2Deduction[Delta,phi(xbar)] computes an expression that represents for all the query instances tbar such that Delta U {phi(tbar)} is consistent."))(POS (TECHNIQUE.INSTANCE REIFICATION))(POS (TECHNIQUE.DESCRIPTION REIFICATION "Reification is an umbrella technique that encompasses all kinds of vocabulary and conceptualization shifts."))(POS (TECHNIQUE.INSTANCE UNNAMED))(POS (TECHNIQUE.DESCRIPTION UNNAMED "Encompasses all unnamed techniques."))(POS (TECHNIQUE.INSTANCE RELATIONALIZING))(POS (TECHNIQUE.DESCRIPTION RELATIONALIZING "Form of reification where object/function constants are turned into relation constants."))(POS (TECHNIQUE.INSTANCE OBJECTIFYING))(POS (TECHNIQUE.DESCRIPTION OBJECTIFYING "Form of reification where relation constants become function or object constants."))(POS (TECHNIQUE.INSTANCE GENERATEOVERGUESS))(POS (TECHNIQUE.DESCRIPTION GENERATEOVERGUESS "Technique that changes a guess-and-check problem formulation reformulation into a formulation that generates the answer constructively."))(POS (TECHNIQUE.INSTANCE DATAEXTRACTION))(POS (TECHNIQUE.DESCRIPTION DATAEXTRACTION "Pulls data out of a rule or set of rules, places that data into tables, and appropriately adjusts the rule so that semantically the original and the new versions are identical.  Inverse of dataInfusion."))(POS (TECHNIQUE.INSTANCE DATAINFUSION))(POS (TECHNIQUE.DESCRIPTION DATAINFUSION "Pushes data from a table into rules, a special form of partial deduction from the logic programming literature.  Inverse of dataExtraction."))(POS (TECHNIQUE.INSTANCE CHIRKOVAREFORMULATION))(POS (TECHNIQUE.DESCRIPTION CHIRKOVAREFORMULATION "Computes the optimal viewset for transforming an unknown (but fixed-size) database into a new database that more efficiently answers a given query set."))(POS (PERSON.INSTANCE NATLOVE))(POS (PERSON.FIRSTNAME NATLOVE "Nat"))(POS (PERSON.LASTNAME NATLOVE "Love"))(POS (PERSON.TEAM NATLOVE NATLOVE))(POS (PERSON.EMAIL NATLOVE "natlove@stanford.edu"))(POS (PERSON.INSTANCE JDUCHI))(POS (PERSON.FIRSTNAME JDUCHI "John"))(POS (PERSON.LASTNAME JDUCHI "Duchi"))(POS (PERSON.TEAM JDUCHI JDUCHI))(POS (PERSON.EMAIL JDUCHI "jduchi@stanford.edu"))(POS (PERSON.INSTANCE DTARLOW))(POS (PERSON.FIRSTNAME DTARLOW "Danny"))(POS (PERSON.LASTNAME DTARLOW "Tarlow"))(POS (PERSON.TEAM DTARLOW DTARLOW))(POS (PERSON.EMAIL DTARLOW "dtarlow@stanford.edu"))(POS (PERSON.INSTANCE THINRICH))(POS (PERSON.FIRSTNAME THINRICH "Tim"))(POS (PERSON.LASTNAME THINRICH "Hinrichs"))(POS (PERSON.TEAM THINRICH THINRICH))(POS (PERSON.EMAIL THINRICH "thinrich@stanford.edu"))(POS (PAPER.INSTANCE ABITEBOUL))(POS (PAPER.BIBTEX ABITEBOUL BOOK))(POS (PAPER.AUTHOR ABITEBOUL "Serge Abiteboul and Richard Hull and Victor Vianu"))(POS (PAPER.TITLE ABITEBOUL "Foundations of Databases"))(POS (PAPER.PUBLISHER ABITEBOUL "Addison-Wesley Publishing Company"))(POS (PAPER.LINK ABITEBOUL "http://www.amazon.com/Foundations-Databases-Logical-Serge-Abiteboul/dp/0201537710"))(POS (PAPER.YEAR ABITEBOUL 1995))(POS (PAPER.DESCRIPTION ABITEBOUL "
The definitive guide for comparing various database query languages.
"))(POS (PAPER.TOPIC ABITEBOUL ""))(POS (PAPER.INSTANCE AGRAWAL2000))(POS (PAPER.BIBTEX AGRAWAL2000 INPROCEEDINGS))(POS (PAPER.AUTHOR AGRAWAL2000 "Agrawal and Chaudrhuri and Narasavya"))(POS (PAPER.TITLE AGRAWAL2000 "Automatic selection of materialized views and indexes in Microsoft SQL Server"))(POS (PAPER.PUBLICATION AGRAWAL2000 "In proceedings of Very Large Databases (VLDB)"))(POS (PAPER.STARTPAGE AGRAWAL2000 496))(POS (PAPER.ENDPAGE AGRAWAL2000 505))(POS (PAPER.YEAR AGRAWAL2000 2000))(POS (PAPER.DESCRIPTION AGRAWAL2000 "
Another paper on view selection problem in databases.
"))(POS (PAPER.TOPIC AGRAWAL2000 "Databases"))(POS (PAPER.INSTANCE AIELLO80))(POS (PAPER.BIBTEX AIELLO80 INPROCEEDINGS))(POS (PAPER.AUTHOR AIELLO80 "Luigia Aiello"))(POS (PAPER.TITLE AIELLO80 "Automatic Generation of Semantic Attachments in FOL"))(POS (PAPER.PUBLICATION AIELLO80 "AAAI"))(POS (PAPER.YEAR AIELLO80 1980))(POS (PAPER.RANK AIELLO80 "[**]"))(POS (PAPER.DESCRIPTION AIELLO80 "
Aiello describes a process of generating new semantic attachments from old
ones by compiling FOL into Lisp.
"))(POS (PAPER.TOPIC AIELLO80 "Theorem Proving with Attachments"))(POS (PAPER.INSTANCE ALFERES94))(POS (PAPER.AUTHOR ALFERES94 "J.J. Alferes, R. Li and L.M. Pereira"))(POS (PAPER.TITLE ALFERES94 "Concurrent Actions and Changes in the Situation Calculus"))(POS (PAPER.PUBLICATION ALFERES94 "Proceedings of IBERAMIA 94"))(POS (PAPER.STARTPAGE ALFERES94 93))(POS (PAPER.ENDPAGE ALFERES94 104))(POS (PAPER.LINK ALFERES94 "http://centria.fct.unl.pt/~lmp/publications/Biblio.html"))(POS (PAPER.YEAR ALFERES94 1994))(POS (PAPER.DESCRIPTION ALFERES94 "
Alferes shows that Situation Calculus extended with concurrent actions (e.g. buytoothpaste||buyshampoo) is no more expressive than standard Situation Calculus.  Intuitively, give names to every subset of actions since there are only 2^n such subsets of n actions.  Use those names as the actions in situation calculus.  The trouble here is how do we produce the effect axioms of a concurrent action set given the effect axioms of the individual actions?  Some of these axioms simply must be given by the user, e.g. buying toothpaste and shampoo at the same time might result in a free bar of soap, though neither effect axiom for buying toothpaste or shampoo would mention soap.  For those actions whose composition (in Alferes terms) can be determined automatically, the authors offer a solution using nonmonotonic logic: if Holds(p, Result(a, Result(b,s))) and Holds(p, Result(b, Result(a,s))) and there is no definition for Holds(p, Result(a||b),s), then conclude Holds(p, Result(a||b,s)).  Alferes elaborates the rule to include preconditions and subsets of size other than 2 (though some technical details arise in doing the latter).
"))(POS (PAPER.TOPIC ALFERES94 "Fundamentals"))(POS (PAPER.INSTANCE ALLEN90))(POS (PAPER.AUTHOR ALLEN90 "J. Allen, J. Hendler and A. Tate"))(POS (PAPER.TITLE ALLEN90 "Readings in Planning"))(POS (PAPER.LINK ALLEN90 "http://www.amazon.com/exec/obidos/ASIN/1558601309/qid%3D954347291/sr%3D1-13/002-1714614-2412067"))(POS (PAPER.YEAR ALLEN90 1990))(POS (PAPER.DESCRIPTION ALLEN90 "
Survey book on planning through 1990.
"))(POS (PAPER.TOPIC ALLEN90 "Historical"))(POS (PAPER.INSTANCE ALLWEIN96))(POS (PAPER.BIBTEX ALLWEIN96 BOOK))(POS (PAPER.AUTHOR ALLWEIN96 "Gerard Allwein and Jon Barwise"))(POS (PAPER.TITLE ALLWEIN96 "Logical Reasoning with Diagrams"))(POS (PAPER.PUBLISHER ALLWEIN96 "Oxford University Press"))(POS (PAPER.LINK ALLWEIN96 "http://www.amazon.com/exec/obidos/tg/detail/-/0195104277/104-6992918-7685512?vi=glance"))(POS (PAPER.YEAR ALLWEIN96 1996))(POS (PAPER.RANK ALLWEIN96 "[***]"))(POS (PAPER.DESCRIPTION ALLWEIN96 "
This book advocates the appropriate use of diagrams in formal, rigorous
proofs.  It formalizes the notions of entailment from a diagram and 
adjustments to a diagram.  The formalization is pretty complex, but
it is not obvious how to simplify it.  The book also looks at various
logics that can incorporate diagramatic methods.  The last two sections
are non-theoretical: a series of case studies and a series of heterogeneous
systems.  The bibiliography looks helpful.
"))(POS (PAPER.TOPIC ALLWEIN96 "Graphical Reasoning Techniques"))(POS (PAPER.INSTANCE ALSAC2002))(POS (PAPER.AUTHOR ALSAC2002 "Guray Alsac and Chitta Baral "))(POS (PAPER.TITLE ALSAC2002 "Reasoning in description logics using declarative logic programming"))(POS (PAPER.LINK ALSAC2002 "http://citeseer.ist.psu.edu/context/2398354/0"))(POS (PAPER.YEAR ALSAC2002 2002))(POS (PAPER.DESCRIPTION ALSAC2002 "
The authors discuss a nontrivial translation of a particular 
description logic into logic programming.
"))(POS (PAPER.TOPIC ALSAC2002 "Logic Programming"))(POS (PAPER.INSTANCE AMIR2001))(POS (PAPER.BIBTEX AMIR2001 PHDTHESIS))(POS (PAPER.AUTHOR AMIR2001 "Eyal Amir"))(POS (PAPER.TITLE AMIR2001 "Dividing and Conquering Logic"))(POS (PAPER.PUBLISHER AMIR2001 "Stanford University"))(POS (PAPER.LINK AMIR2001 ""))(POS (PAPER.YEAR AMIR2001 2001))(POS (PAPER.DESCRIPTION AMIR2001 "
Amir's thesis considers several problems related to the construction and
reasoning about large knowledge bases.  First he discusses object-oriented
first-order logic, a synthesis of the object oriented paradigm and
FOL.  Second he applies this logic to theories of action, most notably
situation calculus.  Third he shows how to parallelize automated
theorem proving where a theory has been partitioned into pieces.  Fourth
he gives algorithms for automatically decomposing theories, based on
the syntactic character of the axioms.  Last he describes a logic-based
subsumption architecture for automated robot control, similar in spirit
to Golog.  An appendix on logic, one on reactive control systems, and
30 pages of references round out the thesis.  It should be noted
that while he does augment various resolution procedures to work
in this parallel setting, the rest of the results are independent of
a particular calculus.
"))(POS (PAPER.TOPIC AMIR2001 "Logical Knowledge Representation"))(POS (PAPER.INSTANCE ARENAS98))(POS (PAPER.AUTHOR ARENAS98 "Marcello Arenas and Leopoldo Bertossi"))(POS (PAPER.TITLE ARENAS98 "Hypothetical Temporal Reasoning with History Encoding"))(POS (PAPER.PUBLICATION ARENAS98 "Knowledge Representation Meets Database"))(POS (PAPER.VOLUME ARENAS98 "4.1-4.8"))(POS (PAPER.LINK ARENAS98 "http://citeseer.ist.psu.edu/529093.html"))(POS (PAPER.YEAR ARENAS98 1998))(POS (PAPER.RANK ARENAS98 "[***]"))(POS (PAPER.DESCRIPTION ARENAS98 "
Arenas and Bertossi build on J. Chomicki's work of progressing a history of a database transaction's effects through the execution of a transaction to save on the costs of doing temporal constraint checking.  They also use Reiter's work on evaluating a query in the state that results after executing a sequence of actions.  The authors meld these two approaches to answer queries about the evolution of a database that contain quantification over states (for two specific types of queries).  This work also leads to a process for transforming dynamic integrity constraints into static ones and transforming history dependent action preconditions into local preconditions. 
"))(POS (PAPER.TOPIC ARENAS98 "Hypothetical Temporal DB Queries"))(POS (PAPER.RELATED ARENAS98 CHOMICKI95))(POS (PAPER.INSTANCE ARENAS98B))(POS (PAPER.AUTHOR ARENAS98B "Marcelo Arenas, Leopoldo Bertossi and Javier Pinto"))(POS (PAPER.TITLE ARENAS98B "Representation of Temporal Knowledge in the Situation Calculus"))(POS (PAPER.LINK ARENAS98B "http://citeseer.ist.psu.edu/527517.html"))(POS (PAPER.YEAR ARENAS98B 1998))(POS (PAPER.RANK ARENAS98B "[***]"))(POS (PAPER.DESCRIPTION ARENAS98B "
This incomplete paper describes translating a first-order modal temporal logic, Metric Time Temporal Logic, into situation calculus in the context of database updates.  The key insight is the creation of new relations that summarize information about the past.  Doing this gives us the power to write non-Markovian axioms (those that depend on a history of states instead of a just the last state).  
"))(POS (PAPER.TOPIC ARENAS98B "Hypothetical Temporal DB Queries"))(POS (PAPER.INSTANCE ARMANDO93))(POS (PAPER.BIBTEX ARMANDO93 ARTICLE))(POS (PAPER.AUTHOR ARMANDO93 "A. Armando and E. Giunchiglia"))(POS (PAPER.TITLE ARMANDO93 "Embedding complex decision procedures inside an interative theorem prover"))(POS (PAPER.PUBLICATION ARMANDO93 "Annals of Mathematics and Artificial Intelligence"))(POS (PAPER.VOLUME ARMANDO93 "8(3-4)"))(POS (PAPER.STARTPAGE ARMANDO93 475))(POS (PAPER.ENDPAGE ARMANDO93 502))(POS (PAPER.LINK ARMANDO93 "http://citeseer.ist.psu.edu/context/552111/0"))(POS (PAPER.YEAR ARMANDO93 1993))(POS (PAPER.DESCRIPTION ARMANDO93 "
Building a Non-CNF SAT solver out of a CNF SAT-solver.  
"))(POS (PAPER.TOPIC ARMANDO93 "SAT Solving"))(POS (PAPER.INSTANCE ARMANDO97))(POS (PAPER.BIBTEX ARMANDO97 TECHREPORT))(POS (PAPER.AUTHOR ARMANDO97 "A. Armando and S. Ranise"))(POS (PAPER.TITLE ARMANDO97 "From Integrated Reasoning Specialists to Plug-and-Play Reasoning Components"))(POS (PAPER.PUBLICATION ARMANDO97 "Technical Report
           "))(POS (PAPER.LINK ARMANDO97 "http://citeseer.ist.psu.edu/armando98from.html"))(POS (PAPER.YEAR ARMANDO97 1997))(POS (PAPER.RANK ARMANDO97 "[***]"))(POS (PAPER.DESCRIPTION ARMANDO97 "
Armando and Ranise investigate breaking apart a reasoner into its
constituent pieces.  This investigation aims at learning how to
describe reasoners in an effort to promote the heterogeneous integration
of reasoners.  Their case study is NQTHM, Boyer and Moore's linear
arithmetic decision procedure.
"))(POS (PAPER.TOPIC ARMANDO97 "Architectures"))(POS (PAPER.INSTANCE ASTRACHAN92))(POS (PAPER.BIBTEX ASTRACHAN92 INPROCEEDINGS))(POS (PAPER.AUTHOR ASTRACHAN92 "Owen Astrachan and Mark Stickel"))(POS (PAPER.TITLE ASTRACHAN92 "Caching and Lemmaizing in Model Elimination Theorem Provers"))(POS (PAPER.PUBLICATION ASTRACHAN92 "Proceedings of CADE"))(POS (PAPER.LINK ASTRACHAN92 "http://citeseer.ist.psu.edu/astrachan92caching.html"))(POS (PAPER.YEAR ASTRACHAN92 1992))(POS (PAPER.RANK ASTRACHAN92 "[***]"))(POS (PAPER.DESCRIPTION ASTRACHAN92 "
Caching essentially saves intermediate results of a proof in a lookup table and
checks that table to avoid repeating the search for a result already computed.
It keeps track of the depth at which solutions are found to ensure
the same solutions are found given the appropriate depth cutoff using
iterative deepening.  Lemmaizing adds a derived result to the set of input 
clauses, which hopefully will decrease the depth of the proof by more 
than it increases the branching factor. This seminal paper deals with the 
Horn case.
"))(POS (PAPER.TOPIC ASTRACHAN92 "Theorem Proving with Attachments"))(POS (PAPER.INSTANCE AUDEMARD2000))(POS (PAPER.BIBTEX AUDEMARD2000 INPROCEEDINGS))(POS (PAPER.AUTHOR AUDEMARD2000 "Gilles Audemard and Belaid Benhamou and Laurent Henocque"))(POS (PAPER.TITLE AUDEMARD2000 "Two techniques to improve Finite Model Search"))(POS (PAPER.PUBLICATION AUDEMARD2000 "Proceedings of the 17th International Conference on Automated Deduction"))(POS (PAPER.LINK AUDEMARD2000 "http://citeseer.ist.psu.edu/386981.html"))(POS (PAPER.YEAR AUDEMARD2000 2000))(POS (PAPER.DESCRIPTION AUDEMARD2000 "
Two techniques are introduced to speed up SEM-style model finding.
"))(POS (PAPER.TOPIC AUDEMARD2000 "Model Building"))(POS (PAPER.INSTANCE BACHMAIR97))(POS (PAPER.AUTHOR BACHMAIR97 "Leo Bachmair and Harald Ganzinger and Andrei Voronkov"))(POS (PAPER.TITLE BACHMAIR97 "Elimination of Equality via Transformation with Ordering Constraints"))(POS (PAPER.PUBLICATION BACHMAIR97 "CADE"))(POS (PAPER.LINK BACHMAIR97 "http://portal.acm.org/citation.cfm?id=648234.753446"))(POS (PAPER.YEAR BACHMAIR97 1997))(POS (PAPER.DESCRIPTION BACHMAIR97 "
This paper  builds on Brand's method for eliminating the substitution,
reflexivity, symmetry, and transitivity axioms of equality by rewriting
the rules.  It adds ordering constraints in the process of transformation,
which seems to be one of the big benefits.
"))(POS (PAPER.TOPIC BACHMAIR97 "Transformations"))(POS (PAPER.INSTANCE BARALIS97))(POS (PAPER.BIBTEX BARALIS97 INPROCEEDINGS))(POS (PAPER.AUTHOR BARALIS97 "Baralis and Paraboschi and Teniente"))(POS (PAPER.TITLE BARALIS97 "Materialized view selection in a multidimensional database"))(POS (PAPER.PUBLICATION BARALIS97 "In proceedings of Very Large Databases (VLDB)"))(POS (PAPER.STARTPAGE BARALIS97 155))(POS (PAPER.ENDPAGE BARALIS97 165))(POS (PAPER.YEAR BARALIS97 1997))(POS (PAPER.DESCRIPTION BARALIS97 "
Paper on view selection problem in databases
"))(POS (PAPER.TOPIC BARALIS97 "Databases"))(POS (PAPER.INSTANCE BARRETT2000))(POS (PAPER.BIBTEX BARRETT2000 INPROCEEDINGS))(POS (PAPER.AUTHOR BARRETT2000 "Clark Barrett and David Dill and Aaron Stump"))(POS (PAPER.TITLE BARRETT2000 "A Framework for Cooperating Decision Procedures"))(POS (PAPER.PUBLICATION BARRETT2000 "17th International Conference on Automated Deduction
           "))(POS (PAPER.LINK BARRETT2000 "http://citeseer.ist.psu.edu/barrett00framework.html"))(POS (PAPER.YEAR BARRETT2000 2000))(POS (PAPER.RANK BARRETT2000 "[**]"))(POS (PAPER.DESCRIPTION BARRETT2000 "
Barrett et. al. describe a framework approach for building reasoners
that combine decision procedures.  This work is a precurser to janicic2002.
They introduce half a dozen operations that can be used to interrelate
these decision procedures; they further show how Nelson Oppen and
Shostak procedures can be built in their framework.
"))(POS (PAPER.TOPIC BARRETT2000 "Architectures"))(POS (PAPER.RELATED BARRETT2000 JANICIC2002))(POS (PAPER.INSTANCE BAUMGARTNER2003))(POS (PAPER.BIBTEX BAUMGARTNER2003 ARTICLE))(POS (PAPER.AUTHOR BAUMGARTNER2003 "Peter Baumgartner and Cesare Tinelli"))(POS (PAPER.TITLE BAUMGARTNER2003 "The Model Evolution Calculus"))(POS (PAPER.PUBLICATION BAUMGARTNER2003 "19th International Conference on Automated
    Deduction"))(POS (PAPER.STARTPAGE BAUMGARTNER2003 350))(POS (PAPER.ENDPAGE BAUMGARTNER2003 364))(POS (PAPER.LINK BAUMGARTNER2003 "http://sherry.ifi.unizh.ch/577584.html"))(POS (PAPER.YEAR BAUMGARTNER2003 2003))(POS (PAPER.RANK BAUMGARTNER2003 "[****]"))(POS (PAPER.DESCRIPTION BAUMGARTNER2003 "
Baumgartner and Tinelli describe a first-order version of the DPLL 
(Davis-Putnam-Logemann-Loveland) SAT solver.  In the case of
propositional logic, ME reduces to DPLL.  It differs in the first-order
case because of additional inference rules and skolemization.  The procedure
works by exaustively trying to build a first-order model.  If the search 
fails, the sentences are unsatisfiable.  But if the sentences are satisfiable,
the procedure may run forever trying to construct one.  (Obviously if there
are only infinite models this technique may have issues.) 
"))(POS (PAPER.TOPIC BAUMGARTNER2003 "The Model Evolution Calculus"))(POS (PAPER.INSTANCE BAUMGARTNER2007))(POS (PAPER.BIBTEX BAUMGARTNER2007 ARTICLE))(POS (PAPER.AUTHOR BAUMGARTNER2007 "Peter Baumgartner and Alexander Fuchs and Hans Nivelle and Cesare Tinelli"))(POS (PAPER.TITLE BAUMGARTNER2007 "Computing Finite Models by Reduction to Function-Free Clause Logic"))(POS (PAPER.PUBLICATION BAUMGARTNER2007 "Journal of Applied Logic"))(POS (PAPER.LINK BAUMGARTNER2007 "http://goedel.cs.uiowa.edu/Darwin/"))(POS (PAPER.YEAR BAUMGARTNER2007 2007))(POS (PAPER.DESCRIPTION BAUMGARTNER2007 "
Paper on FMDarwin for building finite models of clause sets.  Unlike
techniques for finding a model directly and techniques that ground out
sentences and invoke a SAT solver, FMDarwin reduces a set of clauses
to function-free clause logic in a way that preserves satisfiability
for a particular size domain.  Then it uses Darwin, an implementation
of the model evolution calculus, to check the satisfiability of
the function-free clauses, iterating through domain sizes.  
"))(POS (PAPER.TOPIC BAUMGARTNER2007 "Model Building"))(POS (PAPER.INSTANCE BAUMGARTNER94))(POS (PAPER.AUTHOR BAUMGARTNER94 "Peter Baumgartner and Ulrich Furbach"))(POS (PAPER.TITLE BAUMGARTNER94 "Model Elimination Without Contrapositives"))(POS (PAPER.PUBLICATION BAUMGARTNER94 "Proceedings of Conference on Automated Deduction"))(POS (PAPER.VOLUME BAUMGARTNER94 "814"))(POS (PAPER.STARTPAGE BAUMGARTNER94 87))(POS (PAPER.ENDPAGE BAUMGARTNER94 101))(POS (PAPER.LINK BAUMGARTNER94 "http://portal.acm.org/citation.cfm?id=752966"))(POS (PAPER.YEAR BAUMGARTNER94 1994))(POS (PAPER.DESCRIPTION BAUMGARTNER94 "
Baumgartner and Furbach introduce Restart Model Elimination and a couple of refinements.
RME obviates the need for contrapositives; all the rules are written in the form
A1 | ... | An <= B1 ^ ... ^ Bm, i.e. the only extension steps that can be performed
are on one of the Ai.  The price we pay is that whenever the literal on the top of the 
stack is positive, we put the goal literal onto the top of the stack (forcibly in
strict RME), hence the name Restart ME.  Also, this means that ancestry pruning cannot
be used with RME if completeness is to be preserved.  Soundness and refutational 
completeness results.  Some experimental results and fairly lengthy comparison
to other calculi.
"))(POS (PAPER.TOPIC BAUMGARTNER94 "Calculi"))(POS (PAPER.INSTANCE BAUMGARTNER95))(POS (PAPER.BIBTEX BAUMGARTNER95 ARTICLE))(POS (PAPER.AUTHOR BAUMGARTNER95 "Peter Baumgartner and Ulrich Furbach and Frieder Stolzenburg"))(POS (PAPER.TITLE BAUMGARTNER95 "Model Elimination, Logic Programming and Computing Answers"))(POS (PAPER.PUBLICATION BAUMGARTNER95 "Technical Report"))(POS (PAPER.LINK BAUMGARTNER95 "http://citeseer.ist.psu.edu/144755.html"))(POS (PAPER.YEAR BAUMGARTNER95 1995))(POS (PAPER.DESCRIPTION BAUMGARTNER95 "
The authors demonstrate that restart model elimination can be used as a complete
interpreter for positive disjunctive logic programming.  That is, they show how
to adjust RME so that it is complete for (definite) answer extraction.  With proofs.
Also, they introduce a limited form of ancestry pruning.  More experiments.
"))(POS (PAPER.TOPIC BAUMGARTNER95 "Calculi"))(POS (PAPER.INSTANCE BELL95))(POS (PAPER.BIBTEX BELL95 ARTICLE))(POS (PAPER.AUTHOR BELL95 "John Bell"))(POS (PAPER.TITLE BELL95 "Pragmatic Reasoning: A model-based theory"))(POS (PAPER.PUBLISHER BELL95 "Kluwer Academic Publishers"))(POS (PAPER.PUBLICATION BELL95 "Applied Logic: How, What and Why"))(POS (PAPER.LINK BELL95 "http://citeseer.ist.psu.edu/bell92pragmatic.html"))(POS (PAPER.YEAR BELL95 1995))(POS (PAPER.RANK BELL95 "[****]"))(POS (PAPER.DESCRIPTION BELL95 "
Bell defines pragmatic reasoning as context-dependent reasoning, in
contrast to deduction which is context-free.  He mathematizes
the two model-theoretically and discusses different versions
of pragmatic entailment.  He compares it to mental models, and
looks at different techniques that have been developed for
expressing pragmatic reasoning tasks.
"))(POS (PAPER.TOPIC BELL95 "Logical Knowledge Representation"))(POS (PAPER.INSTANCE BEREZIN2002))(POS (PAPER.BIBTEX BEREZIN2002 PHDTHESIS))(POS (PAPER.AUTHOR BEREZIN2002 "Sergey Berezin"))(POS (PAPER.TITLE BEREZIN2002 "Model Checking and Theorem Proving: A Unified Framework"))(POS (PAPER.PUBLICATION BEREZIN2002 "CMU Ph.D. Thesis"))(POS (PAPER.LINK BEREZIN2002 "http://chicory.stanford.edu/~berezin/thesis/"))(POS (PAPER.YEAR BEREZIN2002 2002))(POS (PAPER.RANK BEREZIN2002 "[**]"))(POS (PAPER.DESCRIPTION BEREZIN2002 "
This thesis builds a framework for integrating model checking and 
theorem proving, focusing on formal verification applications.  
The basic framework proves first-order branching time mu-calculus
properties of Kripke models, but the inference rules can be easily
changed to facilitate the fast development of new proof systems
(called model provers).  Related work is not so thorough. 
"))(POS (PAPER.TOPIC BEREZIN2002 "Model Checking"))(POS (PAPER.INSTANCE BLACKBURN))(POS (PAPER.BIBTEX BLACKBURN BOOK))(POS (PAPER.AUTHOR BLACKBURN "Patrick Blackburn and Johan van Benthem and Frank Wolter"))(POS (PAPER.TITLE BLACKBURN "Handbook of Modal Logic"))(POS (PAPER.PUBLISHER BLACKBURN "Elsevier Science"))(POS (PAPER.LINK BLACKBURN "http://www.elsevier.com/wps/find/bookdescription.cws_home/708884/description#description"))(POS (PAPER.YEAR BLACKBURN 2006))(POS (PAPER.RANK BLACKBURN "[*****]"))(POS (PAPER.DESCRIPTION BLACKBURN "
A handbook for modal logic, covering basic and advanced theory, variations and extensions, and applications.
"))(POS (PAPER.TOPIC BLACKBURN ""))(POS (PAPER.INSTANCE BODIRSKY2004))(POS (PAPER.BIBTEX BODIRSKY2004 PHDTHESIS))(POS (PAPER.AUTHOR BODIRSKY2004 "Manuel Bodirsky"))(POS (PAPER.TITLE BODIRSKY2004 "Constraint Satisfaction with Infinite Domains"))(POS (PAPER.LINK BODIRSKY2004 "http://www.informatik.hu-berlin.de/~bodirsky/publications/diss.html"))(POS (PAPER.YEAR BODIRSKY2004 2004))(POS (PAPER.DESCRIPTION BODIRSKY2004 "
Bodirsky examines the problem of the homomorphic CSP: given one structure,
is it homomorphic to the target structure?  He for the first time
considers target structures that are countably large; more precisely,
those that are countably large but are omega categorical, i.e. 
all countable models of the first-order theory of that model are isomorphic.
In this work, he produces an algorithm for constructing a tree that
satisfies a given set of constraints, where those constraints require
the existence of nodes that meet certain conditions.  Three possible conditions:
x is an ancestor of y, x and y are equal, and x occurs in a subtree to
the left of the subtree that includes y.  While these constraints force
nodes to exist that satisfy particular relationships, OOCSPs force 
particular nodes to have a particular relationship.
"))(POS (PAPER.TOPIC BODIRSKY2004 "Miscellaneous"))(POS (PAPER.INSTANCE BONACINA97))(POS (PAPER.BIBTEX BONACINA97 INPROCEEDINGS))(POS (PAPER.AUTHOR BONACINA97 "Maria Bonacina"))(POS (PAPER.TITLE BONACINA97 "Machine-independent evaluation of theorem-proving strategies"))(POS (PAPER.PUBLICATION BONACINA97 "Workshop on Theorem Proving Strategies"))(POS (PAPER.STARTPAGE BONACINA97 37))(POS (PAPER.ENDPAGE BONACINA97 39))(POS (PAPER.LINK BONACINA97 "http://citeseer.ist.psu.edu/bonacina97machineindependent.html"))(POS (PAPER.YEAR BONACINA97 1997))(POS (PAPER.RANK BONACINA97 "[***]"))(POS (PAPER.DESCRIPTION BONACINA97 "
Bonacina's position piece explains the need for 'strategy analysis' of
theorem proving techniques.  'Strategy analysis' focuses on theorem-proving
complexity as in plaisted94, but also incorporates indexing, data-structures,
unification complexity, etc.   Bonacina gives a summary of another paper 
that confronts the problem representing deletion strategies in a search
space.  Cites kowalski69 as handling the case where results are never
deleted.  She also explains how a sizable body of related work 
concentrates on the complexity of a logical formalism without reference
to any automated proof-finding system, e.g. goubault94.  
"))(POS (PAPER.TOPIC BONACINA97 "Comparative Analysis"))(POS (PAPER.RELATED BONACINA97 KOWALSKI69))(POS (PAPER.RELATED BONACINA97 GOUBAULT94))(POS (PAPER.INSTANCE BONACINA98))(POS (PAPER.BIBTEX BONACINA98 MISC))(POS (PAPER.AUTHOR BONACINA98 "Maria Bonacina"))(POS (PAPER.TITLE BONACINA98 "Strategy analysis: from Sequential to parallel strategies"))(POS (PAPER.STARTPAGE BONACINA98 21))(POS (PAPER.ENDPAGE BONACINA98 23))(POS (PAPER.LINK BONACINA98 "http://citeseer.ist.psu.edu/36838.html"))(POS (PAPER.YEAR BONACINA98 1998))(POS (PAPER.RANK BONACINA98 "[*]"))(POS (PAPER.DESCRIPTION BONACINA98 "
Bonacina's position paper describes the formalization of the
search space for parallelized theorem proving with contraction
operations.  This paper covers the main ideas, but the meat looks
to be cited in two technical reports.
"))(POS (PAPER.TOPIC BONACINA98 "Comparative Analysis"))(POS (PAPER.INSTANCE BORGER))(POS (PAPER.BIBTEX BORGER BOOK))(POS (PAPER.AUTHOR BORGER "Egon Borger and Erich Gradel and Yuri Gurevich"))(POS (PAPER.TITLE BORGER "The Classical Decision Problem"))(POS (PAPER.PUBLISHER BORGER "Springer-Verlag"))(POS (PAPER.LINK BORGER "http://books.google.com/books?id=3po2Tv_UVcMC&dq=&pg=PP1&ots=FMOqyLGt4N&sig=7pB4XtFUSbGbiUuF4XlKGattRts&prev=http://www.google.com/search%3Fclient%3Dsafari%26rls%3Den%26q%3Dthe%2Bclassical%2Bdecision%2Bproblem%26ie%3DUTF-8%26oe%3DUTF-8&sa=X&oi=print&ct=title#PPP1,M1"))(POS (PAPER.YEAR BORGER 1997))(POS (PAPER.DESCRIPTION BORGER "
The book detailing decidability results for entailment in various prefix
classes of first-order logic, along with complexity results for the 
decidable classes.
"))(POS (PAPER.TOPIC BORGER ""))(POS (PAPER.INSTANCE BORNING92))(POS (PAPER.BIBTEX BORNING92 ARTICLE))(POS (PAPER.AUTHOR BORNING92 "A. Borning and B.N. Freeman-Benson and M. Wilson"))(POS (PAPER.TITLE BORNING92 "Constraint hierarchies"))(POS (PAPER.PUBLICATION BORNING92 "Lisp and Symbolic Computation"))(POS (PAPER.VOLUME BORNING92 "5"))(POS (PAPER.STARTPAGE BORNING92 223))(POS (PAPER.ENDPAGE BORNING92 270))(POS (PAPER.LINK BORNING92 "http://citeseer.ist.psu.edu/borning92constraint.html"))(POS (PAPER.YEAR BORNING92 1992))(POS (PAPER.RANK BORNING92 "[*]"))(POS (PAPER.DESCRIPTION BORNING92 "
Constraint hierarchies, aka Hierarchical Constraint Satisfaction Problems,
impose a precedence hierarchy on constraints.  Only the highest 
precedence constraints must be satisfied; the others constraints
form an ordered set of preferences on the solutions.
"))(POS (PAPER.TOPIC BORNING92 "Object Oriented Constraint Satisfaction"))(POS (PAPER.INSTANCE BORRETT2001))(POS (PAPER.AUTHOR BORRETT2001 "James Borrett and Edward Tsang"))(POS (PAPER.TITLE BORRETT2001 "A Context for Constraint Satisfaction Problem Formulation Selection"))(POS (PAPER.PUBLICATION BORRETT2001 "Constraints"))(POS (PAPER.VOLUME BORRETT2001 "6"))(POS (PAPER.STARTPAGE BORRETT2001 299))(POS (PAPER.ENDPAGE BORRETT2001 327))(POS (PAPER.LINK BORRETT2001 "http://citeseer.ist.psu.edu/borret99context.html"))(POS (PAPER.YEAR BORRETT2001 2001))(POS (PAPER.RANK BORRETT2001 "[***]"))(POS (PAPER.DESCRIPTION BORRETT2001 "
Borrett and Tsang construct a framework for searching through various constraint satisfaction problem formulations and selecting one.  They only consider
formulations of the form <V,D,C>, i.e. typical CSP formulations.  They break the problem into 4 parts: generating an initial formulation, constructing operators to change that formulation, constructing heuristics for choosing which operator to apply, and constructing an evaluation function to that determines the cost of a given formulation.  They go on to demonstrate a particular type of operator: the introduction of redundant constraints and show how searching through CSP formulations with this type of operator works in their framework.
"))(POS (PAPER.TOPIC BORRETT2001 "Reformulation"))(POS (PAPER.INSTANCE BOWEN91))(POS (PAPER.BIBTEX BOWEN91 ARTICLE))(POS (PAPER.AUTHOR BOWEN91 "J. Bowen and D. Bahler"))(POS (PAPER.TITLE BOWEN91 "Conditional Existence of Variables in Generalized Constraint Networks
"))(POS (PAPER.PUBLICATION BOWEN91 "AAAI "))(POS (PAPER.LINK BOWEN91 "http://www.csc.ncsu.edu/faculty/bahler/aaai91/aaai91.pdf"))(POS (PAPER.YEAR BOWEN91 1991))(POS (PAPER.DESCRIPTION BOWEN91 "
Bowen and Bahler employ Free Logic to construct a constraint network
where not all variables must be assigned values.  A constraint network
is defined as a set of logical sentences with a DCA; 
a solution is an interpretation
of the vocabulary in a model so that the sentences are satisfied.  
Free logic differs from FOL in that not every element in the vocabulary
needs to be mapped into the model.
"))(POS (PAPER.TOPIC BOWEN91 "Miscellaneous"))(POS (PAPER.INSTANCE BRY2007))(POS (PAPER.BIBTEX BRY2007 ARTICLE))(POS (PAPER.AUTHOR BRY2007 "Francois Bry and Norbert Eisinger and Thomas Eiter and Tim Furche and Georg Gottlob and Clemens Ley and Benedikt Linse and Reinhard Pichler and Fang Wei"))(POS (PAPER.TITLE BRY2007 "Foundations of Rule-Based Query Answering"))(POS (PAPER.PUBLICATION BRY2007 "Reasoning Web, Third International Summer School 2007, Grigoris Antoniou, Uwe Assmann, Cristina Baroglio, Stefan Decker, Nicola Henze, Paula-Lavinia Patranjan, Robert Tolksdorf (editors)"))(POS (PAPER.VOLUME BRY2007 "LNCS 4636"))(POS (PAPER.LINK BRY2007 "http://www.pms.ifi.lmu.de/publikationen/index.html#PMS-FB-2007-7"))(POS (PAPER.YEAR BRY2007 2007))(POS (PAPER.DESCRIPTION BRY2007 "
The mathematical foundations of logical query languages.
"))(POS (PAPER.TOPIC BRY2007 "Logical Knowledge Representation"))(POS (PAPER.INSTANCE BUNDY73))(POS (PAPER.BIBTEX BUNDY73 INPROCEEDINGS))(POS (PAPER.AUTHOR BUNDY73 "Alan Bundy"))(POS (PAPER.TITLE BUNDY73 "Doing Arithmetic With Diagrams"))(POS (PAPER.PUBLICATION BUNDY73 "IJCAI"))(POS (PAPER.YEAR BUNDY73 1973))(POS (PAPER.RANK BUNDY73 "[**]"))(POS (PAPER.DESCRIPTION BUNDY73 "
Bundy describes SUMS (System which Understands Mathematical
Symbols), a theorem prover for theorems over natural numbers.
The SUMS proof process represents the natural numbers in
a diagram, and by manipulating the diagram, determines the
truth of a conjecture.  Bundy makes an interesting point at the 
end of the paper: mathematicians do not usually manipulate
logic to prove theorems.  Rather, they convince themselves
of the correctness of a conjecture through diagrams or other
semantic insights and then use logic as a language for
communicating to others the proof of the theorem.  SUMS
is an attempt at building a machine that simply 
convinces itself of the truth of a conjecture.
"))(POS (PAPER.TOPIC BUNDY73 "Graphical Reasoning Techniques"))(POS (PAPER.INSTANCE BUNDY99))(POS (PAPER.AUTHOR BUNDY99 "Alan Bundy"))(POS (PAPER.TITLE BUNDY99 "A Survey of Automated Deduction"))(POS (PAPER.LINK BUNDY99 "http://citeseer.ist.psu.edu/bundy99survey.html"))(POS (PAPER.YEAR BUNDY99 1999))(POS (PAPER.RANK BUNDY99 ""))(POS (PAPER.DESCRIPTION BUNDY99 "
Bundy surveys research in automated deduction.  He focuses on resolution,
term rewriting, built-in unification, higher-order logics and type-theory,
induction, interactive theorem-proving, meta-reasoning, common sense
reasoning, and logic programming.
"))(POS (PAPER.TOPIC BUNDY99 "Theorem Proving"))(POS (PAPER.INSTANCE BYLANDER94))(POS (PAPER.AUTHOR BYLANDER94 "Tom Bylander"))(POS (PAPER.TITLE BYLANDER94 "The Computational Complexity of Propositional STRIPS Planning"))(POS (PAPER.PUBLICATION BYLANDER94 "Artificial Intelligence"))(POS (PAPER.VOLUME BYLANDER94 "69(1-2)"))(POS (PAPER.STARTPAGE BYLANDER94 165))(POS (PAPER.ENDPAGE BYLANDER94 204))(POS (PAPER.LINK BYLANDER94 "http://citeseer.ist.psu.edu/bylander94computational.html"))(POS (PAPER.YEAR BYLANDER94 1994))(POS (PAPER.DESCRIPTION BYLANDER94 "
Bylander discusses complexity results for propositional STRIPS; he also mentions that a class of first-order STRIPS can be reduced in polynomial time to propositional STRIPS, making these results widely applicable.  PLANSAT (decision problem for determining whether an instance of prop STRIPS planning is satisfiable) is PSPACE-complete.  PLANSAT[2+,2] (PLANSAT where all operators have at least 2 positive preconditions and 2 postconditions) is also PSPACE-complete.  Results are shown for a variety of restrictions, concluding that without severe restrictions, PLANSAT is NP-complete or PSPACE-complete.
These results carry over to PLANMIN (the decision problem of determining whether an instance has a solution of k or fewer operators.  The new results here show a variety of PLANMIN are NP-complete, and a couple, very restricted versions are polynomial.  He also shows results for Propositional Strips with formulas (Extended Propositional STRIPS).  EPLANSAT, EPLANSAT[0,1+] restricted to define Horn clauses are PSPACE-complete.  More results are shown for EPLANSAT and EPLANSATMIN.  See paper for details.
"))(POS (PAPER.TOPIC BYLANDER94 "Historical"))(POS (PAPER.INSTANCE BYRNE2000))(POS (PAPER.BIBTEX BYRNE2000 MISC))(POS (PAPER.AUTHOR BYRNE2000 "Ruth Byrne and Lisa Gilroy"))(POS (PAPER.TITLE BYRNE2000 "Mental Models Website"))(POS (PAPER.LINK BYRNE2000 "http://www.tcd.ie/Psychology/Ruth_Byrne/mental_models/index.html"))(POS (PAPER.YEAR BYRNE2000 2000))(POS (PAPER.DESCRIPTION BYRNE2000 "
Mental Models website--the Psychology version of model-based reasoning.
"))(POS (PAPER.TOPIC BYRNE2000 "Model-Based Reasoning"))(POS (PAPER.INSTANCE CADOLI2000))(POS (PAPER.BIBTEX CADOLI2000 MISC))(POS (PAPER.AUTHOR CADOLI2000 "Marco Cadoli and Francesco M. Donini and Paolo Liberatore and Marco Schaerf"))(POS (PAPER.TITLE CADOLI2000 "Preprocessing of Intractable Problems"))(POS (PAPER.PUBLICATION CADOLI2000 "Information and Computation"))(POS (PAPER.VOLUME CADOLI2000 "176(2)"))(POS (PAPER.STARTPAGE CADOLI2000 89))(POS (PAPER.ENDPAGE CADOLI2000 120))(POS (PAPER.LINK CADOLI2000 "http://citeseer.ist.psu.edu/cadoli00preprocessing.html"))(POS (PAPER.YEAR CADOLI2000 2000))(POS (PAPER.RANK CADOLI2000 "[**]"))(POS (PAPER.DESCRIPTION CADOLI2000 "
This paper describes complexity classes for algorithms after they
have been preprocessed, or compiled.  The problems targeted have two
parts, one that is fixed, and one that changes frequently.  For
example, determining whether Delta entails a sentence phi has a
fixed part (Delta) and a changing part (phi).  If we could compile
Delta into a more vivid representation, computing entailment might
be easier.  This paper formalizes that idea, gives a complexity class
hierarchy, and a method for reductions.  Cool ideas, but very
theoretical (and only with propositional KB examples).
"))(POS (PAPER.TOPIC CADOLI2000 "Knowledge Base Compilation"))(POS (PAPER.INSTANCE CADOLI2000B))(POS (PAPER.BIBTEX CADOLI2000B MISC))(POS (PAPER.AUTHOR CADOLI2000B "Marco Cadoli and Francesco Donini and Paolo Liberatore and Marco Schaerf"))(POS (PAPER.TITLE CADOLI2000B "Space Efficiency of Propositional Knowledge Representation Formalisms"))(POS (PAPER.PUBLICATION CADOLI2000B "Journal of Artificial Intelligence Research"))(POS (PAPER.VOLUME CADOLI2000B "13"))(POS (PAPER.STARTPAGE CADOLI2000B 1))(POS (PAPER.ENDPAGE CADOLI2000B 31))(POS (PAPER.LINK CADOLI2000B "http://citeseer.ist.psu.edu/cadoli00space.html"))(POS (PAPER.YEAR CADOLI2000B 2000))(POS (PAPER.RANK CADOLI2000B "[*****]"))(POS (PAPER.DESCRIPTION CADOLI2000B "
The authors leverage previous work on compilation complexity classes to compare
various propositional knowledge formalisms.  They introduce two axes for comparing
such formalisms under translation: theorem-preservation and model-preservation.
That is, given a set of sentences in one formalism, translate those sentences
into another formalism so that (1) the theorems are preserved across the translation
after a translation of their own or (2) the models are preserved across the
translation after a translation of their own.  The translation of premise sets
is assumed to be polynomial in size; the requirement on the translation of
theorems/models is that the representation of the translation process itself
must be polynomial in size.  

The authors then introduce the notion of 
model-C and thm-C classes.  A formalism belongs to the model-C class iff 
model checking in that formalism is in the compilability class C, where the KB is 
the fixed part and the model is the varying part.  A formalism belongs to
the thm-C class iff inference in that formalism is in the compilability class C,
where the KB is the fixed part and the query is the varying part.

Next the authors prove that two formalisms in the same model-C/thm-C class then
there must be a poly-size reduction between the two formalisms that 
preserves models/theorems.  They also show that if two problems are in different
classes there is no polynomial size reduction satisfying models/theorems.

Finally, the propositional formalisms stable model semantics, circumscription, 
generalized closed world, skeptical default logic, credulous default logic, 
WIDTIO belief revision, and skeptical belief revision are analyzed in this 
framework, giving fairly complete coverage of inference/model space complexity.
"))(POS (PAPER.TOPIC CADOLI2000B "Knowledge Base Compilation"))(POS (PAPER.INSTANCE CADOLI2001))(POS (PAPER.AUTHOR CADOLI2001 "Marco Cadoli and Andrea Schaerf"))(POS (PAPER.TITLE CADOLI2001 "Compiling Problem Specifications into SAT"))(POS (PAPER.PUBLICATION CADOLI2001 "Lecture Notes in Computer Science"))(POS (PAPER.VOLUME CADOLI2001 "2028"))(POS (PAPER.LINK CADOLI2001 "http://citeseer.ist.psu.edu/cadoli01compiling.html"))(POS (PAPER.RANK CADOLI2001 "[***]"))(POS (PAPER.DESCRIPTION CADOLI2001 "
Cadoli and Schaerf describe a language, NP-Spec, for specifying problems
in NP, and a technique for translating that language into SAT.  They
mention a previous translation into Prolog.  With SAT, results were
far better than with Prolog; that is, they could solve what they called
medium-sized problems instead of just small problems.  NP-Spec is based
on Prolog without negation (except on some predefined predicates) with
a fixed database. It includes a mix of metalevel constraints and object-level
constraints.
"))(POS (PAPER.TOPIC CADOLI2001 "Knowledge Base Compilation"))(POS (PAPER.INSTANCE CADOLI2002))(POS (PAPER.AUTHOR CADOLI2002 "Marco Cadoli and Toni Mancini"))(POS (PAPER.TITLE CADOLI2002 "Knowledge compilation = Query rewriting + View synthesis"))(POS (PAPER.PUBLICATION CADOLI2002 "Symposium on Principles of Database Systems"))(POS (PAPER.STARTPAGE CADOLI2002 199))(POS (PAPER.ENDPAGE CADOLI2002 208))(POS (PAPER.LINK CADOLI2002 "http://citeseer.ist.psu.edu/641562.html"))(POS (PAPER.RANK CADOLI2002 "[***]"))(POS (PAPER.DESCRIPTION CADOLI2002 "
Cadoli describes a class of propositional knowledge compilation  where
the problem is transformed into a database and a second-order
query over that database.  The database is a straight-forward representation
of the clausal form of the input.  The authors give syntactic conditions
under which the problem can be compiled into P using this technique.
"))(POS (PAPER.TOPIC CADOLI2002 "Knowledge Base Compilation"))(POS (PAPER.INSTANCE CADOLI97))(POS (PAPER.BIBTEX CADOLI97 ARTICLE))(POS (PAPER.AUTHOR CADOLI97 "Marco Cadoli and Francesco M. Donini"))(POS (PAPER.TITLE CADOLI97 "A Survey on Knowledge Compilation"))(POS (PAPER.PUBLICATION CADOLI97 "AI Communications"))(POS (PAPER.VOLUME CADOLI97 "10(3-4)"))(POS (PAPER.STARTPAGE CADOLI97 137))(POS (PAPER.ENDPAGE CADOLI97 150))(POS (PAPER.LINK CADOLI97 "http://citeseer.ist.psu.edu/cadoli98survey.html"))(POS (PAPER.YEAR CADOLI97 1997))(POS (PAPER.RANK CADOLI97 "[***]"))(POS (PAPER.DESCRIPTION CADOLI97 "
Cadoli and Donini review techniques for propositional knowledge base compilation.  
The goal
is to rewrite a KB in a form that will answer queries more quickly.  They survey
exact compilation: prime implicates and implicants, unit-resolution-complete 
methods, and theory prime implicates.  They look at approximate compilation:
anytime versions of exact methods, horn approximations (can result in unsound
inference).  They consider compiling non-monotonic knowledge bases with
circumscription, default logic, and belief revision.  All those techniques aim
to reduce intractable query answering to tractable query answering.  Lastly,
Cadoli and Donini mention compilations of _polynomial-time_ query answering,
compilations into something other than a KB, and compare compilation to 
fixed-parameter tractability.
"))(POS (PAPER.TOPIC CADOLI97 "Knowledge Base Compilation"))(POS (PAPER.INSTANCE CASEAU94))(POS (PAPER.AUTHOR CASEAU94 "Yves Caseau"))(POS (PAPER.TITLE CASEAU94 "Constraint Satisfaction with an Object-Oriented Knowledge
Representation Language"))(POS (PAPER.PUBLICATION CASEAU94 "Applied Intelligence "))(POS (PAPER.VOLUME CASEAU94 "4(2)"))(POS (PAPER.STARTPAGE CASEAU94 157))(POS (PAPER.ENDPAGE CASEAU94 184))(POS (PAPER.LINK CASEAU94 "http://citeseer.ist.psu.edu/caseau94constraint.html"))(POS (PAPER.YEAR CASEAU94 1994))(POS (PAPER.RANK CASEAU94 "[***]"))(POS (PAPER.DESCRIPTION CASEAU94 "
Caseau describes how one might solve constraint satisfaction problems
using Laure, an object-oriented language that combines declarative
and procedural knowledge.  In Laure, a Database is used to model
the world; solving a problem amounts to finding objects to fill
goals and satisfy constraints.  Those objects are completions of
the database.  CSPs can be represented by attaching constraints
to objects; a finite number of these objects allows standard 
CSP techniques, e.g. arc consistency, to find solutions.
"))(POS (PAPER.TOPIC CASEAU94 "OO Languages with Native Constraint Satisfaction"))(POS (PAPER.INSTANCE CASEAU96))(POS (PAPER.BIBTEX CASEAU96 ARTICLE))(POS (PAPER.AUTHOR CASEAU96 "Yves Caseau, Francois Laburthe"))(POS (PAPER.TITLE CASEAU96 "CLAIRE: a brief overview"))(POS (PAPER.PUBLICATION CASEAU96 ""))(POS (PAPER.LINK CASEAU96 "http://citeseer.ist.psu.edu/caseau96claire.html"))(POS (PAPER.YEAR CASEAU96 1996))(POS (PAPER.RANK CASEAU96 "[**]"))(POS (PAPER.DESCRIPTION CASEAU96 "
CLAIRE is a programming language designed to be C++ compliant that  
can compute using constraints natively.
"))(POS (PAPER.TOPIC CASEAU96 "OO Languages with Native Constraint Satisfaction"))(POS (PAPER.INSTANCE CHANGLEE))(POS (PAPER.BIBTEX CHANGLEE BOOK))(POS (PAPER.AUTHOR CHANGLEE "Chin-Liang Chang and Richard Lee"))(POS (PAPER.TITLE CHANGLEE "Symbolic Logic and Mechanical Theorem Proving"))(POS (PAPER.PUBLISHER CHANGLEE "Academic Press"))(POS (PAPER.LINK CHANGLEE "http://www.amazon.com/exec/obidos/ASIN/0121703509/qid%3D965533387/sr%3D1-1/102-6107129-2481765"))(POS (PAPER.YEAR CHANGLEE 1973))(POS (PAPER.RANK CHANGLEE ""))(POS (PAPER.DESCRIPTION CHANGLEE "
A classic text for automated reasoning.  Chang and Lee cover propositional and
first-order logic, Herbrand's theorem, resolution (standard, semantic, lock,
and linear) and equality.  They discuss an alternative to resolution, 
Prawitz's procedure and V-resolution.  A chapter on program analysis
leads to query answering and program synthesis in the final chapter.
"))(POS (PAPER.TOPIC CHANGLEE ""))(POS (PAPER.INSTANCE CHEN2000))(POS (PAPER.AUTHOR CHEN2000 "Hubie Chen"))(POS (PAPER.TITLE CHEN2000 "A Theory of Average-Case Compilability in Knowledge Representation"))(POS (PAPER.LINK CHEN2000 "http://citeseer.ist.psu.edu/590465.html"))(POS (PAPER.RANK CHEN2000 "[***]"))(POS (PAPER.DESCRIPTION CHEN2000 "Chen gives an overview of the Compilability hierarchy given
by Cadoli2000.  Then Chen gives theorems concerning average-case
compilability, i.e. analogs of the Cadoli hierarchy when there is a 
distribution over the space of knowledge representations within a class.
The results are pretty densely presented.  
"))(POS (PAPER.TOPIC CHEN2000 "Knowledge Base Compilation"))(POS (PAPER.INSTANCE CHIRKOVA2002))(POS (PAPER.BIBTEX CHIRKOVA2002 PHDTHESIS))(POS (PAPER.AUTHOR CHIRKOVA2002 "Rada Chirkova"))(POS (PAPER.TITLE CHIRKOVA2002 "Automated Database Restructuring"))(POS (PAPER.PUBLISHER CHIRKOVA2002 "Stanford University"))(POS (PAPER.LINK CHIRKOVA2002 ""))(POS (PAPER.YEAR CHIRKOVA2002 2002))(POS (PAPER.RANK CHIRKOVA2002 "[****]"))(POS (PAPER.DESCRIPTION CHIRKOVA2002 "
Chirkova's thesis presents algorithms for computing the set of views
that if materialized would allow queries to be answered optimally.  That is
there is no set of views that if materialized would answer those queries
any more efficiently.  Three results: the problem is decidable, it
has a triply exponential upper bound in the queries, and it has an
exponential lower bound.  Only conjunctions, i.e. SPJ,
are considered, both for view definitions and the queries.
"))(POS (PAPER.TOPIC CHIRKOVA2002 "Databases"))(POS (PAPER.INSTANCE CHOI2000))(POS (PAPER.BIBTEX CHOI2000 MISC))(POS (PAPER.AUTHOR CHOI2000 "Seungyeob Choi"))(POS (PAPER.TITLE CHOI2000 "Semantically Guided Proof Planning"))(POS (PAPER.LINK CHOI2000 "http://citeseer.ist.psu.edu/464153.html"))(POS (PAPER.YEAR CHOI2000 2000))(POS (PAPER.RANK CHOI2000 "[***]"))(POS (PAPER.DESCRIPTION CHOI2000 "
This thesis proposal focuses on adding semantic guidance to
automated theorem proving in two ways: 1) by incorporating
the use of models with a clause graph procedure and 2) by
incorporating the use of models with a proof planning
procedure.  This gives a good overview of various theorem
proving techniques and semantic techniques.
"))(POS (PAPER.TOPIC CHOI2000 "Model-Guided Proof Techniques"))(POS (PAPER.INSTANCE CHOMICKI95))(POS (PAPER.AUTHOR CHOMICKI95 "Jan Chomicki"))(POS (PAPER.TITLE CHOMICKI95 "Efficient Checking of Temporal Integrity Constraints Using Bounded History Encoding"))(POS (PAPER.PUBLICATION CHOMICKI95 "ACM Transactions on Database Systems"))(POS (PAPER.VOLUME CHOMICKI95 "20(2)"))(POS (PAPER.STARTPAGE CHOMICKI95 149))(POS (PAPER.ENDPAGE CHOMICKI95 186))(POS (PAPER.LINK CHOMICKI95 "http://citeseer.ist.psu.edu/chomicki95efficient.html"))(POS (PAPER.YEAR CHOMICKI95 1995))(POS (PAPER.RANK CHOMICKI95 "[**]"))(POS (PAPER.DESCRIPTION CHOMICKI95 "
Chomicki describes an algorithm for maintaining temporal constraints on a database, which are written in past first order temporal logic.  Instead of storing the entire history of the database, Chomicki describes a way to roll up the history (in a lossy way) into auxiliary relations in the database.  She assumes the set of constraints is fixed, which means a single auxiliary relation can be stored for each sentence in the constraints.  She proves this encoding to be polynomially-bounded in the number of domain values that appear in the database over time.  Chomicki extends this work to include real-time constraints, which refer to a clock.
"))(POS (PAPER.TOPIC CHOMICKI95 "Hypothetical Temporal DB Queries"))(POS (PAPER.INSTANCE CHRISTIAN93))(POS (PAPER.BIBTEX CHRISTIAN93 ARTICLE))(POS (PAPER.AUTHOR CHRISTIAN93 "Jim Christian"))(POS (PAPER.TITLE CHRISTIAN93 "Flatterms, Discrimination Nets, and Fast Term Rewriting"))(POS (PAPER.PUBLICATION CHRISTIAN93 "Journal of Automated Reasoning
"))(POS (PAPER.VOLUME CHRISTIAN93 "10"))(POS (PAPER.STARTPAGE CHRISTIAN93 95))(POS (PAPER.ENDPAGE CHRISTIAN93 113))(POS (PAPER.LINK CHRISTIAN93 ""))(POS (PAPER.YEAR CHRISTIAN93 1993))(POS (PAPER.RANK CHRISTIAN93 ""))(POS (PAPER.DESCRIPTION CHRISTIAN93 "
One of the early papers on Discrimination Nets, which is argued as
a reason for representing terms as flat terms.
"))(POS (PAPER.TOPIC CHRISTIAN93 "Indexing"))(POS (PAPER.INSTANCE CLAESSEN2003))(POS (PAPER.BIBTEX CLAESSEN2003 INPROCEEDINGS))(POS (PAPER.AUTHOR CLAESSEN2003 "K. Claessen and N. Sorensson"))(POS (PAPER.TITLE CLAESSEN2003 "New Techniues that Improve MACE-style Finite Model Finding"))(POS (PAPER.PUBLICATION CLAESSEN2003 "CADE-19 Workshop on Model Computation"))(POS (PAPER.LINK CLAESSEN2003 "http://citeseer.ist.psu.edu/claessen03new.html"))(POS (PAPER.YEAR CLAESSEN2003 2003))(POS (PAPER.DESCRIPTION CLAESSEN2003 "
A serieis of techniques are introduced for constructing a finite model
by conversion to SAT, aka the MACE-style model building.  A/the paradox paper.
"))(POS (PAPER.TOPIC CLAESSEN2003 "Model Building"))(POS (PAPER.INSTANCE CLARKE))(POS (PAPER.BIBTEX CLARKE BOOK))(POS (PAPER.AUTHOR CLARKE "Edmund M. Clarke Jr. and Orna Grumberg and Doron Peled"))(POS (PAPER.TITLE CLARKE "Model Checking"))(POS (PAPER.PUBLISHER CLARKE "The MIT Press"))(POS (PAPER.LINK CLARKE "http://mitpress.mit.edu/catalog/item/default.asp?ttype=2&tid=3730"))(POS (PAPER.YEAR CLARKE 1999))(POS (PAPER.RANK CLARKE "[*****]"))(POS (PAPER.DESCRIPTION CLARKE "
An introduction to model checking as performed by the formal methods community.
"))(POS (PAPER.TOPIC CLARKE ""))(POS (PAPER.INSTANCE COHEN90))(POS (PAPER.AUTHOR COHEN90 "P.R. Cohen and H.J. Levesque"))(POS (PAPER.TITLE COHEN90 "Intention is choice with commitment"))(POS (PAPER.PUBLICATION COHEN90 "Artificial Intelligence"))(POS (PAPER.VOLUME COHEN90 "42(3)"))(POS (PAPER.YEAR COHEN90 1990))(POS (PAPER.RANK COHEN90 "[*]"))(POS (PAPER.DESCRIPTION COHEN90 "
Cohen and Levesque use modal operators without explicit mention of time to describe an agent's persistent goals.  These goals will be worked upon until 1) they are achieved or 2) they are deemed impossible.  No work was done here on planning to achieve these goals. 
"))(POS (PAPER.TOPIC COHEN90 "Behavioral Goals"))(POS (PAPER.INSTANCE COMON99))(POS (PAPER.BIBTEX COMON99 ARTICLE))(POS (PAPER.AUTHOR COMON99 "Hubert Comon and Mehmet Dincbas and Jean-pierre Jouannaud and Claude Kirchner"))(POS (PAPER.TITLE COMON99 "A Methodological View of Constraint Solving"))(POS (PAPER.PUBLICATION COMON99 "Constraints"))(POS (PAPER.VOLUME COMON99 "4"))(POS (PAPER.STARTPAGE COMON99 337))(POS (PAPER.ENDPAGE COMON99 361))(POS (PAPER.LINK COMON99 "http://citeseer.ist.psu.edu/13836.html"))(POS (PAPER.YEAR COMON99 1999))(POS (PAPER.DESCRIPTION COMON99 "
The authors motivate why sets are described using constraints and go on to survey the various techniques that have been used for processing those constraints, i.e. (1) determining whether an element belongs to a set or (2) determining whether one set is included entirely in another set (entailment).  They discuss 3 types of techniques: syntactic, semantic, and hybrid.  Syntactic techniques translate a formula into another formula.  Semantic techniques translate formulas into automata or another such formalism.  Hybrid techniques use both.  For more info on automata, try http://www.grappa.univ-lille3.fr/tata/.
"))(POS (PAPER.TOPIC COMON99 "General"))(POS (PAPER.INSTANCE COOK71))(POS (PAPER.BIBTEX COOK71 ARTICLE))(POS (PAPER.AUTHOR COOK71 "Stephen Cook"))(POS (PAPER.TITLE COOK71 "The Complexity of Theorem-Proving Procedures"))(POS (PAPER.PUBLICATION COOK71 "Symposium on the Theory of Computing (STOC)"))(POS (PAPER.STARTPAGE COOK71 151))(POS (PAPER.ENDPAGE COOK71 158))(POS (PAPER.LINK COOK71 "http://citeseer.ist.psu.edu/context/5446/0"))(POS (PAPER.YEAR COOK71 1971))(POS (PAPER.RANK COOK71 "[*]"))(POS (PAPER.DESCRIPTION COOK71 "
This is Cook's paper which introduces the theory of NP completeness
and polynomial reductions.  He gives complexity bounds on theorem-
proving procedures relative to the minimum number of copies of 
axioms required for propositional unsatisfiability.
"))(POS (PAPER.TOPIC COOK71 "Comparative Analysis"))(POS (PAPER.INSTANCE CRAIG2004))(POS (PAPER.BIBTEX CRAIG2004 ARTICLE))(POS (PAPER.AUTHOR CRAIG2004 "S. Craig and J. Gallagher and M. Leuschel and K. Henriksen"))(POS (PAPER.TITLE CRAIG2004 "Fully Automatic Binding-Time Analysis for Prolog"))(POS (PAPER.PUBLICATION CRAIG2004 "14th International Symposium, Logic Based Program Synthesis and Trnasformation (LOPSTR)"))(POS (PAPER.STARTPAGE CRAIG2004 53))(POS (PAPER.ENDPAGE CRAIG2004 68))(POS (PAPER.LINK CRAIG2004 "http://wotan.liu.edu/docis/dbl/lopstr/index.html"))(POS (PAPER.YEAR CRAIG2004 2004))(POS (PAPER.DESCRIPTION CRAIG2004 "
The authors consider the problem of computing modes, i.e. binding
patterns, for prolog relations, and whether to unroll or inline
such relations.  The first computes a set of disjoint types 
from regular types and then propagates them.  The second 
uses binary clause semantics and convex hull abstraction
to determine which relations will not terminate.  Apparently,
very similar work was done in 2001 by Vanhoof and Bruynooghe
in 2001.
"))(POS (PAPER.TOPIC CRAIG2004 "Reformulation"))(POS (PAPER.INSTANCE CYRLUK96SHOSTAKS))(POS (PAPER.BIBTEX CYRLUK96SHOSTAKS INPROCEEDINGS))(POS (PAPER.AUTHOR CYRLUK96SHOSTAKS "David Cyrluk, Patrick Lincoln, and Natarajan Shankar"))(POS (PAPER.TITLE CYRLUK96SHOSTAKS "On Shostak's Decision Procedure for Combinations of Theories"))(POS (PAPER.PUBLICATION CYRLUK96SHOSTAKS "13th International Conference on Automated Deduction
           "))(POS (PAPER.LINK CYRLUK96SHOSTAKS "http://citeseer.ist.psu.edu/cyrluk96shostaks.html"))(POS (PAPER.YEAR CYRLUK96SHOSTAKS 1996))(POS (PAPER.RANK CYRLUK96SHOSTAKS "[****]"))(POS (PAPER.DESCRIPTION CYRLUK96SHOSTAKS "
Cyrluk, Lincoln, and Shankar give a crisp description of the Shostak
procedure and sketch proofs of its properties.  It breaks the algorithm
down into 1) a congruence closure computation and 2) the interpretation
of functions through canonization.  This version of Shostak and all its
counterparts were later shown incomplete.
"))(POS (PAPER.TOPIC CYRLUK96SHOSTAKS "Nelson-Oppen and Shostak"))(POS (PAPER.RELATED CYRLUK96SHOSTAKS SHOSTAK84))(POS (PAPER.RELATED CYRLUK96SHOSTAKS RUEB2000DECONSTRUCTING))(POS (PAPER.INSTANCE DANTSIN2001))(POS (PAPER.AUTHOR DANTSIN2001 "Evgeny Dantsin and Thomas Eiter and Georg Gottlob and Andrei Voronkov"))(POS (PAPER.TITLE DANTSIN2001 "Complexity and Expressive Power of Logic Programming"))(POS (PAPER.PUBLICATION DANTSIN2001 "ACM Computing Surveys"))(POS (PAPER.VOLUME DANTSIN2001 "33(3)"))(POS (PAPER.STARTPAGE DANTSIN2001 374))(POS (PAPER.ENDPAGE DANTSIN2001 425))(POS (PAPER.LINK DANTSIN2001 "http://portal.acm.org/citation.cfm?id=502810&dl=ACM&coll=GUIDE"))(POS (PAPER.YEAR DANTSIN2001 2001))(POS (PAPER.DESCRIPTION DANTSIN2001 "
Complexity results for logic programming.
"))(POS (PAPER.TOPIC DANTSIN2001 "Logic Programming"))(POS (PAPER.INSTANCE DARWICHE2002))(POS (PAPER.BIBTEX DARWICHE2002 ARTICLE))(POS (PAPER.AUTHOR DARWICHE2002 "Adnan Darwiche and Pierre Marquis"))(POS (PAPER.TITLE DARWICHE2002 "A Knowledge Compilation Map"))(POS (PAPER.PUBLICATION DARWICHE2002 "Journal of Artificial Intelligence Research"))(POS (PAPER.VOLUME DARWICHE2002 "17"))(POS (PAPER.STARTPAGE DARWICHE2002 229))(POS (PAPER.ENDPAGE DARWICHE2002 264))(POS (PAPER.LINK DARWICHE2002 "http://citeseer.ist.psu.edu/497263.html"))(POS (PAPER.YEAR DARWICHE2002 2002))(POS (PAPER.DESCRIPTION DARWICHE2002 "
The authors analyze knowledge compilation on two axes: the succinctness of
the target language and the class of queries and transformations that the
language supports in polytime.  They analyze a large number of existing
approaches.
"))(POS (PAPER.TOPIC DARWICHE2002 "Knowledge Base Compilation"))(POS (PAPER.INSTANCE DAVIS60))(POS (PAPER.BIBTEX DAVIS60 ARTICLE))(POS (PAPER.AUTHOR DAVIS60 "M. Davis and H. Putnam"))(POS (PAPER.TITLE DAVIS60 "A Machine Program for Theorem Proving"))(POS (PAPER.PUBLICATION DAVIS60 "Journal of the ACM"))(POS (PAPER.VOLUME DAVIS60 "7"))(POS (PAPER.STARTPAGE DAVIS60 201))(POS (PAPER.ENDPAGE DAVIS60 215))(POS (PAPER.YEAR DAVIS60 1960))(POS (PAPER.DESCRIPTION DAVIS60 "
One of the DPLL papers.
"))(POS (PAPER.TOPIC DAVIS60 "Calculi"))(POS (PAPER.INSTANCE DAVIS62))(POS (PAPER.BIBTEX DAVIS62 ARTICLE))(POS (PAPER.AUTHOR DAVIS62 "M. Davis and G. Logemann an D. Loveland"))(POS (PAPER.TITLE DAVIS62 "A Computing Procedure for Quantification Theory"))(POS (PAPER.PUBLICATION DAVIS62 "Communications of the ACM"))(POS (PAPER.VOLUME DAVIS62 "5"))(POS (PAPER.STARTPAGE DAVIS62 394))(POS (PAPER.ENDPAGE DAVIS62 397))(POS (PAPER.YEAR DAVIS62 1962))(POS (PAPER.DESCRIPTION DAVIS62 "
One of the DPLL papers.
"))(POS (PAPER.TOPIC DAVIS62 "Calculi"))(POS (PAPER.INSTANCE DAVIS94))(POS (PAPER.BIBTEX DAVIS94 TECHREPORT))(POS (PAPER.AUTHOR DAVIS94 "Ernest Davis"))(POS (PAPER.TITLE DAVIS94 "Lucid Representations"))(POS (PAPER.PUBLISHER DAVIS94 "New York University"))(POS (PAPER.LINK DAVIS94 "http://citeseer.ist.psu.edu/davis94lucid.html"))(POS (PAPER.YEAR DAVIS94 1994))(POS (PAPER.RANK DAVIS94 "[****]"))(POS (PAPER.DESCRIPTION DAVIS94 "
Davis writes Lucid Representations in part to argue Levesque's
Making Believers Out of Computers paper.  Davis claims Levesque argues
that the only representations one should allow are complete ones,
in the database sense to ensure reasoning is fast.  Davis argues
that no AI system could get by with only complete information.
Incomplete information is imperative.  Davis attempts to propose
a technique for achieving the benefits of complete information
from starting from incomplete information by first instantiating
to complete the theory, then reasoning quickly, and finally 
ignoring those results which were artificially  introduced by
the process of instantiation.  This is a position piece trying to
refute Levesque's vision of the future and replacing
it with a vision of its own.
"))(POS (PAPER.TOPIC DAVIS94 "Logical Knowledge Representation"))(POS (PAPER.INSTANCE DEBRAY93))(POS (PAPER.BIBTEX DEBRAY93 ARTICLE))(POS (PAPER.AUTHOR DEBRAY93 "Saumya Debray and Nai-Wei Lin"))(POS (PAPER.TITLE DEBRAY93 "Cost Analysis of Logic Programs"))(POS (PAPER.PUBLICATION DEBRAY93 "ACM Transactions on Programming Languages and Systems>"))(POS (PAPER.VOLUME DEBRAY93 "15(5)"))(POS (PAPER.STARTPAGE DEBRAY93 826))(POS (PAPER.ENDPAGE DEBRAY93 875))(POS (PAPER.YEAR DEBRAY93 1993))(POS (PAPER.DESCRIPTION DEBRAY93 "
Debray and Lin outline techniques for computing upper bounds on the cost
of a logic program, taking in account multiple solutions and nondeterminism.
Based on relationship between argument size, moded relations, and typed 
relations.
"))(POS (PAPER.TOPIC DEBRAY93 "Logic Programming"))(POS (PAPER.INSTANCE DECHTER92))(POS (PAPER.BIBTEX DECHTER92 ARTICLE))(POS (PAPER.AUTHOR DECHTER92 "Rina Dechter and Judea Pearl"))(POS (PAPER.TITLE DECHTER92 "Structure Identificatioin in Relational Data"))(POS (PAPER.PUBLICATION DECHTER92 "Artificial Intelligence"))(POS (PAPER.VOLUME DECHTER92 "58(1-3)"))(POS (PAPER.STARTPAGE DECHTER92 237))(POS (PAPER.ENDPAGE DECHTER92 270))(POS (PAPER.LINK DECHTER92 "http://citeseer.ist.psu.edu/dechter97structure.html"))(POS (PAPER.YEAR DECHTER92 1992))(POS (PAPER.RANK DECHTER92 "[**]"))(POS (PAPER.DESCRIPTION DECHTER92 "
Dechter and Pearl describe building a propositional Horn representation
of a given set of models.  Identifying whether such a representation 
exists turns out to be polynomial in the size of the models.  Building
such a representation is polynomial in the size of the models and
the number of variables.  For k-Horn theories, a tightest approximation
can also be calculated in polynomial time.  
"))(POS (PAPER.TOPIC DECHTER92 "Knowledge Base Compilation"))(POS (PAPER.INSTANCE DELVAL96))(POS (PAPER.BIBTEX DELVAL96 INPROCEEDINGS))(POS (PAPER.AUTHOR DELVAL96 "Alvaro del Val"))(POS (PAPER.TITLE DELVAL96 "Approximate Knowledge Compilation: The First Order Case"))(POS (PAPER.PUBLICATION DELVAL96 "AAAI"))(POS (PAPER.STARTPAGE DELVAL96 498))(POS (PAPER.ENDPAGE DELVAL96 503))(POS (PAPER.LINK DELVAL96 "http://citeseer.ist.psu.edu/delval96approximate.html"))(POS (PAPER.YEAR DELVAL96 1996))(POS (PAPER.RANK DELVAL96 "[****]"))(POS (PAPER.DESCRIPTION DELVAL96 "
This seems to be the seminal work on Knowledge Compilation for FOL.  
del Val introduces a new algorithm for computing the Least Upper
Bound approximation for a propositional knowledge base, at times
exponentially better than the previously known algorithm.  He then
lifts both algorithms to first order logic under some restrictions.
"))(POS (PAPER.TOPIC DELVAL96 "Knowledge Base Compilation"))(POS (PAPER.RELATED DELVAL96 SELMAN91))(POS (PAPER.INSTANCE DERSHOWITZ82))(POS (PAPER.AUTHOR DERSHOWITZ82 "Nachum Dershowitz"))(POS (PAPER.TITLE DERSHOWITZ82 "Orderings for Term-rewriting Systems"))(POS (PAPER.PUBLICATION DERSHOWITZ82 "Theoretical Computer Science"))(POS (PAPER.VOLUME DERSHOWITZ82 "17"))(POS (PAPER.STARTPAGE DERSHOWITZ82 279))(POS (PAPER.ENDPAGE DERSHOWITZ82 301))(POS (PAPER.LINK DERSHOWITZ82 "http://citeseer.ist.psu.edu/context/20249/0"))(POS (PAPER.YEAR DERSHOWITZ82 1982))(POS (PAPER.DESCRIPTION DERSHOWITZ82 "
This paper confronts termination in term-rewriting systems.  
Dershowitz first defines the notion of a non-terminating rewrite system,
i.e. one with an infinite homeomorphic self-embedding derivation.  Then
he defines a simplification ordering as a partial ordering with
the replacement (monotonicity), subterm, and deletion properties.  If there
is a simplification ordering for a term rewriting system such that l > r for
every rewrite rule l -> r then the rewrite system terminates.  Dershowitz
goes on to define a quasi-simplification ordering, which is weaker than
a simplification ordering, making it easier to prove rewrite systems
terminate.  The reason this paper is located in this section is that
the notion of a recursive path ordering is then defined.  RPO and
variants thereof are used in modern theorem provers when ordering
is necessary.  The last section goes through a series of examples
that demonstrate how to prove rewrite systems terminate.
"))(POS (PAPER.TOPIC DERSHOWITZ82 "Orderings"))(POS (PAPER.INSTANCE DERSHOWITZ93))(POS (PAPER.BIBTEX DERSHOWITZ93 INBOOK))(POS (PAPER.AUTHOR DERSHOWITZ93 "Nachum Dershowitz"))(POS (PAPER.TITLE DERSHOWITZ93 "A Taste of Rewrite Systems"))(POS (PAPER.PUBLICATION DERSHOWITZ93 "Functional Programming, Concurrency, Simulation, and
Automated Reasoning"))(POS (PAPER.STARTPAGE DERSHOWITZ93 199))(POS (PAPER.ENDPAGE DERSHOWITZ93 228))(POS (PAPER.LINK DERSHOWITZ93 "http://citeseer.ist.psu.edu/dershowitz93taste.html"))(POS (PAPER.YEAR DERSHOWITZ93 1993))(POS (PAPER.RANK DERSHOWITZ93 ""))(POS (PAPER.DESCRIPTION DERSHOWITZ93 "
Dershowitz gives a whirlwind tour of rewrite systems, covering the
basic properties termination (existence of normal forms), 
confluence (the uniqueness of those forms), completion (how to construct 
confluent systems), checking entailment and solving equations via 
basically abduction.  He also discusses special techniques for dealing
with associative and commutative systems and conditional rewriting rules.
Applications include theorem proving and programming
"))(POS (PAPER.TOPIC DERSHOWITZ93 "Theorem Proving"))(POS (PAPER.INSTANCE DOYLE91))(POS (PAPER.BIBTEX DOYLE91 ARTICLE))(POS (PAPER.AUTHOR DOYLE91 "Jon Doyle and Ramesh Patil"))(POS (PAPER.TITLE DOYLE91 "Two Theses of Knowledge Representation: Language Restrictions, Taxonomic Classification, and the Utility of Representation Services"))(POS (PAPER.PUBLICATION DOYLE91 "Artificial Intelligence"))(POS (PAPER.VOLUME DOYLE91 "48(3)"))(POS (PAPER.STARTPAGE DOYLE91 261))(POS (PAPER.ENDPAGE DOYLE91 298))(POS (PAPER.LINK DOYLE91 "http://citeseer.ist.psu.edu/doyle91two.html"))(POS (PAPER.YEAR DOYLE91 1991))(POS (PAPER.RANK DOYLE91 "[****]"))(POS (PAPER.DESCRIPTION DOYLE91 "
Doyle and Patil argue against Levesque and Brachman's position that a
general purpose KB system must be able to answer all questions 
in a bounded amount of time.  In particular, they examine KL-ONE
and its variants, enumerating classes of problems that a restricted
language cannot express but that would be natural for use in a KB
system.  They argue that worst-case complexity is the right measure for
just a small fraction of all potential applications of a Knowledge-based
system.  
"))(POS (PAPER.TOPIC DOYLE91 "Logical Knowledge Representation"))(POS (PAPER.INSTANCE DYMETMAN91))(POS (PAPER.BIBTEX DYMETMAN91 ARTICLE))(POS (PAPER.AUTHOR DYMETMAN91 "M. Dymetman"))(POS (PAPER.TITLE DYMETMAN91 "Inherently Reversible Grammars, Logic Programming and Computability"))(POS (PAPER.LINK DYMETMAN91 "http://acl.ldc.upenn.edu/W/W91/W91-0104.pdf"))(POS (PAPER.YEAR DYMETMAN91 1991))(POS (PAPER.RANK DYMETMAN91 "[***]"))(POS (PAPER.DESCRIPTION DYMETMAN91 "
Dymetman offers a decoupling of the term reversible grammar into (1)
uniformity of implementation for parsers and generators and (2) 
reversibility as an inherent property of a grammar.  He formalizes
the second idea, which includes various notions about the completeness
and termination of answer extraction for logic programming.
"))(POS (PAPER.TOPIC DYMETMAN91 "Natural Language Processing"))(POS (PAPER.INSTANCE EBBINGHAUS))(POS (PAPER.BIBTEX EBBINGHAUS BOOK))(POS (PAPER.AUTHOR EBBINGHAUS "Heinz-Dieter Ebbinghaus and Jorg Flum"))(POS (PAPER.TITLE EBBINGHAUS "Finite Model Theory"))(POS (PAPER.PUBLISHER EBBINGHAUS "Springer-Verlag"))(POS (PAPER.LINK EBBINGHAUS "http://www.amazon.com/Finite-Theory-Springer-Monographs-Mathematics/dp/3540287876"))(POS (PAPER.YEAR EBBINGHAUS 1999))(POS (PAPER.RANK EBBINGHAUS "[*****]"))(POS (PAPER.DESCRIPTION EBBINGHAUS "
The authors introduce Finite Model Theory, a logic that is identical to first-order
logic but where a model is defined as having a finite universe.  Topics covered
include Ehrenfeucht-Fraisse Method, 01 laws, finite automata, descriptive
complexity theory, fixed-point operators, logic programs, logics for PTIME, 
and logical reductions.
"))(POS (PAPER.TOPIC EBBINGHAUS ""))(POS (PAPER.INSTANCE EITER2001))(POS (PAPER.BIBTEX EITER2001 INPROCEEDINGS))(POS (PAPER.AUTHOR EITER2001 "Thomas Eiter and Toshihide Ibaraki and Kazuhisa Makino"))(POS (PAPER.TITLE EITER2001 "Disjunctions of Horn Theories and their Cores"))(POS (PAPER.PUBLICATION EITER2001 "ISAAC"))(POS (PAPER.LINK EITER2001 "http://citeseer.ist.psu.edu/eiter01disjunctions.html"))(POS (PAPER.YEAR EITER2001 2001))(POS (PAPER.RANK EITER2001 "[*]"))(POS (PAPER.DESCRIPTION EITER2001 "
This paper studies the problem of determining whether a disjunction of 
Horn theories is Horn and if not computing a Horn core and envelope.
Eiter et. al. investigate both the characteristic model representation
of Horn theories and the CNF representation.  For both representations 
the problem is intractable.
"))(POS (PAPER.TOPIC EITER2001 "Characteristic Models"))(POS (PAPER.INSTANCE EITER2004))(POS (PAPER.BIBTEX EITER2004 INPROCEEDINGS))(POS (PAPER.AUTHOR EITER2004 "Thomas Eiter and Thomas Lukasiewicz and Roman Schindlauer and Hans Tompits"))(POS (PAPER.TITLE EITER2004 "Combining Answer Set Programming with Description Logics for the Semantic Web"))(POS (PAPER.PUBLICATION EITER2004 "Proceedings of Knowledge Representation and Reasoning"))(POS (PAPER.LINK EITER2004 "http://citeseer.ist.psu.edu/727609.html"))(POS (PAPER.YEAR EITER2004 2004))(POS (PAPER.DESCRIPTION EITER2004 "
A language that integrates SHIF(D) and SHOIN(D) with answer set programming
"))(POS (PAPER.TOPIC EITER2004 "Semantic Web"))(POS (PAPER.INSTANCE EITER98))(POS (PAPER.BIBTEX EITER98 INPROCEEDINGS))(POS (PAPER.AUTHOR EITER98 "Thomas Eiter and Thoshihide Ibaraki and Kazuhisa Makino"))(POS (PAPER.TITLE EITER98 "Computing Intersections of Horn Theories for Reasoning with Models"))(POS (PAPER.PUBLICATION EITER98 "AAAI"))(POS (PAPER.LINK EITER98 "http://citeseer.ist.psu.edu/537461.html"))(POS (PAPER.YEAR EITER98 1998))(POS (PAPER.RANK EITER98 "[****]"))(POS (PAPER.DESCRIPTION EITER98 "
The authors examine complexity issues that arise when intersecting several
propositional horn knowledge bases, which are represented with 
characteristic models.  Finding
the unique minimal model (which is a characteristic model) can be done
in linear time in the number of KBs.  Finding all-models can be solved
with polynomial delay (a polynomial amount of time between outputting
models).  In a sense, that means the procedure is polynomial, but the 
number of outputs could be exponential.  Finding all characteristic
models of the intersection has no polynomial time algorithm (even if
P = NP).  Answering deductive queries can still be accomplished in
polynomial time by looking at each KB independently.  Finally, abduction
is shown to be intractable, which differs from the result of a single
KB (where it is polynomial).
"))(POS (PAPER.TOPIC EITER98 "Characteristic Models"))(POS (PAPER.INSTANCE ENDERTON))(POS (PAPER.BIBTEX ENDERTON BOOK))(POS (PAPER.AUTHOR ENDERTON "Herbert Enderton"))(POS (PAPER.TITLE ENDERTON "A Mathematical Introduction to Logic"))(POS (PAPER.PUBLISHER ENDERTON "Academic Press"))(POS (PAPER.LINK ENDERTON "http://www.amazon.com/exec/obidos/tg/detail/-/0122384520/qid=1062605496/sr=1-6/ref=sr_1_6/102-6107129-2481765?v=glance&s=books"))(POS (PAPER.YEAR ENDERTON 2000))(POS (PAPER.RANK ENDERTON "[*****]"))(POS (PAPER.DESCRIPTION ENDERTON "
The definitive text on introductory mathematical logic.  Enderton covers both 
propositional (sentential),  and first-order logic including compactness, completeness,
and soundness proofs.  The third chapter covers undecidability, Godel's 
incompleteness proof, and Church's and Tarski's theorems.  The last chapter
covers second-order logic. 
"))(POS (PAPER.TOPIC ENDERTON ""))(POS (PAPER.INSTANCE ETHERINGTON89))(POS (PAPER.BIBTEX ETHERINGTON89 ARTICLE))(POS (PAPER.AUTHOR ETHERINGTON89 "David Etherington and Alex Borgida and Ronald Brachman and Henry Kautz"))(POS (PAPER.TITLE ETHERINGTON89 "Vivid Knowledge and Tractable Reasoning"))(POS (PAPER.PUBLICATION ETHERINGTON89 "IJCAI"))(POS (PAPER.STARTPAGE ETHERINGTON89 1146))(POS (PAPER.ENDPAGE ETHERINGTON89 1152))(POS (PAPER.LINK ETHERINGTON89 "http://citeseer.ist.psu.edu/etherington89vivid.html"))(POS (PAPER.YEAR ETHERINGTON89 1989))(POS (PAPER.RANK ETHERINGTON89 "[****]"))(POS (PAPER.DESCRIPTION ETHERINGTON89 "
Etherington, et.al. give a preliminary description of representing a KB with a set of atoms.  They try to motivate the work by appealing to the speed of humans' commonsense reasoning facilities as evidence that much such reasoning is done via lookup.   A set of atoms is not very expressive, so the first extension is to allow definite clauses: a(x)=>b(x).  To deal with this they use a closed world assumption.  Second extension tries to deal with disjunction: age(joe,53) | age(joe,55) is replaced by age(joe,x)^in50s(x).  Third extension uses skolems to remove disjunction: p(a) | p(b) becomes p(k). 
"))(POS (PAPER.TOPIC ETHERINGTON89 "Logical Knowledge Representation"))(POS (PAPER.INSTANCE FAGIN82))(POS (PAPER.BIBTEX FAGIN82 ARTICLE))(POS (PAPER.AUTHOR FAGIN82 "Ronald Fagin"))(POS (PAPER.TITLE FAGIN82 "Horn Clauses and Database Dependencies"))(POS (PAPER.PUBLICATION FAGIN82 "Journal of the ACM"))(POS (PAPER.VOLUME FAGIN82 "29(4)"))(POS (PAPER.STARTPAGE FAGIN82 952))(POS (PAPER.ENDPAGE FAGIN82 985))(POS (PAPER.LINK FAGIN82 "http://citeseer.ist.psu.edu/context/62052/0"))(POS (PAPER.YEAR FAGIN82 1982))(POS (PAPER.RANK FAGIN82 "[****]"))(POS (PAPER.DESCRIPTION FAGIN82 "
Fagin generalizes dependencies in the database literature and
shows the following are all equivalent for a given set of sentences
S.  1) There is an operator O that maps nonempty families of models
into models such that if sigma is a sentence in S and R_i is a
nonempty family of models, then sigma holds for O(R_i) iff sigma
holds for each R_i.  2) Whenever Sigma is a consistent subset of S
and Sigma* is the set of sentences in S that are logical consequences
of Sigma, there is an Armstrong model--it obeys Sigma* and no other
sentences in S.  3) Whenever Sigma is a subset of S and phi_i is a 
nonempty subset of S then Sigma |= V phi_i iff there is some i for
which Sigma |= phi_i.  For FOL in general, there is no Armstrong relation for 
first-order axiom sets.  Take the empty set of axioms, and assume
there is an Armstrong relation R.  R will either entail or not
entail any non-tautology sigma, which means R is not an Armstrong
relation for the axiom set.  A corollary to this theorem shows
that any axiom set Delta in a Horn-related subset of FOL can be
represented with a single, infinite model.
"))(POS (PAPER.TOPIC FAGIN82 "Characteristic Models"))(POS (PAPER.INSTANCE FIKES71))(POS (PAPER.AUTHOR FIKES71 "R.E. Fikes and N.J. Nilsson"))(POS (PAPER.TITLE FIKES71 "STRIPS: a new approach to the application of theorem proving to problem solving"))(POS (PAPER.PUBLICATION FIKES71 "Artificial Intelligence"))(POS (PAPER.VOLUME FIKES71 "2(3-4)"))(POS (PAPER.STARTPAGE FIKES71 189))(POS (PAPER.ENDPAGE FIKES71 208))(POS (PAPER.YEAR FIKES71 1971))(POS (PAPER.DESCRIPTION FIKES71 "
The STRIPS paper.  Fikes and Nilsson allow first-order formulas to describe the action preconditions and effects (add/delete lists) but maintain that each operator instanatiation must be ground.  They note that the case of non-ground instantiations needs more study.  Interestingly, they generate successor states in the search tree using a form of residue from a proof that a given world state achieves a given subgoal.  They implement a world state as being a set of changes from the initial state.
"))(POS (PAPER.TOPIC FIKES71 "Historical"))(POS (PAPER.INSTANCE FIKES72))(POS (PAPER.AUTHOR FIKES72 "Richard Fikes, Peter Hart and Nils Nilsson"))(POS (PAPER.TITLE FIKES72 "Learning and Executing Generalized Robot Plans"))(POS (PAPER.PUBLICATION FIKES72 "Artificial Intelligence"))(POS (PAPER.VOLUME FIKES72 "3(4)"))(POS (PAPER.STARTPAGE FIKES72 251))(POS (PAPER.ENDPAGE FIKES72 288))(POS (PAPER.YEAR FIKES72 1972))(POS (PAPER.DESCRIPTION FIKES72 "
Fikes, Hart, and Nillson take a STRIPS planner, 1) describe a concise
representation for plans (triangle tables), 2) develop a method for
generalizing plans to make new primitive actions (MACROPs), 3) describe
an execution engine (PLANEX) that uses these Macrops that does replanning and
handles coincidental goal achievement.  They go on to describe needed future
improvements: 1) creating a set of abstractions for the new primitives actions
to avoid dealing with large numbers of preconditions and 2) discarding
subsumed or otherwise unused primitive operators to avoid an ever-growing
operator set.
"))(POS (PAPER.TOPIC FIKES72 "Historical"))(POS (PAPER.INSTANCE FIKES93))(POS (PAPER.AUTHOR FIKES93 "R.E. Fikes and N.J. Nilsson"))(POS (PAPER.TITLE FIKES93 "STRIPS, a retrospective"))(POS (PAPER.PUBLICATION FIKES93 "Artificial Intelligence"))(POS (PAPER.VOLUME FIKES93 "59(1-2)"))(POS (PAPER.STARTPAGE FIKES93 227))(POS (PAPER.ENDPAGE FIKES93 232))(POS (PAPER.YEAR FIKES93 1993))(POS (PAPER.DESCRIPTION FIKES93 "
This short paper puts the STRIPS work in a historical context, examining both the plan generator and execution monitor.  Green's work on deductive plan synthesis was the first real planner, but most researchers didn't explore monitoring execution (they were assuming computational environments).  Fikes and Nilsson used 'kernels' to represent the sentences that must be true at each stage of the plan for the rest of the plan to succeed.  They also used the notion of a 'triangle table' to represent plans so that serendipitous acts and action-failure-but-that's-all-you-can-do-so-just-try-again events would not require replanning.
"))(POS (PAPER.TOPIC FIKES93 "Historical"))(POS (PAPER.INSTANCE FITTING2007))(POS (PAPER.BIBTEX FITTING2007 ARTICLE))(POS (PAPER.AUTHOR FITTING2007 "Melvin Fitting"))(POS (PAPER.TITLE FITTING2007 "Intensional Logic"))(POS (PAPER.PUBLICATION FITTING2007 "The Stanford Encyclopedia of Philosophy (Spring 2007 Edition), Edward N. Zalta (ed.)"))(POS (PAPER.LINK FITTING2007 "http://plato.stanford.edu/archives/spr2007/entries/logic-intensional/"))(POS (PAPER.YEAR FITTING2007 2007))(POS (PAPER.DESCRIPTION FITTING2007 "
The mathematical foundations of logical query languages.
"))(POS (PAPER.TOPIC FITTING2007 "Logical Knowledge Representation"))(POS (PAPER.INSTANCE FOLLETT80))(POS (PAPER.BIBTEX FOLLETT80 ARTICLE))(POS (PAPER.AUTHOR FOLLETT80 "Ria Follett"))(POS (PAPER.TITLE FOLLETT80 "Synthesising Recursive Functions with Side Effects"))(POS (PAPER.PUBLICATION FOLLETT80 "Artificial Intelligence"))(POS (PAPER.VOLUME FOLLETT80 "13:3"))(POS (PAPER.STARTPAGE FOLLETT80 175))(POS (PAPER.ENDPAGE FOLLETT80 200))(POS (PAPER.YEAR FOLLETT80 1980))(POS (PAPER.RANK FOLLETT80 "[*]"))(POS (PAPER.DESCRIPTION FOLLETT80 "
"))(POS (PAPER.TOPIC FOLLETT80 "Theorem Proving with Attachments"))(POS (PAPER.INSTANCE FRANCONI2004))(POS (PAPER.BIBTEX FRANCONI2004 INPROCEEDINGS))(POS (PAPER.AUTHOR FRANCONI2004 "Enrico Franconi and Sergio Tessaris"))(POS (PAPER.TITLE FRANCONI2004 "Rules and Queries with Ontologies: A Unified Logical Framework"))(POS (PAPER.PUBLICATION FRANCONI2004 "Proceedings of Principles and Practice of Semantic Web Reasoning"))(POS (PAPER.LINK FRANCONI2004 "http://www.springerlink.com/content/1hnwcggw510elp4y/"))(POS (PAPER.YEAR FRANCONI2004 2004))(POS (PAPER.DESCRIPTION FRANCONI2004 "
A comparison of various techniques for integrating logic programming with 
description logics.
"))(POS (PAPER.TOPIC FRANCONI2004 "Semantic Web"))(POS (PAPER.INSTANCE GAMMER2007))(POS (PAPER.BIBTEX GAMMER2007 INPROCEEDINGS))(POS (PAPER.AUTHOR GAMMER2007 "Igor Gammer and Eyal Amir"))(POS (PAPER.TITLE GAMMER2007 "Solving Satisfiability in Ground Logic with Equality by Efficient Conversion to Propositional Logic"))(POS (PAPER.PUBLICATION GAMMER2007 "Proc. 7th Symposium on Abstraction, Reformulation, and Approximation"))(POS (PAPER.LINK GAMMER2007 "http://reason.cs.uiuc.edu/eyal/paper.html"))(POS (PAPER.YEAR GAMMER2007 2007))(POS (PAPER.DESCRIPTION GAMMER2007 "
The authors consider ground first-order logic with equality and show
how one can employ Craig's Interpolation theorem to reduce the cost
of grounding out the usual axiomatization of equality.
"))(POS (PAPER.TOPIC GAMMER2007 "Reformulation"))(POS (PAPER.INSTANCE GEDDIS95))(POS (PAPER.BIBTEX GEDDIS95 PHDTHESIS))(POS (PAPER.AUTHOR GEDDIS95 "Don Geddis"))(POS (PAPER.TITLE GEDDIS95 "Caching and Non-Horn Inference in Model Elimination Theorem Provers"))(POS (PAPER.PUBLISHER GEDDIS95 "Stanford University"))(POS (PAPER.LINK GEDDIS95 "http://library.stanford.edu/depts/mathcs/mathcscoll/techreports.html"))(POS (PAPER.YEAR GEDDIS95 1995))(POS (PAPER.RANK GEDDIS95 "[***]"))(POS (PAPER.DESCRIPTION GEDDIS95 "
Geddis investigates Nonhorn caching for model elimination.  Astrachan and
Stickel did the seminal work on caching for the Horn case.  Nonhorn
caching is made difficult by the reduction operation, i.e. proofs of
subgoals are context dependent.  Previous work stored the context and
the proven subgoal.  Geddis shows that if a literal has a completion in
one context, it has a completion in every context.  Thus, if a subgoal
cannot be completed, it can be added to a failure cache.  A completion is
not the same as a proof, however, and there are no results for success
caching.  If a depth-limited search-strategy is used, incompleteness can
result; Geddis found no solution for this problem.  Also discussed is an
extension to David Smith's work: postponement caching.  It basically avoids
infinite recursions if possible by 'enslaving' a subgoal to an ancestor
if the two unify.  It is complete for Horn and incomplete for nonHorn.
"))(POS (PAPER.TOPIC GEDDIS95 "Theorem Proving with Attachments"))(POS (PAPER.INSTANCE GELERNTER63))(POS (PAPER.BIBTEX GELERNTER63 ARTICLE))(POS (PAPER.AUTHOR GELERNTER63 "H. Gelernter"))(POS (PAPER.TITLE GELERNTER63 "Realization of a Geometry-Theorem Proving Machine"))(POS (PAPER.PUBLICATION GELERNTER63 "Computers and Thought"))(POS (PAPER.STARTPAGE GELERNTER63 134))(POS (PAPER.ENDPAGE GELERNTER63 152))(POS (PAPER.YEAR GELERNTER63 1963))(POS (PAPER.RANK GELERNTER63 "[*]"))(POS (PAPER.DESCRIPTION GELERNTER63 "
Gelernter describes the Geometry Machine, an ad hoc theorem prover
for Euclidian geometry.  It uses a diagram as a heuristic to guide
the theorem prover's search, eliminating subgoals when not 
satisfied by the diagram.  Sometimes that diagram prunes too much,
in which case multiple diagrams need to be generated to achieve
completeness.  The system is also unique in the fact that it does
not give the theorem prover a complete axiomitization of geometry,
but rather allows it to add axioms that are 'obvious' from the 
diagram, much as a human might do.
"))(POS (PAPER.TOPIC GELERNTER63 "Graphical Reasoning Techniques"))(POS (PAPER.INSTANCE GELFOND88))(POS (PAPER.BIBTEX GELFOND88 ARTICLE))(POS (PAPER.AUTHOR GELFOND88 "Michael Gelfond and Vladimir Lifschitz"))(POS (PAPER.TITLE GELFOND88 "The Stable Model Semantics for Logic Programming"))(POS (PAPER.PUBLICATION GELFOND88 "Proceedings of the Fifth International Conference on Logic Programming"))(POS (PAPER.STARTPAGE GELFOND88 1070))(POS (PAPER.ENDPAGE GELFOND88 1080))(POS (PAPER.LINK GELFOND88 "http://citeseer.ist.psu.edu/gelfond88stable.html"))(POS (PAPER.YEAR GELFOND88 1988))(POS (PAPER.DESCRIPTION GELFOND88 "
Stable model semantics for logic programming.
"))(POS (PAPER.TOPIC GELFOND88 "Logic Programming"))(POS (PAPER.INSTANCE GENESERETH87))(POS (PAPER.BIBTEX GENESERETH87 BOOK))(POS (PAPER.AUTHOR GENESERETH87 "Michael Genesereth and Nils Nilsson"))(POS (PAPER.TITLE GENESERETH87 "Logical Foundations of Artificial Intelligence"))(POS (PAPER.PUBLISHER GENESERETH87 "Morgan Kaufmann Publishers"))(POS (PAPER.LINK GENESERETH87 "http://www.amazon.com/Foundations-Artificial-Intelligence-Michael-Genesereth/dp/0934613311"))(POS (PAPER.YEAR GENESERETH87 1987))(POS (PAPER.RANK GENESERETH87 "[*****]"))(POS (PAPER.DESCRIPTION GENESERETH87 "
Genesereth and Nilsson construct the foundations of AI using logic.  Covers logic, resolution and various strategies, nonmonotonic reasoning, induction, uncertainty, belief,
metaknowledge and metareasoning, a changing environment, and agent architectures.
"))(POS (PAPER.TOPIC GENESERETH87 ""))(POS (PAPER.INSTANCE GIACOMO2000))(POS (PAPER.AUTHOR GIACOMO2000 "G. De Giacomo, Y. Lesperance, and H.J. Levesque"))(POS (PAPER.TITLE GIACOMO2000 "ConGolog, a concurrent prrogramming language based on the situation calculus"))(POS (PAPER.PUBLICATION GIACOMO2000 "Artificial Intelligence"))(POS (PAPER.VOLUME GIACOMO2000 "121"))(POS (PAPER.STARTPAGE GIACOMO2000 109))(POS (PAPER.ENDPAGE GIACOMO2000 169))(POS (PAPER.LINK GIACOMO2000 "http://www.cs.yorku.ca/~lesperan/publications.html"))(POS (PAPER.YEAR GIACOMO2000 2000))(POS (PAPER.DESCRIPTION GIACOMO2000 "
ConGolog extends Golog (both implementations being in Prolog) to include concurrent actions (conceptualized as interleaving actions of different processes that can block, in the OS sense).  The constructs introduced here include synchronized conditionals (test-and-set), synchronized loops, concurrent execution, concurrency with different priorities (the lower priority process can only execute if the higher priority one is blocked or finished), concurrent iteration, and interrupts.  Nondeterminstic iteration can be useful when an unspecified number of programs need to be run concurrently, e.g. an FTP server.  Some more work is required to handle procedures.  The semantics given in the original Golog paper were evaluation semantics.  Here the authors switch to transition semantics and require all the macros of Golog to become embedded in the language.
Exogenous events are handled by allowing the user to specify which primitive actions may occurs outside the control of the program.  A predefined program for choosing a possible exogenous action, checking its preconditions, and executing it if possible is run concurrently with the user-defined program. To handle truly overlapping actions such as filling-bath-tub and singing-do-re-mi, the authors suggest thinking of filling-bath-tub as not an action, but rather as a state, which requires the start-filling action to enter the state and the stop-filling action to exit the state.  This way, interleaving filling-bath-tub and singing-do-re-mi can happen at the same time.
"))(POS (PAPER.TOPIC GIACOMO2000 "Logic Programming"))(POS (PAPER.INSTANCE GIUNCHIGLIA92))(POS (PAPER.BIBTEX GIUNCHIGLIA92 ARTICLE))(POS (PAPER.AUTHOR GIUNCHIGLIA92 "Fausto Giunchiglia and Toby Walsh"))(POS (PAPER.TITLE GIUNCHIGLIA92 "A theory of abstraction"))(POS (PAPER.PUBLICATION GIUNCHIGLIA92 "Artificial Intelligence"))(POS (PAPER.VOLUME GIUNCHIGLIA92 "57"))(POS (PAPER.STARTPAGE GIUNCHIGLIA92 323))(POS (PAPER.ENDPAGE GIUNCHIGLIA92 389))(POS (PAPER.LINK GIUNCHIGLIA92 "http://citeseer.ist.psu.edu/27696.html"))(POS (PAPER.YEAR GIUNCHIGLIA92 1992))(POS (PAPER.RANK GIUNCHIGLIA92 "[****]"))(POS (PAPER.DESCRIPTION GIUNCHIGLIA92 "
Giunchiglia and Walsh describe a theory of abstraction in very general terms,
which is intended to be independent of proof system.  Most generally,
an abstraction is a mapping between a pair of formal systems, where a
formal system consists of a language and a subset of that language defining
the axioms.  Axiomatic formal systems include an extra element: the
proof system.  Abstractions are categorized by whether they increase, decrease, or
leave constant the set of consequences of the theory: TI, TD, TC.  The authors
claim the TI abstractions is the true meaning of abstraction.  TD abstractions
can be used to prove entailment, i.e. if TD(Delta) |= phi then Delta |= phi.
TI abstractions can be used to prove negative entailment, i.e. if
TI(Delta) |/= phi then Delta |/= phi.  Refutation systems are concerned
not with provability but with inconsistency.  Abstractions in this setting
are characterized as NTI, NTD, and NTC.  If the formal system includes
negation and the abstraction f is negation preserving, i.e. f(-phi) = -f(phi)
then NT* and T* are equivalent.  Further classifications are made of abstractions,
depending on how independently an abstraction translates axioms, inference rules, etc.
A large section explaining how various peoples' work fits into this framework follows.
Then sections follow on inconsistent abstract spaces, operations performed
on abstractions, ordering abstractions, hierarchies of abstraction spaces, and building
abstractions.
"))(POS (PAPER.TOPIC GIUNCHIGLIA92 "Abstraction"))(POS (PAPER.INSTANCE GIUNCHIGLIA96REASONING))(POS (PAPER.BIBTEX GIUNCHIGLIA96REASONING INPROCEEDINGS))(POS (PAPER.AUTHOR GIUNCHIGLIA96REASONING "Fausto Giunchiglia and Paolo Pecchiari and Carolyn Talcott"))(POS (PAPER.TITLE GIUNCHIGLIA96REASONING "Reasoning Theories - Towards an Architecture for Open Mechanized Reasoning Systems"))(POS (PAPER.PUBLICATION GIUNCHIGLIA96REASONING "1st International Workshop: Frontiers of Combining Systems
           "))(POS (PAPER.STARTPAGE GIUNCHIGLIA96REASONING 157))(POS (PAPER.ENDPAGE GIUNCHIGLIA96REASONING 174))(POS (PAPER.LINK GIUNCHIGLIA96REASONING "http://citeseer.ist.psu.edu/354680.html"))(POS (PAPER.YEAR GIUNCHIGLIA96REASONING 1996))(POS (PAPER.RANK GIUNCHIGLIA96REASONING "[***]"))(POS (PAPER.DESCRIPTION GIUNCHIGLIA96REASONING "Giunchiglia et al. describe a formalization of logical reasoners.  Such
reasoners (quoting) might be based on different logics; have different domain models;
use different vocabularies and data structures; use different reasoning
strategies; and have different interaction capabilities.  The authors
put forth a general architecture called Open Mechanized Reasoning Systems
(OMRS) for integrating reasoners described by what they call a
Reasoning Theory.  They use NQTHM as an example to illustrate the construction
of a Reasoning Theory.
"))(POS (PAPER.TOPIC GIUNCHIGLIA96REASONING "Architectures"))(POS (PAPER.INSTANCE GIUNCHIGLIA99APPLYING))(POS (PAPER.BIBTEX GIUNCHIGLIA99APPLYING INPROCEEDINGS))(POS (PAPER.AUTHOR GIUNCHIGLIA99APPLYING "Enrico Giunchiglia and Roberto Sebastiani"))(POS (PAPER.TITLE GIUNCHIGLIA99APPLYING "Applying the Davis-Putnam Procedure to Non-clausal Formulas"))(POS (PAPER.PUBLICATION GIUNCHIGLIA99APPLYING "Proceedings of the 6th Congress of the Italian Association for Artificial Intelligence on Advances in Artificial Intelligence"))(POS (PAPER.STARTPAGE GIUNCHIGLIA99APPLYING 84))(POS (PAPER.ENDPAGE GIUNCHIGLIA99APPLYING 94))(POS (PAPER.LINK GIUNCHIGLIA99APPLYING "http://citeseer.ist.psu.edu/giunchiglia99applying.html"))(POS (PAPER.YEAR GIUNCHIGLIA99APPLYING 1999))(POS (PAPER.DESCRIPTION GIUNCHIGLIA99APPLYING "
Continuation of their earlier work on building a SAT solver that handles
non-clausal form by translating the problem into CNF in such a way that 
the search space of the non-CNF problem is preserved in some way.
"))(POS (PAPER.TOPIC GIUNCHIGLIA99APPLYING "SAT Solving"))(POS (PAPER.INSTANCE GIUNCHIGLIA99PLANNING))(POS (PAPER.BIBTEX GIUNCHIGLIA99PLANNING INPROCEEDINGS))(POS (PAPER.AUTHOR GIUNCHIGLIA99PLANNING "Fausto Giunchiglia and Paolo Traverso"))(POS (PAPER.TITLE GIUNCHIGLIA99PLANNING "Planning as Model Checking"))(POS (PAPER.LINK GIUNCHIGLIA99PLANNING "http://citeseer.ist.psu.edu/giunchiglia99planning.html"))(POS (PAPER.YEAR GIUNCHIGLIA99PLANNING 1999))(POS (PAPER.RANK GIUNCHIGLIA99PLANNING "[*]"))(POS (PAPER.DESCRIPTION GIUNCHIGLIA99PLANNING "
This paper gives an introduction to Planning as Model Checking for
both deterministic and nondeterministic domains.  It explains
the model checking problem, planning as model checking, 
planning in nondeterministic domains, an implementation, and
related work.  They look at problems formalized in Computation
Tree Logic (CTL).
"))(POS (PAPER.TOPIC GIUNCHIGLIA99PLANNING "Model Checking"))(POS (PAPER.INSTANCE GRAMLICH2005))(POS (PAPER.BIBTEX GRAMLICH2005 ARTICLE))(POS (PAPER.AUTHOR GRAMLICH2005 "Bernhard Gramlich"))(POS (PAPER.TITLE GRAMLICH2005 "Strategic issues, Problems and Challenges in Inductive Theorem Proving"))(POS (PAPER.LINK GRAMLICH2005 "http://www.logic.at/staff/gramlich/ papers/strategies04-entcs05.pdf.gz"))(POS (PAPER.YEAR GRAMLICH2005 2005))(POS (PAPER.RANK GRAMLICH2005 "[***]"))(POS (PAPER.DESCRIPTION GRAMLICH2005 "
Gramlich outlines the inductive theorem proving, how it differs from
first-order theorem proving, and some of the obstacles that must be
overcome to make automated inductive theorem proving a reality.
"))(POS (PAPER.TOPIC GRAMLICH2005 "Herbrand Logic"))(POS (PAPER.INSTANCE GREEN69))(POS (PAPER.AUTHOR GREEN69 "C. Green"))(POS (PAPER.TITLE GREEN69 "Theorem-proving by resolution as a basis for question-answering systems."))(POS (PAPER.PUBLICATION GREEN69 "Machine Intelligence 4"))(POS (PAPER.STARTPAGE GREEN69 183))(POS (PAPER.ENDPAGE GREEN69 205))(POS (PAPER.YEAR GREEN69 1969))(POS (PAPER.DESCRIPTION GREEN69 "
Green describes using a theorem prover, QA3, to build a question-answering system.  Both statements and questions are written in FOL.  Questions can be True/False or Constructive (i.e. ask for an x such that ...).  Constructive answers are produced by adding the rule question-of-user(x) => Answer(x).  Green goes on to describe what we now call deductive plan synthesis, i.e. answer extraction of situation calculus axioms.  QA3 uses subsumption, duplicate literal elimination, unit preference, a variant on set of support, and no equality (yet).
"))(POS (PAPER.TOPIC GREEN69 "Fundamentals"))(POS (PAPER.INSTANCE GREINER91))(POS (PAPER.BIBTEX GREINER91 ARTICLE))(POS (PAPER.AUTHOR GREINER91 "Russell Greiner and Charles Elkan"))(POS (PAPER.TITLE GREINER91 "Measuring and Improving the Effectiveness of Representations"))(POS (PAPER.PUBLICATION GREINER91 "IJCAI"))(POS (PAPER.STARTPAGE GREINER91 518))(POS (PAPER.ENDPAGE GREINER91 524))(POS (PAPER.LINK GREINER91 "http://citeseer.ist.psu.edu/114212.html"))(POS (PAPER.YEAR GREINER91 1991))(POS (PAPER.RANK GREINER91 "[****]"))(POS (PAPER.DESCRIPTION GREINER91 "
Greiner and Elkan give axes upon which a representation, i.e. black box
for answering questions, can be evaluated: accuracy (how often the answer
given is correct), categoricity (how often the answer is I don't know), and
efficiency. A representation is thus evaluated wrt a query stream.  This 
external form of evaluation captures what any system using a representation
system actually cares about -- how well that representation works.  The
internal representation might also be evaluated by, for example, its
conciseness or elegance, but that is not covered here.  They also formalize
all bounded, linearly separable utility measures, i.e. ways of combining
evaluations wrt the 3 axes above.  Finally the authors confront statistical
approaches for performing evaluation, comparing representations, and improving
existing representations.   Well written.
"))(POS (PAPER.TOPIC GREINER91 "Logical Knowledge Representation"))(POS (PAPER.INSTANCE GREINER98))(POS (PAPER.BIBTEX GREINER98 ARTICLE))(POS (PAPER.AUTHOR GREINER98 "Russell Greiner and Christian Darken and N. Santoso"))(POS (PAPER.TITLE GREINER98 "Efficient Reasoning"))(POS (PAPER.PUBLICATION GREINER98 "ACM Computing Surveys"))(POS (PAPER.VOLUME GREINER98 "33(1)"))(POS (PAPER.STARTPAGE GREINER98 1))(POS (PAPER.ENDPAGE GREINER98 30))(POS (PAPER.LINK GREINER98 "http://citeseer.ist.psu.edu/greiner98efficient.html"))(POS (PAPER.YEAR GREINER98 1998))(POS (PAPER.RANK GREINER98 "[*]"))(POS (PAPER.DESCRIPTION GREINER98 "
Greiner gives a survey of techniques for efficient reasoning: both deductive 
and probabilistic.  He talks about the various techniques available for
dealing with exponential run times: unsound inference, incompleteness, etc.
"))(POS (PAPER.TOPIC GREINER98 "Logical Knowledge Representation"))(POS (PAPER.INSTANCE GROHE2001))(POS (PAPER.BIBTEX GROHE2001 INPROCEEDINGS))(POS (PAPER.AUTHOR GROHE2001 "Martin Grohe"))(POS (PAPER.TITLE GROHE2001 "Generalized Model-Checking Problems for First-Order Logic"))(POS (PAPER.PUBLICATION GROHE2001 "Symposium on Theoretical Aspects of Computer Science"))(POS (PAPER.STARTPAGE GROHE2001 12))(POS (PAPER.ENDPAGE GROHE2001 26))(POS (PAPER.LINK GROHE2001 "http://www.dcs.ed.ac.uk/home/grohe/pub.html"))(POS (PAPER.YEAR GROHE2001 2001))(POS (PAPER.RANK GROHE2001 "[****]"))(POS (PAPER.DESCRIPTION GROHE2001 "
Grohe investigates the parameterized complexity of various model-checking
problems in first-order logic.  In general, the problem is PSPACE-complete
for the combined size of the query and the model.  Under the assumption
of a small query, the parameterized complexity is still AW[*].  However,
some types of formulas and models lend themselves to tractable algorithms:
those with an underlying tree structure.  This paper gives a survey
of various model-checking complexity results for first-order logic.
"))(POS (PAPER.TOPIC GROHE2001 "Model Checking"))(POS (PAPER.RELATED GROHE2001 GROHE2002))(POS (PAPER.INSTANCE GROHE2002))(POS (PAPER.BIBTEX GROHE2002 ARTICLE))(POS (PAPER.AUTHOR GROHE2002 "Martin Grohe"))(POS (PAPER.TITLE GROHE2002 "Parameterized Complexity for the Database Theorist"))(POS (PAPER.PUBLICATION GROHE2002 "SIGMOD"))(POS (PAPER.VOLUME GROHE2002 "31(4)"))(POS (PAPER.LINK GROHE2002 "http://www.dcs.ed.ac.uk/home/grohe/pub.html"))(POS (PAPER.YEAR GROHE2002 2002))(POS (PAPER.RANK GROHE2002 "[*]"))(POS (PAPER.DESCRIPTION GROHE2002 "
Grohe gives a gentle introduction to Parameterized Complexity Theory for
database theorists.  The theory defines a complexity hierarchy for
problems with nonstandard constraints and reductions for proofs
of problem locations within the hierarchy.
These parameterized problems include more information than their standard
counterparts, and thus, can have better solutions.
"))(POS (PAPER.TOPIC GROHE2002 "Knowledge Base Compilation"))(POS (PAPER.INSTANCE GROSOF2003))(POS (PAPER.BIBTEX GROSOF2003 INPROCEEDINGS))(POS (PAPER.AUTHOR GROSOF2003 "Benjamin Grosof and Ian Horrocks and Raphael Volz and Stefan Decker"))(POS (PAPER.TITLE GROSOF2003 "Description Logic Programs: Combining Logic Programs with Description Logic"))(POS (PAPER.PUBLICATION GROSOF2003 "Proceedings of the 12th International Conference on the World Wide Web"))(POS (PAPER.LINK GROSOF2003 "http://citeseer.ist.psu.edu/grosof03description.html"))(POS (PAPER.YEAR GROSOF2003 2003))(POS (PAPER.DESCRIPTION GROSOF2003 "
Description Logic Programs are introduced, which lie in the intersection 
of logic programming and OWL DL.  In addition, mechanisms for reasoning
about this fragment with either description logic or logic programming
tools are introduced.
"))(POS (PAPER.TOPIC GROSOF2003 "Semantic Web"))(POS (PAPER.INSTANCE GUREVICH90))(POS (PAPER.BIBTEX GUREVICH90 ARTICLE))(POS (PAPER.AUTHOR GUREVICH90 "Yuri Gurevich"))(POS (PAPER.TITLE GUREVICH90 "On the Classical Decision Problem"))(POS (PAPER.PUBLICATION GUREVICH90 "Bulletin of the European Association for Theoretical Computer Science"))(POS (PAPER.VOLUME GUREVICH90 "42"))(POS (PAPER.STARTPAGE GUREVICH90 140))(POS (PAPER.ENDPAGE GUREVICH90 150))(POS (PAPER.LINK GUREVICH90 "http://citeseer.ist.psu.edu/gurevich93classical.html"))(POS (PAPER.YEAR GUREVICH90 1990))(POS (PAPER.RANK GUREVICH90 "[*]"))(POS (PAPER.DESCRIPTION GUREVICH90 "
This paper takes the form of a dialogue between the Author and Quisani.
It gives an introduction to the problem of determining whether a first-
order formula is satisfiable (or valid).  The classic decision problem
is whether this problem is decidable.  Church and Turing showed
it to be undecidable.  Then the question becomes, for which
formulas is this decidable?  Classes are given based on the 
quantifier prefixes that are decidable.  More interestingly, 
a certain set of 4 prefixes are enough to completely solve the
decision problem for prefix classes.
"))(POS (PAPER.TOPIC GUREVICH90 "Decidable Fragments of First-Order Logic"))(POS (PAPER.INSTANCE HAAS86))(POS (PAPER.AUTHOR HAAS86 "Andrew R. Haas"))(POS (PAPER.TITLE HAAS86 "A Syntactic Theory of Belief and Action"))(POS (PAPER.PUBLICATION HAAS86 "Artificial Intelligence"))(POS (PAPER.VOLUME HAAS86 "28(3)"))(POS (PAPER.STARTPAGE HAAS86 245))(POS (PAPER.ENDPAGE HAAS86 292))(POS (PAPER.LINK HAAS86 "http://www.reviews.com/Review/Review_review.cfm?media_id=778843&reviewer=110938&pos=3&page=4"))(POS (PAPER.YEAR HAAS86 1986))(POS (PAPER.DESCRIPTION HAAS86 "
Haas describes an approach for reasoning about belief, both an agent's own
beliefs and another agent's belief's.  First, we represent an agent's belief's
with Believes(agent, sentence), where sentence names a sentence of FOL.  Haas
names sentences of FOL by quoting each component, i.e. p(a) is named 'p('a)
(it looks cleaner in prefix notation).  He also gives names for intervals of
time so he can state how long it will take for an agent to believe a certain
sentence; afterall inference is not instantaneous.   In order to give an agent
the ability to determine what another agent will infer, Haas borrows
Konolige's suggestion of implanting an agent's inference rules into the
Believes statements.  Then, Haas introduces The Reflection Schema to do
inference.  Specifically,
Ax1,..,xn. (ClosedTerm x1)^...^(ClosedTerm xn) => IsProof(s)
s is a proof quoted appropriately.  He shows this schema sound and complete.
Haas goes on to define 'Knowing What' in terms of the context of what was asked.
'Knowing How' means a robot has a program to execute.  Finally, Haas connnects
belief and truth using the truth predicate: 'true(quote p) 'iff 'p.  The
Liar's paradox shows up here, but Haas avoids it by proving if p is ground,
true produces no contradictions.
"))(POS (PAPER.TOPIC HAAS86 "Metalevel Reasoning"))(POS (PAPER.INSTANCE HAHNLE2002))(POS (PAPER.AUTHOR HAHNLE2002 "Reiner Hahnle and Neil Murray and Erik Rosenthal"))(POS (PAPER.TITLE HAHNLE2002 "Ordered Resolution vs. Connection Graph Resolution"))(POS (PAPER.LINK HAHNLE2002 "http://citeseer.ist.psu.edu/446349.html"))(POS (PAPER.YEAR HAHNLE2002 2002))(POS (PAPER.DESCRIPTION HAHNLE2002 "
Hahnle et. al. first describe connection graph resolution for
propositional logic, introduced by Kowalski in 1975.  
CGR begins with a graph of clauses with
edges between complementary literals.  Activating an edge
means performing a step of resolution, producing a new 
clause graph.  Then they show that ordered resolution
is a special case of cg-resolution (for prop logic) and then
that ordered cg-resolution will always terminate.  Ordered
cg-resolution enforces a total ordering on literals so
that resolution is applied only to the maximally ordered
literal in a clause.  It is a little unclear to what extent
the results are new, but apparently
the proofs are simpler than those given in the past.  At the end,
the authors discuss issues for lifting this to first-order and
give Eisinger's example that shows unrestricted cg-resolution
is non-terminal.  
"))(POS (PAPER.TOPIC HAHNLE2002 "Calculi"))(POS (PAPER.INSTANCE HALEVY2001))(POS (PAPER.BIBTEX HALEVY2001 ARTICLE))(POS (PAPER.AUTHOR HALEVY2001 "Alon Halevy"))(POS (PAPER.TITLE HALEVY2001 "Answering Queries Using Views: A Survey"))(POS (PAPER.PUBLICATION HALEVY2001 "VLDB Journal: Very Large Data Bases"))(POS (PAPER.VOLUME HALEVY2001 "10(4)"))(POS (PAPER.STARTPAGE HALEVY2001 270))(POS (PAPER.ENDPAGE HALEVY2001 294))(POS (PAPER.LINK HALEVY2001 "http://citeseer.ist.psu.edu/halevy00answering.html"))(POS (PAPER.YEAR HALEVY2001 2001))(POS (PAPER.RANK HALEVY2001 "[****]"))(POS (PAPER.DESCRIPTION HALEVY2001 "
Halevy's survey splits the work that answers queries using views into two
cateogires: using materialized views to speed up query answering and
data integration.  In the former setting, materialized views have the potential
to speed up query answering because some portion of the query may have already
been computed and stored in the db as a materialized view.  The goal here is
to produce an efficient execution plan that uses base tables and materialized views.
In the latter setting, data integration techniques provide a schema, sometimes
called the mediated schema, for a user to query a large number of separate
databases.  To define how each individual schema relates to the mediated schema,
the tables in the individual schemas are expressed as views of the mediated schema.
Here the work focuses on rewriting the query in terms of the views of the mediated
schema, i.e. in terms of the database schema that actually exist.  This case is
particularly interesting because it requires the views to be treated as
incomplete, e.g. both the database of american cars and the database of foreign
cars contribute to the car table.
"))(POS (PAPER.TOPIC HALEVY2001 "Databases"))(POS (PAPER.INSTANCE HALMOS))(POS (PAPER.BIBTEX HALMOS BOOK))(POS (PAPER.AUTHOR HALMOS "Paul Halmos"))(POS (PAPER.TITLE HALMOS "Naive Set Theory"))(POS (PAPER.PUBLISHER HALMOS "Van Nostrand Reinhold Company"))(POS (PAPER.LINK HALMOS "http://www.amazon.com/Naive-Theory-Undergraduate-Texts-Mathematics/dp/0387900926"))(POS (PAPER.YEAR HALMOS 1960))(POS (PAPER.RANK HALMOS ""))(POS (PAPER.DESCRIPTION HALMOS "
A 100-page book on naive set theory.
"))(POS (PAPER.TOPIC HALMOS ""))(POS (PAPER.INSTANCE HALPERN91))(POS (PAPER.AUTHOR HALPERN91 "Joseph Halpern and Moshe Vardi"))(POS (PAPER.TITLE HALPERN91 "Model Checking vs. Theorem Proving: A Manifesto"))(POS (PAPER.PUBLICATION HALPERN91 "Artificial and mathematical Theory of Computation
       (Papers in Honor of John McCarthy)"))(POS (PAPER.LINK HALPERN91 "http://www.cs.cornell.edu/home/halpern/abstract.html#bookart4"))(POS (PAPER.YEAR HALPERN91 1991))(POS (PAPER.RANK HALPERN91 "[****]"))(POS (PAPER.DESCRIPTION HALPERN91 "
Halpern and Vardi prescribe using a semantic model to represent an agent's
knowledge and use model checking to determine logical entailment.  This differs
greatly from the standard approach of using logical sentences to represent
knowledge and then doing theorem proving to check entailment.  The authors
outline constructing such models in a few contexts and consider problems with
the model checking.
"))(POS (PAPER.TOPIC HALPERN91 "Model Checking"))(POS (PAPER.INSTANCE HAMMER93))(POS (PAPER.BIBTEX HAMMER93 ARTICLE))(POS (PAPER.AUTHOR HAMMER93 "Peter Hammer and Alexander Kogan"))(POS (PAPER.TITLE HAMMER93 "Optimal Compression of Propositional Horn Knowledge Bases: Complexity and Approximation"))(POS (PAPER.PUBLICATION HAMMER93 "Artificial Intelligence"))(POS (PAPER.VOLUME HAMMER93 "64(1)"))(POS (PAPER.STARTPAGE HAMMER93 131))(POS (PAPER.ENDPAGE HAMMER93 145))(POS (PAPER.LINK HAMMER93 "http://citeseer.ist.psu.edu/hammer93optimal.html"))(POS (PAPER.YEAR HAMMER93 1993))(POS (PAPER.RANK HAMMER93 "[*]"))(POS (PAPER.DESCRIPTION HAMMER93 "
Hammer and Kogan show that finding the minimum propositional Horn
KB of a given Horn KB is NP-Complete.  They also show a previous
O(n^2) approximation algorithm to be a good one since it allows
no more than a linear factor more rules.
"))(POS (PAPER.TOPIC HAMMER93 "Knowledge Base Compilation"))(POS (PAPER.INSTANCE HAYES75))(POS (PAPER.AUTHOR HAYES75 "Philip J. Hayes"))(POS (PAPER.TITLE HAYES75 "A Representation for Robot Plans"))(POS (PAPER.PUBLICATION HAYES75 "IJCAI"))(POS (PAPER.STARTPAGE HAYES75 181))(POS (PAPER.ENDPAGE HAYES75 188))(POS (PAPER.YEAR HAYES75 1975))(POS (PAPER.DESCRIPTION HAYES75 "
Due to the need for replanning, Hayes advocates producing plans that consist
of two data structures: a subgoal tree and a decision graph.  The subgoal tree represents the plan in a hierarchical-type planner, i.e. root is the overall
goal; each internal node is a reduction of its parent; each leaf is a
primitive action.  The decision graph records the decisions made by the planner while producing the plan.  Links exist between the decision graph and the
subgoal tree so that when a failure occurs during plan execution, the
appropriate parts of both data structures can be removed.
"))(POS (PAPER.TOPIC HAYES75 "Historical"))(POS (PAPER.INSTANCE HENTENRYCK89))(POS (PAPER.BIBTEX HENTENRYCK89 BOOK))(POS (PAPER.AUTHOR HENTENRYCK89 "Pascal Van Hentenryck"))(POS (PAPER.TITLE HENTENRYCK89 "Constraint Satisfaction in Logic Programming"))(POS (PAPER.PUBLISHER HENTENRYCK89 "MIT Press"))(POS (PAPER.YEAR HENTENRYCK89 1989))(POS (PAPER.DESCRIPTION HENTENRYCK89 "
This is an extended form of Hentenryck's thesis.  It concerns the integration
of two standard CSP techniques (forward checking and arc consistency) into
Prolog.  First, there is a thorough introduction to Prolog--syntax,
semantics, proof theory.  Then he formally shows how to do the
integration.  Next he explains an implementation of the integration
that allows users the ability to specify when to apply the
new techniques.  
"))(POS (PAPER.TOPIC HENTENRYCK89 "Logic Programming"))(POS (PAPER.INSTANCE HEYMANS2003))(POS (PAPER.BIBTEX HEYMANS2003 INPROCEEDINGS))(POS (PAPER.AUTHOR HEYMANS2003 "S. Heymans and D. Vermeir"))(POS (PAPER.TITLE HEYMANS2003 "Integrating Semantic Web Reasoning and Answer Set Programming"))(POS (PAPER.PUBLICATION HEYMANS2003 "Proceedings of the 2nd International ASP Workshop"))(POS (PAPER.LINK HEYMANS2003 "http://citeseer.ist.psu.edu/727609.html"))(POS (PAPER.YEAR HEYMANS2003 2003))(POS (PAPER.DESCRIPTION HEYMANS2003 "
Translating another description logic into logic programming, this time
using stable model semantics.
"))(POS (PAPER.TOPIC HEYMANS2003 "Semantic Web"))(POS (PAPER.INSTANCE HINRICHS2004))(POS (PAPER.BIBTEX HINRICHS2004 ARTICLE))(POS (PAPER.BIBTEX HINRICHS2004 PROCEEDINGS))(POS (PAPER.AUTHOR HINRICHS2004 "T. Hinrichs and N. Love and C. Petrie and L. Ramshaw and A. Sahai and S. Singhal."))(POS (PAPER.AUTHOR HINRICHS2004 "Tim Hinrichs, Nathaniel Love, Charles Petrie, Lyle Ramshaw, Akhil Sahai and Sharad Singhal"))(POS (PAPER.TITLE HINRICHS2004 "Using Object-Oriented Constraint Satisfaction for Automated Configuration Generation"))(POS (PAPER.TITLE HINRICHS2004 "Using Object-Oriented Constraint Satisfaction for Automated Configuration Generation"))(POS (PAPER.PUBLICATION HINRICHS2004 "DSOM"))(POS (PAPER.PUBLICATION HINRICHS2004 "Utility Computing: 15th IFIP/IEEE International Workshop on Distributed Systems: Operations and Management, DSOM 2004"))(POS (PAPER.LINK HINRICHS2004 "http://logic.stanford.edu/~thinrich/publications.htm"))(POS (PAPER.LINK HINRICHS2004 "papers/hinrichs2004using.pdf"))(POS (PAPER.YEAR HINRICHS2004 2004))(POS (PAPER.YEAR HINRICHS2004 2004))(POS (PAPER.RANK HINRICHS2004 ""))(POS (PAPER.DESCRIPTION HINRICHS2004 "
Hinrichs, et. al. describe an application of Object-Oriented Constraint 
Satisfaction to configuration management.
"))(POS (PAPER.DESCRIPTION HINRICHS2004 "
In this paper, we describe an approach for automatically generating configurations for complex applications. Automated generation of system configurations is required to allow large-scale deployment of custom applications within utility computing environments. Our approach models the configuration management problem as an Object-Oriented Constraint Satisfaction Problem (OOCSP) that can be solved efficiently using a resolution-based theorem-prover. We outline the approach and discuss both the benefits of the approach as well as its limitations, and highlight certain unresolved issues that require further work. We demonstrate the viability of this approach using an e-Commerce site as an example, and provide results on the complexity and time required to solve for the configuration of such an application.
"))(POS (PAPER.TOPIC HINRICHS2004 "Object Oriented Constraint Satisfaction"))(POS (PAPER.TOPIC HINRICHS2004 "References"))(POS (PAPER.INSTANCE HINRICHS2005AXIOM))(POS (PAPER.BIBTEX HINRICHS2005AXIOM INPROCEEDINGS))(POS (PAPER.AUTHOR HINRICHS2005AXIOM "Timothy Hinrichs and Michael Genesereth"))(POS (PAPER.TITLE HINRICHS2005AXIOM "Axiom Schemata as Metalevel Axioms: Model Theory"))(POS (PAPER.PUBLICATION HINRICHS2005AXIOM "In proceedings of American Association for Aritificial Intelligence"))(POS (PAPER.LINK HINRICHS2005AXIOM "http://logic.stanford.edu/~thinrich/papers/hinrichs2005axiom.pdf"))(POS (PAPER.YEAR HINRICHS2005AXIOM 2005))(POS (PAPER.DESCRIPTION HINRICHS2005AXIOM "
Logicians frequently use axiom schemata to encode (potentially infinite) sets of sentences with particular syntactic form. In this paper we examine a first-order language in which it is possible to write expressions that both describe sentences and assert the truth of the sentences so described. The effect of adding such expressions to a knowledge base is the same as directly including the set of described sentences. 
"))(POS (PAPER.TOPIC HINRICHS2005AXIOM "References"))(POS (PAPER.INSTANCE HINRICHS2006HERBRAND))(POS (PAPER.BIBTEX HINRICHS2006HERBRAND TECHREPORT))(POS (PAPER.AUTHOR HINRICHS2006HERBRAND "Timothy Hinrichs and Michael Genesereth"))(POS (PAPER.TITLE HINRICHS2006HERBRAND "Herbrand Logic"))(POS (PAPER.PUBLISHER HINRICHS2006HERBRAND "Stanford University"))(POS (PAPER.LINK HINRICHS2006HERBRAND "http://logic.stanford.edu/reports/LG-2006-02.pdf"))(POS (PAPER.YEAR HINRICHS2006HERBRAND 2006))(POS (PAPER.DESCRIPTION HINRICHS2006HERBRAND "
Herbrand logic has the same syntax as first-order logic but has Herbrand semantics. That is, the only models that exist in Herbrand logic are the Herbrand models. This logic is easier to learn than first-order logic and is often better suited for modeling and manipulating today's computer systems, the central concerns of computer science. In Herbrand logic, arithmetic using the natural numbers if finitely axiomatizable; however, neither entailment nor satisfiability are semi-decidable. Nevertheless, four of the most industrially successful applications of logic in computer science have been built within fragments of Herbrand logic: deductive databases, logic programming, constraint satisfaction, and formal verification. In this paper, we define Herbrand logic formally, prove several of its properties, discuss Goedel's incompleteness result with respect to Herbrand logic, and demonstrate how each of the four applications mentioned above can be formalized within Herbrand logic. 
"))(POS (PAPER.TOPIC HINRICHS2006HERBRAND "References"))(POS (PAPER.INSTANCE HINRICHS2007EXTENSIONAL))(POS (PAPER.BIBTEX HINRICHS2007EXTENSIONAL INPROCEEDINGS))(POS (PAPER.AUTHOR HINRICHS2007EXTENSIONAL "Timothy Hinrichs and Michael Genesereth"))(POS (PAPER.TITLE HINRICHS2007EXTENSIONAL "Extensional Reasoning"))(POS (PAPER.PUBLICATION HINRICHS2007EXTENSIONAL "In proceedings of CADE Workshop on Empirically Successful Automated Reasoning in Large Theories (ESARLT)"))(POS (PAPER.LINK HINRICHS2007EXTENSIONAL "http://logic.stanford.edu/~thinrich/papers/hinrichs2007extensional.pdf"))(POS (PAPER.YEAR HINRICHS2007EXTENSIONAL 2007))(POS (PAPER.DESCRIPTION HINRICHS2007EXTENSIONAL "
Relational databases are one of the most industrially successful applications of logic in computer science, built for handling massive amounts of data. The power of the paradigm is clear both because of its widespread adoption and theoretical analysis. Today, automated theorem provers are not able to take advantage of database query engines and therefore do not routinely leverage that source of power. Extensional Reasoning is an approach to automated theorem proving where the machine automatically translates a logical entailment query into a database, a set of view definitions, and a database query such that the entailment query can be answered by answering the database query. This paper discusses the framework for Extensional Reasoning, describes algorithms that enable a theorem prover to leverage the power of the database in the case of axiomatically complete theories, and discusses theory resolution for handling incomplete theories. 
"))(POS (PAPER.TOPIC HINRICHS2007EXTENSIONAL "References"))(POS (PAPER.INSTANCE HINRICHS2007REFORMULATION))(POS (PAPER.BIBTEX HINRICHS2007REFORMULATION INPROCEEDINGS))(POS (PAPER.AUTHOR HINRICHS2007REFORMULATION "Timothy Hinrichs and Michael Genesereth"))(POS (PAPER.TITLE HINRICHS2007REFORMULATION "Reformulation for Extensional Reasoning"))(POS (PAPER.PUBLICATION HINRICHS2007REFORMULATION "In proceedings of the Symposium of Abstraction, Reformulation, and Approximation (SARA)"))(POS (PAPER.LINK HINRICHS2007REFORMULATION "http://logic.stanford.edu/~thinrich/papers/hinrichs2007reformulation.pdf"))(POS (PAPER.YEAR HINRICHS2007REFORMULATION 2007))(POS (PAPER.DESCRIPTION HINRICHS2007REFORMULATION "
Relational databases have had great industrial success in computer science. The power of the paradigm is made clear both by its widespread adoption and by theoretical analysis. Today, automated theorem provers are not able to take advantage of database query engines and therefore do not routinely leverage that source of power. Extensional Reasoning (ER) is an approach to automated theorem proving where the machine automatically translates a logical entailment query into a database, a set of view definitions, and a database query such that the entailment query can be answered by answering the database query. The techniques developed for ER to date are applicable only when the logical theory is axiomatically complete. This paper discusses techniques for reformulating an incomplete theory into a complete theory so that Extensional Reasoning techniques can be applied. 

"))(POS (PAPER.TOPIC HINRICHS2007REFORMULATION "References"))(POS (PAPER.INSTANCE HITZLER2005))(POS (PAPER.BIBTEX HITZLER2005 INPROCEEDINGS))(POS (PAPER.AUTHOR HITZLER2005 "Pascal Hitzler and Peter Haase and Markus Krotzsch and York Sure and Rudi Studer"))(POS (PAPER.TITLE HITZLER2005 "DLP isn't so bad after all"))(POS (PAPER.PUBLICATION HITZLER2005 "Proceedings of the WS OWL -- Experiences and Directions"))(POS (PAPER.LINK HITZLER2005 "http://citeseer.ist.psu.edu/733286.html"))(POS (PAPER.YEAR HITZLER2005 2005))(POS (PAPER.DESCRIPTION HITZLER2005 "
The authors try to clarify the controversy surrounding Description Logic
Programs, which is a fragment of OWL DL that can be reasoned about effectively
with logic programming engines.  
"))(POS (PAPER.TOPIC HITZLER2005 "Semantic Web"))(POS (PAPER.INSTANCE HODGSON2002))(POS (PAPER.BIBTEX HODGSON2002 ARTICLE))(POS (PAPER.AUTHOR HODGSON2002 "Kahlil Hodgson and John Slaney"))(POS (PAPER.TITLE HODGSON2002 "TPTP, CASC and the development of a semantically guided 
theorem prover"))(POS (PAPER.PUBLICATION HODGSON2002 "AI Communications"))(POS (PAPER.VOLUME HODGSON2002 "15"))(POS (PAPER.STARTPAGE HODGSON2002 135))(POS (PAPER.ENDPAGE HODGSON2002 146))(POS (PAPER.LINK HODGSON2002 "http://citeseer.ist.psu.edu/558093.html"))(POS (PAPER.YEAR HODGSON2002 2002))(POS (PAPER.RANK HODGSON2002 ""))(POS (PAPER.DESCRIPTION HODGSON2002 "
Hodgson and Slaney describe SCOTT 5, the fifth generation of
semantically constrained otter.  The authors give a quick
description of the differences between the five versions
and explain the algorithm for the newest.  Instead of
maintaining a single model that satisfies some of the
constraints, they maintain several models.  Moreover,
sometimes they use these models to implement the semantic
queue strategy.  Pick the largest set of clauses known
to be satisfiable and if the number of clauses complementary
to a clause in S in the passive list is small, into the
active list. If none of these so called co-NMCSs are small
enough, cycle through them and add clauses to the active
queue.  SCOTT keeps separate the model builder and the theorem
prover from semantic guidance routines to allow, in principle,
a plug and play architecture.
"))(POS (PAPER.TOPIC HODGSON2002 "System Designs"))(POS (PAPER.INSTANCE HOHFELD88))(POS (PAPER.BIBTEX HOHFELD88 ARTICLE))(POS (PAPER.AUTHOR HOHFELD88 "M. Hohfeld and Gert Smolka"))(POS (PAPER.TITLE HOHFELD88 "Definite Relations over Constraint Languages"))(POS (PAPER.LINK HOHFELD88 "http://citeseer.ist.psu.edu/hohfeld88definite.html"))(POS (PAPER.YEAR HOHFELD88 1988))(POS (PAPER.RANK HOHFELD88 "[****]"))(POS (PAPER.DESCRIPTION HOHFELD88 "
Hohfeld and Smolka generalize the previous formal foundations of Constraint
Logic Programming by allowing arbitrary constraints placed on definite
logic programming clauses.  Their definition for constraint states  that
it is simply a restriction on variables; predicate logic is simply a special
case.  They give a generalization of SLD resolution that is sound and 
complete for this broader definition of CLP.  The authors go on to give a 'semantic type discipline' for these CLP clause sets.
"))(POS (PAPER.TOPIC HOHFELD88 "Constraint Logic Programming"))(POS (PAPER.INSTANCE HORIYAMA99))(POS (PAPER.BIBTEX HORIYAMA99 INPROCEEDINGS))(POS (PAPER.AUTHOR HORIYAMA99 "Takashi Horiyama and Toshihide ibaraki"))(POS (PAPER.TITLE HORIYAMA99 "Ordered Binary Decision Diagrams as Knowledge-Bases"))(POS (PAPER.PUBLICATION HORIYAMA99 "International Symposium on Algorithms and Computation"))(POS (PAPER.LINK HORIYAMA99 "http://citeseer.ist.psu.edu/horiyama99ordered.html"))(POS (PAPER.YEAR HORIYAMA99 1999))(POS (PAPER.RANK HORIYAMA99 "[*]"))(POS (PAPER.DESCRIPTION HORIYAMA99 "
Ordered binary decision diagrams can be used to represent propositional 
knowledge bases.  Deduction can be done from such a representation in 
polynomial time; not surprisingly, some knowledge bases require exponential
space while others require only polynomial space.  On the up-side, the
space requirements are not correlated with either characteristic models
(see kautz and khardon) or standard CNF representations.
"))(POS (PAPER.TOPIC HORIYAMA99 "Model-Based Reasoning"))(POS (PAPER.RELATED HORIYAMA99 KAUTZ93))(POS (PAPER.RELATED HORIYAMA99 KHARDON94))(POS (PAPER.INSTANCE HOWER96))(POS (PAPER.BIBTEX HOWER96 ARTICLE))(POS (PAPER.AUTHOR HOWER96 "Walter Hower and Winfried Graf"))(POS (PAPER.TITLE HOWER96 "A bibliographical survey of constraint-based approaches to CAD,
graphics, layout, visualization, and related topics"))(POS (PAPER.PUBLICATION HOWER96 "Knowledge-Based Systems
"))(POS (PAPER.VOLUME HOWER96 "9(7)"))(POS (PAPER.STARTPAGE HOWER96 449))(POS (PAPER.ENDPAGE HOWER96 464))(POS (PAPER.LINK HOWER96 "http://citeseer.ist.psu.edu/hower96bibliographical.html"))(POS (PAPER.YEAR HOWER96 1996))(POS (PAPER.RANK HOWER96 "[**]"))(POS (PAPER.DESCRIPTION HOWER96 "
Survey paper on just what the title indicates.  There are a few paragraphs
on object-oriented approaches most of which is orthogonal.
"))(POS (PAPER.TOPIC HOWER96 "Miscellaneous"))(POS (PAPER.INSTANCE JACKSON98))(POS (PAPER.BIBTEX JACKSON98 ARTICLE))(POS (PAPER.AUTHOR JACKSON98 "Daniel Jackson and Somesh Jha and Craig Damon"))(POS (PAPER.TITLE JACKSON98 "Isomorph-free model enumeration: a new method for checking relational specifications"))(POS (PAPER.PUBLICATION JACKSON98 "ACM Transactions on Programming Languages and Systems"))(POS (PAPER.LINK JACKSON98 "http://portal.acm.org/citation.cfm?id=276396&dl=ACM&coll=portal"))(POS (PAPER.YEAR JACKSON98 1998))(POS (PAPER.DESCRIPTION JACKSON98 "
Methods for building models while avoiding the enumeration of isomorphic candidates for the language Nitpick.
"))(POS (PAPER.TOPIC JACKSON98 "Model Building"))(POS (PAPER.INSTANCE JAFFAR87))(POS (PAPER.BIBTEX JAFFAR87 ARTICLE))(POS (PAPER.AUTHOR JAFFAR87 "J. Jaffar and J.L. Lassez"))(POS (PAPER.TITLE JAFFAR87 "Constraint Logic Programming"))(POS (PAPER.PUBLICATION JAFFAR87 "ACM Symposium on Principles of Programming Languages"))(POS (PAPER.STARTPAGE JAFFAR87 111))(POS (PAPER.ENDPAGE JAFFAR87 119))(POS (PAPER.LINK JAFFAR87 "http://portal.acm.org/citation.cfm?id=41635&dl=GUIDE&coll=GUIDE"))(POS (PAPER.YEAR JAFFAR87 1987))(POS (PAPER.RANK JAFFAR87 "[****]"))(POS (PAPER.DESCRIPTION JAFFAR87 "
Jaffar and Lassez introduce constraint logic programming as a class
of logic programming languages, one for each domain of discourse.  
Every rule has associated with it a set of constraints 
over that domain.  Hohfeld and Smolka in '88 generalize this 
framework, but this is the seminal paper.  Solution to a CLP problem
is a set of constraints; thus, logic programming is a special form
of CLP where those constraints must be equality constraints.
"))(POS (PAPER.TOPIC JAFFAR87 "Constraint Logic Programming"))(POS (PAPER.INSTANCE JANICIC2002))(POS (PAPER.BIBTEX JANICIC2002 ARTICLE))(POS (PAPER.AUTHOR JANICIC2002 "Predrag Janicic and Alan Bundy"))(POS (PAPER.TITLE JANICIC2002 "A General Setting for Flexibly Combining and Augmenting Decision Procedures"))(POS (PAPER.PUBLICATION JANICIC2002 "Journal of Automated Reasoning
           "))(POS (PAPER.VOLUME JANICIC2002 "28(3)"))(POS (PAPER.STARTPAGE JANICIC2002 257))(POS (PAPER.ENDPAGE JANICIC2002 305))(POS (PAPER.LINK JANICIC2002 "http://www.inf.ed.ac.uk/publications/report/0095.html"))(POS (PAPER.YEAR JANICIC2002 2002))(POS (PAPER.RANK JANICIC2002 "[***]"))(POS (PAPER.DESCRIPTION JANICIC2002 "
Janicic and Bundy invent a set of macro rewrite rules that can be used
to build a reasoner out of a set of decision procedures.  They provide
a good overview of the main influences in the field of combining
and augmenting decision procedures.  They build a prototype system
and report comparison results for Nelson-Oppen, Shostak, etc.
"))(POS (PAPER.TOPIC JANICIC2002 "Architectures"))(POS (PAPER.INSTANCE JEAVONS99))(POS (PAPER.BIBTEX JEAVONS99 ARTICLE))(POS (PAPER.AUTHOR JEAVONS99 "Peter Jeavons and David Cohen and Marc Gyssens"))(POS (PAPER.TITLE JEAVONS99 "How to Determine the Expressive Power of Constraints"))(POS (PAPER.PUBLICATION JEAVONS99 "Constraints"))(POS (PAPER.VOLUME JEAVONS99 "4"))(POS (PAPER.STARTPAGE JEAVONS99 113))(POS (PAPER.ENDPAGE JEAVONS99 131))(POS (PAPER.LINK JEAVONS99 "http://citeseer.ist.psu.edu/jeavons98how.html"))(POS (PAPER.YEAR JEAVONS99 1999))(POS (PAPER.DESCRIPTION JEAVONS99 "
The authors define expresssive power as the set of relations definable
from another set of relations.  They show how to compute which algebraic 
operators are closed for a given set of relations by solving a particular
kind of CSP for the given relations.  Then they show that the set of
relations definable from a given set is equal to the set of relations
that are closed under the same operations as that given set.  If some set
R is closed under the set of operations O and every operation in O is 
what they call essentially unary, the problem is NP-complete.  Moreover,
if O includes an operation that is not essentially unary, it includes
an operation that has arity at most max(3, the size of the domain).
Thus, this paper details sufficient conditions for checking whether
a particular CSP is NP-complete: (1) compute the set of operations
that are closed over the permissible tables in the constraints of the CSP.
(2) If that set includes just essentially-unary operations (which can
be deduced by checking for operations of arity up to max(3, size of domain), 
we are assured the problem is NP-complete.
"))(POS (PAPER.TOPIC JEAVONS99 "General"))(POS (PAPER.INSTANCE KAUTZ91))(POS (PAPER.BIBTEX KAUTZ91 INPROCEEDINGS))(POS (PAPER.AUTHOR KAUTZ91 "Henry Kautz and Bart Selman"))(POS (PAPER.TITLE KAUTZ91 "A General Framework for Knowledge Compilation"))(POS (PAPER.PUBLICATION KAUTZ91 "International Workshop on Processing Declarative Knowledge"))(POS (PAPER.LINK KAUTZ91 "http://citeseer.ist.psu.edu/kautz91general.html"))(POS (PAPER.YEAR KAUTZ91 1991))(POS (PAPER.RANK KAUTZ91 "[****]"))(POS (PAPER.DESCRIPTION KAUTZ91 "
This follows up on selman91 and generalizes the Knowledge Compilation 
idea into a framework.  It says that it lifts the algorithms for
Least Upper Bound and Greatest Lower Bound Horn approximations to first-
order, but the proofs of computability are nonexistent.  
"))(POS (PAPER.TOPIC KAUTZ91 "Knowledge Base Compilation"))(POS (PAPER.RELATED KAUTZ91 SELMAN91))(POS (PAPER.INSTANCE KAUTZ92))(POS (PAPER.BIBTEX KAUTZ92 INPROCEEDINGS))(POS (PAPER.AUTHOR KAUTZ92 "Henry Kautz and Bart Selman"))(POS (PAPER.TITLE KAUTZ92 "Forming Concepts for Fast Inference"))(POS (PAPER.PUBLICATION KAUTZ92 "ECAI-Workshop on Knowledge Representation and Reasoning
      "))(POS (PAPER.STARTPAGE KAUTZ92 200))(POS (PAPER.ENDPAGE KAUTZ92 215))(POS (PAPER.LINK KAUTZ92 "http://citeseer.ist.psu.edu/kautz92forming.html"))(POS (PAPER.YEAR KAUTZ92 1992))(POS (PAPER.RANK KAUTZ92 "[**]"))(POS (PAPER.DESCRIPTION KAUTZ92 "
Kautz and Selman show the Least Upper Bound Horn approximation to a 
propositional knowledge base can be exponential in size.  In general,
there do exist knowledge bases (quoting) whose LUBs cannot be represented 
in a form that is both small and tractable.  This paper mainly
considers the utility of learning new concepts to reduce the size
of the LUB.  
"))(POS (PAPER.TOPIC KAUTZ92 "Knowledge Base Compilation"))(POS (PAPER.RELATED KAUTZ92 SELMAN91))(POS (PAPER.INSTANCE KAUTZ93))(POS (PAPER.BIBTEX KAUTZ93 INPROCEEDINGS))(POS (PAPER.AUTHOR KAUTZ93 "Henry Kautz and Michael Kearns and Bart Selman"))(POS (PAPER.TITLE KAUTZ93 "Reasoning with Characteristic Models"))(POS (PAPER.PUBLICATION KAUTZ93 "AAAI"))(POS (PAPER.LINK KAUTZ93 "http://citeseer.ist.psu.edu/kautz93reasoning.html"))(POS (PAPER.YEAR KAUTZ93 1993))(POS (PAPER.RANK KAUTZ93 "[*****]"))(POS (PAPER.DESCRIPTION KAUTZ93 "
This is the seminal work on characteristic models.  The authors
define the characteristic models of a set M of models as those that cannot 
be derived by intersecting other models of M.  For propositional Horn
theories, these characteristic models are sufficient for computing 
entailment in time linear in the size of the characteristic models and
the conjecture.  In some cases the clausal representation requires 
exponentially more space than the characteristic representation, but
in others just the reverse is true.  Abduction using characteristic
models can be done in time polynomial in the size of the assumption set 
and the size of the characteristic set.  Very clean paper overall.
"))(POS (PAPER.TOPIC KAUTZ93 "Characteristic Models"))(POS (PAPER.INSTANCE KAUTZ95))(POS (PAPER.BIBTEX KAUTZ95 ARTICLE))(POS (PAPER.AUTHOR KAUTZ95 "Henry Kautz and Michael Kearns and Bart Selman"))(POS (PAPER.TITLE KAUTZ95 "Horn Approximations of Empirical Data"))(POS (PAPER.PUBLICATION KAUTZ95 "Artificial Intelligence"))(POS (PAPER.VOLUME KAUTZ95 "74(1)"))(POS (PAPER.STARTPAGE KAUTZ95 129))(POS (PAPER.ENDPAGE KAUTZ95 145))(POS (PAPER.LINK KAUTZ95 "http://citeseer.ist.psu.edu/kautz95horn.html"))(POS (PAPER.YEAR KAUTZ95 1995))(POS (PAPER.RANK KAUTZ95 "[****]"))(POS (PAPER.DESCRIPTION KAUTZ95 "
This paper essentially rehashes that of kautz93, except it also looks
at the problem of converting a given set of models into either clausal
form or characteristic model form.  This idea of extracting structure
from 'empirical data' was first addressed in dechter92.
"))(POS (PAPER.TOPIC KAUTZ95 "Characteristic Models"))(POS (PAPER.RELATED KAUTZ95 KAUTZ93))(POS (PAPER.RELATED KAUTZ95 DECHTER92))(POS (PAPER.INSTANCE KAVVADIAS93))(POS (PAPER.BIBTEX KAVVADIAS93 INPROCEEDINGS))(POS (PAPER.AUTHOR KAVVADIAS93 "D. Kavvadias and C. Papadimitriou and M. Sideri"))(POS (PAPER.TITLE KAVVADIAS93 "On Horn Envelopes and Hypergraph Transversals"))(POS (PAPER.PUBLICATION KAVVADIAS93 "ISAAC"))(POS (PAPER.LINK KAVVADIAS93 "http://www.aueb.gr/Users/sideri/publicat.htm"))(POS (PAPER.YEAR KAVVADIAS93 1993))(POS (PAPER.RANK KAVVADIAS93 "[**]"))(POS (PAPER.DESCRIPTION KAVVADIAS93 "
This is the seminal work relating hypergraph transversals to
characteristic models.  Kavvadias et. al. look into the complexity
of computing the Horn envelope of a set of boolean models (the minimal
set of clauses that entail all the models) and the Horn core
(the maximal set of clauses that entail a subset of the models).
"))(POS (PAPER.TOPIC KAVVADIAS93 "Characteristic Models"))(POS (PAPER.INSTANCE KHARDON94))(POS (PAPER.BIBTEX KHARDON94 INPROCEEDINGS))(POS (PAPER.AUTHOR KHARDON94 "Roni Khardon and Dan Roth"))(POS (PAPER.TITLE KHARDON94 "Reasoning with Models"))(POS (PAPER.PUBLICATION KHARDON94 "AAAI"))(POS (PAPER.LINK KHARDON94 "http://citeseer.ist.psu.edu/khardon96reasoning.html"))(POS (PAPER.YEAR KHARDON94 1994))(POS (PAPER.RANK KHARDON94 "[****]"))(POS (PAPER.DESCRIPTION KHARDON94 "
This paper describes a method for determining entailment and abduction
through model-
checking for a KB of full propositional logic over a restricted set of 
queries.   It extends the work of Kautz, et. al. who wrote the seminal
work for propositional Horn KBs.  The definition for characteristic
models relies on Monotone Theory, which describes properties of 
Boolean functions.  It is important to note that these characteristic
models are defined with respect to a class of queries; that is, given
a class of queries, one can compute the characteristic models for
a propositional KB.  That set of models is then the optimal set, 
meaning all models are needed for correct entailment and abduction.
This paper does a thorough treatment of the issues it
brings up, but it is hard to penetrate.  Section 4 is a list of definitions
of Monotone theory, with little motivation or intuition as to the
utility of each definition.  Of course, the rest of the paper relies
on these definitions.  Reread! 
"))(POS (PAPER.TOPIC KHARDON94 "Characteristic Models"))(POS (PAPER.RELATED KHARDON94 KAUTZ93))(POS (PAPER.INSTANCE KHARDON94A))(POS (PAPER.BIBTEX KHARDON94A INPROCEEDINGS))(POS (PAPER.AUTHOR KHARDON94A "Roni Khardon and Dan Roth"))(POS (PAPER.TITLE KHARDON94A "Exploiting Relevance through Model-Based Reasoning"))(POS (PAPER.PUBLICATION KHARDON94A "AAAI"))(POS (PAPER.LINK KHARDON94A "http://citeseer.ist.psu.edu/40071.html"))(POS (PAPER.YEAR KHARDON94A 1994))(POS (PAPER.RANK KHARDON94A "[*****]"))(POS (PAPER.DESCRIPTION KHARDON94A "
Khardon and Roth outline three cases when the relevance can be exploited
to reason more efficiently.  The first deals with context.  Instead of using
all models for logical entailment, use just those that are relevant to 
the current context.  The second use of relevance is in using the Least
Upper Bound approximation of a theory to determine entailment when all 
queries will be answered correctly by the LUB.  Lastly, machine learning
is used to make reasoning easier as it gains experience in the world.
"))(POS (PAPER.TOPIC KHARDON94A "Model-Based Reasoning"))(POS (PAPER.INSTANCE KHARDON95))(POS (PAPER.BIBTEX KHARDON95 ARTICLE))(POS (PAPER.AUTHOR KHARDON95 "Roni Khardon"))(POS (PAPER.TITLE KHARDON95 "Translating between Horn Representations and their Characteristic Models"))(POS (PAPER.PUBLICATION KHARDON95 "Journal of Artificial Intelligence Research"))(POS (PAPER.VOLUME KHARDON95 "3"))(POS (PAPER.STARTPAGE KHARDON95 349))(POS (PAPER.ENDPAGE KHARDON95 372))(POS (PAPER.LINK KHARDON95 "http://citeseer.ist.psu.edu/khardon95translating.html"))(POS (PAPER.YEAR KHARDON95 1995))(POS (PAPER.RANK KHARDON95 "[***]"))(POS (PAPER.DESCRIPTION KHARDON95 "
Khardon builds on the previous work in kautz93 and khardon94 and investigates
the complexity of translating between propositional 
characteristic models and their
horn representations.  He shows that translating either way is polynomial-
reducible to the other, and that both are equivalent to deciding whether
a given set of models is the set of characteristic models of a given
set of horn clauses.  All these problems are at least as hard as converting
a monotone (no negations) CNF formula into a monotone DNF formula.  This
problem has a sub-exponential time solution of n^O(log n).
This paper also gives references to equivalent work in the database 
community under the name Armstrong relations.
"))(POS (PAPER.TOPIC KHARDON95 "Characteristic Models"))(POS (PAPER.RELATED KHARDON95 KAUTZ93))(POS (PAPER.RELATED KHARDON95 KHARDON95))(POS (PAPER.INSTANCE KHARDON95B))(POS (PAPER.BIBTEX KHARDON95B ARTICLE))(POS (PAPER.AUTHOR KHARDON95B "Roni Khardon and Heikki Mannila and Dan Roth"))(POS (PAPER.TITLE KHARDON95B "Reasoning with Examples: Propositional Formulae and Database Dependencies"))(POS (PAPER.PUBLICATION KHARDON95B "Techical Report: Harvard University"))(POS (PAPER.LINK KHARDON95B "http://citeseer.ist.psu.edu/170480.html"))(POS (PAPER.YEAR KHARDON95B 1995))(POS (PAPER.RANK KHARDON95B "[***]"))(POS (PAPER.DESCRIPTION KHARDON95B "
The authors show the connection between characteristic models and Armstrong
relations, i.e. relations that are sufficient for determining logical
entailment of functional dependencies.  They strengthen some of the
results on Armstrong relations and demonstrate a connection between
finding keys and abduction.
"))(POS (PAPER.TOPIC KHARDON95B "Characteristic Models"))(POS (PAPER.RELATED KHARDON95B KAUTZ93))(POS (PAPER.RELATED KHARDON95B KHARDON95))(POS (PAPER.INSTANCE KHARDON97))(POS (PAPER.BIBTEX KHARDON97 ARTICLE))(POS (PAPER.AUTHOR KHARDON97 "Roni Khardon and Dan Roth"))(POS (PAPER.TITLE KHARDON97 "Defaults and Relevance in Model Based Reasoning"))(POS (PAPER.PUBLICATION KHARDON97 "Artificial Intelligence"))(POS (PAPER.VOLUME KHARDON97 "97(1-2)"))(POS (PAPER.STARTPAGE KHARDON97 169))(POS (PAPER.ENDPAGE KHARDON97 193))(POS (PAPER.LINK KHARDON97 "http://citeseer.ist.psu.edu/khardon97defaults.html"))(POS (PAPER.YEAR KHARDON97 1997))(POS (PAPER.RANK KHARDON97 "[****]"))(POS (PAPER.DESCRIPTION KHARDON97 "
This paper explains how model-based reasoning can be used to model reasoning
with context.  Suppose the KB is represented by a set of models M.  As the agent's
context changes, new sentences appear that define that context.  Entailment in
the context then means that the sentence holds in the subset of models M that
satisfy those new sentences.  By representing the theory as a set of models,
as context changes, that set can be reduced online.  In this paper, context
change is represented using default logic.  Algorithms are given for both
skeptical and credulous default reasoning where the knowledge base is represented
as a set of models.  Conditions are given under which these algorithms work
correctly.  Finally, the learning to reason paradigm is brought up as a third
argument for representing a KB as the set of models that satisfy it.  All three,
context, defaults, and learning to reason, sometimes produce computational
benefits because models are used to represent knowledge.
"))(POS (PAPER.TOPIC KHARDON97 "Characteristic Models"))(POS (PAPER.INSTANCE KHARDON98))(POS (PAPER.BIBTEX KHARDON98 ARTICLE))(POS (PAPER.AUTHOR KHARDON98 "Roni Khardon and Heikki Manilla and Dan Roth"))(POS (PAPER.TITLE KHARDON98 "Reasoning with Examples: Propositional Formulae and Database Dependencies"))(POS (PAPER.PUBLICATION KHARDON98 "Acta Informatica"))(POS (PAPER.VOLUME KHARDON98 "36(4)"))(POS (PAPER.STARTPAGE KHARDON98 267))(POS (PAPER.ENDPAGE KHARDON98 286))(POS (PAPER.LINK KHARDON98 "http://citeseer.ist.psu.edu/170480.html"))(POS (PAPER.YEAR KHARDON98 1998))(POS (PAPER.RANK KHARDON98 "[***]"))(POS (PAPER.DESCRIPTION KHARDON98 "
Reasoning with Examples means reasoning with enough models to correctly
determine entailment.  This technique shows up both in the database
literature under the name 'Armstrong Relations' and in the automated
reasoning literature under the name 'Characteristic Models'.  While
the latter refers to a set of examples, the former refers to a single
example.  The number of models needed in Characteristic Models for
propositional logic is bounded by |B|*|DNF(kb)|, where B is the 
basis for the knowledge base kb.  The bulk of this paper shows how the 
two concepts are closely intertwined; it goes on to show that finding 
the keys of a DB is akin to finding abductive explanations in a propositional
knowledge base. 
"))(POS (PAPER.TOPIC KHARDON98 "Characteristic Models"))(POS (PAPER.RELATED KHARDON98 FAGIN82))(POS (PAPER.RELATED KHARDON98 KHARDON95))(POS (PAPER.INSTANCE KIM87))(POS (PAPER.BIBTEX KIM87 ARTICLE))(POS (PAPER.AUTHOR KIM87 "Myung Won Kim"))(POS (PAPER.TITLE KIM87 "On Automatically Generating and Using Examples in a Computational Logic System"))(POS (PAPER.PUBLICATION KIM87 "Technical Report"))(POS (PAPER.LINK KIM87 "http://citeseer.ist.psu.edu/342499.html"))(POS (PAPER.YEAR KIM87 1987))(POS (PAPER.RANK KIM87 "[*]"))(POS (PAPER.DESCRIPTION KIM87 "
Kim's dissertation explores an algorithm for automatically generating 
examples that satisfy a particular constraint given other such examples.
He also explores how such an algorithm can be used to help prune
a theorem-proving search space.  The logic is the Boyer-Moore theory,
and the theorem prover is the Boyer Moore theorem prover.
"))(POS (PAPER.TOPIC KIM87 "Reasoning with Examples"))(POS (PAPER.INSTANCE KIM94))(POS (PAPER.BIBTEX KIM94 INPROCEEDINGS))(POS (PAPER.AUTHOR KIM94 "Sun Kim and Hantao Zhang"))(POS (PAPER.TITLE KIM94 "ModGen: Theorem Proving by Model Generation"))(POS (PAPER.PUBLICATION KIM94 "AAAI"))(POS (PAPER.LINK KIM94 "http://citeseer.ist.psu.edu/kim94modgen.html"))(POS (PAPER.YEAR KIM94 1994))(POS (PAPER.RANK KIM94 "[**]"))(POS (PAPER.DESCRIPTION KIM94 "
The authors describe a system that propositionalizes Otter sentences and then
applies model-checking.  The limitation here is the requirement of a 
finite Herbrand universe.
"))(POS (PAPER.TOPIC KIM94 "Model-Based Reasoning"))(POS (PAPER.INSTANCE KLEER84))(POS (PAPER.BIBTEX KLEER84 INPROCEEDINGS))(POS (PAPER.AUTHOR KLEER84 "Johan de Kleer"))(POS (PAPER.TITLE KLEER84 "Choices without Backtracking"))(POS (PAPER.PUBLICATION KLEER84 "AAAI"))(POS (PAPER.YEAR KLEER84 1984))(POS (PAPER.RANK KLEER84 "[**]"))(POS (PAPER.DESCRIPTION KLEER84 "
Kleer describes a method for increasing the efficiency of problem solving
by storing the assumptions of a derived fact along with that fact.  Doing
this limits the amount of backtracking necessary.  This might be applicable
when backtracking with data structures.  Here it is situated within a truth
maintenance system.
"))(POS (PAPER.TOPIC KLEER84 "Theorem Proving with Attachments"))(POS (PAPER.INSTANCE KOWALSKI69))(POS (PAPER.BIBTEX KOWALSKI69 INBOOK))(POS (PAPER.AUTHOR KOWALSKI69 "Robert Kowalski"))(POS (PAPER.TITLE KOWALSKI69 "Search Strategies for Theorem-Proving"))(POS (PAPER.PUBLICATION KOWALSKI69 "Machine Intelligence"))(POS (PAPER.VOLUME KOWALSKI69 "5"))(POS (PAPER.STARTPAGE KOWALSKI69 181))(POS (PAPER.ENDPAGE KOWALSKI69 201))(POS (PAPER.YEAR KOWALSKI69 1969))(POS (PAPER.RANK KOWALSKI69 "[***]"))(POS (PAPER.DESCRIPTION KOWALSKI69 "
Kowalski abstractly defines the theorem-proving problem in terms of an 
'abstract theorem-proving graph'.  He defines the search space by giving
a specification for each state, the operators that act on those 
states, and a termination condition.  In this case, the tp graph initially
consists of a set of nodes, one for each input axiom.  Further nodes 
(states) are reached (generated) by applying an inference rule to a set
of already reached (generated) nodes.   A search strategy is a mapping
from sets of nodes to other sets of nodes.  Kowalski gives sufficient
(abstract) conditions under which a search strategy is complete.  The
last few sections cover heuristics, their optimality and their 
admissibility.
"))(POS (PAPER.TOPIC KOWALSKI69 "Comparative Analysis"))(POS (PAPER.INSTANCE KOWALSKI79))(POS (PAPER.AUTHOR KOWALSKI79 "Robert Kowalski"))(POS (PAPER.TITLE KOWALSKI79 "Algorithm = Logic + Control"))(POS (PAPER.PUBLICATION KOWALSKI79 "Communications of the ACM"))(POS (PAPER.VOLUME KOWALSKI79 "22(7)"))(POS (PAPER.STARTPAGE KOWALSKI79 424))(POS (PAPER.ENDPAGE KOWALSKI79 436))(POS (PAPER.LINK KOWALSKI79 "http://portal.acm.org/citation.cfm?id=359136&dl=ACM&coll=portal&CFID=6287538&CFTOKEN=93143078"))(POS (PAPER.YEAR KOWALSKI79 1979))(POS (PAPER.RANK KOWALSKI79 "[*****]"))(POS (PAPER.DESCRIPTION KOWALSKI79 "
Kowalski defines an algorithm as Logic and Control.  Logic specifies what the
algorithm does or the knowledge used in
solving a problem.  Control determines the problem-solving strategies, namely
top-down, bottom -up, a combination of the two, and
orthogonally parallelization.  Ideally, the bulk of efficiency concerns
should fall under Control; however, we can improve the efficiency of an
algorithm by adjusting either the Logic or the Control.  
Quote: Computer programs
will be more often correct, more easily improved, and more readily adapted to
new problems when programming languages separate logic and control.
"))(POS (PAPER.TOPIC KOWALSKI79 "Logical Knowledge Representation"))(POS (PAPER.INSTANCE KROTZSCH2005))(POS (PAPER.BIBTEX KROTZSCH2005 TECHREPORT))(POS (PAPER.AUTHOR KROTZSCH2005 "Markus Krotzsch and Pascal Hitzler and Michael Sintek and Denny Vrandecic"))(POS (PAPER.TITLE KROTZSCH2005 "Expressive OWL Reasoning"))(POS (PAPER.PUBLISHER KROTZSCH2005 "University of Kalrsruhe"))(POS (PAPER.LINK KROTZSCH2005 "http://citeseer.ist.psu.edu/733293.html"))(POS (PAPER.YEAR KROTZSCH2005 2005))(POS (PAPER.DESCRIPTION KROTZSCH2005 "
The authors enlarge the class of formulas in OWL DL that can be reasoned
about with a logic programming engine; in addition they present
an alternative characterization of Description Logic Programming.
"))(POS (PAPER.TOPIC KROTZSCH2005 "Semantic Web"))(POS (PAPER.INSTANCE LENAT90))(POS (PAPER.BIBTEX LENAT90 BOOK))(POS (PAPER.AUTHOR LENAT90 "D.B. Lenat and R.V. Guha"))(POS (PAPER.TITLE LENAT90 "Building Large Knowledge-Based Systems: Representation and Inference in the CYC Project"))(POS (PAPER.PUBLISHER LENAT90 "Addison-Wesley"))(POS (PAPER.YEAR LENAT90 1990))(POS (PAPER.DESCRIPTION LENAT90 "
Book on Cyc, the large common-sense knowledge base in Texas.
"))(POS (PAPER.TOPIC LENAT90 "Logical Knowledge Representation"))(POS (PAPER.INSTANCE LENZ98))(POS (PAPER.BIBTEX LENZ98 BOOK))(POS (PAPER.AUTHOR LENZ98 "(ed.) Mario Lenz, et. al."))(POS (PAPER.TITLE LENZ98 "Case-Based Reasoning Technology:From Foundations to Applications (Lecture Notes in Artificial Intelligence)"))(POS (PAPER.LINK LENZ98 "http://www.amazon.com/exec/obidos/tg/detail/-/3540645721/104-6992918-7685512?vi=glance"))(POS (PAPER.YEAR LENZ98 1998))(POS (PAPER.RANK LENZ98 "[***]"))(POS (PAPER.DESCRIPTION LENZ98 "
Case-based reasoning analogically produces solutions to problems through
the use of a case library.  Chapter 1 tries to situate it in the field of
knowledge representation, explain the fundamental process, and describe
the problems to be solved.
"))(POS (PAPER.TOPIC LENZ98 "Case-Based Reasoning"))(POS (PAPER.INSTANCE LESPERANCE95))(POS (PAPER.AUTHOR LESPERANCE95 "Yves Lesperance, Hector J. Levesque, Fangzhen Lin, and Richard B.
Scherl"))(POS (PAPER.TITLE LESPERANCE95 "Ability and Knowing How in the Situation Calculus"))(POS (PAPER.LINK LESPERANCE95 "http://citeseer.ist.psu.edu/lesperance95ability.html"))(POS (PAPER.YEAR LESPERANCE95 1995))(POS (PAPER.DESCRIPTION LESPERANCE95 "
Lesperance et. al. describe 1) a formalism for showing that a given goal can or cannot be accomplished
without simply producing a plan to accomplish it.  This involves discovering whether there is a path of
actions that will lead to the goal at the metalevel.  2) In the plan space that includes sensing actions, nondeterministic
branching, nondeterministic argument-passing, and nondeterministic primitive action choice, the authors formalize the notion that a dumb execution
engine cannot execute all the same plans as an intelligent execution engine.  Building on (1), they
define DumbKnowHow (DKH) and SmartKnowHow (SKH) predicates.  Cool ideas here.  There is also a nice summary
of a formalization of these sensing actions.
"))(POS (PAPER.TOPIC LESPERANCE95 "Fundamentals"))(POS (PAPER.INSTANCE LEUSCHEL2002))(POS (PAPER.BIBTEX LEUSCHEL2002 ARTICLE))(POS (PAPER.AUTHOR LEUSCHEL2002 "Michael Leuschel and Maurice Bruynooghe"))(POS (PAPER.TITLE LEUSCHEL2002 "Logic Program Specialisation Through Partial Deduction: Control Issues"))(POS (PAPER.PUBLICATION LEUSCHEL2002 "Theory and Practice of Logic Programming"))(POS (PAPER.VOLUME LEUSCHEL2002 "2(4-5)"))(POS (PAPER.STARTPAGE LEUSCHEL2002 461))(POS (PAPER.ENDPAGE LEUSCHEL2002 515))(POS (PAPER.LINK LEUSCHEL2002 ""))(POS (PAPER.YEAR LEUSCHEL2002 2002))(POS (PAPER.DESCRIPTION LEUSCHEL2002 "
The authors go through some of the work on partial evaluation in the case
of pure logic programming, which is called partial deduction.  (It differs
from partial evaluation in LP because axioms can be partially partially 
evaluated in the case of non-ground static arguments.)  Partial deduction
means constructing a partial SLDNF tree for a query, and using the fringe
to imply the goal as the output.  Interestingly, with negation, most work 
focuses on preserving operational semantics, as the well-founded semantics
are preserved for all groundings of the goal(s).  This paper focuses on
control issues surrounding the constructing of these SLDNF trees: (1)
given a goal atom A, how do we construct a tree, the local control
problem, and (2) what is the set of all goal atoms, the global control. 
The second problem only occurs because of the desire to preserve
procedural semantics.  The process of unfolding, i.e. constructing
the tree, is difficult because applying too many resolutions can 
result in local code explosion, work duplication, and non
termination.  If the unfold function is guaranteed to produce a tree 
with at most one non-failing
branch, it is said to be determinate; determine unfolding will not
produce code explosion or work duplication.  It is undecidable to determine
whether a tree with at most one non-failing branch can be constructed.
Approximations are usually used.   To deal with termination, binding-time
analysis is used (sometimes computed using abstract interpretation), which
creates annotations that have decided whether to unfold or not.  Instead of
handling termination offline, another approach handles it online--during
specialisation.  Well-founded and well-quasi orders are popular here.  
There is also a discussion of global control issues.  Interestingly,
tabling with partial deduction can turn a terminating program into
a nonterminating program.  Long reference list.
"))(POS (PAPER.TOPIC LEUSCHEL2002 "Reformulation"))(POS (PAPER.INSTANCE LEVESQUE84))(POS (PAPER.BIBTEX LEVESQUE84 CHAPTER))(POS (PAPER.AUTHOR LEVESQUE84 "Hector J. Levesque"))(POS (PAPER.TITLE LEVESQUE84 "The Logic of Incomplete Knowledge Bases"))(POS (PAPER.PUBLISHER LEVESQUE84 "Springer-Verlag"))(POS (PAPER.PUBLICATION LEVESQUE84 "On Conceptual Modelling"))(POS (PAPER.STARTPAGE LEVESQUE84 165))(POS (PAPER.ENDPAGE LEVESQUE84 189))(POS (PAPER.LINK LEVESQUE84 ""))(POS (PAPER.YEAR LEVESQUE84 1984))(POS (PAPER.RANK LEVESQUE84 "[**]"))(POS (PAPER.DESCRIPTION LEVESQUE84 "
Levesque attacks the problem of querying an incomplete knowledge base about its
incompleteness.  How else does one know how accurately the KB represents the domain
it is modeling?  If a query is not entailed, without being able to ask whether the
query itself is known to the KB, we do not know if the query is false or whether
the KB simply doesn't know.  Levesque introduces a language, KL, based on the operator
K for dealing with this problem.  In the end, he claims the interaction of a KB
with a user should be done using this  language, but that any such query can be
translated into straight-up FOL without K.
"))(POS (PAPER.TOPIC LEVESQUE84 "Logical Knowledge Representation"))(POS (PAPER.INSTANCE LEVESQUE85))(POS (PAPER.BIBTEX LEVESQUE85 INBOOK))(POS (PAPER.AUTHOR LEVESQUE85 "Hector J. Levesque and Ronald J. Brachman"))(POS (PAPER.TITLE LEVESQUE85 "A Fundamental Tradeoff in Knowledge Representation and Reasoning"))(POS (PAPER.PUBLISHER LEVESQUE85 "Morgan Kaufmann Publishers"))(POS (PAPER.PUBLICATION LEVESQUE85 "Readings in Knowledge Representation and Reasoning
           "))(POS (PAPER.LINK LEVESQUE85 "http://citeseer.ist.psu.edu/context/54197/0"))(POS (PAPER.YEAR LEVESQUE85 1985))(POS (PAPER.RANK LEVESQUE85 "[***]"))(POS (PAPER.DESCRIPTION LEVESQUE85 "
Levesque and Brachman argue that a perfect representation language does not
exist.  Rather, languages vary in expressiveness and tractability, and some
are only more interesting than others for certain uses.  The authors examine
first-order logic, databases, semantic nets, and frame systems as examples.
"))(POS (PAPER.TOPIC LEVESQUE85 "Logical Knowledge Representation"))(POS (PAPER.INSTANCE LEVESQUE86))(POS (PAPER.AUTHOR LEVESQUE86 "Hector J. Levesque"))(POS (PAPER.TITLE LEVESQUE86 "Making Believers Out of Computers"))(POS (PAPER.PUBLICATION LEVESQUE86 "Artificial Intelligence"))(POS (PAPER.VOLUME LEVESQUE86 "30(1)"))(POS (PAPER.STARTPAGE LEVESQUE86 81))(POS (PAPER.ENDPAGE LEVESQUE86 108))(POS (PAPER.YEAR LEVESQUE86 1986))(POS (PAPER.RANK LEVESQUE86 "[***]"))(POS (PAPER.DESCRIPTION LEVESQUE86 "
Levesque argues that the combinatorial explosion of exponential-time
algorithms cannot be tolerated for AI systems, except for a 'puzzle-mode'.  
To that end, he advises building knowledge bases using languages that
only allow complete ('vivid') information and using 
reasoning methods that may at times be unsound and/or incomplete.  His
examples invoke the reader's imagination to invent a pictures that model
the example descriptions.  Such descriptions can then be considered vivid.
"))(POS (PAPER.TOPIC LEVESQUE86 "Logical Knowledge Representation"))(POS (PAPER.INSTANCE LEVESQUE96))(POS (PAPER.AUTHOR LEVESQUE96 "Hector J. Levesque"))(POS (PAPER.TITLE LEVESQUE96 "What is Planning in the presence of sensing?"))(POS (PAPER.LINK LEVESQUE96 "http://www.cs.toronto.edu/cogrobo/Papers/sensing.pdf"))(POS (PAPER.YEAR LEVESQUE96 1996))(POS (PAPER.DESCRIPTION LEVESQUE96 "

Intro: Classical planning doesn't deal with the problem of sensing or looping, e.g. it cannot produce plans that will successfully achieve the Airport or the Omlette examples.  Sensing is necessary iff there are properties of the world that cannot be deduced at plan time but that are required for achieving the goal.

<br><br>Classical Planning: Use sit calc to formally define the classical planning problem.  It is unclear to me whether the sit calc he is using would somehow allow there to be partial order plans, e.g. return something like (do (parallel a b c) (do (parallel e f) (do h s0))).  For now let's say it can't and sitcalc plans must be total orders.  We might argue that because his definition is tied to sitcalc, which produces only totally ordered plans, his 'definition' of the classical planning problem is wrong.  But it doesn't really matter for the rest of what he is going to say.

Incorporating sensing actions: gives an overview of another one of his papers which introduces sensing actions into sitcalc, and reviews some related work.

<br><br>Robot programs: introduces a language for describing plans that is more expressive than the standard sitcalc (do a (do b (do .... s0)))) and partial order languages.  Includes loops and branches.  He defines the semantics of the language in situation calculus, relying on a new second order construct for defining the semantics of a loop.  Finally, he states the first theorem, which amounts to a set of rewrite rules for each of the new constructs in the robot language, where the rewrite rules allow one to construct an interpreter for the language.  That is, the obvious interpreter for the language does the right thing, and the theorem proves that.

The revised planning task: formalize, using the machinery built up above, the planning problem as it includes loops, branches, and sensing.  Remember this is all sitcalc in first-order logic + a couple second-order constructs.  The rest of the section works through the Airport example.

<br><br>Note: Importantly, all the examples thusfar, as well as the definition of the planning task requires a _deductive_ solution.  That is, the airport example includes the axiom AtGate(a) | AtGate(b).  At plan-time we can prove that the plan (seq goto-airport (if check-gate(a) then goto-gate-a else goto-gate-b)) will work.  This is unlike our room reservation example since there may be no room to reserve, but we won't know that until plan execution time.  At plan-time, there is no plan we can prove will work.

<br><br>Are robot programs enough?: They claim the original plan language is not sufficient for expressing plans for every solvable planning problem.  The reason is that there is no memory available for the program to use.  Asking for a plan that returns the number of eggs it is given at runtime cannot be achieved without (infinite) memory.  Levesque adds 5 actions (left, right, mark, erase, read_mark) that can be used to expand the plans expressible by his robot language to include (he claims) everything that is computable.  That is, his planning language with these additional actions would force a planner to construct a Turing Machine that achieves the given goal.  Of course, that problem is undecidable.  

<br><br>A two sentence summary.  Levesque introduces a plan description language that includes branching and loops (with an extension that he claims makes the language Turing complete), for the simple reason that solving some real world planning problems requires sensing and looping.  He formalizes the planning problem as one of deduction, which has the benefit that deductive solutions will always be right but has the drawback that it eliminates plans that we might expect a machine to produce, e.g. room reservation.


"))(POS (PAPER.TOPIC LEVESQUE96 "Planning with Sensing Actions"))(POS (PAPER.INSTANCE LEVESQUE97))(POS (PAPER.AUTHOR LEVESQUE97 "Levesque, et al."))(POS (PAPER.TITLE LEVESQUE97 "Golog: A Logic Programming Language for Dynamic Domains"))(POS (PAPER.LINK LEVESQUE97 "http://citeseer.ist.psu.edu/27198.html"))(POS (PAPER.YEAR LEVESQUE97 1997))(POS (PAPER.DESCRIPTION LEVESQUE97 "
Golog does macro-replacement into situation calculus from nondeterministic parameter choice, nondeterministic action choice, nondeterministic iteration, test actions, and procedures.  This macro-replacement means answer extraction cannot be used to extract a complex plan using the above constructs.  Instead, given a complex plan, the Golog interpreter produces an equivalent situation calculus plan(I think--still fuzzy here).
"))(POS (PAPER.TOPIC LEVESQUE97 "Logic Programming"))(POS (PAPER.INSTANCE LEVESQUE98))(POS (PAPER.AUTHOR LEVESQUE98 "Hector Levesque, Fiora Pirri, and Ray Reiter"))(POS (PAPER.TITLE LEVESQUE98 "Foundations for the Situation Calculus"))(POS (PAPER.PUBLICATION LEVESQUE98 "Linkoping Electronic Articles in Computer and Information Science"))(POS (PAPER.VOLUME LEVESQUE98 "3"))(POS (PAPER.LINK LEVESQUE98 "http://citeseer.ist.psu.edu/levesque98foundations.html"))(POS (PAPER.YEAR LEVESQUE98 1998))(POS (PAPER.RANK LEVESQUE98 "[***]"))(POS (PAPER.DESCRIPTION LEVESQUE98 "
This is a rehash of Pirri99, except they add in a
section describing sensing and knowledge in Situation Calculus.  They extend
their definition of a basic action theory to include knowledge-producing
actions.  Namely, a knowledge-action theory D_e = Sigma_e U D_ss U D_ap U D_una
U D_S0 U D_sf U D_k0.  Sigma_e is an expanded set of foundational axioms; D_ss
are the successor state axioms; D_ap are the action precondition axioms;
D_una are the unique name axioms for actions; D_s0 is the initial situation;
D_k0 is an initial knowldge axiom (what the agent knows in S0).  This stuff
gets pretty messy, but eventually they provide a solution to the knowledge
frame problem, i.e. "))(POS (PAPER.TOPIC LEVESQUE98 "Fundamentals"))(POS (PAPER.INSTANCE LIFSCHITZ2002))(POS (PAPER.BIBTEX LIFSCHITZ2002 ARTICLE))(POS (PAPER.AUTHOR LIFSCHITZ2002 "V. Lifschitz"))(POS (PAPER.TITLE LIFSCHITZ2002 "Answer set programming and plan generation"))(POS (PAPER.PUBLICATION LIFSCHITZ2002 "Artificial Intelligence"))(POS (PAPER.VOLUME LIFSCHITZ2002 "138(1-2)"))(POS (PAPER.STARTPAGE LIFSCHITZ2002 39))(POS (PAPER.ENDPAGE LIFSCHITZ2002 54))(POS (PAPER.LINK LIFSCHITZ2002 "http://citeseer.ist.psu.edu/301403.html"))(POS (PAPER.YEAR LIFSCHITZ2002 2002))(POS (PAPER.DESCRIPTION LIFSCHITZ2002 "
Answer set programming paper by Lifschitz.
"))(POS (PAPER.TOPIC LIFSCHITZ2002 "Logic Programming"))(POS (PAPER.INSTANCE LIFSCHITZ85))(POS (PAPER.BIBTEX LIFSCHITZ85 ARTICLE))(POS (PAPER.AUTHOR LIFSCHITZ85 "Vladimir Lifschitz"))(POS (PAPER.TITLE LIFSCHITZ85 "Closed World Databases and Circumscription"))(POS (PAPER.PUBLICATION LIFSCHITZ85 "Artificial Intelligence"))(POS (PAPER.VOLUME LIFSCHITZ85 "27(2)"))(POS (PAPER.STARTPAGE LIFSCHITZ85 229))(POS (PAPER.ENDPAGE LIFSCHITZ85 235))(POS (PAPER.YEAR LIFSCHITZ85 1985))(POS (PAPER.DESCRIPTION LIFSCHITZ85 "
Lifschitz proves the following theorem.  If CWA is consistent,
then CWA and Circumscription produce 
equivalent theories when applied to universal, closed sentences in a
function-free, equality-free vocabulary with finitely many relation and
object constants whenever the domain closure assumption and unique
names assumption are in play.
"))(POS (PAPER.TOPIC LIFSCHITZ85 "Non-monotonic Reasoning"))(POS (PAPER.INSTANCE LIFSCHITZ87))(POS (PAPER.AUTHOR LIFSCHITZ87 "V. Lifschitz"))(POS (PAPER.TITLE LIFSCHITZ87 "On the semantics of STRIPS"))(POS (PAPER.PUBLICATION LIFSCHITZ87 "Reasoning About Actions and Plans"))(POS (PAPER.STARTPAGE LIFSCHITZ87 1))(POS (PAPER.ENDPAGE LIFSCHITZ87 9))(POS (PAPER.LINK LIFSCHITZ87 "http://www.cs.utexas.edu/users/vl/papers-old.html"))(POS (PAPER.YEAR LIFSCHITZ87 1987))(POS (PAPER.DESCRIPTION LIFSCHITZ87 "
Lifschitz gives semantics to Fike's and Nilsson's STRIPS.  He gives one definition of a STRIPS system's soundness that relies on atomic sentences for both the add and delete lists (effectively).  All non-atomic sentences must be true in all worlds.  The preconditions can still be full FOL.  Lifschitz goes on to explain how to deal with peculiarities to improve efficiency, e.g. only including nextTo(a,b) when nextTo(x,y) is symmetric.
"))(POS (PAPER.TOPIC LIFSCHITZ87 "Historical"))(POS (PAPER.INSTANCE LIFSCHITZ96))(POS (PAPER.BIBTEX LIFSCHITZ96 CHAPTER))(POS (PAPER.AUTHOR LIFSCHITZ96 "Vladimir Lifschitz"))(POS (PAPER.TITLE LIFSCHITZ96 "Foundations of Logic Programming"))(POS (PAPER.PUBLICATION LIFSCHITZ96 "Principles of Knowledge Representation"))(POS (PAPER.STARTPAGE LIFSCHITZ96 69))(POS (PAPER.ENDPAGE LIFSCHITZ96 127))(POS (PAPER.LINK LIFSCHITZ96 "http://citeseer.ist.psu.edu/lifschitz96foundations.html"))(POS (PAPER.YEAR LIFSCHITZ96 1996))(POS (PAPER.DESCRIPTION LIFSCHITZ96 "
Survey of logic programming theory.
"))(POS (PAPER.TOPIC LIFSCHITZ96 "Logic Programming"))(POS (PAPER.INSTANCE LIN94))(POS (PAPER.AUTHOR LIN94 "Fangzhen Lin and Ray Reiter"))(POS (PAPER.TITLE LIN94 "How to Progress a Database (and Why) I. Logical Foundations"))(POS (PAPER.PUBLICATION LIN94 "Principles of Knowledge Representation and Reasoning "))(POS (PAPER.STARTPAGE LIN94 425))(POS (PAPER.ENDPAGE LIN94 436))(POS (PAPER.LINK LIN94 "http://citeseer.ist.psu.edu/11152.html"))(POS (PAPER.YEAR LIN94 1994))(POS (PAPER.RANK LIN94 "[****]"))(POS (PAPER.DESCRIPTION LIN94 "
Lin and Reiter argue that STRIPS (planning) can be thought of as progressing an initial database S0 with an action sequence A to a final database SA.  They prove the general problem cannot be solved using only FOL, but in fact properly needs induction.  The special cases of 'relatively complete' initial databases and 'context-free' action theories (with certain restrictions on the initial database) yield first-order theories.
"))(POS (PAPER.TOPIC LIN94 "Theories of Action"))(POS (PAPER.INSTANCE LIN95A))(POS (PAPER.AUTHOR LIN95A "Fangzhen Lin and Ray Reiter"))(POS (PAPER.TITLE LIN95A "How to Progress a Database II: The STRIPS Connection"))(POS (PAPER.PUBLICATION LIN95A "IJCAI"))(POS (PAPER.STARTPAGE LIN95A 2001))(POS (PAPER.ENDPAGE LIN95A 2009))(POS (PAPER.LINK LIN95A "http://citeseer.ist.psu.edu/lin94how.html"))(POS (PAPER.YEAR LIN95A 1995))(POS (PAPER.RANK LIN95A "[*]"))(POS (PAPER.DESCRIPTION LIN95A "
Lin and Reiter build on the first part of this paper and give certain varieties of STRIPS semantics based on progressing a database.  
"))(POS (PAPER.TOPIC LIN95A "Theories of Action"))(POS (PAPER.RELATED LIN95A LIN94))(POS (PAPER.INSTANCE LIN95B))(POS (PAPER.AUTHOR LIN95B "Fangzhen Lin and Yoav Shoham"))(POS (PAPER.TITLE LIN95B "Provably Correct Theories of Action"))(POS (PAPER.PUBLICATION LIN95B "Journal of the ACM"))(POS (PAPER.VOLUME LIN95B "42(2)"))(POS (PAPER.STARTPAGE LIN95B 293))(POS (PAPER.ENDPAGE LIN95B 320))(POS (PAPER.LINK LIN95B "http://citeseer.ist.psu.edu/lin91provably.html"))(POS (PAPER.YEAR LIN95B 1995))(POS (PAPER.RANK LIN95B "[****]"))(POS (PAPER.DESCRIPTION LIN95B "
Lin and Shoham give a formal definition for epistemologically complete theories of action.  They explain monotonic and nonmonotonic completions of action theories; the former requires frame axioms and the latter circumscription.   They go on to extend situation calculus to handle concurrent actions by bundling primitive actions together into 'global actions'.  They extend their definition for epistemological completeness to encompass this variation of sitcalc.
"))(POS (PAPER.TOPIC LIN95B "Theories of Action"))(POS (PAPER.INSTANCE LLOYD))(POS (PAPER.BIBTEX LLOYD BOOK))(POS (PAPER.AUTHOR LLOYD "John Lloyd"))(POS (PAPER.TITLE LLOYD "Foundations of Logic Programming"))(POS (PAPER.PUBLISHER LLOYD "Springer Verlag"))(POS (PAPER.LINK LLOYD "http://www.amazon.com/Foundations-Logic-Programming-Symbolic-Computation/dp/0387181997"))(POS (PAPER.YEAR LLOYD 1984))(POS (PAPER.RANK LLOYD "[*****]"))(POS (PAPER.DESCRIPTION LLOYD "
Lloyd covers the declarative and procedural semantics of logic programming without
negation and then considers the case of an acyclic logic program with negation,
and proves soundness and completeness via predicate completion.  The classic text.
"))(POS (PAPER.TOPIC LLOYD ""))(POS (PAPER.INSTANCE LLOYD84))(POS (PAPER.BIBTEX LLOYD84 ARTICLE))(POS (PAPER.AUTHOR LLOYD84 "J. Lloyd and R. Topor"))(POS (PAPER.TITLE LLOYD84 "Making Prolog more expressive"))(POS (PAPER.PUBLICATION LLOYD84 "Journal of Logic Programming"))(POS (PAPER.VOLUME LLOYD84 "1(3)"))(POS (PAPER.STARTPAGE LLOYD84 225))(POS (PAPER.ENDPAGE LLOYD84 240))(POS (PAPER.YEAR LLOYD84 1984))(POS (PAPER.DESCRIPTION LLOYD84 "
Includes the Lloyd-Topor transformation.
"))(POS (PAPER.TOPIC LLOYD84 "Logic Programming"))(POS (PAPER.INSTANCE LOBO))(POS (PAPER.BIBTEX LOBO BOOK))(POS (PAPER.AUTHOR LOBO "Jorge Lobo and Jack Minker and Arcot Rajasekar"))(POS (PAPER.TITLE LOBO "Foundations of Disjunctive Logic Programming"))(POS (PAPER.PUBLISHER LOBO "The MIT Press"))(POS (PAPER.LINK LOBO "http://mitpress.mit.edu/catalog/item/default.asp?ttype=2&tid=5834"))(POS (PAPER.YEAR LOBO 1992))(POS (PAPER.DESCRIPTION LOBO "
Book laying the foundations of disjunctive logic programming.
"))(POS (PAPER.TOPIC LOBO ""))(POS (PAPER.INSTANCE LOCHNER02))(POS (PAPER.BIBTEX LOCHNER02 ARTICLE))(POS (PAPER.AUTHOR LOCHNER02 "Bernd Loechner and Thomas Hillenbrand"))(POS (PAPER.TITLE LOCHNER02 "A phytography of Waldmeister"))(POS (PAPER.PUBLICATION LOCHNER02 "AI Communications"))(POS (PAPER.VOLUME LOCHNER02 "15"))(POS (PAPER.STARTPAGE LOCHNER02 127))(POS (PAPER.ENDPAGE LOCHNER02 133))(POS (PAPER.LINK LOCHNER02 "http://citeseer.ist.psu.edu/558093.html"))(POS (PAPER.YEAR LOCHNER02 2002))(POS (PAPER.RANK LOCHNER02 ""))(POS (PAPER.DESCRIPTION LOCHNER02 "
Waldmeister is a unit equation theorem prover based on
unfailing completion.  Its architecture is the same
Discount algorithm found in Vampire and E.  Written in C,
it uses perfect discrimination trees (a variation on the trie)
to index terms.  It also includes automated tuning of 
its parameters, based on TPTP experience.
"))(POS (PAPER.TOPIC LOCHNER02 "System Designs"))(POS (PAPER.INSTANCE LOECHNER2004))(POS (PAPER.AUTHOR LOECHNER2004 "Bernd Loechner"))(POS (PAPER.TITLE LOECHNER2004 "Things to know when implementing LPO"))(POS (PAPER.PUBLICATION LOECHNER2004 "Workshop on Empirically Successful First Ordering Reasoning"))(POS (PAPER.LINK LOECHNER2004 ""))(POS (PAPER.YEAR LOECHNER2004 2004))(POS (PAPER.DESCRIPTION LOECHNER2004 "
Loechner explains that the naive implementation of Lexicographic Path
Ordering is exponential but then goes on to show how to make it
multiplicative in the size of the two terms.  
"))(POS (PAPER.TOPIC LOECHNER2004 "Orderings"))(POS (PAPER.INSTANCE LOPEZGARCIA2004))(POS (PAPER.BIBTEX LOPEZGARCIA2004 ARTICLE))(POS (PAPER.AUTHOR LOPEZGARCIA2004 "P. Lopez-Garcia and F. Bueno and M. Hermenegildo"))(POS (PAPER.TITLE LOPEZGARCIA2004 "Determinacy Analysis for Logic Programs Using Mode and Type Information"))(POS (PAPER.PUBLICATION LOPEZGARCIA2004 "14th International Symposium, Logic Based Program Synthesis and Trnasformation (LOPSTR)"))(POS (PAPER.STARTPAGE LOPEZGARCIA2004 19))(POS (PAPER.ENDPAGE LOPEZGARCIA2004 35))(POS (PAPER.LINK LOPEZGARCIA2004 "http://wotan.liu.edu/docis/dbl/lopstr/index.html"))(POS (PAPER.YEAR LOPEZGARCIA2004 2004))(POS (PAPER.DESCRIPTION LOPEZGARCIA2004 "
In the context of Logic programming, the authors consider two problems:
(1) detecting whether a relation will ever return more than one answer
through all control paths, i.e. whether the relation is determinate,
 and (2) determining whether more than one
rule with for a relation will ever be satisfied for
the same query, i.e. whether the rules defining that relation
are mutually exclusive.  Addressing these questions relies on type
information, i.e. all the possible queries asked for a relation, and
mode information, i.e. whether a variable is used for validation or
for generation.  For r to be determinate, it is sufficient
that every relation that is a subgoal of r be mutually exclusive.
Thus an approximation of (1) can be accomplished by computing (2).  The test
for mutual exclusion offered here will return true only when all the 
rules for a relation contain procedural attachments that can be shown
to be mutually exclusive for all the types of the relation.  Experimental
results are shown for the case where the procedural attachments are
equality/distinction/inequality.
"))(POS (PAPER.TOPIC LOPEZGARCIA2004 "Reformulation"))(POS (PAPER.INSTANCE MANNA86))(POS (PAPER.AUTHOR MANNA86 "Zohar Manna"))(POS (PAPER.TITLE MANNA86 "How to Clear a Block: A Theory of Plans"))(POS (PAPER.LINK MANNA86 "http://library.stanford.edu/depts/mathcs/mathcscoll/techreports.html"))(POS (PAPER.YEAR MANNA86 1986))(POS (PAPER.DESCRIPTION MANNA86 "
This is the recursive plan paper everyone cites; not surprisingly, it shows up in the context of
program synthesis.  Manna uses Deductive Tableaux to produce programs that contain conditionals
(via a special inference rule) and recursion (using a well-founded mathematical
induction axiom).  The problem with Manna's recursion lies in the need for what he calls
Generalization, i.e. automatically strengthening the stated goal.  Manna also deals
with equality by building it into the unification algorithm.
"))(POS (PAPER.TOPIC MANNA86 "Recursive Plan Generation"))(POS (PAPER.INSTANCE MANNA94))(POS (PAPER.BIBTEX MANNA94 INBOOK))(POS (PAPER.AUTHOR MANNA94 "Zohar Manna et. al."))(POS (PAPER.TITLE MANNA94 "STeP: the Stanford Temporal Prover"))(POS (PAPER.PUBLICATION MANNA94 "TAPSOFT"))(POS (PAPER.LINK MANNA94 "http://citeseer.ist.psu.edu/manna94step.html"))(POS (PAPER.YEAR MANNA94 1994))(POS (PAPER.RANK MANNA94 "[*]"))(POS (PAPER.DESCRIPTION MANNA94 "
STeP is a verification system that proves first order temporal 
formulas valid in concurrent, reactive systems described in SPL.  
It combines equational and arithmetic simplification, model 
checking, interactive first-order theorem proving, and automatic
invariant generation.  The model checking is done through 
Streett automaton and behavior automaton.  The first-order
theorem proving is automated with non-clausal resolution
and paramodulation and utilizes lemmas.  The interactive
theorem proving is handled with a Gentzen-style prover:
both first-order and temporal first-order.  Propositional
temporal formulas can be automatically verified.
This paper is well-written and clear, but assumes knowledge
of temporal logic and transition systems.
"))(POS (PAPER.TOPIC MANNA94 "Model Checking"))(POS (PAPER.INSTANCE MANTHEY88))(POS (PAPER.BIBTEX MANTHEY88 INPROCEEDINGS))(POS (PAPER.AUTHOR MANTHEY88 "Rainer Manthey and Francois Bry"))(POS (PAPER.TITLE MANTHEY88 "SATCHMO: A Theorem Prover Implemented in Prolog"))(POS (PAPER.PUBLICATION MANTHEY88 "Proceedings of the Conference on Automated Deduction"))(POS (PAPER.STARTPAGE MANTHEY88 415))(POS (PAPER.ENDPAGE MANTHEY88 434))(POS (PAPER.YEAR MANTHEY88 1988))(POS (PAPER.DESCRIPTION MANTHEY88 "
Tableaux-style prover implemented in Prolog, using assert and retract.
"))(POS (PAPER.TOPIC MANTHEY88 "Calculi"))(POS (PAPER.INSTANCE MARRAFA91))(POS (PAPER.BIBTEX MARRAFA91 ARTICLE))(POS (PAPER.AUTHOR MARRAFA91 "Palmira Marrafa and Patrick Saint-Dizier"))(POS (PAPER.TITLE MARRAFA91 "Reversibility in a Constraint and Type based Logic Grammar"))(POS (PAPER.LINK MARRAFA91 "http://acl.ldc.upenn.edu/W/W91/W91-0102.pdf"))(POS (PAPER.YEAR MARRAFA91 1991))(POS (PAPER.RANK MARRAFA91 "[***]"))(POS (PAPER.DESCRIPTION MARRAFA91 "
In the topic of reversible grammars.
Marrafa and Saint-Dizier introduce a mathematical language for 
describing natural languages.  The mathematical language includes certain
object-oriented concepts. In addition, abstract machines for parsing and
generating languages so described are given.
"))(POS (PAPER.TOPIC MARRAFA91 "Natural Language Processing"))(POS (PAPER.INSTANCE MASTERS2003))(POS (PAPER.BIBTEX MASTERS2003 ARTICLE))(POS (PAPER.AUTHOR MASTERS2003 "James Masters and Zelai Gungordu"))(POS (PAPER.TITLE MASTERS2003 "Semantic Knowledge Source Integration: A Progress Report"))(POS (PAPER.PUBLICATION MASTERS2003 "Integration of Knowledge Intensive Multi-Agent Systems"))(POS (PAPER.YEAR MASTERS2003 2003))(POS (PAPER.RANK MASTERS2003 ""))(POS (PAPER.DESCRIPTION MASTERS2003 "
Paper on using a database to speed up theorem proving.  Here they want togive a TP access to the information contained in several databases.
"))(POS (PAPER.TOPIC MASTERS2003 "Theorem Proving with Attachments"))(POS (PAPER.INSTANCE MATZINGER97))(POS (PAPER.BIBTEX MATZINGER97 TECHREPORT))(POS (PAPER.AUTHOR MATZINGER97 "Robert Matzinger"))(POS (PAPER.TITLE MATZINGER97 "Comparing Computational Representations of Herbrand Models"))(POS (PAPER.LINK MATZINGER97 "http://www.kr.tuwien.ac.at/guests/matzi/publications.html"))(POS (PAPER.YEAR MATZINGER97 1997))(POS (PAPER.RANK MATZINGER97 "[*****]"))(POS (PAPER.DESCRIPTION MATZINGER97 "
Matzinger investigates various representations of models and
answers three complexity questions for each representation:
ground atom entailment, clause entailment, model equivalence.
The two representations of finite models examined are
context-free grammers and atom representations.  Both CFGs
and ground atoms plus ground equations are equivalent
to finite models, i.e. both representations have an associated
finite model and every finite model has a submodel that
is equivalent to both representations.
Different subsets of all infinite models can be represented by 
term schematizations and constrained atoms.  They seem to be
incomparable.  This paper is pretty dense, but also very important.
"))(POS (PAPER.TOPIC MATZINGER97 "Model-Based Reasoning"))(POS (PAPER.INSTANCE MCCARTHY59))(POS (PAPER.AUTHOR MCCARTHY59 "John McCarthy"))(POS (PAPER.TITLE MCCARTHY59 "Programs with Common Sense"))(POS (PAPER.PUBLICATION MCCARTHY59 "Proceedings of the Teddington Conference on the
                Mechanization of Thought Processes"))(POS (PAPER.STARTPAGE MCCARTHY59 77))(POS (PAPER.ENDPAGE MCCARTHY59 81))(POS (PAPER.LINK MCCARTHY59 "http://www-formal.stanford.edu/jmc/mcc59.html"))(POS (PAPER.YEAR MCCARTHY59 1958))(POS (PAPER.RANK MCCARTHY59 "[*****]"))(POS (PAPER.DESCRIPTION MCCARTHY59 "
Most likely the first paper on logical AI, i.e. the advice taker paper.
It describes a system(the advice taker) that can be told sentences in logic
and can draw conclusions about the world from its knowledge base.
"))(POS (PAPER.TOPIC MCCARTHY59 "Logical Knowledge Representation"))(POS (PAPER.INSTANCE MCCARTHY80))(POS (PAPER.BIBTEX MCCARTHY80 ARTICLE))(POS (PAPER.AUTHOR MCCARTHY80 "John McCarthy"))(POS (PAPER.TITLE MCCARTHY80 "Circumscription -- a form of non-monotonic reasoning"))(POS (PAPER.PUBLICATION MCCARTHY80 "Artificial Intelligence"))(POS (PAPER.VOLUME MCCARTHY80 "13"))(POS (PAPER.STARTPAGE MCCARTHY80 27))(POS (PAPER.ENDPAGE MCCARTHY80 39))(POS (PAPER.YEAR MCCARTHY80 1988))(POS (PAPER.DESCRIPTION MCCARTHY80 "
Circumscription.
"))(POS (PAPER.TOPIC MCCARTHY80 "Non-monotonic Reasoning"))(POS (PAPER.INSTANCE MCCARTHY82))(POS (PAPER.BIBTEX MCCARTHY82 TECHREPORT))(POS (PAPER.AUTHOR MCCARTHY82 "John McCarthy"))(POS (PAPER.TITLE MCCARTHY82 "Coloring Maps and the Kowalski Doctrine"))(POS (PAPER.PUBLISHER MCCARTHY82 "Stanford University"))(POS (PAPER.YEAR MCCARTHY82 1982))(POS (PAPER.DESCRIPTION MCCARTHY82 "
Paper that analyzes various formulations of the map coloring problem
written in Prolog.  Looks at various reorderings of subgoals.
"))(POS (PAPER.TOPIC MCCARTHY82 "Logic Programming"))(POS (PAPER.INSTANCE MCCHAY69))(POS (PAPER.AUTHOR MCCHAY69 "John McCarthy and Patrick J. Hayes"))(POS (PAPER.TITLE MCCHAY69 "Some Philosophical Problems from the Standpoint of Artificial Intelligence"))(POS (PAPER.PUBLICATION MCCHAY69 "Machine Intelligence 4"))(POS (PAPER.STARTPAGE MCCHAY69 463))(POS (PAPER.ENDPAGE MCCHAY69 502))(POS (PAPER.LINK MCCHAY69 "http://www-formal.stanford.edu/jmc/mcchay69.html"))(POS (PAPER.YEAR MCCHAY69 1969))(POS (PAPER.DESCRIPTION MCCHAY69 "
The basic situation calculus paper.  McCarthy and Hayes consider not only the classic planning environment (fully-observable), but also a partially-observable one, introducing what are now referred to as 'sensing actions'.  They attempt a self-proclaimed ad-hoc approach to handling these sensing actions.  They also point out the frame problem, alluding to a state vector as a possible solution.  The qualification problem (though they don't name it that) shows up here, along with the introduction of the modal operators consistent(phi), probably(phi), and normally(phi) as a tentative solution avenue.  Finally, McCarthy and Hayes look into embedding Modal Logic, Logic of Knowledge (Hintikka), Tense Logics, and a couple of others into situation calculus.
"))(POS (PAPER.TOPIC MCCHAY69 "Historical"))(POS (PAPER.INSTANCE MCCUNE2001))(POS (PAPER.BIBTEX MCCUNE2001 MISC))(POS (PAPER.AUTHOR MCCUNE2001 "William McCune"))(POS (PAPER.TITLE MCCUNE2001 "Mace 2.0 Reference Manual and Guide"))(POS (PAPER.LINK MCCUNE2001 "http://citeseer.ist.psu.edu/464179.html"))(POS (PAPER.YEAR MCCUNE2001 2001))(POS (PAPER.DESCRIPTION MCCUNE2001 "
Manual for Mace 2.0, a finite model builder that grounds out formulas
and relies on a SAT solver.
"))(POS (PAPER.TOPIC MCCUNE2001 "Model Building"))(POS (PAPER.INSTANCE MCCUNE2003))(POS (PAPER.BIBTEX MCCUNE2003 TECHREPORT))(POS (PAPER.AUTHOR MCCUNE2003 "William McCune"))(POS (PAPER.TITLE MCCUNE2003 "Mace4 Reference Manual and Guide"))(POS (PAPER.PUBLISHER MCCUNE2003 "Argonne National Laboratory"))(POS (PAPER.LINK MCCUNE2003 "http://www-unix.mcs.anl.gov/AR/mace4/July-2005/doc/mace4.pdf"))(POS (PAPER.YEAR MCCUNE2003 2003))(POS (PAPER.DESCRIPTION MCCUNE2003 "
The reference manual for Mace4.  Unlike its predecessors, which flattened
formulas, ground them, and used a SAT solver, Mace4 incrementally constructs
a model and after each instantiation computes the consequences of the
instantiation wrt the sentences of interest.
"))(POS (PAPER.TOPIC MCCUNE2003 "Model Building"))(POS (PAPER.INSTANCE MCDONALD91))(POS (PAPER.BIBTEX MCDONALD91 ARTICLE))(POS (PAPER.AUTHOR MCDONALD91 "D. McDonald"))(POS (PAPER.TITLE MCDONALD91 "Reversible NLP by Deriving the Grammars from the Knowledge Base"))(POS (PAPER.LINK MCDONALD91 "http://acl.ldc.upenn.edu/W/W91/W91-0106.pdf"))(POS (PAPER.YEAR MCDONALD91 1991))(POS (PAPER.RANK MCDONALD91 "[***]"))(POS (PAPER.DESCRIPTION MCDONALD91 "
Reversible grammars.
McDonald presents an architecture for constructing a parsing grammar and
an acceptance grammar from a single knowledge base and semantic model.  Thus
the strongest techniques for both parsing and generation can be used without
losing the simplicity of maintenance derived from  using a single, 
reversible grammar.
"))(POS (PAPER.TOPIC MCDONALD91 "Natural Language Processing"))(POS (PAPER.INSTANCE MCILRAITH98))(POS (PAPER.BIBTEX MCILRAITH98 ARTICLE))(POS (PAPER.AUTHOR MCILRAITH98 "Sheila McIlraith"))(POS (PAPER.TITLE MCILRAITH98 "Logic-based Abductive Inference"))(POS (PAPER.PUBLICATION MCILRAITH98 "Knowledge Systems Lab Technical Report KSL98-19"))(POS (PAPER.LINK MCILRAITH98 "http://citeseer.ist.psu.edu/mcilraith98logicbased.html"))(POS (PAPER.YEAR MCILRAITH98 1998))(POS (PAPER.DESCRIPTION MCILRAITH98 "
McIlraith covers various ways to operationalize abduction, i.e. finding
an augmentation to a logical knowledge base such that a given query
is entailed. 
"))(POS (PAPER.TOPIC MCILRAITH98 "Abduction"))(POS (PAPER.INSTANCE MCKENZIE97))(POS (PAPER.BIBTEX MCKENZIE97 TECHREPORT))(POS (PAPER.AUTHOR MCKENZIE97 "Bruce McKenzie"))(POS (PAPER.TITLE MCKENZIE97 "Generating Strings at Random from a Context Free Grammar"))(POS (PAPER.LINK MCKENZIE97 "http://coscweb2.cosc.canterbury.ac.nz/research/reports/TechReps/#year1997"))(POS (PAPER.YEAR MCKENZIE97 1997))(POS (PAPER.RANK MCKENZIE97 "[***]"))(POS (PAPER.DESCRIPTION MCKENZIE97 "
McKenzie gives an algorithm for generating strings of length n from a CFG 
so that all strings of length n are equally likely.  The preprocessing
portion of the algorithm requires O(n^2) time and O(n^2) space.  The
generation portion requires O(n) time and space.
"))(POS (PAPER.TOPIC MCKENZIE97 "Context Free Grammars"))(POS (PAPER.INSTANCE MENG20067))(POS (PAPER.AUTHOR MENG20067 "Jia Meng and L.C. Paulson"))(POS (PAPER.TITLE MENG20067 "Lightweight Relevance Filtering for Machine-Generated Resolution Problems"))(POS (PAPER.PUBLICATION MENG20067 "ESCoR: Empirically Successful Computerized Reasoning"))(POS (PAPER.LINK MENG20067 "http://www.cl.cam.ac.uk/~lp15/papers/frameset.html"))(POS (PAPER.YEAR MENG20067 2006))(POS (PAPER.DESCRIPTION MENG20067 "
The authors argue for the case that large axiom sets are the norm when
an entailment query is constructed by a machine; moreover, it is often the
case that only a small fraction of those axioms are relevant to the query
at hand, and thus determining which clauses are relevant is a good first
step toward solving the problem.  The criteria for relevance they use
is based on the presence of function symbols in the clauses.
"))(POS (PAPER.TOPIC MENG20067 "Transformations"))(POS (PAPER.INSTANCE MERZ2001))(POS (PAPER.BIBTEX MERZ2001 INBOOK))(POS (PAPER.AUTHOR MERZ2001 "Stephan Merz"))(POS (PAPER.TITLE MERZ2001 "Model Checking: A Tutorial Overview"))(POS (PAPER.PUBLISHER MERZ2001 "Springer-Verlag"))(POS (PAPER.PUBLICATION MERZ2001 "Modeling and Verification of Parallel Processes"))(POS (PAPER.VOLUME MERZ2001 "2067"))(POS (PAPER.STARTPAGE MERZ2001 3))(POS (PAPER.ENDPAGE MERZ2001 38))(POS (PAPER.LINK MERZ2001 "http://www.loria.fr/~merz/papers/mc-tutorial.html"))(POS (PAPER.YEAR MERZ2001 2001))(POS (PAPER.RANK MERZ2001 "[****]"))(POS (PAPER.DESCRIPTION MERZ2001 "
The model checking problem is to determine if a sentence s is entailed
by a model M.  It is mainly used to analyze reactive systems, i.e. systems
that continually interact with their environment.  These systems are usually
modelled with a Kripke structure or an omega(Buchi)-Automaton.  The sentence s 
is usually written in Propositional Temporal Logic (PTL) (which allows only
universal statements), Computation Tree Logic (CTL) (which allows 
universal and existential statements), CTL*, or propositional mu-calculus.
PTL and CTL are not comparable (neither is more expressive than the other).
CTL* is strictly more expressive than CTL and PTL, and propositional
mu-calculus subsumes CTL*.  Model checking algorithms can either be local
(PTL), global (CTL), or symbolic.  Symbolic formulas can be represented
with ordered binary decision diagrams.
"))(POS (PAPER.TOPIC MERZ2001 "Model Checking"))(POS (PAPER.INSTANCE MILLER94))(POS (PAPER.AUTHOR MILLER94 "Rob Miller and Muray Shanahan"))(POS (PAPER.TITLE MILLER94 "Narratives in the Situation Calculus"))(POS (PAPER.PUBLICATION MILLER94 "Journal of Logic and Computation"))(POS (PAPER.VOLUME MILLER94 "4(5)"))(POS (PAPER.STARTPAGE MILLER94 513))(POS (PAPER.ENDPAGE MILLER94 530))(POS (PAPER.LINK MILLER94 "http://citeseer.ist.psu.edu/miller94narratives.html"))(POS (PAPER.YEAR MILLER94 1994))(POS (PAPER.RANK MILLER94 "[*]"))(POS (PAPER.DESCRIPTION MILLER94 "
Miller and Shanahan take a first crack at embedding narratives in the Situation calculus.  They use a new sort for times, define Happens(action, time), and define Duration(action).  Using these, they can represent narratives, noninstantaneous actions, and overlapping actions.   Miller and Shanahan rely heavily on circumscription.  
"))(POS (PAPER.TOPIC MILLER94 "Behavioral Goals"))(POS (PAPER.INSTANCE MITTAL90))(POS (PAPER.BIBTEX MITTAL90 ARTICLE))(POS (PAPER.AUTHOR MITTAL90 "Sanjay Mittal and Brian Falkenhainer"))(POS (PAPER.TITLE MITTAL90 "Dynamic Constraint Satisfaction Problems "))(POS (PAPER.PUBLICATION MITTAL90 "AAAI 90 "))(POS (PAPER.STARTPAGE MITTAL90 25))(POS (PAPER.ENDPAGE MITTAL90 32))(POS (PAPER.YEAR MITTAL90 1990))(POS (PAPER.RANK MITTAL90 "[****]"))(POS (PAPER.DESCRIPTION MITTAL90 "
Mittal and Falkenhainer describe a version of CSPs where the 
number of variables is partially determined by the values of other
variables.  To accomplish this they provide a constraint language that
can express conditions under which variables must be assigned values
and conditions under which variables need not be assigned values.  For 
every variable vi there is a propositional constant active:vi.  If 
active:vi must hold given the values of other variables, vi must
be assigned a value.  If ~active:vi must hold, vi need not be assigned
a value.  It is unclear what happens if neither active:vi nor ~active:vi 
holds.  They use an assumption-based truth maintenance system to build
a Dynamic CSP solver. 
"))(POS (PAPER.TOPIC MITTAL90 "Various Forms of Constraint Satisfaction"))(POS (PAPER.INSTANCE MOORE77))(POS (PAPER.AUTHOR MOORE77 "Robert C. Moore"))(POS (PAPER.TITLE MOORE77 "Reasoning about knowledge and action"))(POS (PAPER.PUBLICATION MOORE77 "Proceedings of the 5th International Joint
Conference on Artificial Intelligence (IJCAI-77, MIT)"))(POS (PAPER.STARTPAGE MOORE77 223))(POS (PAPER.ENDPAGE MOORE77 227))(POS (PAPER.YEAR MOORE77 1977))(POS (PAPER.DESCRIPTION MOORE77 "
Moore contributes the following formalization (after a little tweaking):
1. T(p, s): p is true in world s.
2. K(Agent, s, s'): Given what Agent knows in s, s' would be another possible world.
3. As,a,p.(True(Know(a, p), s) =def= As'.(K(a, s, s') => T(p, s')): "))(POS (PAPER.TOPIC MOORE77 "Planning with Sensing Actions"))(POS (PAPER.INSTANCE MOORE82))(POS (PAPER.BIBTEX MOORE82 ARTICLE))(POS (PAPER.AUTHOR MOORE82 "Robert C. Moore"))(POS (PAPER.TITLE MOORE82 "The Role of Logic in Knowledge Representation and Commonsense Reasoning"))(POS (PAPER.PUBLICATION MOORE82 "AAAI 82"))(POS (PAPER.LINK MOORE82 ""))(POS (PAPER.YEAR MOORE82 1982))(POS (PAPER.RANK MOORE82 "[**]"))(POS (PAPER.DESCRIPTION MOORE82 "
Moore tries to convince AI researchers that logic can be a useful method for reasoning and not just the analysis of systems.  He points out that some of the early experiments that supposedly showed logical reasoning too inefficient only showed that a particular method of inference and control were too inefficient to be used for every reasoning task.
"))(POS (PAPER.TOPIC MOORE82 "Logical Knowledge Representation"))(POS (PAPER.INSTANCE MOSES96))(POS (PAPER.BIBTEX MOSES96 ARTICLE))(POS (PAPER.AUTHOR MOSES96 "Yoram Moses and Moshe Tennenholtz"))(POS (PAPER.TITLE MOSES96 "Off-line reasoning for on-line efficiency: knowledge bases"))(POS (PAPER.PUBLICATION MOSES96 "Artificial Intelligence"))(POS (PAPER.VOLUME MOSES96 "83(2)"))(POS (PAPER.STARTPAGE MOSES96 229))(POS (PAPER.ENDPAGE MOSES96 239))(POS (PAPER.LINK MOSES96 "http://citeseer.ist.psu.edu/moses96offline.html"))(POS (PAPER.YEAR MOSES96 1996))(POS (PAPER.RANK MOSES96 "[***]"))(POS (PAPER.DESCRIPTION MOSES96 "
Moses and Tennenholtz give conditions under which compiling a KB is
worthwhile.  The results given focus almost entirely on propositional
logic.  If a KB has a basis under which all queries
can be computed via conjunctions of the basis, compilation is a good
idea if the basis can be computed in polynomial time.  The process
of compilation essentially stores all the elements of the basis
in a binary tree.  Thus, any query can be answered in (log n)*|query|.
"))(POS (PAPER.TOPIC MOSES96 "Knowledge Base Compilation"))(POS (PAPER.INSTANCE MOSKEWICZ2001))(POS (PAPER.BIBTEX MOSKEWICZ2001 ARTICLE))(POS (PAPER.AUTHOR MOSKEWICZ2001 "Matthew Moskewicz and Conor Madigan and Ying Zhao and Lintao Zhang and Sharad Malik"))(POS (PAPER.TITLE MOSKEWICZ2001 "Chaff: Engineering an Efficient SAT Solver"))(POS (PAPER.PUBLICATION MOSKEWICZ2001 "39th Design Automation Conference"))(POS (PAPER.LINK MOSKEWICZ2001 "http://citeseer.csail.mit.edu/moskewicz01chaff.html"))(POS (PAPER.YEAR MOSKEWICZ2001 2001))(POS (PAPER.DESCRIPTION MOSKEWICZ2001 "
The authors give an overview of DPLL and how it is implemented in Chaff.
Nice read.
"))(POS (PAPER.TOPIC MOSKEWICZ2001 "Solvers"))(POS (PAPER.INSTANCE MOTIK2007BRIDGING))(POS (PAPER.BIBTEX MOTIK2007BRIDGING INPROCEEDINGS))(POS (PAPER.AUTHOR MOTIK2007BRIDGING "Boris Motik and Ian Horrocks and Ulrike Sattler"))(POS (PAPER.TITLE MOTIK2007BRIDGING "Bridging the Gap Between OWL and Relational Databases"))(POS (PAPER.PUBLICATION MOTIK2007BRIDGING "Proceedings of the 16th Conference on the World Wide Web "))(POS (PAPER.LINK MOTIK2007BRIDGING ""))(POS (PAPER.YEAR MOTIK2007BRIDGING 2007))(POS (PAPER.DESCRIPTION MOTIK2007BRIDGING "
The paper attempts to implement integrity constraints as defined in the 
database literature into OWL.
"))(POS (PAPER.TOPIC MOTIK2007BRIDGING "Semantic Web"))(POS (PAPER.INSTANCE MOTIK2007FAITHFUL))(POS (PAPER.BIBTEX MOTIK2007FAITHFUL INPROCEEDINGS))(POS (PAPER.AUTHOR MOTIK2007FAITHFUL "Boris Motik and Riccardo Rosati"))(POS (PAPER.TITLE MOTIK2007FAITHFUL "A Faithful Integration of Description Logics with Logic Programming"))(POS (PAPER.PUBLICATION MOTIK2007FAITHFUL "Proceedings of International Joint Conference on Artificial Intelligence"))(POS (PAPER.LINK MOTIK2007FAITHFUL ""))(POS (PAPER.YEAR MOTIK2007FAITHFUL 2007))(POS (PAPER.DESCRIPTION MOTIK2007FAITHFUL "
The paper introduces hybrid MKNF knowledge bases, a formalism that integrates
logic programming and description logics, which reduces to LP semantics
when the DL portion is empty and to DL semantics when the LP portion is empty.
Also gives complexity results for certain classes of the logic.
"))(POS (PAPER.TOPIC MOTIK2007FAITHFUL "Semantic Web"))(POS (PAPER.INSTANCE MOTTA91))(POS (PAPER.BIBTEX MOTTA91 ARTICLE))(POS (PAPER.AUTHOR MOTTA91 "Enrico Motta and Arthur Stutt"))(POS (PAPER.TITLE MOTTA91 "An Architecture for the Integration of Heterogenous Inference Systems"))(POS (PAPER.PUBLICATION MOTTA91 "Open University Technical Report"))(POS (PAPER.LINK MOTTA91 "http://citeseer.ist.psu.edu/motta91architecture.html"))(POS (PAPER.YEAR MOTTA91 1991))(POS (PAPER.RANK MOTTA91 "[*]"))(POS (PAPER.DESCRIPTION MOTTA91 "
The authors describe an architecture for integrating specialized reasoners
where each reasoner is known to handle a particular vocabulary.
"))(POS (PAPER.TOPIC MOTTA91 "Architectures"))(POS (PAPER.INSTANCE MUHAMMED2006))(POS (PAPER.BIBTEX MUHAMMED2006 INPROCEEDINGS))(POS (PAPER.AUTHOR MUHAMMED2006 "R. Muhammed and P.J. Stuckey"))(POS (PAPER.TITLE MUHAMMED2006 "A stochastic Non-CNF SAT Solver"))(POS (PAPER.PUBLICATION MUHAMMED2006 "In Proceedings 9th Biennial Pacific Rim International Conference on Artificial Intelligence"))(POS (PAPER.STARTPAGE MUHAMMED2006 120))(POS (PAPER.ENDPAGE MUHAMMED2006 129))(POS (PAPER.LINK MUHAMMED2006 "http://www.cs.mu.oz.au/~pjs/papers.html"))(POS (PAPER.YEAR MUHAMMED2006 2006))(POS (PAPER.DESCRIPTION MUHAMMED2006 "
Paper on a stochastic SAT solver whose input is allowed to be 
in something other than CNF.
"))(POS (PAPER.TOPIC MUHAMMED2006 "SAT Solving"))(POS (PAPER.INSTANCE MYERS90))(POS (PAPER.BIBTEX MYERS90 INPROCEEDINGS))(POS (PAPER.AUTHOR MYERS90 "Karen Myers"))(POS (PAPER.TITLE MYERS90 "Automatically Generating Universal Attachments through Compilation"))(POS (PAPER.PUBLICATION MYERS90 "AAAI"))(POS (PAPER.LINK MYERS90 "http://www.ai.sri.com/~myers/"))(POS (PAPER.YEAR MYERS90 1990))(POS (PAPER.RANK MYERS90 "[**]"))(POS (PAPER.DESCRIPTION MYERS90 "
Myers describes a method for generating new universal attachments.
"))(POS (PAPER.TOPIC MYERS90 "Theorem Proving with Attachments"))(POS (PAPER.INSTANCE MYERS90T))(POS (PAPER.BIBTEX MYERS90T PHDTHESIS))(POS (PAPER.AUTHOR MYERS90T "Karen Myers"))(POS (PAPER.TITLE MYERS90T "Universal Attachments: A Logical Framework for Hybrid Reasoning"))(POS (PAPER.PUBLISHER MYERS90T "Stanford University"))(POS (PAPER.LINK MYERS90T "http://library.stanford.edu/depts/mathcs/mathcscoll/techreports.html"))(POS (PAPER.YEAR MYERS90T 1990))(POS (PAPER.RANK MYERS90T "[***]"))(POS (PAPER.DESCRIPTION MYERS90T "
"))(POS (PAPER.TOPIC MYERS90T "Theorem Proving with Attachments"))(POS (PAPER.INSTANCE NAREYEK99))(POS (PAPER.BIBTEX NAREYEK99 ARTICLE))(POS (PAPER.AUTHOR NAREYEK99 "Alexander Nareyek"))(POS (PAPER.TITLE NAREYEK99 "Structural Constraint Satisfaction"))(POS (PAPER.PUBLICATION NAREYEK99 "AAAI Workshop on Configurations"))(POS (PAPER.STARTPAGE NAREYEK99 76))(POS (PAPER.ENDPAGE NAREYEK99 82))(POS (PAPER.LINK NAREYEK99 "http://citeseer.ist.psu.edu/nareyek99structural.html"))(POS (PAPER.YEAR NAREYEK99 1999))(POS (PAPER.RANK NAREYEK99 "[***]"))(POS (PAPER.DESCRIPTION NAREYEK99 "
It is a little hard to follow what's happening here.  Nareyek seems
to be introducing generalization of CSPs where in addition to constraints
on tuples of variables, there are constraints on the structure of those
constraints.  These meta constraints are implemented via Graph Grammars.
Narayek states that solving these problems is undecidable, but gives
no proof.
"))(POS (PAPER.TOPIC NAREYEK99 "Various Forms of Constraint Satisfaction"))(POS (PAPER.INSTANCE NAYAK95))(POS (PAPER.BIBTEX NAYAK95 PROCEEDINGS))(POS (PAPER.AUTHOR NAYAK95 "P. Nayak and Alon Levy"))(POS (PAPER.TITLE NAYAK95 "A Semantic Theory of Abstractions"))(POS (PAPER.PUBLICATION NAYAK95 "IJCAI"))(POS (PAPER.LINK NAYAK95 "http://citeseer.ist.psu.edu/nayak94semantic.html"))(POS (PAPER.YEAR NAYAK95 1995))(POS (PAPER.RANK NAYAK95 "[***]"))(POS (PAPER.DESCRIPTION NAYAK95 "
Nayak and Levy explain a new approach to producing abstractions of
axioms.  Instead of simply mapping axioms to axioms as is done in
previous work, first abstract the axioms to an intended domain
model, and then find sentences that capture that model.  The
theoretical component of this paper, which accounts for the
majority of it, is very clean.  It gives model-theoretic
explainations for good (allowing no 'false proofs') and bad
(allowing 'false proofs') abstractions.
"))(POS (PAPER.TOPIC NAYAK95 "Abstraction"))(POS (PAPER.INSTANCE NELSON79))(POS (PAPER.BIBTEX NELSON79 INPROCEEDINGS))(POS (PAPER.AUTHOR NELSON79 "Greg Nelson and Derek Oppen"))(POS (PAPER.TITLE NELSON79 "Simplification by Cooperating Decision Procedures"))(POS (PAPER.PUBLICATION NELSON79 "ACM Transactions on Programming Languages and Systems
           "))(POS (PAPER.VOLUME NELSON79 "1(2)"))(POS (PAPER.STARTPAGE NELSON79 245))(POS (PAPER.ENDPAGE NELSON79 257))(POS (PAPER.LINK NELSON79 ""))(POS (PAPER.YEAR NELSON79 1979))(POS (PAPER.RANK NELSON79 "[****]"))(POS (PAPER.DESCRIPTION NELSON79 "
Nelson and Oppen describe a method for combining decision procedures
for disjoint equational theories.
To determine the satisfiability of a set of quantifier-free formulas,
partition based on the theory to which the vocabulary belongs.  If 
a term from one theory is embedded in a relation from another theory,
introduce a new variable, replace the term with that variable, and include
the sentence where that variable is set to the term in the appropriate
partition.  If any of the partitions are unsatisfiable, the entire thing
is unsatisfiable.  Otherwise, compute all the strongest equality theorems
including only variables for each of the partitions and pass to all the 
other partitions.  If the theory is nonconvex, case analysis is
necessary.
Check for unsatisfiability and repeat.  Nelson and Oppen prove correctness
and termination.
"))(POS (PAPER.TOPIC NELSON79 "Nelson-Oppen and Shostak"))(POS (PAPER.INSTANCE NEWELL63))(POS (PAPER.AUTHOR NEWELL63 "Allen Newell and H.A. Simon"))(POS (PAPER.TITLE NEWELL63 "GPS, A Program that Simulates Human Thought"))(POS (PAPER.PUBLICATION NEWELL63 "Computers and Thought, Feigenbaum and Feldman (eds.)"))(POS (PAPER.STARTPAGE NEWELL63 279))(POS (PAPER.ENDPAGE NEWELL63 293))(POS (PAPER.YEAR NEWELL63 1963))(POS (PAPER.DESCRIPTION NEWELL63 "
Description of probably the first planner. Newell et. al. compare an inexperienced student doing a logic proof to how GPS solves the same problem.  GPS takes a goal and can perform any of four operations: transform object A into object B (unification?), reduce the difference D between object A and object B (satisfaction of a subgoal of A?), and apply operator Q to object A (reduction of A to subgoals?).
"))(POS (PAPER.TOPIC NEWELL63 "Historical"))(POS (PAPER.INSTANCE NIEUWENHUIS2003))(POS (PAPER.AUTHOR NIEUWENHUIS2003 "Robert Nieuwenhuis and Thomas Hillenbrand and Alexandre Riazanov and Andrei Voronkov"))(POS (PAPER.TITLE NIEUWENHUIS2003 "On the Evaluation of Indexing Techniques for Theorem Proving"))(POS (PAPER.LINK NIEUWENHUIS2003 "http://citeseer.ist.psu.edu/nieuwenhuis03evaluation.html"))(POS (PAPER.YEAR NIEUWENHUIS2003 2003))(POS (PAPER.DESCRIPTION NIEUWENHUIS2003 "
Nieuwenhuis, et. al. describe a methodology for comparing indexing schemes.
To demonstrate it, they compare Waldmeister's discrimination trees,
Context trees, and Vampire's code trees for term indexing.  The scenario tested
involved both additions and deletions from the index and queries where
only one answer need be reported (e.g. for forward subsumption).  They
reported both space and time results.
"))(POS (PAPER.TOPIC NIEUWENHUIS2003 "Indexing"))(POS (PAPER.INSTANCE NILES2001))(POS (PAPER.BIBTEX NILES2001 INPROCEEDINGS))(POS (PAPER.AUTHOR NILES2001 "Ian Niles and Adam Pease"))(POS (PAPER.TITLE NILES2001 "Formal Ontology in Information Systems"))(POS (PAPER.PUBLICATION NILES2001 "Proceedings of the International Conference on Formal Ontology in Information Systems"))(POS (PAPER.STARTPAGE NILES2001 2))(POS (PAPER.ENDPAGE NILES2001 9))(POS (PAPER.LINK NILES2001 "http://portal.acm.org/citation.cfm?id=505170"))(POS (PAPER.YEAR NILES2001 2001))(POS (PAPER.DESCRIPTION NILES2001 "
Primary paper on SUMO, the Suggested Upper Merged Ontology.
"))(POS (PAPER.TOPIC NILES2001 "Logical Knowledge Representation"))(POS (PAPER.INSTANCE ORMAN98))(POS (PAPER.BIBTEX ORMAN98 ARTICLE))(POS (PAPER.AUTHOR ORMAN98 "Levent Orman"))(POS (PAPER.TITLE ORMAN98 "Differential Relational Calculus for Integrity Maintenance"))(POS (PAPER.PUBLICATION ORMAN98 "IEEE Transactions of Knowledge and Data Engineering"))(POS (PAPER.VOLUME ORMAN98 "10(2)"))(POS (PAPER.STARTPAGE ORMAN98 328))(POS (PAPER.ENDPAGE ORMAN98 341))(POS (PAPER.LINK ORMAN98 "http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=683760&isnumber=15039"))(POS (PAPER.YEAR ORMAN98 1998))(POS (PAPER.RANK ORMAN98 "[****]"))(POS (PAPER.DESCRIPTION ORMAN98 "
Orman defines differential relational calculus.  Given a 
database constraint V such that V is true if and only if there is an integrity
constraint violation and a transaction T, what are the necessary and
sufficient conditions for computing whether there is would be an integrity
violation after execution T, assuming there was no violation to start with?
"))(POS (PAPER.TOPIC ORMAN98 "Databases"))(POS (PAPER.INSTANCE OWRE96))(POS (PAPER.BIBTEX OWRE96 INPROCEEDINGS))(POS (PAPER.AUTHOR OWRE96 "S. Owre et. al."))(POS (PAPER.TITLE OWRE96 "PVS: Combining Specification, Proof Checking, and Model Checking"))(POS (PAPER.PUBLICATION OWRE96 "Computer Aided Verification"))(POS (PAPER.STARTPAGE OWRE96 411))(POS (PAPER.ENDPAGE OWRE96 414))(POS (PAPER.LINK OWRE96 "http://citeseer.ist.psu.edu/246180.html"))(POS (PAPER.YEAR OWRE96 1996))(POS (PAPER.RANK OWRE96 "[*]"))(POS (PAPER.DESCRIPTION OWRE96 "
PVS (Prototype Verification System) allows a user to construct a
machine-verified proof.  It combines interactive theorem
proving, typechecking, a set of decision procedures including
a model checker, and strategies to avoid tedious proof step 
repetitions for the user.   The strategies can be extended
if necessary.
"))(POS (PAPER.TOPIC OWRE96 "Model Checking"))(POS (PAPER.INSTANCE PALTRINIERI94))(POS (PAPER.BIBTEX PALTRINIERI94 ARTICLE))(POS (PAPER.AUTHOR PALTRINIERI94 "Massimo Paltrinieri"))(POS (PAPER.TITLE PALTRINIERI94 "Some Remarks on the Design of Constraint Satisfaction
Problems"))(POS (PAPER.PUBLICATION PALTRINIERI94 "Second International Workshop on the Principles
and Practice of Constraint Programming"))(POS (PAPER.STARTPAGE PALTRINIERI94 299))(POS (PAPER.ENDPAGE PALTRINIERI94 311))(POS (PAPER.LINK PALTRINIERI94 "http://citeseer.ist.psu.edu/paltrinieri94some.html"))(POS (PAPER.YEAR PALTRINIERI94 1994))(POS (PAPER.RANK PALTRINIERI94 "[****]"))(POS (PAPER.DESCRIPTION PALTRINIERI94 "
Paltrinieri gives a loose definition for an object-oriented constraint
satisfaction problem and goes on to show its utility for modelling
some CSPs.  His formulation of an OOCSP is no more expressive than
a standard CSP; solving an OOCSP then amounts to translating it into
a CSP.  To do this, find all the instances of objects needed to solve
the OOCSP and replicate the class constraints for each instance.
"))(POS (PAPER.TOPIC PALTRINIERI94 "Object Oriented Constraint Satisfaction"))(POS (PAPER.INSTANCE PALTRINIERI95))(POS (PAPER.BIBTEX PALTRINIERI95 ARTICLE))(POS (PAPER.AUTHOR PALTRINIERI95 "Massimo Paltrinieri"))(POS (PAPER.TITLE PALTRINIERI95 "A Visual Environment for Constraint Programming"))(POS (PAPER.PUBLICATION PALTRINIERI95 "Proceedings 11th International IEEE Symposium on Visual
Langauges"))(POS (PAPER.STARTPAGE PALTRINIERI95 118))(POS (PAPER.ENDPAGE PALTRINIERI95 119))(POS (PAPER.LINK PALTRINIERI95 "
http://citeseer.ist.psu.edu/paltrinieri95visual.html"))(POS (PAPER.YEAR PALTRINIERI95 1995))(POS (PAPER.RANK PALTRINIERI95 "[****]"))(POS (PAPER.DESCRIPTION PALTRINIERI95 "
Paltrinieri gives a 2-page description of a generalization of CSPs to
object-oriented CSPs.  He also describes a visual environment for 
dealing with OOCSPs.
"))(POS (PAPER.TOPIC PALTRINIERI95 "Object Oriented Constraint Satisfaction"))(POS (PAPER.INSTANCE PASTRE78))(POS (PAPER.BIBTEX PASTRE78 ARTICLE))(POS (PAPER.AUTHOR PASTRE78 "D. Pastre"))(POS (PAPER.TITLE PASTRE78 "Automatic Theorem Proving in Set Theory"))(POS (PAPER.PUBLICATION PASTRE78 "Artificial Intelligence"))(POS (PAPER.VOLUME PASTRE78 "10(1)"))(POS (PAPER.STARTPAGE PASTRE78 1))(POS (PAPER.ENDPAGE PASTRE78 27))(POS (PAPER.LINK PASTRE78 ""))(POS (PAPER.YEAR PASTRE78 1978))(POS (PAPER.RANK PASTRE78 "[**]"))(POS (PAPER.DESCRIPTION PASTRE78 "
Pastre describes PROVER, a theorem prover for set theory that builds
diagrams from axioms in order to prune the search space of theorem proving.
Pastre admits the methods to be incomplete, but claims an incomplete
method may prove more theorems than a complete one in practice.
"))(POS (PAPER.TOPIC PASTRE78 "Graphical Reasoning Techniques"))(POS (PAPER.INSTANCE PELTIER2000))(POS (PAPER.BIBTEX PELTIER2000 ARTICLE))(POS (PAPER.AUTHOR PELTIER2000 "Nicolas Peltier"))(POS (PAPER.TITLE PELTIER2000 "Model Building with Ordered Resolution"))(POS (PAPER.PUBLICATION PELTIER2000 "International Workshop on First Order Theorem Proving (FTP)"))(POS (PAPER.LINK PELTIER2000 "http://citeseer.ist.psu.edu/peltier00model.html"))(POS (PAPER.YEAR PELTIER2000 2000))(POS (PAPER.RANK PELTIER2000 "[****]"))(POS (PAPER.DESCRIPTION PELTIER2000 "
Peltier describes two algorithms that can be used after an ordered
resolution proof has failed: (1) to extract from the resolution closure
a set of formulas that have a single Herbrand model where that model
satisfies the original clauseset and (2) to turn those formulas into
a set of clauses.  Peltier's Herbrand model is represented by a clauseset,
and since the clauseset is guaranteed to have exactly one Herbrand model,
proof by consistency can be used to check whether that model satisfies
a particular sentence; moreover, for ground literals, satisfaction is decidable
since either the literal or its negation must be consistent and the 
clauseset is satisfiable, exactly one is consistent, which ensures one
is inconsistent.  Any off-the- shelf first-order entailment algorithm will 
find an inconsistency.  The technique is based on predicate completion,
which only works when there is a strict ordering among the clauses. 
"))(POS (PAPER.TOPIC PELTIER2000 "Model Building"))(POS (PAPER.INSTANCE PEREIRA80))(POS (PAPER.BIBTEX PEREIRA80 INPROCEEDINGS))(POS (PAPER.AUTHOR PEREIRA80 "Pereira and Porto"))(POS (PAPER.TITLE PEREIRA80 "Selective Backtracking for Logic Programs"))(POS (PAPER.PUBLICATION PEREIRA80 "In Proceedings of the Conference on Automated Deduction"))(POS (PAPER.YEAR PEREIRA80 1980))(POS (PAPER.DESCRIPTION PEREIRA80 "
One of the papers that uses the Logic Programming formulation of map coloring.
"))(POS (PAPER.TOPIC PEREIRA80 "Logic Programming"))(POS (PAPER.INSTANCE PETERSON98))(POS (PAPER.BIBTEX PETERSON98 INPROCEEDINGS))(POS (PAPER.AUTHOR PETERSON98 "Brian Peterson and William Anderson and Joshua Engel"))(POS (PAPER.TITLE PETERSON98 "Knowledge Bus: Generating Application-focused Databases from Large Ontologies"))(POS (PAPER.PUBLICATION PETERSON98 "Knowledge Representation Meets Databases"))(POS (PAPER.LINK PETERSON98 "http://citeseer.ist.psu.edu/peterson98knowledge.html"))(POS (PAPER.YEAR PETERSON98 1998))(POS (PAPER.DESCRIPTION PETERSON98 "
The authors attempt to construct a logic program from Cyc for answering a
given set of queries.  Their transformation is lossy, and it is unclear
to what extent the logical consequences are preserved.
"))(POS (PAPER.TOPIC PETERSON98 "Reformulation"))(POS (PAPER.INSTANCE PETRIE2004))(POS (PAPER.BIBTEX PETRIE2004 ARTICLE))(POS (PAPER.AUTHOR PETRIE2004 "Charles J. Petrie, Michael R. Genesereth, Hans Bjornsson, Rada Chirkova, Martin Ekstrom, Hidehito Gomi, Tim Hinrichs, Rob Hoskins, Michael Kassoff, Daishi Kato, Kyohei Kawazoe, Jung Ung Min, and Waqar Mohsin"))(POS (PAPER.TITLE PETRIE2004 "Adding AI to Web Services"))(POS (PAPER.PUBLICATION PETRIE2004 "Lecture Notes in Artificial Intelligence"))(POS (PAPER.VOLUME PETRIE2004 "2926"))(POS (PAPER.STARTPAGE PETRIE2004 322))(POS (PAPER.ENDPAGE PETRIE2004 338))(POS (PAPER.LINK PETRIE2004 "papers/petrie2004adding.pdf"))(POS (PAPER.YEAR PETRIE2004 2004))(POS (PAPER.DESCRIPTION PETRIE2004 "
The FX-Agents project consisted of members of the Stanford Logic Group 
and industrial visitors from NEC and Intec Web and Genome working together 
to develop new technologies based upon the combination of Web services and 
techniques from artificial intelligence, using our experience in AI-based 
software agents. This two-year project ran from April 2001 until March 2002 
and explored the then emerging functionality of Web services. This paper is 
a result of our findings. In particular, this paper discusses the shortcomings 
of current Web service standards like WSDL and how logical AI techniques 
like declarative commands, agents, and planning can be used to address some 
of these shortcomings. The primary problems that we address are automated 
Web service discovery and composition of Web services. 
"))(POS (PAPER.TOPIC PETRIE2004 "References"))(POS (PAPER.INSTANCE PICHLER2000))(POS (PAPER.BIBTEX PICHLER2000 ARTICLE))(POS (PAPER.AUTHOR PICHLER2000 "Reinhard Pichler"))(POS (PAPER.TITLE PICHLER2000 "On the Complexity of Equational Problems in CNF over a Finite Domain"))(POS (PAPER.LINK PICHLER2000 "http://citeseer.ist.psu.edu/478741.html"))(POS (PAPER.YEAR PICHLER2000 2000))(POS (PAPER.RANK PICHLER2000 "[**]"))(POS (PAPER.DESCRIPTION PICHLER2000 "
Pichler shows that the complexity of satisfiability of a purely equational 
Herbrand logic sentence E*A*.M, where M is in CNF, is Sigma_2^p-complete.
"))(POS (PAPER.TOPIC PICHLER2000 "Herbrand Logic"))(POS (PAPER.INSTANCE PINTO94))(POS (PAPER.AUTHOR PINTO94 "Javier Pinto"))(POS (PAPER.TITLE PINTO94 "Temporal Reasoning in the Situation Calculus"))(POS (PAPER.LINK PINTO94 "http://citeseer.ist.psu.edu/pinto94temporal.html"))(POS (PAPER.YEAR PINTO94 1994))(POS (PAPER.RANK PINTO94 "[**]"))(POS (PAPER.DESCRIPTION PINTO94 "
Pinto's thesis extends situation calculus to cover temporal reasoning.  He includes ACTUAL PATHS (narratives), concurrent actions, and continuous time with natural events.  He goes on to compare his situation calculus with interval temporal logic, the calculus of events, and modal temporal logics.  He later reworked his approach to narratives in [pinto98], which does not call for circumscription.  Reiter published a paper on 'Natural Actions, Concurrency, and Continuous Time' [reiter96] after Pinto--should probably read that one instead.
"))(POS (PAPER.TOPIC PINTO94 "Behavioral Goals"))(POS (PAPER.RELATED PINTO94 REITER96))(POS (PAPER.RELATED PINTO94 PINTO98))(POS (PAPER.INSTANCE PINTO98))(POS (PAPER.AUTHOR PINTO98 "Javier Pinto"))(POS (PAPER.TITLE PINTO98 "Occurrences and Narratives as Constraints in the Branching Structure of the Situation Calculus"))(POS (PAPER.PUBLICATION PINTO98 "Journal of Logic and Computation"))(POS (PAPER.VOLUME PINTO98 "8(6)"))(POS (PAPER.STARTPAGE PINTO98 777))(POS (PAPER.ENDPAGE PINTO98 808))(POS (PAPER.LINK PINTO98 "http://citeseer.ist.psu.edu/pinto96occurrences.html"))(POS (PAPER.YEAR PINTO98 1998))(POS (PAPER.RANK PINTO98 "[*****]"))(POS (PAPER.DESCRIPTION PINTO98 "
Pinto tackles the problem of expressing occurrences in situation calculus.  Occurrences are sequences of events that really do happen in every hypothetical branch of the situation tree.  In deductive plan synthesis via the Green method, we want all plans returned to include all the occurrences given.  Pinto names two specific types of occurrences: narratives (a partial specification of a sequence of events known to happen) and triggers (as in the database sense).  His formulation assigns time values to situations, a second order induction axiom, along with an extension to the sitcalc ontology to define 'nonpreventable occurrences', 'conditional occurrences', and 'simple occurrences'.  He defines 'legal(s)' in terms of these 3 occurrence types to mean that a situation s includes all the mentioned occurrences and is a valid sitcalc situation.  Pinto goes on to define when one situation is preferred to another: s preferred-to s' iff s' has the same actions as s with extra actions appended to the end.  For planning, Pinto shows that instead of finding an s s.t. goal(s) is true, we can find an s s.t. goal(s) ^ legal(s) is true. 
"))(POS (PAPER.TOPIC PINTO98 "Behavioral Goals"))(POS (PAPER.INSTANCE PIRRI99))(POS (PAPER.AUTHOR PIRRI99 "Fiora Pirri and Ray Reiter"))(POS (PAPER.TITLE PIRRI99 "Some Contributions to the Metatheory of the Situation Calculus"))(POS (PAPER.PUBLICATION PIRRI99 "Journal of the ACM"))(POS (PAPER.VOLUME PIRRI99 "46(3)"))(POS (PAPER.STARTPAGE PIRRI99 325))(POS (PAPER.ENDPAGE PIRRI99 361))(POS (PAPER.LINK PIRRI99 "http://citeseer.ist.psu.edu/pirri99some.html"))(POS (PAPER.YEAR PIRRI99 1999))(POS (PAPER.RANK PIRRI99 "[****]"))(POS (PAPER.DESCRIPTION PIRRI99 "
Pirri and Reiter formalize the theory of situation calculus and define basic
action theories as D = Sigma U D_ss U D_ap U D_una U D_s0.  Sigma are the
foundational axioms (induction, situation ordering, equality, unique names
for situations); D_ss are
successor state axioms; D_ap are action precondition axioms; D_una are unique
name axioms for actions; D_s0 are initial state axioms.  This definition
appears throughout later work on the situation calculus.  Well written.
They also define Regression (in a clearer way than reiter91--the
Frame problem...), which means rewriting a regressable formula so that the only
situations referenced are S0.  Entailment of a regressed formula requires
only knowledge
of D_s0 and D_una.  Pirri and Reiter also give conditions when induction is
not needed for entailment, as well as when other components of Sigma are
unnecessary.  They go on to show that Sigma is unnecessary for GOLOG programs.
"))(POS (PAPER.TOPIC PIRRI99 "Fundamentals"))(POS (PAPER.INSTANCE PLAISTED81))(POS (PAPER.BIBTEX PLAISTED81 ARTICLE))(POS (PAPER.AUTHOR PLAISTED81 "David Plaisted"))(POS (PAPER.TITLE PLAISTED81 "Theorem Proving with Abstraction"))(POS (PAPER.PUBLICATION PLAISTED81 "Artificial Intelligence"))(POS (PAPER.VOLUME PLAISTED81 "16(1)"))(POS (PAPER.STARTPAGE PLAISTED81 47))(POS (PAPER.ENDPAGE PLAISTED81 107))(POS (PAPER.LINK PLAISTED81 ""))(POS (PAPER.YEAR PLAISTED81 1981))(POS (PAPER.DESCRIPTION PLAISTED81 "
Plaisted defines the notion of an abstraction of a literal and a clause and
shows that under this definition, the union and composition of two
abstractions is another abstraction.  He also gives local conditions
under which a mapping is an abstraction, which can be practically used.
He goes on to discuss abstract resolution proofs and multi-clauses (which
admit simpler proof procedures than regular clauses).  He discusses
using more than one abstraction at a time.  Using these abstractions admits
a complete proof procedure.  Finally, he introduces a variant
of the multi-clause notion and considers a version of completeness for it.
"))(POS (PAPER.TOPIC PLAISTED81 "Abstraction"))(POS (PAPER.INSTANCE PLAISTED94))(POS (PAPER.BIBTEX PLAISTED94 INPROCEEDINGS))(POS (PAPER.AUTHOR PLAISTED94 "David Plaisted"))(POS (PAPER.TITLE PLAISTED94 "The Search Efficiency of Theorem Proving Strategies: An Analytical Comparison"))(POS (PAPER.PUBLICATION PLAISTED94 "CADE"))(POS (PAPER.STARTPAGE PLAISTED94 1))(POS (PAPER.ENDPAGE PLAISTED94 40))(POS (PAPER.LINK PLAISTED94 "http://citeseer.ist.psu.edu/plaisted94search.html"))(POS (PAPER.YEAR PLAISTED94 1994))(POS (PAPER.RANK PLAISTED94 "[***]"))(POS (PAPER.DESCRIPTION PLAISTED94 "
Plaisted does a comparison of a slew of clausal, refutation 
theorem-proving strategies for
propositional Horn clauses.  He gives three measures for the search
spaces generated by each strategy: iterated duplication, case-analysis
duplication, and combination duplication, the produce of which bounds
the total size of the search space.  The first measures the longest path,
the second measures the number of paths, and the third measures the
maximum size of clauses generated in any state. 
"))(POS (PAPER.TOPIC PLAISTED94 "Comparative Analysis"))(POS (PAPER.INSTANCE PLAISTED97))(POS (PAPER.BIBTEX PLAISTED97 INPROCEEDINGS))(POS (PAPER.AUTHOR PLAISTED97 "David Plaisted and Yunshan Zhu"))(POS (PAPER.TITLE PLAISTED97 "Ordered Semantic Hyper Linking"))(POS (PAPER.PUBLICATION PLAISTED97 "AAAI"))(POS (PAPER.LINK PLAISTED97 "http://citeseer.ist.psu.edu/218207.html"))(POS (PAPER.YEAR PLAISTED97 1997))(POS (PAPER.RANK PLAISTED97 "[***]"))(POS (PAPER.DESCRIPTION PLAISTED97 "
Ordered Semantic Hyper Linking is a proof procedure based on
model-building.  In includes a total ordering on
formulae to remove redundant interpretations.  OSHL allows the user
to give an initial interpretation to guide the search.
It propositionalizes first order theories to build its models.  
The paper claims soundness and completeness, but no proofs are
supplied (probably due to lack of space).
"))(POS (PAPER.TOPIC PLAISTED97 "Resolution Variants"))(POS (PAPER.INSTANCE PLUMMER95))(POS (PAPER.BIBTEX PLUMMER95 MISC))(POS (PAPER.AUTHOR PLUMMER95 "Dave Barker-Plummer and Sidney Bailin"))(POS (PAPER.TITLE PLUMMER95 "Proofs and Pictures: Proving the Diamond lemma with the GROVER Theorem Proving System"))(POS (PAPER.LINK PLUMMER95 "http://citeseer.ist.psu.edu/193199.html"))(POS (PAPER.YEAR PLUMMER95 1995))(POS (PAPER.RANK PLUMMER95 "[*]"))(POS (PAPER.DESCRIPTION PLUMMER95 "
The authors describe a theorem proving system that takes a set of axioms, Delta,
a diagram, D, and a conjecture phi.  It proves Delta |= phi by 1) examining D and 
determining that D |= phi, and 2) proving Delta |= D.  The method seems to be 
ad hoc with no guarantees of soundness or completeness; however, given enough
hints, GROVER was able to prove the Diamond Lemma.
"))(POS (PAPER.TOPIC PLUMMER95 "Graphical Reasoning Techniques"))(POS (PAPER.INSTANCE PRASAD2005))(POS (PAPER.BIBTEX PRASAD2005 ARTICLE))(POS (PAPER.AUTHOR PRASAD2005 "Mukul Prasad and Armin Biere and Aarti Gupta"))(POS (PAPER.TITLE PRASAD2005 "A Survey of Recent Advances in SAT-Based Formal Verification"))(POS (PAPER.PUBLICATION PRASAD2005 "Software Tools for Technology Transfer"))(POS (PAPER.VOLUME PRASAD2005 "7(2)"))(POS (PAPER.STARTPAGE PRASAD2005 156))(POS (PAPER.ENDPAGE PRASAD2005 173))(POS (PAPER.LINK PRASAD2005 "http://www.cerc.utexas.edu/~jay/fv_surveys/"))(POS (PAPER.YEAR PRASAD2005 2005))(POS (PAPER.DESCRIPTION PRASAD2005 "
A survey paper discussing how boolean SAT solvers are being used
for formal verification.
"))(POS (PAPER.TOPIC PRASAD2005 "Formal Verification"))(POS (PAPER.INSTANCE PUEBLA2004))(POS (PAPER.BIBTEX PUEBLA2004 ARTICLE))(POS (PAPER.AUTHOR PUEBLA2004 "G. Puebla and E. Albert and M. Hermenegildo"))(POS (PAPER.TITLE PUEBLA2004 "Efficient Local Unfolding with Ancestor Stacks for Full Prolog"))(POS (PAPER.PUBLICATION PUEBLA2004 "14th International Symposium, Logic Based Program Synthesis and Transformation (LOPSTR)"))(POS (PAPER.STARTPAGE PUEBLA2004 1))(POS (PAPER.ENDPAGE PUEBLA2004 18))(POS (PAPER.LINK PUEBLA2004 "http://wotan.liu.edu/docis/dbl/lopstr/index.html"))(POS (PAPER.YEAR PUEBLA2004 2004))(POS (PAPER.DESCRIPTION PUEBLA2004 "
In the context of Horn prolog with built-ins, the authors address the
problem of efficiently unfolding of recursive relations.  That is,
one implementation of partial evaluation/partial deduction is to produce
a partial SLD tree and using the fringe as the body of a rule for proving
the goal.  The problem with this approach is that the recursive relations 
produce infinite SLD trees, unless the recursion is cut off.  To determine
when the recursion should be cut off, a common practice is to apply a
recursive rule only when the subgoal is smaller, according to some
ordering, e.g. well-founded, well-quasi, than all its ancestors.  To
implement that, all the ancestors of each goal have in the past 
been stored, which is expensive both in time to check and in space
to store.  This paper tackles this problem by expanding the tree in a 
variant of depth-first search so that only the current call stack need
be stored.  They also consider the case of built-in predicates.
"))(POS (PAPER.TOPIC PUEBLA2004 "Reformulation"))(POS (PAPER.INSTANCE RAMACHANDRAN2005))(POS (PAPER.BIBTEX RAMACHANDRAN2005 ARTICLE))(POS (PAPER.AUTHOR RAMACHANDRAN2005 "D. Ramachandran and E. Amir"))(POS (PAPER.TITLE RAMACHANDRAN2005 "Compact Propositional Encodings of First-Order Theories"))(POS (PAPER.PUBLICATION RAMACHANDRAN2005 "20th National Conference on Artificial Intelligence"))(POS (PAPER.LINK RAMACHANDRAN2005 "http://reason.cs.uiuc.edu/eyal/paper.html"))(POS (PAPER.YEAR RAMACHANDRAN2005 2005))(POS (PAPER.DESCRIPTION RAMACHANDRAN2005 "
The authors introduce polynomial-time algorithms for converting
first-order logic (sometimes with a DCA) into propositional logic,
where the goal is a small output size.  Relies on a certain
structure within the FOL theory.
"))(POS (PAPER.TOPIC RAMACHANDRAN2005 "Reformulation"))(POS (PAPER.INSTANCE RAO2004))(POS (PAPER.BIBTEX RAO2004 ARTICLE))(POS (PAPER.AUTHOR RAO2004 "M.R.K. Krishna Rao"))(POS (PAPER.TITLE RAO2004 "Input-Termination of Logic Programs"))(POS (PAPER.PUBLICATION RAO2004 "14th International Symposium, Logic Based Program Synthesis and Transformation (LOPSTR)"))(POS (PAPER.STARTPAGE RAO2004 215))(POS (PAPER.ENDPAGE RAO2004 230))(POS (PAPER.LINK RAO2004 "http://wotan.liu.edu/docis/dbl/lopstr/index.html"))(POS (PAPER.YEAR RAO2004 2004))(POS (PAPER.DESCRIPTION RAO2004 "
Rao defines a class of logic programs, linear bounded programs,
and show that such programs are input-terminating under Prolog's 
selection rule.  Rao also shows that all simply-moded linear bounded
programs are input-terminating.  Importantly, determining whether
a program is linearly bounded is decidable, unlike previous work
which gave necessary and sufficient conditions for a class of 
decidable programs, but checking those conditions is undecidable.  Input-
consuming derivations do not instantiate variables that only occur
in the input positions of the initial query, and input-termination is the
property that all input-consuming derivations are finite.
"))(POS (PAPER.TOPIC RAO2004 "Reformulation"))(POS (PAPER.INSTANCE REITER2000))(POS (PAPER.AUTHOR REITER2000 "Ray Reiter"))(POS (PAPER.TITLE REITER2000 "Narratives as Programs"))(POS (PAPER.PUBLICATION REITER2000 "Principles of Knowledge Representation and Reasoning"))(POS (PAPER.STARTPAGE REITER2000 99))(POS (PAPER.ENDPAGE REITER2000 108))(POS (PAPER.LINK REITER2000 "http://citeseer.ist.psu.edu/reiter00narratives.html"))(POS (PAPER.YEAR REITER2000 2000))(POS (PAPER.RANK REITER2000 "[*]"))(POS (PAPER.DESCRIPTION REITER2000 "
Reiter argues that narratives (a sequence of events known to occur) are actually programs.  He uses GOLOG to represent narratives and shows that making a query Q(s) over a narrative is identical to proving a property about a program, as in program verification.  In GOLOG terms, we want to ask whether Q holds on a program v; we simply show that SitcalcAxioms |= As.(Do(v,S0,s)=>Q(s)).
"))(POS (PAPER.TOPIC REITER2000 "Behavioral Goals"))(POS (PAPER.INSTANCE REITER73))(POS (PAPER.BIBTEX REITER73 INPROCEEDINGS))(POS (PAPER.AUTHOR REITER73 "Ray Reiter"))(POS (PAPER.TITLE REITER73 "A Semantically Guided Deductive System for Automatic Theorem-Proving"))(POS (PAPER.PUBLICATION REITER73 "IJCAI"))(POS (PAPER.YEAR REITER73 1973))(POS (PAPER.RANK REITER73 "[**]"))(POS (PAPER.DESCRIPTION REITER73 "
Reiter describes a system for natural deduction that intertwines model-
building and deduction, where each affects the other.  The system itself
is composed of 12 inference rules which manipulate both axioms and 
models.  This may have been the seminal work on using an explicit 
model to aid theorem-proving; previous work used heuristics, which
Reiter characterized as implicit semantics. 
"))(POS (PAPER.TOPIC REITER73 "Model-Guided Proof Techniques"))(POS (PAPER.INSTANCE REITER78))(POS (PAPER.BIBTEX REITER78 INPROCEEDINGS))(POS (PAPER.AUTHOR REITER78 "Ray Reiter"))(POS (PAPER.TITLE REITER78 "On Closed World Databases"))(POS (PAPER.PUBLICATION REITER78 "In proceedings of 1978 ACM SIGMOD International Conference on Management of Data"))(POS (PAPER.YEAR REITER78 1978))(POS (PAPER.DESCRIPTION REITER78 "
The closed world assumption (CWA).
"))(POS (PAPER.TOPIC REITER78 "Logical Knowledge Representation"))(POS (PAPER.INSTANCE REITER80))(POS (PAPER.BIBTEX REITER80 ARTICLE))(POS (PAPER.AUTHOR REITER80 "Raymond Reiter"))(POS (PAPER.TITLE REITER80 "Equality and Domain Closure in First-Order Databases"))(POS (PAPER.PUBLICATION REITER80 "Journal of the ACM"))(POS (PAPER.VOLUME REITER80 "27(2)"))(POS (PAPER.STARTPAGE REITER80 235))(POS (PAPER.ENDPAGE REITER80 249))(POS (PAPER.LINK REITER80 "http://portal.acm.org/citation.cfm?id=322189"))(POS (PAPER.YEAR REITER80 1980))(POS (PAPER.RANK REITER80 "[**]"))(POS (PAPER.DESCRIPTION REITER80 "
Reiter explores techniques for doing first-order reasoning with 
a Domain Closure Axiom
(x=a1 | x=a2 | ... | x=an).  He focuses on axiom sets for which there
are a finite number of object constants, no function constants, and when
written in prenex form include no existential quantifiers.
To do so he (1) shows that existential queries will never require
the DCA, for algorithms exploiting Herbrand's theorem, and 
(2) how to build on this fact 
to answer any kind of query by peeling away quantifiers to build an 
existential query.  The second step uses a generalization of the 
relational database division operator for universal quantifiers and a 
generalization of the projection operator for existential quantifiers. 
Next it is shown that Horn databases and positive existential queries never 
require computing disjunctive answers. 
Then conditions are given for the removal of all but the x=x equality axiom: 
E-saturation, i.e.
unique names over all the constants.  Lastly it is
shown that extending DCA to include infinitely many constants can result in
an infinite disjunction as an answer to a query.  Very thorough, as always.
"))(POS (PAPER.TOPIC REITER80 "Logical Knowledge Representation"))(POS (PAPER.INSTANCE REITER84))(POS (PAPER.BIBTEX REITER84 CHAPTER))(POS (PAPER.AUTHOR REITER84 "Raymond Reiter"))(POS (PAPER.TITLE REITER84 "Towards a Logical Reconstruction of Relational Database Theory"))(POS (PAPER.PUBLISHER REITER84 "Springer-Verlag"))(POS (PAPER.PUBLICATION REITER84 "On Conceptual Modelling"))(POS (PAPER.STARTPAGE REITER84 191))(POS (PAPER.ENDPAGE REITER84 238))(POS (PAPER.LINK REITER84 ""))(POS (PAPER.YEAR REITER84 1984))(POS (PAPER.RANK REITER84 "[***]"))(POS (PAPER.DESCRIPTION REITER84 "
Reiter formalizes Database theory from a logical perspective.  Databases in this view are first-order models, and integrity constraints are sentences that such a model satisfies.  A relational theory (the set of sentences entailed by a relational database) can be defined as the set of ground atoms in the DB, a completion axiom for each table ensuring that those ground atoms not in the table are false, unique-names axioms, a domain closure axiom, and equality/substitution axioms.   Proof is provided.  Next Reiter goes on to generalize this definition to handle positive disjunction, which requires altering the completion axioms.  Lastly he shows how to deal with null values by changing the DCA and the completion axioms. 
"))(POS (PAPER.TOPIC REITER84 "Logical Knowledge Representation"))(POS (PAPER.INSTANCE REITER91))(POS (PAPER.AUTHOR REITER91 "Raymond Reiter"))(POS (PAPER.TITLE REITER91 "The Frame Problem in the Situation Calculus: A Simple Solution (Sometimes) and a Completeness Result for Goal Regression"))(POS (PAPER.PUBLICATION REITER91 "Artificial Intelligence and Mathematical Theory of Computation: Papers in Honor of John McCarthy"))(POS (PAPER.LINK REITER91 "http://ftp.cs.toronto.edu/pub/cogrob/README.html"))(POS (PAPER.YEAR REITER91 1991))(POS (PAPER.RANK REITER91 "[**]"))(POS (PAPER.DESCRIPTION REITER91 "
Reiter describes his solution to the frame problem, namely successor state
axioms of the form
Poss(a,s)=>[R(do(a,s)) =def= r_pos(a,s) V R(s) ^ ~r_neg(a,s)].  Poss(a,s) is
the action precondition axiom; R(do(a,s)) is the fluent, r_pos(a,s) is the
positive effect axiom for R; r_neg(a,s) is the negative effect axiom for R.
This works when also given a single definition for Poss(A,s) for each action A,
unique naming axioms for actions and states.  This technique requires F+A
axioms instead of 2*A*F axioms to describe frame and effect axioms for a
domain, where F is the number of fluents and A the number of actions.
Reiter also discusses a regression operator, which does deductive plan synthesis by taking a normal situation calculus axiomitization (using successor state axioms) and rewrites it so that every fluent only mentions S0.  Under certain conditions, Reiter shows that the rewriting can be done iff Es.G(s).
"))(POS (PAPER.TOPIC REITER91 "Fundamentals"))(POS (PAPER.INSTANCE REITER93))(POS (PAPER.AUTHOR REITER93 "Raymond Reiter"))(POS (PAPER.TITLE REITER93 "Proving Properties of States in the Situation Calculus"))(POS (PAPER.PUBLICATION REITER93 "Artificial Intelligence"))(POS (PAPER.VOLUME REITER93 "64(2)"))(POS (PAPER.STARTPAGE REITER93 337))(POS (PAPER.ENDPAGE REITER93 351))(POS (PAPER.LINK REITER93 "http://citeseer.ist.psu.edu/reiter93proving.html"))(POS (PAPER.YEAR REITER93 1993))(POS (PAPER.RANK REITER93 "[****]"))(POS (PAPER.DESCRIPTION REITER93 "
Reiter motivates the need to prove properties about states by citing the examples in the physical world (once broken, an object stays that way), planning (showing there is no plan to achieve a goal), and integrity constraints on a database.  He formulates an induction axiom sufficient for proving P(s) for all states s>=S0.  He relies on explanation closure axioms, proposed by Schubert and Haas, which are logically equivalent to frame axioms.
"))(POS (PAPER.TOPIC REITER93 "Theories of Action"))(POS (PAPER.INSTANCE REITER95))(POS (PAPER.AUTHOR REITER95 "Ray Reiter"))(POS (PAPER.TITLE REITER95 "On Specifying Database Updates"))(POS (PAPER.PUBLICATION REITER95 "Journal of Logic Programming"))(POS (PAPER.VOLUME REITER95 "25(1)"))(POS (PAPER.STARTPAGE REITER95 53))(POS (PAPER.ENDPAGE REITER95 91))(POS (PAPER.LINK REITER95 "http://citeseer.ist.psu.edu/reiter92specifying.html"))(POS (PAPER.YEAR REITER95 1995))(POS (PAPER.RANK REITER95 "[*]"))(POS (PAPER.DESCRIPTION REITER95 "
Reiter summarizes several previous pieces of work including proving properties of states in Situation Calculus and formalizing the querying of a database transaction.  He also compares this approach to other database query techniques.
"))(POS (PAPER.TOPIC REITER95 "Hypothetical Temporal DB Queries"))(POS (PAPER.INSTANCE REITER96))(POS (PAPER.AUTHOR REITER96 "Ray Reiter"))(POS (PAPER.TITLE REITER96 "Natural Actions, Concurrency and Continuous Time in the Situation Calculus"))(POS (PAPER.PUBLICATION REITER96 "Principles of Knowledge Representation and Reasoning: Proceedings of the Fifth International Conference"))(POS (PAPER.STARTPAGE REITER96 2))(POS (PAPER.ENDPAGE REITER96 13))(POS (PAPER.LINK REITER96 "http://ftp.cs.toronto.edu/pub/cogrob/README.html"))(POS (PAPER.YEAR REITER96 1996))(POS (PAPER.RANK REITER96 "[*****]"))(POS (PAPER.DESCRIPTION REITER96 "
Reiter gives an axiomitization for Concurrent, Temporal Situation Calculus.  He mentions any solution to the Precondition Interaction Problem (where two actions preconditions may both be satisfied yet the 2 actions are mutually exclusive) works within the given framework.  The axiomitization allows actions following the laws of physics to occur at the same time an agent is acting in the world.  Plans can consequently be produced that take these laws into account.
"))(POS (PAPER.TOPIC REITER96 "Behavioral Goals"))(POS (PAPER.INSTANCE RIAZANOV02))(POS (PAPER.BIBTEX RIAZANOV02 ARTICLE))(POS (PAPER.AUTHOR RIAZANOV02 "Alexandre Riazanov and Andrei Voronkov"))(POS (PAPER.TITLE RIAZANOV02 "The design and implementation of Vampire"))(POS (PAPER.PUBLICATION RIAZANOV02 "AI Communications"))(POS (PAPER.VOLUME RIAZANOV02 "15"))(POS (PAPER.STARTPAGE RIAZANOV02 91))(POS (PAPER.ENDPAGE RIAZANOV02 110))(POS (PAPER.LINK RIAZANOV02 ""))(POS (PAPER.YEAR RIAZANOV02 2002))(POS (PAPER.RANK RIAZANOV02 ""))(POS (PAPER.DESCRIPTION RIAZANOV02 "
Riazanov and Voronkov describe Vampire v2.0.  They first give an overview
of the high-level functionality, then give a more detailed discussion
of the architecture based on DISCOUNT, talk about term-indexing, 
and delve into representational
issues (e.g. shared terms) along with memory management.  
"))(POS (PAPER.TOPIC RIAZANOV02 "System Designs"))(POS (PAPER.INSTANCE RIAZANOV2001))(POS (PAPER.AUTHOR RIAZANOV2001 "Alexandre Riazanov and Andrei Voronkov"))(POS (PAPER.TITLE RIAZANOV2001 "Splitting without Backtracking"))(POS (PAPER.PUBLICATION RIAZANOV2001 "IJCAI"))(POS (PAPER.STARTPAGE RIAZANOV2001 611))(POS (PAPER.ENDPAGE RIAZANOV2001 617))(POS (PAPER.LINK RIAZANOV2001 "http://rpc25.cs.man.ac.uk/voronkov/all_publications.html"))(POS (PAPER.YEAR RIAZANOV2001 2001))(POS (PAPER.DESCRIPTION RIAZANOV2001 "
The authors describe a technique for resolution that allows resolution
to break a clause apart when variables are not shared between pieces.
Suppose the clause C can be partitioned into 2 parts D and E, where each
part shares no variables with any other part.  Splitting replaces
C with the clauses D | p and E | -p.  This only makes sense when there
is an ordering imposed on the literals so that p and -p are not immediately
resolved together undoing the work of splitting.  The authors investigate
two orders: blocking and parallel.  In blocking, the -p literals 
are ranked highest; the non p literals are ranked next with negative
bigger than positive; the p atoms are ranked lowest.  In parallel,
the p literals (positive or negative) are ranked last.  Also, 
these p literals are considered names.  If there is another clause 
C' with partition D and F, then C' is split into F | -p.  Some
experimental results from TPTP show that splitting is a bad idea
with equality but that Parallel ordering with Naming is a good idea
without equaity. 
"))(POS (PAPER.TOPIC RIAZANOV2001 "Calculi"))(POS (PAPER.INSTANCE RIAZANOV2003))(POS (PAPER.AUTHOR RIAZANOV2003 "Alexandre Riazanov and Andrei Voronkov"))(POS (PAPER.TITLE RIAZANOV2003 "Efficient Instance Retrieval with Standard and Relational Path Indexing
"))(POS (PAPER.LINK RIAZANOV2003 "http://citeseer.ist.psu.edu/594779.html"))(POS (PAPER.YEAR RIAZANOV2003 2003))(POS (PAPER.DESCRIPTION RIAZANOV2003 "
Riazanov and Voronkov follow on their first indexing paper with this one.
They compare discrimination trees and path indexing for the case of instance
retrieval.  Given a term t, find all terms u and substitutions sigma such that 
t.sigma = u.  Discrimination trees represent terms as strings; path
indexing represents terms as trees.  The authors show that with the
standard implementation of path indexing is slower than DT.  Then
they augment PI with skip lists, early cleaning to more closely
approximate perfect filtering, and a couple of other improvements.  Then
they argue for relational path indexing, utilizing database theory
to conceptualize the integration of cleaning after imperfect filtering
into the imperfect filtering.  They show how this idea makes
commutative indexing and backward subsumption on multiliteral
clauses.
"))(POS (PAPER.TOPIC RIAZANOV2003 "Indexing"))(POS (PAPER.INSTANCE ROBINSON))(POS (PAPER.BIBTEX ROBINSON BOOK))(POS (PAPER.AUTHOR ROBINSON "Alan Robinson and Andrei Voronkov"))(POS (PAPER.TITLE ROBINSON "Handbook of Automated Reasoning"))(POS (PAPER.PUBLISHER ROBINSON "MIT Press and Elsevier Science"))(POS (PAPER.LINK ROBINSON "http://www.amazon.com/Handbook-Automated-Reasoning-Alan-Robinson/dp/0262182238"))(POS (PAPER.YEAR ROBINSON 2001))(POS (PAPER.RANK ROBINSON "[*****]"))(POS (PAPER.DESCRIPTION ROBINSON "
Robinson and Voronkov edit this two volume handbook.  The first volume covers
a history of the field, methods for first-order logic, methods for equality and
other built-in theories, and induction.  The second volume covers higher-order
logics, nonclassical logics, decidable classes and model building, and implementational
details.
"))(POS (PAPER.TOPIC ROBINSON ""))(POS (PAPER.INSTANCE ROBINSON65MACHINE))(POS (PAPER.BIBTEX ROBINSON65MACHINE ARTICLE))(POS (PAPER.AUTHOR ROBINSON65MACHINE "J.A. Robinson"))(POS (PAPER.TITLE ROBINSON65MACHINE "A Machine-Oriented Logic Based on the Resolution Principle"))(POS (PAPER.PUBLICATION ROBINSON65MACHINE "Journal of the ACM"))(POS (PAPER.VOLUME ROBINSON65MACHINE "12(1)"))(POS (PAPER.STARTPAGE ROBINSON65MACHINE 23))(POS (PAPER.ENDPAGE ROBINSON65MACHINE 41))(POS (PAPER.YEAR ROBINSON65MACHINE 1965))(POS (PAPER.RANK ROBINSON65MACHINE ""))(POS (PAPER.DESCRIPTION ROBINSON65MACHINE "
The resolution paper.
"))(POS (PAPER.TOPIC ROBINSON65MACHINE "Theorem Proving"))(POS (PAPER.INSTANCE ROY2000))(POS (PAPER.BIBTEX ROY2000 ARTICLE))(POS (PAPER.AUTHOR ROY2000 "Pierre Roy, Anne Liret, Francois Pachet"))(POS (PAPER.TITLE ROY2000 "The Framework Approach for Constraint Satisfaction"))(POS (PAPER.PUBLICATION ROY2000 "ACM Computing Surveys"))(POS (PAPER.VOLUME ROY2000 "32"))(POS (PAPER.STARTPAGE ROY2000 13))(POS (PAPER.ENDPAGE ROY2000 16))(POS (PAPER.LINK ROY2000 "http://citeseer.ist.psu.edu/roy00framework.html"))(POS (PAPER.YEAR ROY2000 2000))(POS (PAPER.RANK ROY2000 "[**]"))(POS (PAPER.DESCRIPTION ROY2000 "
The authors argue that a Framework is a better paradigm for
allowing a user to solve CSPs than either a Library of generic
constraints or a Language built for writing solvers of CSPs. 
The former approach is too coarsely-grained, and the latter is
too finely-grained.  The framework approach sits nicely in the
middle. 
"))(POS (PAPER.TOPIC ROY2000 "OO Languages with Native Constraint Satisfaction"))(POS (PAPER.INSTANCE ROY97))(POS (PAPER.AUTHOR ROY97 "Pierre Roy, Francois Pachet"))(POS (PAPER.TITLE ROY97 "Reifying Constraint Satisfaction in Smalltalk"))(POS (PAPER.PUBLICATION ROY97 "Journal of Object-Oriented Programming"))(POS (PAPER.VOLUME ROY97 "10(4)"))(POS (PAPER.STARTPAGE ROY97 43))(POS (PAPER.ENDPAGE ROY97 51))(POS (PAPER.LINK ROY97 "http://citeseer.ist.psu.edu/roy97reifying.html"))(POS (PAPER.YEAR ROY97 1997))(POS (PAPER.RANK ROY97 "[**]"))(POS (PAPER.DESCRIPTION ROY97 "
Roy describes Backtalk, a system that allows a library of
generic CSP algorithms to be written.
Doing so requires reifying
the notion of a constraint, a CSP problem, a solution, etc..
"))(POS (PAPER.TOPIC ROY97 "OO Languages with Native Constraint Satisfaction"))(POS (PAPER.INSTANCE RUEB2000DECONSTRUCTING))(POS (PAPER.BIBTEX RUEB2000DECONSTRUCTING INPROCEEDINGS))(POS (PAPER.AUTHOR RUEB2000DECONSTRUCTING "Harald Rueb and Nataranjan Shankar"))(POS (PAPER.TITLE RUEB2000DECONSTRUCTING "Deconstructing Shostak"))(POS (PAPER.PUBLICATION RUEB2000DECONSTRUCTING "17th International Conference on Automated Deduction
           "))(POS (PAPER.LINK RUEB2000DECONSTRUCTING "http://citeseer.ist.psu.edu/290082.html"))(POS (PAPER.YEAR RUEB2000DECONSTRUCTING 2000))(POS (PAPER.RANK RUEB2000DECONSTRUCTING "[****]"))(POS (PAPER.DESCRIPTION RUEB2000DECONSTRUCTING "
Rueb and Shankar show the crisply outlined Shostak procedure outlined
in cyrluk96shostaks and all its variants to date are incomplete.  They
go further and give a complete version of the Shostak procedure and
finally give soundness and completeness proofs.
"))(POS (PAPER.TOPIC RUEB2000DECONSTRUCTING "Nelson-Oppen and Shostak"))(POS (PAPER.RELATED RUEB2000DECONSTRUCTING CYRLUK96SHOSTAKS))(POS (PAPER.RELATED RUEB2000DECONSTRUCTING SHOSTAK84))(POS (PAPER.INSTANCE SABIN96))(POS (PAPER.BIBTEX SABIN96 ARTICLE))(POS (PAPER.AUTHOR SABIN96 "D. Sabin and E. Freuder"))(POS (PAPER.TITLE SABIN96 "Configuration as Composite Constraint Satisfaction"))(POS (PAPER.PUBLICATION SABIN96 " AAAI Configuration Workshop"))(POS (PAPER.STARTPAGE SABIN96 28))(POS (PAPER.ENDPAGE SABIN96 36))(POS (PAPER.LINK SABIN96 "http://citeseer.ist.psu.edu/sabin96configuration.html"))(POS (PAPER.YEAR SABIN96 1996))(POS (PAPER.RANK SABIN96 "[****]"))(POS (PAPER.DESCRIPTION SABIN96 "
Sabin and Freuder define a new form of CSP which generalizes 
Meta CSPs, conditional CSPs, and hierarchical domain CSPs.
Composite CSP domain values are the set of solutions to an
entire subproblem.
"))(POS (PAPER.TOPIC SABIN96 "Various Forms of Constraint Satisfaction"))(POS (PAPER.INSTANCE SACERDOTI74))(POS (PAPER.AUTHOR SACERDOTI74 "Earl D. Sacerdoti"))(POS (PAPER.TITLE SACERDOTI74 "Planning in a Hierarchy of Abstraction Spaces"))(POS (PAPER.PUBLICATION SACERDOTI74 "Artificial Intelligence"))(POS (PAPER.VOLUME SACERDOTI74 "5"))(POS (PAPER.STARTPAGE SACERDOTI74 115))(POS (PAPER.ENDPAGE SACERDOTI74 135))(POS (PAPER.YEAR SACERDOTI74 1974))(POS (PAPER.DESCRIPTION SACERDOTI74 "
The ABSTRIPS (Abstraction-based STRIPS) paper.  In 1969, McCarthy and Hayes' asserted that knowledge representation should be epistemologically adequate and also define heuristic adequacy.  Sufficiently complex problems contain too many details to be epistemologically adequate and have adequeate heuristics.  To that end, Sacerdoti first plans through an abstract plan space and then refines a solution in that space to ensure the details support the abstraction.  To implement this idea, Sacerdoti extends STRIPS by assigning 'criticality' measures to each precondition of an action.  These measures define a hierarchy of abstraction spaces.  The planner finds a solution at the highest level of abstraction, and proceeds recursively to the next highest level.  Control of the search (i.e. the cost assigned to nodes in the search space) changes based on the level of abstraction.
"))(POS (PAPER.TOPIC SACERDOTI74 "Historical"))(POS (PAPER.INSTANCE SACERDOTI75))(POS (PAPER.AUTHOR SACERDOTI75 "Earl D. Sacerdoti"))(POS (PAPER.TITLE SACERDOTI75 "The Nonlinear Nature of Plans"))(POS (PAPER.PUBLICATION SACERDOTI75 "Aritificial Intelligence"))(POS (PAPER.VOLUME SACERDOTI75 "32"))(POS (PAPER.STARTPAGE SACERDOTI75 333))(POS (PAPER.ENDPAGE SACERDOTI75 377))(POS (PAPER.YEAR SACERDOTI75 1975))(POS (PAPER.DESCRIPTION SACERDOTI75 "
Sacerdoti describes NOAH (Nets Of Action Hierarchies), the first partial order
planner that relies heavily on the concept of a procedural net.  A 'procedural
net' is the data structure that maintains the
partially-ordered plan.  Much like his earlier work on
Hierarchical Planning, NOAH begins with an abstract
plan and continually refines it, alleviating conflicts through the use of
critics, until the plan consists of primitive actions.
"))(POS (PAPER.TOPIC SACERDOTI75 "Historical"))(POS (PAPER.INSTANCE SAGONAS94))(POS (PAPER.BIBTEX SAGONAS94 INPROCEEDINGS))(POS (PAPER.AUTHOR SAGONAS94 "K. Sagonas and T. Swift and D. S. Warren"))(POS (PAPER.TITLE SAGONAS94 "XSB as an Efficient Deductive Database Engine"))(POS (PAPER.PUBLICATION SAGONAS94 "Proceedings of the ACM SIGMOD International Conference on the Management of Data>"))(POS (PAPER.STARTPAGE SAGONAS94 442))(POS (PAPER.ENDPAGE SAGONAS94 453))(POS (PAPER.YEAR SAGONAS94 1994))(POS (PAPER.DESCRIPTION SAGONAS94 "
XSB is Warren's current Prolog implementation, which includes tabling.
"))(POS (PAPER.TOPIC SAGONAS94 "Logic Programming"))(POS (PAPER.INSTANCE SAIS94))(POS (PAPER.BIBTEX SAIS94 INPROCEEDINGS))(POS (PAPER.AUTHOR SAIS94 "Lakhdar Sais"))(POS (PAPER.TITLE SAIS94 "Characterization of the Set of Models by Means of Symmetries"))(POS (PAPER.PUBLICATION SAIS94 "Second International Workshop on Principles and Practice of Constraint Programming"))(POS (PAPER.LINK SAIS94 "http://citeseer.ist.psu.edu/162645.html"))(POS (PAPER.YEAR SAIS94 1994))(POS (PAPER.RANK SAIS94 "[**]"))(POS (PAPER.DESCRIPTION SAIS94 "
Sais gives an algorithm that seems to compute the characteristic models
of a given propositional, CNF theory.  There is no proof that the models
generated are exactly a set of characteristic models, but rather that
the models generated are non-symmetric.  [Maybe the equivalence is obvious,
but there is no theorem stating it.]
"))(POS (PAPER.TOPIC SAIS94 "Characteristic Models"))(POS (PAPER.INSTANCE SANDFORD80))(POS (PAPER.BIBTEX SANDFORD80 ARTICLE))(POS (PAPER.AUTHOR SANDFORD80 "David Sandford"))(POS (PAPER.TITLE SANDFORD80 "Using Sophisticated Models in Resolution Theorem Proving"))(POS (PAPER.PUBLISHER SANDFORD80 "Springer-Verlag"))(POS (PAPER.PUBLICATION SANDFORD80 "Lecture Notes in Computer Science"))(POS (PAPER.VOLUME SANDFORD80 "90"))(POS (PAPER.LINK SANDFORD80 ""))(POS (PAPER.YEAR SANDFORD80 1980))(POS (PAPER.RANK SANDFORD80 "[**]"))(POS (PAPER.DESCRIPTION SANDFORD80 "
Sandford describes a new refinement of semantic resolution, hereditary 
lock resolution, and a new approach for representing models as required 
in semantic resolution.  The pertinent part of the work is the model 
representation.  Semantic resolution puts clauses into two bins throughout 
the resolution process.  Part of the input to the procedure is a model, 
any model, and those clauses that are satisfied by the model are put into 
bin 1 while clauses not satisfied by the model are put into bin 2.  
This partitioning of clauses shrinks the search space since every resolution 
must use at least one clause from the set of unsatisfied clauses.  
Sandford describes a method for using a set of sentences to define that 
model (in possibly a totally different language) and using a satisfaction 
test to determine whether a clause belongs in bin 1 or 2.   Of course, 
the computational and complexity properties could be horrible, but so 
long as the satisfaction test is sound (only returns true when the sentences 
and clause are satisfiable), we retain completeness. 
"))(POS (PAPER.TOPIC SANDFORD80 "Model-Guided Proof Techniques"))(POS (PAPER.INSTANCE SCHULZ2001))(POS (PAPER.BIBTEX SCHULZ2001 INPROCEEDINGS))(POS (PAPER.AUTHOR SCHULZ2001 "S. Schulz"))(POS (PAPER.TITLE SCHULZ2001 "A Comparison of Different Techniques for Grounding Near-Propositional CNF Formulae"))(POS (PAPER.PUBLICATION SCHULZ2001 "Proc. 15th International FLAIRS Conference"))(POS (PAPER.STARTPAGE SCHULZ2001 72))(POS (PAPER.ENDPAGE SCHULZ2001 76))(POS (PAPER.LINK SCHULZ2001 "http://citeseer.ist.psu.edu/565512.html"))(POS (PAPER.YEAR SCHULZ2001 2002))(POS (PAPER.DESCRIPTION SCHULZ2001 "
Paper comparing various approaches for grounding a set of first-order, function-free clauses.  Won best-paper at FLAIR 2002.
"))(POS (PAPER.TOPIC SCHULZ2001 "Reformulation"))(POS (PAPER.INSTANCE SCHULZ2002))(POS (PAPER.BIBTEX SCHULZ2002 INPROCEEDINGS))(POS (PAPER.BIBTEX SCHULZ2002 ARTICLE))(POS (PAPER.AUTHOR SCHULZ2002 "Stephan Schulz"))(POS (PAPER.AUTHOR SCHULZ2002 "Stephan Schulz"))(POS (PAPER.TITLE SCHULZ2002 "A Comparison of Different Techniques for Grounding Near-Propositional CNF Formulae"))(POS (PAPER.TITLE SCHULZ2002 "E - A brainiac theorem prover"))(POS (PAPER.PUBLICATION SCHULZ2002 "Proceedings, 15th International FLAIRS Conference"))(POS (PAPER.PUBLICATION SCHULZ2002 "AI Communications"))(POS (PAPER.VOLUME SCHULZ2002 "15"))(POS (PAPER.STARTPAGE SCHULZ2002 72))(POS (PAPER.STARTPAGE SCHULZ2002 111))(POS (PAPER.ENDPAGE SCHULZ2002 76))(POS (PAPER.ENDPAGE SCHULZ2002 126))(POS (PAPER.LINK SCHULZ2002 "http://citeseer.ist.psu.edu/565512.html"))(POS (PAPER.LINK SCHULZ2002 "http://citeseer.ist.psu.edu/560030.html"))(POS (PAPER.YEAR SCHULZ2002 2002))(POS (PAPER.YEAR SCHULZ2002 2002))(POS (PAPER.RANK SCHULZ2002 ""))(POS (PAPER.DESCRIPTION SCHULZ2002 "
Schulz compares three techniques for reducing the cost of generating 
the grounding of universal clause sets without function symbols.  The
first is hypersplitting, a generalization of which is (now) used in
the model builders that ground and use SAT solvers, structural constraints,
restricting instantiations to avoid the creation of pure literals, and 
post-processing the grounded sentences via unit subsumption, unit
propagation, and tautology deletion.  The combination of all three
outperformed any one of the techniques.
"))(POS (PAPER.DESCRIPTION SCHULZ2002 "
Schulz describes E, a full first-order theorem prover with
equality.  It is a saturation-based prover from a purely 
equational view. It is based on the superposition calculus
with literal selection and was one of the first to use
the DISCOUNT algorithm.  The paper first describes the 
calculus, gives the proof search algorithm, discusses
search control by way of clause and literal selection,
term orderings, and auto configuration.  It delves into
implementation details: shared terms and indexing.
"))(POS (PAPER.TOPIC SCHULZ2002 "Herbrand Logic"))(POS (PAPER.TOPIC SCHULZ2002 "System Designs"))(POS (PAPER.INSTANCE SCHUTZ96))(POS (PAPER.BIBTEX SCHUTZ96 ARTICLE))(POS (PAPER.AUTHOR SCHUTZ96 "Heribert Schutz"))(POS (PAPER.TITLE SCHUTZ96 "Comparison of Two Complementary Herbrand Model Generators"))(POS (PAPER.LINK SCHUTZ96 "http://citeseer.ist.psu.edu/122874.html"))(POS (PAPER.YEAR SCHUTZ96 1996))(POS (PAPER.RANK SCHUTZ96 "[**]"))(POS (PAPER.DESCRIPTION SCHUTZ96 "
Schutz describes and analyzes two different Herbrand model-building 
techniques built on hyperresolution.  He shows that some of the 
strengths of one can be used to help on cases where the other is weak
and vice versa.  
"))(POS (PAPER.TOPIC SCHUTZ96 "Model Building"))(POS (PAPER.INSTANCE SELMAN91))(POS (PAPER.BIBTEX SELMAN91 INPROCEEDINGS))(POS (PAPER.AUTHOR SELMAN91 "Bart Selman and Henry Kautz"))(POS (PAPER.TITLE SELMAN91 "Knowledge Compilation Using Horn Approximations"))(POS (PAPER.PUBLICATION SELMAN91 "AAAI"))(POS (PAPER.LINK SELMAN91 "http://citeseer.ist.psu.edu/selman91knowledge.html"))(POS (PAPER.YEAR SELMAN91 1991))(POS (PAPER.RANK SELMAN91 "[****]"))(POS (PAPER.DESCRIPTION SELMAN91 "
This seems to be the seminal work on Knowledge Compilation.  Selman and
Kautz investigate finding two Horn approximations for a propositional 
knowledge base: one that is too strong and one that is too weak.  The 
algorithms for computing those approximations are anytime algorithms. 
To determine whether a given sentence p is entailed by the original
knowledge base, return yes if the strong approximation entails it and
no if the weak one doesn't.  If neither of these two cases hold, resort
to the original knowledge base.  Since entailment for propositional Horn
requires linear time, the worst case wastes O(2n) computation time, but
the best case might save exponential time.
"))(POS (PAPER.TOPIC SELMAN91 "Knowledge Base Compilation"))(POS (PAPER.INSTANCE SELMAN96))(POS (PAPER.BIBTEX SELMAN96 ARTICLE))(POS (PAPER.AUTHOR SELMAN96 "Bart Selman and Henry Kautz"))(POS (PAPER.TITLE SELMAN96 "Knowledge Compilation and Theory Approximation"))(POS (PAPER.PUBLICATION SELMAN96 "Journal of the ACM "))(POS (PAPER.VOLUME SELMAN96 "43(2)"))(POS (PAPER.STARTPAGE SELMAN96 193))(POS (PAPER.ENDPAGE SELMAN96 224))(POS (PAPER.LINK SELMAN96 "http://citeseer.ist.psu.edu/41052.html"))(POS (PAPER.YEAR SELMAN96 1996))(POS (PAPER.RANK SELMAN96 "[*****]"))(POS (PAPER.DESCRIPTION SELMAN96 "
This paper essentially glues together the work of kautz91, selman91,
kautz92,  and kautz95.  Especially noteworthy is the thorough related
work section.  It also brought together the fact that the Greatest
Upper Bound approximation of a propositional theory is always linear
in the size of the theory, but the Least Upper Bound can be exponential
in the size of the theory.
"))(POS (PAPER.TOPIC SELMAN96 "Knowledge Base Compilation"))(POS (PAPER.RELATED SELMAN96 SELMAN91))(POS (PAPER.RELATED SELMAN96 KAUTZ91))(POS (PAPER.RELATED SELMAN96 KAUTZ92))(POS (PAPER.RELATED SELMAN96 KAUTZ95))(POS (PAPER.INSTANCE SHERL93))(POS (PAPER.AUTHOR SHERL93 "R. Sherl and H. Levesque"))(POS (PAPER.TITLE SHERL93 "The frame problem and knowledge-producing actions"))(POS (PAPER.LINK SHERL93 "http://citeseer.ist.psu.edu/scherl93frame.html"))(POS (PAPER.YEAR SHERL93 1993))(POS (PAPER.DESCRIPTION SHERL93 "None yet.
"))(POS (PAPER.TOPIC SHERL93 "Planning with Sensing Actions"))(POS (PAPER.INSTANCE SHOSTAK84))(POS (PAPER.BIBTEX SHOSTAK84 ARTICLE))(POS (PAPER.AUTHOR SHOSTAK84 "Robert Shostak"))(POS (PAPER.TITLE SHOSTAK84 "Deciding Combinations of Theories"))(POS (PAPER.PUBLICATION SHOSTAK84 "Journal of the ACM
           "))(POS (PAPER.VOLUME SHOSTAK84 "31"))(POS (PAPER.STARTPAGE SHOSTAK84 1))(POS (PAPER.ENDPAGE SHOSTAK84 12))(POS (PAPER.LINK SHOSTAK84 "http://portal.acm.org/citation.cfm?id=322411&dl=ACM&coll=portal"))(POS (PAPER.YEAR SHOSTAK84 1984))(POS (PAPER.RANK SHOSTAK84 "[****]"))(POS (PAPER.DESCRIPTION SHOSTAK84 "
Shostak describes what is now commonly known as Shostak's decision procedure.
The decision procedure works on algebraically solvable and canonizable 
equational theories.  It functions by computing the congruence closure of 
the terms in the language representing each one by their canonical forms.  
The canonization takes into account both interpreted and unintepreted
functions.  Unlike Nelson Oppen, Shostak shows how to merge the decision
procedures for two theories by taking a solver and canonizer for each and
building a single solver and canonizer pair for the union of the theories.
"))(POS (PAPER.TOPIC SHOSTAK84 "Nelson-Oppen and Shostak"))(POS (PAPER.RELATED SHOSTAK84 NELSON79))(POS (PAPER.INSTANCE SIKKA96))(POS (PAPER.BIBTEX SIKKA96 PHDTHESIS))(POS (PAPER.AUTHOR SIKKA96 "Vishal Sikka"))(POS (PAPER.TITLE SIKKA96 "Integrating Specialized Procedures into Proof Systems"))(POS (PAPER.PUBLISHER SIKKA96 "Stanford University"))(POS (PAPER.LINK SIKKA96 "http://library.stanford.edu/depts/mathcs/mathcscoll/techreports.html"))(POS (PAPER.YEAR SIKKA96 1996))(POS (PAPER.RANK SIKKA96 "[*****]"))(POS (PAPER.DESCRIPTION SIKKA96 "
Compiled code can be used by a theorem prover to expedite a proof.  
Sikka describes a general method for integrating such specialized 
procedures into proof systems using function constants, data 
structure constants, and the 'apply' operator.  
"))(POS (PAPER.TOPIC SIKKA96 "Theorem Proving with Attachments"))(POS (PAPER.INSTANCE SIPSER))(POS (PAPER.BIBTEX SIPSER BOOK))(POS (PAPER.AUTHOR SIPSER "Michael Sipser"))(POS (PAPER.TITLE SIPSER "Introduction to the Theory of Computation"))(POS (PAPER.PUBLISHER SIPSER "Brooks Cole"))(POS (PAPER.LINK SIPSER "http://www.amazon.com/exec/obidos/tg/detail/-/053494728X/qid=1062605920/sr=1-1/ref=sr_1_1/102-6107129-2481765?v=glance&s=books"))(POS (PAPER.YEAR SIPSER 1996))(POS (PAPER.RANK SIPSER "[*****]"))(POS (PAPER.DESCRIPTION SIPSER "
One of the two definitive introductions to the theory of computation.  Sipser
covers automata and languages, computability theory, and complexity theory.
"))(POS (PAPER.TOPIC SIPSER ""))(POS (PAPER.INSTANCE SLANEY93))(POS (PAPER.BIBTEX SLANEY93 INPROCEEDINGS))(POS (PAPER.AUTHOR SLANEY93 "John Slaney"))(POS (PAPER.TITLE SLANEY93 "SCOTT: A Model-Guided Theorem Prover"))(POS (PAPER.PUBLICATION SLANEY93 "IJCAI"))(POS (PAPER.LINK SLANEY93 "http://citeseer.ist.psu.edu/slaney93scott.html"))(POS (PAPER.YEAR SLANEY93 1993))(POS (PAPER.RANK SLANEY93 "[***]"))(POS (PAPER.DESCRIPTION SLANEY93 "
Slaney describes a case study of SCOTT (Semantically Constrained
Otter).  SCOTT consists of OTTER augmented with a model-generator
FINDER.  It restricts the resolutions done by Otter to include one
parent clause not true in the model being generated.  A new model
is generated every time a new clause is generated that is false
in the current model (up to 100 clauses).  If no new model can 
be found, the old one is used.  SCOTT retains completeness
for binary resolution since every model generated is a model of the
usable list (those axioms assumed to be consistent).  
"))(POS (PAPER.TOPIC SLANEY93 "Model-Guided Proof Techniques"))(POS (PAPER.INSTANCE SLANEY94))(POS (PAPER.BIBTEX SLANEY94 INPROCEEDINGS))(POS (PAPER.BIBTEX SLANEY94 INPROCEEDINGS))(POS (PAPER.AUTHOR SLANEY94 "John Slaney"))(POS (PAPER.AUTHOR SLANEY94 "John Slaney"))(POS (PAPER.TITLE SLANEY94 "Finder: Finite Domain Enumerator System Description"))(POS (PAPER.TITLE SLANEY94 "The Crisis in Finite Mathematics: Automated Reasoning as Cause and Cure"))(POS (PAPER.PUBLICATION SLANEY94 "In proceedings, CADE-12"))(POS (PAPER.PUBLICATION SLANEY94 "CADE"))(POS (PAPER.LINK SLANEY94 "http://citeseer.ist.psu.edu/252758.html"))(POS (PAPER.LINK SLANEY94 "http://arp.anu.edu.au/~jks/constraints.html"))(POS (PAPER.YEAR SLANEY94 1994))(POS (PAPER.YEAR SLANEY94 1994))(POS (PAPER.RANK SLANEY94 ""))(POS (PAPER.DESCRIPTION SLANEY94 "
Very short description of Finder, a model builder for FOL.  It grounds and
then uses a combination of tableaux and negative hyperresolution.  Used
in SCOTT to constrain the search space of Otter.
"))(POS (PAPER.DESCRIPTION SLANEY94 "
Slaney describes the problems associated with using machines to exhaustively
check a solution space as proof of the non-existence of a solution.  Is that
really a proof?  Afterall, no one will actually verify such a proof.
But, if a theorem prover outputs a trace, we can check the trace with an
independent proof checker.  This trace-checking may be much easier than
proving the correctness of a theorem prover.
"))(POS (PAPER.TOPIC SLANEY94 "Model Building"))(POS (PAPER.TOPIC SLANEY94 "Theorem Proving"))(POS (PAPER.INSTANCE SOUTCHANSKI2000))(POS (PAPER.AUTHOR SOUTCHANSKI2000 "Mikhail Soutchanski"))(POS (PAPER.TITLE SOUTCHANSKI2000 "An On-line Decision-Theoretic Golog Interpreter"))(POS (PAPER.PUBLICATION SOUTCHANSKI2000 "AAAI"))(POS (PAPER.LINK SOUTCHANSKI2000 "http://www.cs.toronto.edu/~cebly/papers.html"))(POS (PAPER.YEAR SOUTCHANSKI2000 2000))(POS (PAPER.DESCRIPTION SOUTCHANSKI2000 "
Building on previous work, Southchanski couples Golog with a decision-theoretic planner based on Markov decision processes.  The original work found a optimal conditional policy, the probability that the policy could be executed, and the expected utility of the policy all offline.  This is really only possible in an environment without sensing actions with continuous return values.  Soutchanski also points out that only a single policy can be computed for an entire program, even if the program could be easily partitioned into two independent portions.  Soutchanski introduces optimize(p1);p2 to indicate that a single policy should be found for program p1 and another for program p2.  He also gives a new formulation of sensing actions of the form sense(act, value, s), meaning the result of executing the action act is value in situation s.  Since Golog is an online interpreter, sensing actions with continuous return values can be handled.
"))(POS (PAPER.TOPIC SOUTCHANSKI2000 "Logic Programming"))(POS (PAPER.INSTANCE SQALLI2001))(POS (PAPER.AUTHOR SQALLI2001 "Mohammed Sqalli and Eugene Freuder"))(POS (PAPER.TITLE SQALLI2001 "Solving InterOperability Problems Using Object-Oriented CSP 
 Modeling"))(POS (PAPER.LINK SQALLI2001 "http://citeseer.ist.psu.edu/487285.html"))(POS (PAPER.YEAR SQALLI2001 2001))(POS (PAPER.RANK SQALLI2001 "[**]"))(POS (PAPER.DESCRIPTION SQALLI2001 "
Sqalli and Freuder describe a combination of Case-based reasoning
and constraint satisfaction.  They use Paltrinieri's OOCSP definition
except that they add methods to classes.  To solve an OOCSP, they
convert it to a standard CSP.  
"))(POS (PAPER.TOPIC SQALLI2001 "Object Oriented Constraint Satisfaction"))(POS (PAPER.INSTANCE STICKEL85))(POS (PAPER.BIBTEX STICKEL85 ARTICLE))(POS (PAPER.AUTHOR STICKEL85 "Mark Stickel"))(POS (PAPER.TITLE STICKEL85 "Automated Deduction by Theory Resolution"))(POS (PAPER.PUBLICATION STICKEL85 "Journal of Automated Reasoning"))(POS (PAPER.VOLUME STICKEL85 "1"))(POS (PAPER.STARTPAGE STICKEL85 333))(POS (PAPER.ENDPAGE STICKEL85 356))(POS (PAPER.LINK STICKEL85 "http://citeseer.ist.psu.edu/stickel85automated.html"))(POS (PAPER.YEAR STICKEL85 1985))(POS (PAPER.RANK STICKEL85 "[***]"))(POS (PAPER.DESCRIPTION STICKEL85 "
The theory resolution paper.
"))(POS (PAPER.TOPIC STICKEL85 "Theorem Proving with Attachments"))(POS (PAPER.INSTANCE STICKEL87))(POS (PAPER.AUTHOR STICKEL87 "Mark Stickel"))(POS (PAPER.TITLE STICKEL87 "A Prolog Technology Theorem Prover"))(POS (PAPER.LINK STICKEL87 "http://citeseer.ist.psu.edu/stickel87prolog.html"))(POS (PAPER.YEAR STICKEL87 1987))(POS (PAPER.DESCRIPTION STICKEL87 "
"))(POS (PAPER.TOPIC STICKEL87 "Calculi"))(POS (PAPER.INSTANCE STICKEL94))(POS (PAPER.BIBTEX STICKEL94 ARTICLE))(POS (PAPER.AUTHOR STICKEL94 "Mark Stickel and Richard Waldinger and Michael Lowry and Thomas Pressburger and Ian Underwood"))(POS (PAPER.TITLE STICKEL94 "Deductive Composition of Astronomical Software from Subroutine Libraries"))(POS (PAPER.PUBLICATION STICKEL94 "Conference on Automated Deduction"))(POS (PAPER.STARTPAGE STICKEL94 341))(POS (PAPER.ENDPAGE STICKEL94 355))(POS (PAPER.LINK STICKEL94 "http://citeseer.ist.psu.edu/67907.html"))(POS (PAPER.YEAR STICKEL94 1994))(POS (PAPER.RANK STICKEL94 "[*]"))(POS (PAPER.DESCRIPTION STICKEL94 "
The authors describe a system that allows a user to graphically describe
a specification for a system relying on subroutine libraries and then uses
automated deduction techniques to produce a proof of the specification from
axioms describing the library.  That proof is then translated into a 
Fortran program.
"))(POS (PAPER.TOPIC STICKEL94 "Miscellaneous"))(POS (PAPER.INSTANCE STONE))(POS (PAPER.BIBTEX STONE ARTICLE))(POS (PAPER.AUTHOR STONE "Nicholas Stone"))(POS (PAPER.TITLE STONE "Object-Oriented Constraint Satisfaction Planning for Whole Farm
Management"))(POS (PAPER.PUBLICATION STONE "AI Applications"))(POS (PAPER.LINK STONE "http://everest.ento.vt.edu/Publications/NDS-Paper-.html"))(POS (PAPER.YEAR STONE NIL))(POS (PAPER.RANK STONE "[*]"))(POS (PAPER.DESCRIPTION STONE "
Stone describes an Object-oriented approach to writing a planner.
"))(POS (PAPER.TOPIC STONE "Miscellaneous"))(POS (PAPER.INSTANCE STRZALKOWSKI91))(POS (PAPER.BIBTEX STRZALKOWSKI91 ARTICLE))(POS (PAPER.AUTHOR STRZALKOWSKI91 "Tomek Strzalkowski"))(POS (PAPER.TITLE STRZALKOWSKI91 "A General Computational Method for Grammar Inversion"))(POS (PAPER.LINK STRZALKOWSKI91 "http://acl.ldc.upenn.edu/W/W91/W91-0112.pdf"))(POS (PAPER.YEAR STRZALKOWSKI91 1991))(POS (PAPER.RANK STRZALKOWSKI91 "[***]"))(POS (PAPER.DESCRIPTION STRZALKOWSKI91 "
Strzalkowski describes a procedure for converting a unification grammar defined in Prolog, which was built for sentence parsing, into another set of Prolog rules for sentence generation.
"))(POS (PAPER.TOPIC STRZALKOWSKI91 "Natural Language Processing"))(POS (PAPER.INSTANCE SUCHENEK93))(POS (PAPER.BIBTEX SUCHENEK93 ARTICLE))(POS (PAPER.AUTHOR SUCHENEK93 "Marek Suchenek"))(POS (PAPER.TITLE SUCHENEK93 "First-Order Syntactic Characterizations of Minimal Entailment, Domain-Minimal Entailment, and Herbrand Entailment"))(POS (PAPER.LINK SUCHENEK93 "www.springerlink.com/index/L14483241892Q613.pdf"))(POS (PAPER.YEAR SUCHENEK93 1993))(POS (PAPER.RANK SUCHENEK93 "[***]"))(POS (PAPER.DESCRIPTION SUCHENEK93 "
Suchenek treats formally three types of minimal-model theory: minimal
entailment (cwa), Herbrand entailment (only the Herbrand models exist),
and domain-minimal entailment (only elements in the domain are those
that must be in the domain).  Touches on domain closure, unique-names,
deductive databases, closed world, non-mon.
"))(POS (PAPER.TOPIC SUCHENEK93 "Herbrand Logic"))(POS (PAPER.INSTANCE SUSSMAN74))(POS (PAPER.AUTHOR SUSSMAN74 "Gerald J. Sussman"))(POS (PAPER.TITLE SUSSMAN74 "The Virtuous Nature of Bugs"))(POS (PAPER.YEAR SUSSMAN74 1974))(POS (PAPER.DESCRIPTION SUSSMAN74 "
Sussman describes HACKER, a total-order planner that composes stored subroutines to achieve its goal.  If subgoals conflict, HACKER identifies a bug in the plan it has generated and debugs it.  To do so, it matches a model of the behavior of the misbehaving plan with prototypes of bugs.  Once a match is found, a 'critic' is compiled with what HACKER has learned from the debugging.  In future plans, critics are used to avoid pitfalls already seen.
"))(POS (PAPER.TOPIC SUSSMAN74 "Historical"))(POS (PAPER.INSTANCE SUTCLIFFE98))(POS (PAPER.BIBTEX SUTCLIFFE98 ARTICLE))(POS (PAPER.AUTHOR SUTCLIFFE98 "G. Sutcliffe and C.B. Suttner"))(POS (PAPER.TITLE SUTCLIFFE98 "The TPTP Problem Library: CNF Release v1.2.1"))(POS (PAPER.PUBLICATION SUTCLIFFE98 "Journal of Automated Reasoning"))(POS (PAPER.VOLUME SUTCLIFFE98 "21(2)"))(POS (PAPER.STARTPAGE SUTCLIFFE98 177))(POS (PAPER.ENDPAGE SUTCLIFFE98 203))(POS (PAPER.LINK SUTCLIFFE98 "http://citeseer.ist.psu.edu/30379.html"))(POS (PAPER.YEAR SUTCLIFFE98 1998))(POS (PAPER.RANK SUTCLIFFE98 ""))(POS (PAPER.DESCRIPTION SUTCLIFFE98 "
Paper on the TPTP library.
"))(POS (PAPER.TOPIC SUTCLIFFE98 "Theorem Proving"))(POS (PAPER.INSTANCE SUTCLIFFE98CADE))(POS (PAPER.BIBTEX SUTCLIFFE98CADE ARTICLE))(POS (PAPER.AUTHOR SUTCLIFFE98CADE "Christian Suttner and Geoff Sutcliffe"))(POS (PAPER.TITLE SUTCLIFFE98CADE "The CADE-14 ATP System Competition"))(POS (PAPER.PUBLICATION SUTCLIFFE98CADE "Journal of Automated Reasoning"))(POS (PAPER.VOLUME SUTCLIFFE98CADE "21(1)"))(POS (PAPER.STARTPAGE SUTCLIFFE98CADE 99))(POS (PAPER.ENDPAGE SUTCLIFFE98CADE 134))(POS (PAPER.LINK SUTCLIFFE98CADE "http://citeseer.ist.psu.edu/87162.html"))(POS (PAPER.YEAR SUTCLIFFE98CADE 1998))(POS (PAPER.RANK SUTCLIFFE98CADE ""))(POS (PAPER.DESCRIPTION SUTCLIFFE98CADE "
Paper on the results of one of the CASC competitions: the yearly first-order theorem proving competition held at CADE.
"))(POS (PAPER.TOPIC SUTCLIFFE98CADE "Theorem Proving"))(POS (PAPER.INSTANCE SWAMY2000))(POS (PAPER.BIBTEX SWAMY2000 PHDTHESIS))(POS (PAPER.AUTHOR SWAMY2000 "Nikhil Swamy"))(POS (PAPER.TITLE SWAMY2000 "A Study in Automated Reasoning about Abstract Algebra"))(POS (PAPER.LINK SWAMY2000 "http://www.cs.umd.edu/~nswamy/thesis/ch2-IntroToATP.ps"))(POS (PAPER.YEAR SWAMY2000 2000))(POS (PAPER.RANK SWAMY2000 ""))(POS (PAPER.DESCRIPTION SWAMY2000 "
Swamy's second chapter (Advanced theorem proving techniques) gives a good
overview of resolution-style theorem-proving and definitions/proofs
of UR-Resolution, Hyperresolution, factoring, paramodulation,
subsumption, demodulation, set of support, and Knuth-Bendix completion.
Link goes to said chapter.
"))(POS (PAPER.TOPIC SWAMY2000 "Theorem Proving"))(POS (PAPER.INSTANCE TAMMET2001))(POS (PAPER.BIBTEX TAMMET2001 MISC))(POS (PAPER.AUTHOR TAMMET2001 "Tanel Tammet"))(POS (PAPER.TITLE TAMMET2001 "Finite model building: improvements and comparisons"))(POS (PAPER.LINK TAMMET2001 "http://citeseer.ist.psu.edu/675660.html"))(POS (PAPER.YEAR TAMMET2001 2001))(POS (PAPER.DESCRIPTION TAMMET2001 "
Comparison of Mace 2.0 and Falcon-style finite model builders, along
with some enhancements to Falcon to produce Gandolf.  Mace 2.0 used flattening,
grounding, and boolean sat solvers.  Falcon used consequence finding during
incremental model generation, much like arc consistency in CSPs.
"))(POS (PAPER.TOPIC TAMMET2001 "Model Building"))(POS (PAPER.INSTANCE TAMMET2002))(POS (PAPER.BIBTEX TAMMET2002 ARTICLE))(POS (PAPER.AUTHOR TAMMET2002 "Tanel Tammete"))(POS (PAPER.TITLE TAMMET2002 "Finite model building: improvements and comparisons"))(POS (PAPER.LINK TAMMET2002 "http://citeseer.ist.psu.edu/675660.html"))(POS (PAPER.YEAR TAMMET2002 2002))(POS (PAPER.RANK TAMMET2002 ""))(POS (PAPER.DESCRIPTION TAMMET2002 "
Tammet gives an overview of two different styles of finite model builders
after situating the topic in the context of automated reasoning: Mace and
Falcon.  Mace operates by reducing the problem to one of propositional 
satisfiability and employing a SAT solver.  Tammet describes an augmentation
of Mace (nonground splitting) to reduce the number of distinct variables
in a clause (suboptimally).  Falcon works almost as a naive model builder
but makes certain inferences to prune the search.  Both the Mace-style
and Falcon-style builder were implemented  in Gandalf, a theorem-prover/
model checker written in Scheme and compiled into C.  Various versions
of the two builders were run over the 2002 satisfiable CASC problems,
and some conclusions were drawn.
"))(POS (PAPER.TOPIC TAMMET2002 "Model Building"))(POS (PAPER.INSTANCE THIFFAULT2004))(POS (PAPER.BIBTEX THIFFAULT2004 INPROCEEDINGS))(POS (PAPER.AUTHOR THIFFAULT2004 "Christian Thiffault and Fahiem Bacchus and Toby Walsh"))(POS (PAPER.TITLE THIFFAULT2004 "Solving Non-clausal Formulas with DPLL Search"))(POS (PAPER.PUBLICATION THIFFAULT2004 "Proceedings of the 10th International Conference on Principles and Practice of Constraint Programming"))(POS (PAPER.STARTPAGE THIFFAULT2004 663))(POS (PAPER.ENDPAGE THIFFAULT2004 678))(POS (PAPER.LINK THIFFAULT2004 "http://www.satisfiability.org/SAT04/accepted/71.html"))(POS (PAPER.YEAR THIFFAULT2004 2004))(POS (PAPER.DESCRIPTION THIFFAULT2004 "
A paper that adopts DPLL to handle Non-CNF directly.
"))(POS (PAPER.TOPIC THIFFAULT2004 "SAT Solving"))(POS (PAPER.INSTANCE TIN94))(POS (PAPER.BIBTEX TIN94 ARTICLE))(POS (PAPER.AUTHOR TIN94 "Erkan Tin and Varol Akman"))(POS (PAPER.TITLE TIN94 "Computatinal Situation Theory"))(POS (PAPER.PUBLICATION TIN94 "SIGART Bulletin"))(POS (PAPER.VOLUME TIN94 "5(4)"))(POS (PAPER.STARTPAGE TIN94 4))(POS (PAPER.ENDPAGE TIN94 17))(POS (PAPER.LINK TIN94 "http://portal.acm.org/citation.cfm?id=191604.191608"))(POS (PAPER.YEAR TIN94 1994))(POS (PAPER.RANK TIN94 "[*]"))(POS (PAPER.DESCRIPTION TIN94 "
Tin and Akman give an overview of Situation Theory, which allows
one to describe states of the world relative to spatio and temporal
positions.  This theory is used to give semantics to natural language
utterances.  The authors then overview several systems that deal
with situation theory.
"))(POS (PAPER.TOPIC TIN94 "Miscellaneous"))(POS (PAPER.INSTANCE TINELLI2000))(POS (PAPER.BIBTEX TINELLI2000 INPROCEEDINGS))(POS (PAPER.AUTHOR TINELLI2000 "Cesare Tinelli"))(POS (PAPER.TITLE TINELLI2000 "Cooperation of Background Reasoners in Theory Reasoning by
Residue Sharing"))(POS (PAPER.PUBLICATION TINELLI2000 "International Workshop on First Order Theorem Proving (FTP)
           "))(POS (PAPER.LINK TINELLI2000 "http://citeseer.ist.psu.edu/572497.html"))(POS (PAPER.YEAR TINELLI2000 2000))(POS (PAPER.RANK TINELLI2000 "[****]"))(POS (PAPER.DESCRIPTION TINELLI2000 "
Tinelli shows how to use theory reasoning to combine specialized reasoners in
a sound and complete way in the context of semantic tableaus.  The theories
those reasoners embody must be universal, a requirement for theory reasoning.
Tinelli's results hinge on an interpolation lemma that
requires all the background theory signatures to include all the
same functions.   This lemma shows that determining unsatisfiability of
wrt a set of theories requires only passing disjunctions of literals in
the common signature among the theories.  One can thus alter the tableau
procedure by allowing a new type of derivation: hand off a subset of the
literals on a particular branch which are of the appropriate signature
to the corresponding background reasoner.  If the reasoner returns
'unsatisfiable', close the branch; otherwise, add the residue to the
end of the branch.
"))(POS (PAPER.TOPIC TINELLI2000 "Theorem Proving with Attachments"))(POS (PAPER.INSTANCE TORLAK2006))(POS (PAPER.BIBTEX TORLAK2006 TECHREPORT))(POS (PAPER.AUTHOR TORLAK2006 "Emina Torlak and Daniel Jackson"))(POS (PAPER.TITLE TORLAK2006 "The Design of a Relational Engine"))(POS (PAPER.PUBLISHER TORLAK2006 "MIT-CSAIL"))(POS (PAPER.LINK TORLAK2006 "http://web.mit.edu/emina/www/kodkod.html"))(POS (PAPER.YEAR TORLAK2006 2006))(POS (PAPER.DESCRIPTION TORLAK2006 "
The authors describe a model-builder for a relational logic with transitive
closure and a finite domain.  The system does symmetry detection, compresses
expressions using compact boolean circuits, and
translates to propositional logic to answer queries using a SAT solver.
"))(POS (PAPER.TOPIC TORLAK2006 "Model Building"))(POS (PAPER.INSTANCE ULLMAN))(POS (PAPER.BIBTEX ULLMAN BOOK))(POS (PAPER.AUTHOR ULLMAN "J. Hopcroft and J. Ullman"))(POS (PAPER.TITLE ULLMAN "Introduction to Automata Theory, Languages, and Computation"))(POS (PAPER.PUBLISHER ULLMAN "Addison Wesley"))(POS (PAPER.LINK ULLMAN "http://www-db.stanford.edu/~ullman/ialc.html"))(POS (PAPER.YEAR ULLMAN 1979))(POS (PAPER.RANK ULLMAN "[*****]"))(POS (PAPER.DESCRIPTION ULLMAN "
One of the two definitive introductions to the theory of computation. Hopcroft
and Ullman--the classic.
"))(POS (PAPER.TOPIC ULLMAN ""))(POS (PAPER.INSTANCE ULLMAN96))(POS (PAPER.BIBTEX ULLMAN96 ARTICLE))(POS (PAPER.AUTHOR ULLMAN96 "Jeffrey Ullman"))(POS (PAPER.TITLE ULLMAN96 "The Database Approach to Knowledge Representation"))(POS (PAPER.PUBLICATION ULLMAN96 "AAAI"))(POS (PAPER.LINK ULLMAN96 "http://citeseer.ist.psu.edu/ullman96database.html"))(POS (PAPER.YEAR ULLMAN96 1996))(POS (PAPER.RANK ULLMAN96 "[****]"))(POS (PAPER.DESCRIPTION ULLMAN96 "
Ullman explains to the AI community the database perspective on
knowledge representation: start at low expressiveness and efficient computation
and work your way up.  Datalog (prolog w/o negation or functions)
is given the fixed-point semantics.  When extended with negation,
the least-fixed-point semantics are troublesome; stratified negation
and well-founded semantics have been developed to handle this.
Query containment of conjunctive queries is NP complete in general,
but is linear if no predicate appears more than twice in any
query.  Whether a conjunctive query is contained in a Datalog
program is exponential, and the reverse is decidable.  Rewriting
a query in terms of views has been done when the views are 
conjunctive queries as well as when the views are described
by Datalog programs.  
"))(POS (PAPER.TOPIC ULLMAN96 "Logical Knowledge Representation"))(POS (PAPER.INSTANCE ULLMANDB))(POS (PAPER.BIBTEX ULLMANDB BOOK))(POS (PAPER.AUTHOR ULLMANDB "Jeffrey Ullman"))(POS (PAPER.TITLE ULLMANDB "Principles of Database and Knowledge-Base Systems"))(POS (PAPER.PUBLISHER ULLMANDB "Computer Science Press"))(POS (PAPER.LINK ULLMANDB "http://www.amazon.com/exec/obidos/tg/detail/-/0716781581/qid=1110684085/sr=8-3/ref=sr_8_xs_ap_i3_xgl14/104-0791189-4759116?v=glance&s=books&n=507846"))(POS (PAPER.YEAR ULLMANDB 1989))(POS (PAPER.RANK ULLMANDB "[*****]"))(POS (PAPER.DESCRIPTION ULLMANDB "
This two-volume set describes how database principles can be applied to 
produce knowledge-based systems.
"))(POS (PAPER.TOPIC ULLMANDB ""))(POS (PAPER.INSTANCE URIBE2000))(POS (PAPER.BIBTEX URIBE2000 INPROCEEDINGS))(POS (PAPER.AUTHOR URIBE2000 "Tomas Uribe"))(POS (PAPER.TITLE URIBE2000 "Combinations of Model Checking and Theorem Proving"))(POS (PAPER.PUBLICATION URIBE2000 "Frontiers of Combining Systems (FroCoS)"))(POS (PAPER.STARTPAGE URIBE2000 151))(POS (PAPER.ENDPAGE URIBE2000 170))(POS (PAPER.LINK URIBE2000 "http://citeseer.ist.psu.edu/uribe00combinations.html"))(POS (PAPER.YEAR URIBE2000 2000))(POS (PAPER.RANK URIBE2000 "[****]"))(POS (PAPER.DESCRIPTION URIBE2000 "
Uribe surveys combinations of model checkers and theorem provers in the
context of formal verification.  The paper is pretty much self-contained,
explaining transition systems, fair transition systems,
finite-state model checking, deductive verification, abstraction, and
invariant generation.   Then Uribe discusses loosely coupled systems,
which treat the model checker/theorem prover as a black box. Modularity
and abstraction, general deductive environments (debugging, incremental
verification, and formal decomposition), and abstraction generation using
theorem proving have all been investigated in this loosely-coupled way.  
Lastly he considers tightly coupled systems.  Diagram-based
formalisms provide abstractions.  Model checking infinite-state systems
can also be attacked with abstraction.  A handful of tightly integrated
systems are also mentioned.  This survey feels like it is made up of a
hodge-podge of attempts--whether that is characteristic of the field
or the paper is unclear.
"))(POS (PAPER.TOPIC URIBE2000 "Model Checking"))(POS (PAPER.INSTANCE VANGELDER91))(POS (PAPER.BIBTEX VANGELDER91 ARTICLE))(POS (PAPER.AUTHOR VANGELDER91 "Allen van Gelder and Kenneth Ross and John Schlipf"))(POS (PAPER.TITLE VANGELDER91 "The Well-Founded Semantics for General Logic Programs"))(POS (PAPER.PUBLICATION VANGELDER91 "Journal of the ACM"))(POS (PAPER.VOLUME VANGELDER91 "38(3)"))(POS (PAPER.STARTPAGE VANGELDER91 620))(POS (PAPER.ENDPAGE VANGELDER91 650))(POS (PAPER.LINK VANGELDER91 "http://citeseer.ist.psu.edu/gelder91wellfounded.html"))(POS (PAPER.YEAR VANGELDER91 1991))(POS (PAPER.DESCRIPTION VANGELDER91 "
Well-founded semantics for logic programming.
"))(POS (PAPER.TOPIC VANGELDER91 "Logic Programming"))(POS (PAPER.INSTANCE VANHOOF2004))(POS (PAPER.BIBTEX VANHOOF2004 ARTICLE))(POS (PAPER.AUTHOR VANHOOF2004 "Wim Vanhoof"))(POS (PAPER.TITLE VANHOOF2004 "Searching Semantically Equivalent Code Fragments in Logic Programs"))(POS (PAPER.PUBLICATION VANHOOF2004 "14th International Symposium, Logic Based Program Synthesis and Trnasformation (LOPSTR)"))(POS (PAPER.STARTPAGE VANHOOF2004 1))(POS (PAPER.ENDPAGE VANHOOF2004 18))(POS (PAPER.LINK VANHOOF2004 "http://wotan.liu.edu/docis/dbl/lopstr/index.html"))(POS (PAPER.YEAR VANHOOF2004 2004))(POS (PAPER.DESCRIPTION VANHOOF2004 "
In the context of logic programming over Horn rules, 
Vanhoof considers three problems: (1) determining when some portion
of a rule body is equivalent to a portion of another rule body, (2) 
determining when two relations are identical up to argument permutation,
and (3) whether two portions of rule bodies share enough functionality
to be generalized as a higher-order rule, e.g. mapcar.  The nice
part about this topic of semantic equivalence in LP is that two
relations/conjunctions are equivalent iff they have the same extensions.
Vanhoof gives approximation algorithms, i.e. algorithms that are 
sufficient, for determining various kinds of semantic equivalences.
"))(POS (PAPER.TOPIC VANHOOF2004 "Reformulation"))(POS (PAPER.INSTANCE VARDI82))(POS (PAPER.BIBTEX VARDI82 INPROCEEDINGS))(POS (PAPER.AUTHOR VARDI82 "Moshe Vardi"))(POS (PAPER.TITLE VARDI82 "The complexity of relational query languages"))(POS (PAPER.PUBLICATION VARDI82 "Proceedings of the fourteenth annual ACM symposium on Theory of computing"))(POS (PAPER.STARTPAGE VARDI82 137))(POS (PAPER.ENDPAGE VARDI82 146))(POS (PAPER.LINK VARDI82 "http://portal.acm.org/citation.cfm?id=802186&dl=ACM&coll=GUIDE"))(POS (PAPER.YEAR VARDI82 1982))(POS (PAPER.DESCRIPTION VARDI82 "
Data and expression complexity results for various database query languages.
"))(POS (PAPER.TOPIC VARDI82 "Databases"))(POS (PAPER.INSTANCE VOROBYOV98))(POS (PAPER.BIBTEX VOROBYOV98 INPROCEEDINGS))(POS (PAPER.AUTHOR VOROBYOV98 "Sergei Vorobyov and Andrei Voronkov"))(POS (PAPER.TITLE VOROBYOV98 "Complexity of Nonrecursive Logic Programs with Complex Values"))(POS (PAPER.PUBLICATION VOROBYOV98 "Proceedings of the Seventeenth ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems"))(POS (PAPER.STARTPAGE VOROBYOV98 244))(POS (PAPER.ENDPAGE VOROBYOV98 253))(POS (PAPER.LINK VOROBYOV98 "http://citeseer.ist.psu.edu/258671.html"))(POS (PAPER.YEAR VOROBYOV98 1998))(POS (PAPER.DESCRIPTION VOROBYOV98 "
Breaks down the complexity of nonrecursive logic programs based on the 
signature/vocabulary of the program.
"))(POS (PAPER.TOPIC VOROBYOV98 "Logic Programming"))(POS (PAPER.INSTANCE WAAL93))(POS (PAPER.BIBTEX WAAL93 ARTICLE))(POS (PAPER.AUTHOR WAAL93 "D.A. de Waal and J. Gallagher"))(POS (PAPER.TITLE WAAL93 "The Applicability of Logic Program Analysis and Transformation to Theorem Proving"))(POS (PAPER.PUBLICATION WAAL93 "CADE"))(POS (PAPER.LINK WAAL93 "http://citeseer.ist.psu.edu/dewaal93applicability.html"))(POS (PAPER.YEAR WAAL93 1993))(POS (PAPER.RANK WAAL93 "[****]"))(POS (PAPER.DESCRIPTION WAAL93 "
de Waal and Gallagher show how to employ the results of (1) approximation
of logic programs and (2) partial evaluation to produce strategies
for pruning the search space of theorem proving procedures.  They model
a theorem proving algorithm as a logic program, add in the theory and query
in question, and run approximation techniques after partially evaluating
the constructed logic program.  Regular unary clauses (r(f(x1,...,xn) <= 
t1(x1) ^ ... ^ tn(xn))are used to
do the approximations, but the technique can be applied to different
approximations as well.  The authors demonstrate this technique on
a model-elimination procedure and a Naive nH-Prolog proof system.
"))(POS (PAPER.TOPIC WAAL93 "Metalevel Reasoning"))(POS (PAPER.INSTANCE WALDINGER75))(POS (PAPER.AUTHOR WALDINGER75 "R. Waldinger"))(POS (PAPER.TITLE WALDINGER75 "Achieving several goals simultaneously"))(POS (PAPER.PUBLICATION WALDINGER75 "Machine Intelligence 8"))(POS (PAPER.STARTPAGE WALDINGER75 94))(POS (PAPER.ENDPAGE WALDINGER75 138))(POS (PAPER.YEAR WALDINGER75 1975))(POS (PAPER.DESCRIPTION WALDINGER75 "
Waldinger examines planning where sugoals interfere with one another.  He introduces regression  planning, where totally ordered plan steps are reordered.  A solution is constructed incrementally for each subgoal, but when a later subgoal interferes, the position of that subgoal is moved earlier in the plan.  He also touches on the ramification problem (but doesn't call it that) in an effort to show the STRIPS assumption as an unsatisfactory solution to the frame problem.
"))(POS (PAPER.TOPIC WALDINGER75 "Historical"))(POS (PAPER.INSTANCE WALSH2000))(POS (PAPER.BIBTEX WALSH2000 ARTICLE))(POS (PAPER.AUTHOR WALSH2000 "Toby Walsh"))(POS (PAPER.TITLE WALSH2000 "Reformulating Propositional Satisfiability as Constraint Satisfaction"))(POS (PAPER.PUBLICATION WALSH2000 "Symposium on Abstraction, Reformulation, and Approximation (SARA)"))(POS (PAPER.STARTPAGE WALSH2000 233))(POS (PAPER.ENDPAGE WALSH2000 246))(POS (PAPER.LINK WALSH2000 "http://citeseer.ifi.unizh.ch/walsh00reformulating.html"))(POS (PAPER.YEAR WALSH2000 2000))(POS (PAPER.DESCRIPTION WALSH2000 "
Walsh gives an overview of various approaches to encoding propositional
satisfiability as CSPs.  Then he goes on to discuss how various
algorithms operate on those CSPs.
"))(POS (PAPER.TOPIC WALSH2000 "Reformulation"))(POS (PAPER.INSTANCE WAM))(POS (PAPER.BIBTEX WAM BOOK))(POS (PAPER.AUTHOR WAM "Hassan Ait-Kaci"))(POS (PAPER.TITLE WAM "Warren's Abstract Machine: A Tutorial Reconstruction"))(POS (PAPER.PUBLISHER WAM "MIT Press"))(POS (PAPER.LINK WAM "http://mitpress.mit.edu/catalog/item/default.asp?ttype=2&tid=7292"))(POS (PAPER.YEAR WAM 1991))(POS (PAPER.RANK WAM "[*****]"))(POS (PAPER.DESCRIPTION WAM "
Description of the original Prolog compiler.
"))(POS (PAPER.TOPIC WAM ""))(POS (PAPER.INSTANCE WANG85))(POS (PAPER.BIBTEX WANG85 INPROCEEDINGS))(POS (PAPER.AUTHOR WANG85 "Tie Cheng Wang"))(POS (PAPER.TITLE WANG85 "Designing Examples for Semantically Guided Hierarchical Deduction"))(POS (PAPER.PUBLICATION WANG85 "IJCAI"))(POS (PAPER.YEAR WANG85 1985))(POS (PAPER.RANK WANG85 "[*]"))(POS (PAPER.DESCRIPTION WANG85 "
This paper describes a hierarchical theorem prover guided by a model
and gives guidelines for humans to pick a good model.
"))(POS (PAPER.TOPIC WANG85 "Model-Guided Proof Techniques"))(POS (PAPER.INSTANCE WARREN74))(POS (PAPER.AUTHOR WARREN74 "D.H.D. Warren"))(POS (PAPER.TITLE WARREN74 "Extract from APIC Studies in Data Processing"))(POS (PAPER.YEAR WARREN74 1974))(POS (PAPER.DESCRIPTION WARREN74 "
Quick synopsis of the Prolog implementation of Warren's WARPLAN.  WARPLAN was the first planner implemented in Prolog.  It was not optimal, sometimes finding longer plans than needed.
"))(POS (PAPER.TOPIC WARREN74 "Historical"))(POS (PAPER.INSTANCE WEYHRAUCH80))(POS (PAPER.BIBTEX WEYHRAUCH80 ARTICLE))(POS (PAPER.AUTHOR WEYHRAUCH80 "Richard Weyhrauch"))(POS (PAPER.TITLE WEYHRAUCH80 "Prolegomena to a theory of mechanized formal reasoning"))(POS (PAPER.PUBLICATION WEYHRAUCH80 "Artificial Intelligence"))(POS (PAPER.VOLUME WEYHRAUCH80 "13"))(POS (PAPER.STARTPAGE WEYHRAUCH80 133))(POS (PAPER.ENDPAGE WEYHRAUCH80 170))(POS (PAPER.YEAR WEYHRAUCH80 1980))(POS (PAPER.RANK WEYHRAUCH80 "[***]"))(POS (PAPER.DESCRIPTION WEYHRAUCH80 "
Weyhrauch describes the FOL system.  FOL allows rules to be written that
produce semantic attachments, i.e. attaching Lisp addition to the function
symbol '+'.  It also allows rules that rewrite expressions.  FOL includes
an evaluator for first order logic that combines the rewrite rules with
the semantic attachments to do proofs.  FOL is a system that operates on
'LS pairs': a set of logical sentences, a set of attachments, and a set
of facts.  Because this is done uniformly, FOL allows multiple LS pairs
to be defined at the same time.  A special LS pair, Meta, is a theory
of LS pairs; reflection is achieved in FOL by allowing Meta to
operate on another LS pair.   Metametalevel reasoning
can be accomplished in the same way.  Self-reflection is another special
case of this mechanism--give Meta the LS pair Meta to operate on.
"))(POS (PAPER.TOPIC WEYHRAUCH80 "Theorem Proving with Attachments"))(POS (PAPER.INSTANCE YAMATOMOTO2000))(POS (PAPER.AUTHOR YAMATOMOTO2000 "Akihiro Yamatomoto, Bertram Fronhofer"))(POS (PAPER.TITLE YAMATOMOTO2000 "Hypothesis Finding via Residue Hypotheses with the Resolution Principle"))(POS (PAPER.LINK YAMATOMOTO2000 "http://link.springer.de/link/service/series/0558/bibs/1968/19680156.htm"))(POS (PAPER.YEAR YAMATOMOTO2000 2000))(POS (PAPER.DESCRIPTION YAMATOMOTO2000 "
Given a set of background sentences B that do not entail a positive example E, we want to find a hypothesis H such that
B and H entail E.  The authors argue for the use of anti-subsumption over anti-instantiation as a method for
finding residue hypotheses.
"))(POS (PAPER.TOPIC YAMATOMOTO2000 "Theorem Proving Applications"))(POS (PAPER.INSTANCE ZHANG90))(POS (PAPER.BIBTEX ZHANG90 ARTICLE))(POS (PAPER.AUTHOR ZHANG90 "Weining Zhang and Clement Yu and Daniel Troy"))(POS (PAPER.TITLE ZHANG90 "Necessary and Sufficient Conditions to Linearize Doubly Recursive Programs in Logic Databases"))(POS (PAPER.PUBLICATION ZHANG90 "ACM Transactions on Database Systems"))(POS (PAPER.VOLUME ZHANG90 "15(3)"))(POS (PAPER.STARTPAGE ZHANG90 459))(POS (PAPER.ENDPAGE ZHANG90 482))(POS (PAPER.LINK ZHANG90 "http://portal.acm.org/citation.cfm?coll=GUIDE&dl=GUIDE&id=89237"))(POS (PAPER.YEAR ZHANG90 1990))(POS (PAPER.DESCRIPTION ZHANG90 "
The authors examine conditions under which a doubly recursive program, i.e. a program of the form r(xbar) if s(xbar) and r(xbar) if r(ybar) ^ q(ybar') ^ r(ybar''), can be expressed as a linear recursive program, i.e. where the first recursive r definition is resolved with s(xbar).  The only assumption is that 
all the variables in the head appear somewhere in the body.  This result
strengthens previous results.  All rules are horn, and the semantics are LP. 
The necessary and sufficient conditions are nasty, as you might expect.
"))(POS (PAPER.TOPIC ZHANG90 "Reformulation"))(POS (PAPER.INSTANCE ZHANG95))(POS (PAPER.BIBTEX ZHANG95 INPROCEEDINGS))(POS (PAPER.AUTHOR ZHANG95 "J. Zhang and H. Zhang"))(POS (PAPER.TITLE ZHANG95 "SEM: A System for Enumerating Models"))(POS (PAPER.PUBLICATION ZHANG95 "In proceedings, IJCAI-95, Morgan Kaufmann"))(POS (PAPER.LINK ZHANG95 "http://citeseer.ist.psu.edu/context/34167/0"))(POS (PAPER.YEAR ZHANG95 1995))(POS (PAPER.DESCRIPTION ZHANG95 "
Model builder based on searching for a model directly and using the Least Number Heuristic, a method for reducing symmetry in the search space.
"))(POS (PAPER.TOPIC ZHANG95 "Model Building"))(POS (PAPER.INSTANCE ZHANG96))(POS (PAPER.BIBTEX ZHANG96 ARTICLE))(POS (PAPER.AUTHOR ZHANG96 "J. Zhang"))(POS (PAPER.TITLE ZHANG96 "Constructing Finite Algebras with FALCON"))(POS (PAPER.PUBLICATION ZHANG96 "Journal of Automated Reasoning"))(POS (PAPER.VOLUME ZHANG96 "17(1)"))(POS (PAPER.STARTPAGE ZHANG96 1))(POS (PAPER.ENDPAGE ZHANG96 22))(POS (PAPER.LINK ZHANG96 "http://citeseer.ist.psu.edu/context/254103/0"))(POS (PAPER.YEAR ZHANG96 1996))(POS (PAPER.DESCRIPTION ZHANG96 "
Model builder based on searching for a model directly, the so-called
Falcon-style approach.
"))(POS (PAPER.TOPIC ZHANG96 "Model Building"))(POS (PAPER.INSTANCE ZHANG97))(POS (PAPER.BIBTEX ZHANG97 ARTICLE))(POS (PAPER.AUTHOR ZHANG97 "Yan Zhang and Norman Foo"))(POS (PAPER.TITLE ZHANG97 "Deriving Invariants and Constraints from Action Theories"))(POS (PAPER.PUBLICATION ZHANG97 "Fundamenta Informaticae"))(POS (PAPER.VOLUME ZHANG97 "30(1)"))(POS (PAPER.STARTPAGE ZHANG97 109))(POS (PAPER.ENDPAGE ZHANG97 123))(POS (PAPER.LINK ZHANG97 "http://citeseer.ist.psu.edu/zhang96deriving.html"))(POS (PAPER.YEAR ZHANG97 1997))(POS (PAPER.RANK ZHANG97 "[*****]"))(POS (PAPER.DESCRIPTION ZHANG97 "
Zhang and Foo describe an approach to the construction of action invariants
(statements that hold in the predecessor and successor states when
executing a particular action) and state constraints (statements
true in all states reachable from an initial state).   It is based
on a state-based persistence formalism (Zhang's work), and assumes
a domain-closure axiom.  It considers actions with disjunctive effects
and preconditions, but does not provide complete results for those
cases.  It relies on the use of induction to prove a candidate
state constraint is actually a state constraint, but the generation
of these candidates is done algorithmically.
"))(POS (PAPER.TOPIC ZHANG97 "Theories of Action"))(POS (PAPER.INSTANCE ZHU98))(POS (PAPER.BIBTEX ZHU98 PHDTHESIS))(POS (PAPER.AUTHOR ZHU98 "Yunshan Zhu"))(POS (PAPER.TITLE ZHU98 "Efficient First-Order Semantic Deduction Techniques"))(POS (PAPER.LINK ZHU98 "http://citeseer.ist.psu.edu/zhu98efficient.html"))(POS (PAPER.YEAR ZHU98 1998))(POS (PAPER.RANK ZHU98 "[*]"))(POS (PAPER.DESCRIPTION ZHU98 "
This is Zhu's thesis on Ordered Semantic Hyperlinking, complexity
measures of theorem proving, and OSHL applied to planning.
Contains some good citations to semantically driven proof techniques
in section 2.1.
"))(POS (PAPER.TOPIC ZHU98 "Resolution Variants"))(POS (PAPER.RELATED ZHU98 PLAISTED97))(POS (EXAMPLE.INSTANCE DRESDENQUEENS))(POS (EXAMPLE.DATEENTERED DRESDENQUEENS 3355255579))(POS (EXAMPLE.DATEMODIFIED DRESDENQUEENS 3355255579))(POS (EXAMPLE.TECHNIQUE DRESDENQUEENS DATAEXTRACTION))(POS (EXAMPLE.TECHNIQUE DRESDENQUEENS GENERATEOVERGUESS))(POS (EXAMPLE.DESCRIPTION DRESDENQUEENS "We extracted the data out of the rules and relied on generation instead of guess and check."))(POS (EXAMPLE.SOURCE DRESDENQUEENS "  (<= (goal player ?s)
      (attacks ?n)
      (mapnum2val ?n ?s))
  (mapnum2val s0 100)
  (mapnum2val s2 90)
  (mapnum2val s3 80)
  (mapnum2val s4 70)
  (mapnum2val s5 60)
  (mapnum2val s6 50)
  (mapnum2val s7 40)
  (mapnum2val s8 0)
  (mapnum2val s9 0)
  (mapnum2val s10 0)
"))(POS (EXAMPLE.TARGET DRESDENQUEENS "  (<= (goal player 100)
      (attacks s0))
  (<= (goal player 90)
      (attacks s2))
  (<= (goal player 80)
      (attacks s3))
  (<= (goal player 70)
      (attacks s4))
  (<= (goal player 60)
      (attacks s5))
  (<= (goal player 50)
      (attacks s6))
  (<= (goal player 40)
      (attacks s7))
  (<= (goal player 0)
      (attacks s8))
  (<= (goal player 0)
      (attacks s9))
  (<= (goal player 0)
      (attacks s10))
"))(POS (EXAMPLE.INSTANCE TOETICTAC))(POS (EXAMPLE.DATEENTERED TOETICTAC 3355255669))(POS (EXAMPLE.DATEMODIFIED TOETICTAC 3355255669))(POS (EXAMPLE.TECHNIQUE TOETICTAC RELATIONALIZING))(POS (EXAMPLE.DESCRIPTION TOETICTAC "The old: each of the 9 cells is labelled with an x, an o, or a b: cell(x,y,label).  The new: each of the 9 cells (a,b,c,d,e,f,g,h,i) is either true of ecks or ohs or blank, each of which is a unary relation. "))(POS (LANGUAGE.INSTANCE IKIF))(POS (LANGUAGE.INSTANCE KIF))(POS (LANGUAGE.INSTANCE XML))(POS (TECHNIQUE.INSTANCE CONSISTENCY2DEDUCTION))(POS (TECHNIQUE.DESCRIPTION CONSISTENCY2DEDUCTION "Consistency2Deduction[Delta,phi(xbar)] computes an expression that represents for all the query instances tbar such that Delta U {phi(tbar)} is consistent."))(POS (TECHNIQUE.INSTANCE REIFICATION))(POS (TECHNIQUE.DESCRIPTION REIFICATION "Reification is an umbrella technique that encompasses all kinds of vocabulary and conceptualization shifts."))(POS (TECHNIQUE.INSTANCE UNNAMED))(POS (TECHNIQUE.DESCRIPTION UNNAMED "Encompasses all unnamed techniques."))(POS (TECHNIQUE.INSTANCE RELATIONALIZING))(POS (TECHNIQUE.DESCRIPTION RELATIONALIZING "Form of reification where object/function constants are turned into relation constants."))(POS (TECHNIQUE.INSTANCE OBJECTIFYING))(POS (TECHNIQUE.DESCRIPTION OBJECTIFYING "Form of reification where relation constants become function or object constants."))(POS (TECHNIQUE.INSTANCE GENERATEOVERGUESS))(POS (TECHNIQUE.DESCRIPTION GENERATEOVERGUESS "Technique that changes a guess-and-check problem formulation reformulation into a formulation that generates the answer constructively."))(POS (TECHNIQUE.INSTANCE DATAEXTRACTION))(POS (TECHNIQUE.DESCRIPTION DATAEXTRACTION "Pulls data out of a rule or set of rules, places that data into tables, and appropriately adjusts the rule so that semantically the original and the new versions are identical.  Inverse of dataInfusion."))(POS (TECHNIQUE.INSTANCE DATAINFUSION))(POS (TECHNIQUE.DESCRIPTION DATAINFUSION "Pushes data from a table into rules, a special form of partial deduction from the logic programming literature.  Inverse of dataExtraction."))(POS (TECHNIQUE.INSTANCE CHIRKOVAREFORMULATION))(POS (TECHNIQUE.DESCRIPTION CHIRKOVAREFORMULATION "Computes the optimal viewset for transforming an unknown (but fixed-size) database into a new database that more efficiently answers a given query set."))(POS (PERSON.INSTANCE NATLOVE))(POS (PERSON.FIRSTNAME NATLOVE "Nat"))(POS (PERSON.LASTNAME NATLOVE "Love"))(POS (PERSON.TEAM NATLOVE NATLOVE))(POS (PERSON.EMAIL NATLOVE "natlove@stanford.edu"))(POS (PERSON.INSTANCE JDUCHI))(POS (PERSON.FIRSTNAME JDUCHI "John"))(POS (PERSON.LASTNAME JDUCHI "Duchi"))(POS (PERSON.TEAM JDUCHI JDUCHI))(POS (PERSON.EMAIL JDUCHI "jduchi@stanford.edu"))(POS (PERSON.INSTANCE DTARLOW))(POS (PERSON.FIRSTNAME DTARLOW "Danny"))(POS (PERSON.LASTNAME DTARLOW "Tarlow"))(POS (PERSON.TEAM DTARLOW DTARLOW))(POS (PERSON.EMAIL DTARLOW "dtarlow@stanford.edu"))(POS (PERSON.INSTANCE THINRICH))(POS (PERSON.FIRSTNAME THINRICH "Tim"))(POS (PERSON.LASTNAME THINRICH "Hinrichs"))(POS (PERSON.TEAM THINRICH THINRICH))(POS (PERSON.EMAIL THINRICH "thinrich@stanford.edu"))(POS (EXAMPLE.INSTANCE DRESDENQUEENS))(POS (EXAMPLE.DATEENTERED DRESDENQUEENS 3355255579))(POS (EXAMPLE.DATEMODIFIED DRESDENQUEENS 3355255579))(POS (EXAMPLE.TECHNIQUE DRESDENQUEENS DATAEXTRACTION))(POS (EXAMPLE.TECHNIQUE DRESDENQUEENS GENERATEOVERGUESS))(POS (EXAMPLE.DESCRIPTION DRESDENQUEENS "We extracted the data out of the rules and relied on generation instead of guess and check."))(POS (EXAMPLE.SOURCE DRESDENQUEENS "  (<= (goal player ?s)
      (attacks ?n)
      (mapnum2val ?n ?s))
  (mapnum2val s0 100)
  (mapnum2val s2 90)
  (mapnum2val s3 80)
  (mapnum2val s4 70)
  (mapnum2val s5 60)
  (mapnum2val s6 50)
  (mapnum2val s7 40)
  (mapnum2val s8 0)
  (mapnum2val s9 0)
  (mapnum2val s10 0)
"))(POS (EXAMPLE.TARGET DRESDENQUEENS "  (<= (goal player 100)
      (attacks s0))
  (<= (goal player 90)
      (attacks s2))
  (<= (goal player 80)
      (attacks s3))
  (<= (goal player 70)
      (attacks s4))
  (<= (goal player 60)
      (attacks s5))
  (<= (goal player 50)
      (attacks s6))
  (<= (goal player 40)
      (attacks s7))
  (<= (goal player 0)
      (attacks s8))
  (<= (goal player 0)
      (attacks s9))
  (<= (goal player 0)
      (attacks s10))
"))(POS (EXAMPLE.INSTANCE TOETICTAC))(POS (EXAMPLE.DATEENTERED TOETICTAC 3355255669))(POS (EXAMPLE.DATEMODIFIED TOETICTAC 3355255669))(POS (EXAMPLE.TECHNIQUE TOETICTAC RELATIONALIZING))