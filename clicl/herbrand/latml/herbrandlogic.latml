

This page defines the syntax and semantics of Herbrand logic, and for the purpose of comparison, first-order logic.  It finishes with a couple of quick examples illustrating the difference between first-order semantics and Herbrand semantics.

<h2>Syntax</h2>

<p>The syntax of Herbrand logic is exactly the same as for first-order logic.

<p><b>Definition (Vocabulary)</b>: A vocabulary V consists of:
<ul>
<li>A set of relation constants {r_1, ..., r_n}, each with an associated arity.
<li>A set of function constants {f_1, ..., f_m}, each with an associated arity.
<li>A non-empty set of object constants {c_1, ..., c_k}.
<li>A set of variables {x_1,x_2,...}.
</ul>

<p>For the sake of simplicity, we assume the set of constants in a vocabulary is finite.  A countable set of constants changes the wording of certain theorems, but conceptually nothing changes.   

<p><b>Definition (Term)</b>: A term in V:
<ul>
<li>A variable.
<li>An object constant.
<li>A function constant with arity n applied to n terms.
<li>Only expressions produced by the above rules are terms.
</ul>

<p><b>Definition (Sentence)</b>: A sentence in V:
<ul>
<li>A relation constant with arity n applied to n terms.
<li>\neg \phi where \phi is a sentence.
<li>\phi \vee \psi, where \phi and \psi are sentences.
<li>\phi \wedge \psi, where \phi and \psi are sentences.
<li>\phi \Leftarrow \psi, where \phi and \psi are sentences.
<li>\phi \Rightarrow \psi, where \phi and \psi are sentences.
<li>\phi \Leftrightarrow \psi, where \phi and \psi are sentences.
<li>\forallx.\phi, where \phi is a sentence.
<li>\existsx.\phi, where \phi is a sentence.
<li>Only expressions produced by the above rules are sentences.
</ul>

<p>An <i>atom</i> is a sentence of the form p(t_1,...,t_n).  A <i>literal</i> is either an atom or the negation of an atom.  A <i>ground sentence</i> has no variables or quantifiers.  A <i>closed sentence</i> has no free variables, whereas an <i>open sentence</i> does have free variables.  We treat free variables in an open sentence as being implicitly universally quantified.

<h2>Herbrand Semantics</h2>

<p>Herbrand logic differs from first-order logic solely in the structures it considers to be models.  The semantics of a given set of sentences is defined to be the set of Herbrand models that satisfy it, for a given vocabulary.

<p><b>Definition (Herbrand Model)</b>: A Herbrand model for vocabulary V is any set of ground atoms in V.

<!--
<p>Herbrand semantics allow one to determine whether a particular model satisfies a particular sentence by simply grounding the sentence, i.e. \forall and \exists range over the terms in V.

<p><b>Definition (Grounding)</b>: Consider the case of a closed sentence.  Let the ground terms in V be {t_1,t_2,...}.
<ul>
<li>Ground[p(u_1,...,u_n)] = p(u_1,...,u_n)
<li>Ground[\forall x.\phi(x)] = Ground[\phi(t_1)] \wedge Ground[\phi(t_2)] \wedge ...
<li>Ground[\exists x.\phi(x)] = Ground[\phi(t_1)] \vee Ground[\phi(t_2)] \vee ...
<li>Ground[\neg \phi] = \neg Ground[\phi]
<li>Ground[\phi \wedge \psi] = Ground[\phi] \wedge Ground[\psi]
<li>Ground[\phi \vee \psi] = Ground[\phi] \vee Ground[\psi]
<li>Ground[\phi \Rightarrow \psi] = Ground[\phi] \Rightarrow Ground[\psi]
<li>Ground[\phi \Leftarrow \psi] = Ground[\phi] \Leftarrow Ground[\psi]
<li>Ground[\phi \Leftrightarrow \psi] = Ground[\phi] \Leftrightarrow Ground[\psi]
</ul>


<p>Notice that if there is at least one function, the number of terms is infinite, and the grounding of any sentence with quantifiers is an infinitely long expression.  Such expressions are not sentences in the logic, but serve only as a device for defining satisfaction.

<p>In the following definition, we use the convention \wedge \psi_i to mean a conjunction of sentences \psi_1,\psi_2,..., where the conjunction may be infinite.

-->

<p><b>Definition (Herbrand Satisfaction)</b>: Let \phi be a closed sentence
and M a Herbrand model in the vocabulary V.
<ul>
<li>\models_M s=t if and only if s and t are syntactically identical.
<li>\models_M p(t_1,...,t_n) if and only if p(t_1,...,t_n) \in M.
<li>\models_M \neg \psi if and only if \not\models_M \psi.
<li>\models_M \phi \wedge \psi if and only if \models_M \phi and \models_M \psi.
<li>\models_M \phi \vee \psi if and only if \models_M \phi or \models_M \psi.
<li>\models_M \phi \Rightarrow \psi if and only if \not\models_M \phi or \models_M \psi.
<li>\models_M \phi \Leftarrow \psi if and only if \models_M \psi \Rightarrow \phi.
<li>\models_M \phi \Leftrightarrow \psi if and only if either \models_M \phi\wedge\psi or \models_M \neg\phi \wedge \neg\psi.
<li>\models_M \forallx.\phi(x) if and only if \models_M \phi(t) for all ground terms t in V.
<li>\models_M \existsx.\phi(x) if and only if \models_M \phi(t) for some ground term t in V. 
</ul>

<p>We always assume that satisfaction for a set of sentences \Delta is defined with respect to a vocabulary that includes all the constants and variables that appear in \Delta.  Otherwise, a model might satisfy neither a sentence nor its negation.

<p>One of the consequences of this definition is that the theory of equality is fixed in Herbrand logic: every ground term is distinct from every other ground term and the universe.  Another consequence is that quantifiers range over exactly the set of all ground terms.  That is, Herbrand logic builds in a domain closure axiom (which is sometimes infinitely long) and unique-names axioms.  

<p><b>Definition (Herbrand Entailment)</b>: Let \Delta be a set of closed sentences and V a vocabulary that is a superset of the vocabulary of \Delta.  Let \phi be a closed sentence. \Delta entails \phi with respect to vocabulary V if and only if every Herbrand model for V that satisfies \Delta also satisfies \phi.<center> \Delta \models \phi wrt V if and only if  \models_M \Delta implies \models_M \phi, where M is a Herbrand model for V</center>

<p>If no vocabulary is named in satisfaction or entailment, it is assumed the minimal vocabulary is used, i.e. the vocabulary that includes just the constants in the sentences given.

<h2>First-order Semantics</h2>
<p>To demonstrate the simplicity of Herbrand semantics, here we give the standard semantics of first-order logic for comparison.  To be clear, Herbrand logic does not have the following semantics; it has the semantics from the last section.
<p><b>Definition (First-order Model)</b>: A first-order model M consists of
<ul><li>|M|: universe
<li>For each n-ary relation constant p an n-ary relation p^M over |M|
<li>For each n-ary function constant f an n-ary function f^M over |M|
<li>For each object constant c an element c^M from |M|
</ul>

<p><b>Definition (Variable Assignment)</b>: In a model M, a variable assignment is a mapping of all the variables in the vocabulary to elements in |M|.

<p>Given an arbitrary model and a variable assignment for that model, every term in the language is assigned an element in that model's universe.  

<p><b>Definition(e_v)</b>: Let v be a variable assignment and M a first-order model.  e_v maps a term to an element of |M|.
<ul><li>For variable x, e_v(x) = v(x)
<li>For object constant c, e_v(c) = c^M
<li>For terms t_1,...,t_n, e_v(f(t_1,...,t_n)) = f^M(e_v(t_1),...,e_v(t_n))
</ul>

<p>Finally we can define satisfaction in a model.  Satisfaction assumes there is some given variable assignment v.

<p><b>Definition(First-order Satisfaction)</b>: Let M be a model and v a variable assignment for M.  \models_M \phi is defined as follows.
<ul>
<li>\models_M t_1=t_2[v] iff e_v(t_1)=e_v(t_2)
<li>\models_M p(t_1,...,t_n)[v] iff &lt;e_v(t_1),...,e_v(t_n)&gt; \in p^M
<li>\models_M \neg \phi[v] iff \not\models \phi[v]
<li>\models_M \phi \wedge \psi [v] iff \models_M \phi[v] and \models_M \psi[v]
<li>\models_M \phi \vee \psi [v] iff \models_M \phi[v] or \models_M \psi[v] 
<li>\models_M \phi \Rightarrow \psi [v] iff \not\models_M \phi[v] or \models_M \psi[v] 
<li>\models_M \phi \Leftarrow \psi [v] iff \models_M \psi \Rightarrow \phi [v] 
<li>\models_M \phi \Leftrightarrow \psi [v] iff \models_M \phi \wedge \psi [v] or \models_M \neg\phi \wedge \neg\psi [v]
<li>\models_M \forallx.\phi[v] iff for every d in |M| \models_M \phi[v(x/d)]
<li>\models_M \existsx.\phi[v] iff for some d in |M| \models_M \phi[v(x/d)]
</ul>

<p><b>Definition (First-order Entailment)</b>: Let \Delta be a set of sentences and \phi be a sentence.  \Delta entails \phi if and only if every first-order model that satisfies \Delta[v] for all variable assignments v also satisfies \phi[v] for all variable assignments v.
<center>\Delta \models \phi if and only if for all variable assignments v and u, \models_M \Delta[v] implies \models_M \phi[u], where M is a first-order model</center>


<h2>Examples</h2>

<p>The following sentence has two satisfying Herbrand models for the vocabulary {p, a, b}.  It has infinitely many first-order models.
<indent>p(a)
Herbrand Models: {p(a)}, {p(a), p(b)}
Some First-order Models: 
&nbsp;&nbsp;&nbsp;{{1},p={&lt;1&gt;},a=1,b=1}, 
&nbsp;&nbsp;&nbsp;{{1,2,3,...},p={&lt;17&gt;,&lt;63&gt;}, a=17, b=51}, 
&nbsp;&nbsp;&nbsp;{Reals, p={&lt;3.14159...&gt;,&lt;17.0&gt;}, a=3.14159..., b=0.33333...} </indent>

<p>In Herbrand logic, restricting the vocabulary to {p, a} ensures there is only one satisfying model: {p(a)}.  In first-order logic, shrinking the vocabulary does not reduce the number of models at all; the only difference is that models of the smaller vocabulary do not have an assignment for b.

<p>The following sentences are Herbrand unsatisfiable for the vocabulary {p, a}.
<indent>p(a)
	\existsx.\neg p(x)
</indent>
However, in first-order logic, regardless the vocabulary, they are always satisfiable, e.g. {{1,2}, p={&lt;1&gt;}, a=1}.  In Herbrand logic, enlarging the vocabulary to include an extra element is sufficient for satisfiability in this example: the vocabulary {p, a, b} allows the satisfying model {p(a)}.  

<p>More generally, in first-order logic, changing the vocabulary never changes the satisfiability (again the vocabulary must always be a superset of the symbols in the axiom set), whereas in Herbrand logic, changing the vocabulary can affect satisfiability.

<p>A note on the dependence of Herbrand satisfaction on a vocabulary. To see why satisfaction is defined as it is, suppose instead of fixing the vocabulary up front (which defines the class of candidate models), we instead define satisfaction so that the vocabulary is gleamed from the sentences we are given.  Now consider the following axioms.
<indent>p(a)
	\negp(b)
	\existsx.\negp(x)
</indent>
This set of sentences is satisfied by the model {p(a), \negp(b)} for vocabulary {p, a, b}.  But, if we were to drop out the \neg p(b) sentence, under the new definition of satisfaction, the vocabulary would be {p, a}, which as commented above is unsatisfiable.  That is, under this new definition of satisfaction, a set of sentences could be satisfiable, but a subset of those sentences could be unsatisfiable.  Clearly, that would cause havoc in proof procedures; by fixing the vocabulary up front, in this case to {p, a, b}, the satisfiability of a set of sentences ensures the satisfiability of every subset.

