;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; (c) 1996-2002 by Michael Genesereth.  All rights reserved.;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(eval-when (compile load eval) (proclaim '(special *reservations*)))(defparameter *schedules* (make-instance 'agent :name 'schedules))(defmethod askx (x p sender (receiver (eql *schedules*)))  (declare (ignore sender))  (aspectize x (make-schedule-from-query p)))(defmethod asks (x p sender (receiver (eql *schedules*)))  (declare (ignore x sender))  (make-schedule-from-query p t))(defun aspectize (aspect value)  (let ((objvar (find-first-variable aspect)))    (cond     ((varp objvar)      (plug aspect `((,objvar . ,value) (t . t)))))))(defun find-first-variable (kif)  (cond ((varp kif) kif )        ((listp kif) (or-ify-ffv kif))))(defun or-ify-ffv (lst)  (when lst    (let ((ffv (find-first-variable (first lst))))      (if ffv ffv (or-ify-ffv (rest lst))))))(defun make-schedule-from-query (query &optional (ask-all? nil))  (let (ans)    (setq ans          (cond ((and (eq (car query) 'and) (eq (caaddr query) 'formatted-table))	         (list (caddr (cadr query))                        (make-schedule-from-symbol (caddr (cadr query)))))                ((eq (car query) 'formatted-table) (list (make-schedule-from-symbol (cadr query))))	        (t (make-symbols-from-query query))))    (if ask-all? ans (car ans))))(setf (get 'tableau 'basicval) 'make-tableau-from-symbol)(defun make-tableau-from-symbol (p)  (make-schedule-from-symbol (cadr p)))(defun tableau (x) (make-schedule-from-symbol x))(defun make-symbols-from-query (query)  (declare (type list query))  (unless (varp (cadar (member 'isa-room-schedule (cdr query) :key 'car)))    (return-from make-symbols-from-query nil))  (let ((rooms nil)	(dates nil)	(s-hours nil)	(e-hours nil)	(ress nil)	(intervals nil)	(symbols nil)	symbol )    (if (eq (first query) 'and)	(setq query (rest query))      (setq query (list query)))    (setq query      (loop	  for clause in query	  unless (eq (first clause) 'or)	  collect clause	  when (eq (first clause) 'or)	  append (rest clause) ))    (loop	for (slot o val) in query	do              (unless o (print "no-o"))             (case slot	     (scheduled-room	      (push val rooms) )	     (starting-date	       (push (intern (parsedate (stringify val))) dates))	     (schedule-interval	      (push val intervals) )	     (schedule-start-time	      (push val s-hours) )	     (schedule-end-time	      (push val e-hours) )	     (resolution-minutes	      (push val ress))))    (unless rooms      (setq rooms '(all)))    (unless dates      (setq dates	(list (last-monday-date)) ))    (unless s-hours      (setq s-hours (list 800)) )    (unless e-hours      (setq e-hours (list 1700)) )    (unless ress      (setq ress (list 30)) )    (unless intervals      (setq intervals (list 'day)) )        ;; Symbols    (dolist (room rooms)      (dolist (date dates)	(dolist (s-hour s-hours)	  (setq s-hour (floor s-hour 100))	  (dolist (e-hour e-hours)	    (setq e-hour (floor e-hour 100))	    (dolist (res ress)	      (dolist (interval intervals)		(setq symbol		  (format nil "~A-~A-~A-~A-~A-~A"			  room date s-hour e-hour res interval ))		(setq symbol (intern symbol))		(push symbol symbols)))))))    symbols))(defun make-schedule-from-symbol (symbol)  "Symbol is <building>-<room>-<week>-<start hour>-<end hour>-<resolution>"  (unless (symbolp symbol)    (return-from make-schedule-from-symbol (list symbol)) )  (let ((info (symbol-name symbol))	dash-pos building room start-date start-hour end-hour resolution interval )        ;; Building    (setq dash-pos (position #\- info))    (setq building (subseq info 0 dash-pos))    (setq info (subseq info (1+ dash-pos)))    ;; Room    (setq dash-pos (position #\- info))    (setq room (subseq info 0 dash-pos))    (setq info (subseq info (1+ dash-pos)))    ;; Week    (setq dash-pos (position #\- info))    (setq start-date (intern (subseq info 0 dash-pos)))    (setq info (subseq info (1+ dash-pos)))     ;; Start hour    (setq dash-pos (position #\- info))    (setq start-hour (read-from-string info nil nil :end dash-pos))    (setq info (subseq info (1+ dash-pos)))        ;; End hour    (setq dash-pos (position #\- info))    (setq end-hour (read-from-string info nil nil :end dash-pos))    (setq info (subseq info (1+ dash-pos)))    ;; Resolution    (setq dash-pos (position #\- info))    (setq resolution (read-from-string info nil nil :end dash-pos))    (setq info (subseq info (1+ dash-pos)))    ;; Interval    (setq interval (intern info))    (unless (eq interval 'week) (setq interval 'day))        (if (string-equal building "all")      (make-schedule-int-rooms start-date start-hour end-hour resolution)      (make-schedule-int (intern (strappend building "." room)) start-date start-hour end-hour resolution interval))))(defun make-schedule-int (room start-date start-hour end-hour resolution interval)  (let (reserv-list (start-time (hour-to-time start-hour)) (end-time (hour-to-time end-hour)) date-list)    (setq reserv-list      (request `(ask-all (?reserveid ?st ?et ?date)	     (and (event.room ?reserveid ,room)                  (event.date ?reserveid ?date)                  (event.start ?reserveid ?st)                  (event.end ?reserveid ?et))) *receiver*	     *reservations*))    (setq date-list	  (loop	    for count from 0 to 6	    collect (dateint-plus start-date count interval)))    (setq reserv-list	  (remove-if	   #'(lambda (quad)	       (or (not (find (fourth quad) date-list))		   (lessp (third quad) start-time)		   (lessp end-time (second quad)) ))	   reserv-list))    (main-gen-table room start-date reserv-list resolution start-hour end-hour interval)))(defun hour-to-time (hour)  (intern (strappend (format nil "~2,'0D" hour) "-00")))(defun main-gen-table (room week-of all-data-list resolution start-hour end-hour interval)  (let (ids sts ets dates (start-time (hour-to-time start-hour)) (end-time (hour-to-time end-hour)))    (setq ids (mapcar #'first all-data-list))    (setq sts (mapcar #'second all-data-list))    (setq sts	(mapcar #'(lambda (time) (if (lessp time start-time) start-time time))		sts))    (setq sts (mapcar #'(lambda (st) (time-ceiling st resolution)) sts))    (setq ets (mapcar #'third all-data-list))    (setq ets	(mapcar #'(lambda (time)		    (if (greaterp time end-time)			(+ end-time resolution)		      time ))		ets))    (setq ets (mapcar #'(lambda (et) (time-ceiling et resolution)) ets))    (setq dates (mapcar #'fourth all-data-list))    (make-html-schedule room week-of ids sts ets dates resolution start-hour end-hour interval)))(defun make-html-schedule (room start-date ids sts ets dates resolution start-hour end-hour interval)  (with-output-to-string (ns)    (format ns "<HTML><TABLE BORDER>")    (format ns "<TR>")    (format ns "<TH>~A</TH>" (prettify room))    (loop	for count from 0 to 6	for dateint = (dateint-plus start-date count interval)	for day = (day-of (month-of dateint) (date-of dateint) (year-of dateint))	do (format ns "<TH WIDTH=\"12%\">~:(~A~)<BR>~A/~A</TH>" 		   (nth day *short-day-names*) (month-of dateint) (date-of dateint)))    (format ns "</TR>")    (loop	with filled-box	with last-time = -1	for time in (all-times resolution start-hour end-hour)	do	  (format ns "<TR>")	  (format ns "<TH>~A</TH>" (prettify time))	  (dotimes (day 7)	    (setq filled-box nil)	    (loop		with dateint = (dateint-plus start-date day interval)		for id in ids		for st in sts		for et in ets		for date in dates		unless filled-box		do		  (cond ((and (lessp last-time st)                              (or (eq time st) (greaterp time st))                              (eq dateint date))		         (print-event ns id (schedule-span st et resolution))		         (setq filled-box t))		        ((and (eq dateint date) (lessp st time) (lessp time et))		         (setq filled-box t))))	    (unless filled-box (format ns "<TD></TD>")))	  (format ns "</TR>") (crlf ns)	  (setq last-time time))    (format ns "</TABLE></HTML>")))(defun make-schedule-int-rooms (start-date start-hour end-hour resolution)  (let (reserv-list (start-time (hour-to-time start-hour)) (end-time (hour-to-time end-hour)));    (setq start-date (date-to-syed-date start-date))    (setq reserv-list      (request `(ask-all (?reserveid ?st ?et ?room)	     (and (event.room ?reserveid ?room)                  (event.date ?reserveid ,start-date)                  (event.start ?reserveid ?st)                  (event.end ?reserveid ?et)                  (leq ,start-time ?et)                  (leq ?st ,end-time))) *receiver*	     *reservations*))    (main-gen-table-rooms start-date reserv-list resolution start-hour end-hour)))(defun main-gen-table-rooms (week-of all-data-list resolution start-hour end-hour)  (let (ids sts ets rooms (start-time (hour-to-time start-hour)) (end-time (hour-to-time end-hour)))    (setq ids (mapcar #'first all-data-list))    (setq sts (mapcar #'second all-data-list))    (setq sts	(mapcar #'(lambda (time) (if (lessp time start-time) start-time time))		sts))    (setq sts (mapcar #'(lambda (st) (time-ceiling st resolution)) sts))    (setq ets (mapcar #'third all-data-list))    (setq ets	(mapcar #'(lambda (time) (if (greaterp time end-time) (+ end-time resolution) time))		ets))    (setq ets (mapcar #'(lambda (et) (time-ceiling et resolution)) ets))    (setq rooms (mapcar #'fourth all-data-list))    (make-html-schedule-rooms week-of ids sts ets rooms resolution start-hour end-hour)))(defun make-html-schedule-rooms (start-date ids sts ets rooms resolution start-hour end-hour)  (let (classrooms)    (setq classrooms (request '(ask-all ?x (isa ?x classroom)) *client* *receiver*))    (with-output-to-string (ns)      (format ns "<HTML><TABLE BORDER>")      (format ns "<TR>")      (format ns "<TH>~A</TH>"   (format nil "~A<BR>~A/~A"                                          (nth                                           (day-of (month-of start-date) 					          (date-of start-date) 					          (year-of start-date))                                          *short-day-names*)                                         (month-of start-date) (date-of start-date)))      (dolist (room classrooms)        (format ns "<th>")        (output-handle ns room)        (format ns "/th>"))      (format ns "</TR>")      (loop	with filled-box	with last-time = 0	for time in (all-times resolution start-hour end-hour)	do (format ns "<TR>")           (format ns "<TH>~A</TH>" (prettify time))           (dolist (current-room  classrooms)             (setq filled-box nil)             (loop               for id in ids               for st in sts               for et in ets               for rm in rooms               unless filled-box               do               (cond ((and (eq current-room rm)                           (lessp last-time st)                           (or (eq time st) (greaterp time st)))                      (print-event ns id (schedule-span st et resolution))                      (setq filled-box t))                ((and (equal current-room rm) (lessp st time) (lessp time et))                 (setq filled-box t))))             (unless filled-box (format ns "<TD></TD>")))           (format ns "</TR>")           (setq last-time time))      (format ns "</TABLE>"))))(defun print-event (s handle span)  (let (title st et)    (format s "<TD ALIGN=CENTER ROWSPAN=\"~A\">" span)    (setq title      (or       (request `(ask-one ?desc (event.title ,handle ?desc)) *receiver*	      *reservations* )       "<EM>Title unknown</EM>" ))    (format s "<A HREF=\"/fastINSPECTpage?Object=~A\">~A</A>" handle title)        (setq st (request `(ask-one ?t (event.start ,handle ?t)) *receiver* *reservations*))    (setq et (request `(ask-one ?t (event.end ,handle ?t)) *receiver* *reservations*))    (when (and st et)      (setq st (nbsp-ify (prettify st)))      (setq et (nbsp-ify (prettify et)))      (format s "<BR><FONT SIZE=-1>")      (format s "~A - ~A" st et)      (format s "</FONT>") )    (format s "</TD>") ))(defun prettytime (time)  (let ((hour (floor time 100)) (minute (mod time 100)))    (cond ((<= hour 12) (format nil "~D:~2,'0D am" hour minute))          (t (format nil "~D:~2,'0D pm" (- hour 12) minute)))))(defun all-times (resolution start-hour end-hour)  (loop      for hour from start-hour to (1- end-hour)      append	(if (= hour end-hour) (list (maktime hour 0))	    (loop for minute from 0 to 59 by resolution	          collect (maktime hour minute)))))(defun dateint-plus (dateint count &optional (interval 'day))  (let ((month (month-of dateint))	(date (date-of dateint))	(year (year-of dateint)) )    (multiple-value-bind (newmonth newdate newyear)	(date-plus month date year count interval)      (intern (strappend (princ-to-string newmonth) "/"                         (princ-to-string newdate)  "/"                         (princ-to-string newyear))))))(defun month-of (x)  (setq x (symbol-name x))  (read-from-string (stringsubseq x 1 2)))(defun date-of (x)  (setq x (symbol-name x))  (read-from-string (stringsubseq x 4 5)))(defun year-of (x)  (setq x (symbol-name x))  (read-from-string (stringsubseq x 7 10)))(defun strip-slash (x)  (delete #\/ x) )(defun date-to-int (x)  (parse-integer (strip-slash x)) )(defun 31-days (x)   (if (member x '(1 3 5 7 8 10 12))      t    nil ))(defun add-week (x)   (let ((date (date-of x))	(month (month-of x))	(year (year-of x)) )    (cond     ((eq month 12)      (add-week-12 x date) )     ((eq month 2)      (add-week-2 x date year) )     ((31-days month)      (add-week-31 x date month) )     (t      (add-week-30 x date month) ))))(defun add-week-12 (x date)		; what if year like 9999??  (let ((newdt (+ date 6)))    (if (<= newdt 31)	(+ x 60000)       (+ 1000000	 (rem (+ (- x (* date 10000)) 1 (* 10000 (- newdt 31))) 1000000)))))(defun add-week-2 (x date year)  (let ((newdt (+ date 6)))    (if (<= newdt 28)	(+ x 60000)      (if (leap-year? year) 	  (if (<= newdt 29)	      (+ x 60000)	    (+ 3000000	       (rem (+ (- x (* date 10000)) (* 10000 (- newdt 29))) 1000000) ))	(+ 3000000	   (rem (+ (- x (* date 10000)) (* 10000 (- newdt 28))) 1000000))))))(defun add-week-30 (x date month)  (declare (ignore month))  (let ((newdt (+ date 6)))    (if (<= newdt 30)	(+ x 60000)      (+ 1000000 (- x (* 10000 date)) (* 10000 (- newdt 30))))))(defun add-week-31 (x date month)  (declare (ignore month))  (let ((newdt (+ date 6)))    (if (<= newdt 31)	(+ x 60000)      (+ 1000000 (- x (* 10000 date)) (* 10000 (- newdt 31))))))(defun schedule-span (start-time end-time resolution)  (let (s-hour s-min e-hour e-min)    (setq s-hour (hour start-time) s-min (minute start-time))    (setq e-hour (hour end-time) e-min (minute end-time))    (setq s-min (* resolution (ceiling s-min resolution)))    (setq e-min (* resolution (floor e-min resolution)))    (let (min-diff)      (setq min-diff (+ (* (- e-hour s-hour) 60) (- e-min s-min)))      (ceiling (/ min-diff resolution)))))(defun time-ceiling (time resolution)  (maktime (hour time) (* resolution (ceiling (minute time) resolution))))(defun hour (time)  (read-from-string (stringsubseq (symbol-name time) 1 2)))(defun minute (time)  (read-from-string (stringsubseq (symbol-name time) 4 5)))(defun maktime (hour minute)  (intern (strappend (format nil "~2,'0D" hour) "-" (format nil "~2,'0D" minute))))(defun time-int-to-str (time)  "NNNN (integer) to \"HH:MM am/pm\" (string)"  (declare (type (integer 0 2500) time))  (let ((hour (truncate (/ time 100)))	(minute (mod time 100))	suffix )    (cond     ((= hour 12)      (setq suffix "noon") )     ((or (= hour 0) (= hour 24))      (setq hour 12)      (setq suffix "mid") )     ((< hour 12)      (setq suffix "am") )     (t      (setq hour (- hour 12))      (setq suffix "pm") ))    (if (= minute 0)	(format nil "~D&nbsp;~A" hour suffix)      (format nil "~D:~2,'0D" hour minute) )))(defun nbsp-ify (str)  (do ((space-pos (position #\space str) (position #\space str)))      ((null space-pos) str)      (setq str	    (concatenate 'string	                 (subseq str 0 space-pos) "&nbsp;" (subseq str (1+ space-pos))))));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;