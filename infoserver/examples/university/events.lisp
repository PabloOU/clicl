;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Reservations.Lisp ;;; Winton Davies, October 14th, 1997.;;; Special case handler for Room scheduling.;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;TODO:;; Prev/Next;; Mail;; Daily Mon-Fri, Mon-Wed-Fri, Tue-Thu;; Authorization;; Authentication ;; logging;; resourse scheduling (no repeat events, UTC);;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;                                          When Warning  No-Conflict  When-Conflict;; CASES -- Create New Repeating Event              ;;          Modify Non Date Part of Repeating Event;;          Modify Date Part of Repeat Event;;          Delete Repeat Event;;          Create Non Repeat Event;;          Modify Non Repeat Event;;          Delete Non Repeat Event;;          Modify Child Event;;          Delete Child Event;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(defvar *port* niL)(setq *web-server-port* 8000)(setq *background-event-ticks* 100)(setq *background-sleep-ticks* 5);;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Local Definitions;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(defparameter *domail* t)(defparameter *reservations* (make-instance 'fastserver :name 'reservations))(defparameter *lock* (make-lock :name "reservations"))(defparameter *dumpcount* 100) ;;; force it to dump first thing after start up...(defparameter *dumpmax* 100)(defparameter *basedir* "/logic2/gin/Data")(defparameter *kiffile* (format nil "~a/~a" *basedir* "gates-events.kif"))(defparameter *incfile* (format nil "~a/~a" *basedir* "gates-events.inc"));;;; Start cleanup;;(defun cleanup-files ()  (mapcar       #'(lambda (filename)          (ignore-errors (delete-file filename)))      (mapcar #'(lambda (ts) (format nil "~a.~a" *kiffile* ts))              (ordered-files-ts "gates-events*kif*")))  (mapcar       #'(lambda (filename)          (ignore-errors (delete-file filename )))      (mapcar #'(lambda (ts) (format nil "~a.~a" *incfile* ts))              (ordered-files-ts "gates-events*inc*"))))(defun ordered-files-ts (filestring )  (nthcdr 3 (sort (mapcar #'(lambda (x)              (read-from-string (subseq x (1+ (position #\. x :start (1+ (position #\. x)))))))          (mapcar #'file-namestring (directory (format nil "~a/~a" *basedir* filestring)))          )        #'>)));;;;;; End Cleanup;;;         ;;; copy-files to .timestamp         ;;; dump-files to .tmp         ;;; delete .kif, .inc         ;;; rename .tmp to .kif(defmethod message-handler :around (msg sender (receiver (eql *reservations*)))  (let ((status nil))    (with-lock-grabbed (*lock*)      (when (and (listp msg) (find (car msg) '(tell untell)))        (when (> *dumpcount* *dumpmax*)          (let* ((ts (get-universal-time))                 (kfarch (format nil "~a.~a" *kiffile* ts))                 (ifarch (format nil "~a.~a" *incfile* ts))                 (kftemp (format nil "~a.tmp" *kiffile*))                 (iftemp (format nil "~a.tmp" *incfile*)))            (handler-case              (progn                 (dump-theory receiver kftemp)                (logmessage (list 'quote `(created ,iftemp ,(get-universal-time))) iftemp))              (error (condition)                      (progn                        (ignore-errors (delete-file kftemp )) ;; because we don't corrupted data                       (ignore-errors (delete-file iftemp )) ;; because we don't corrupted data                       (setq status (format nil  "Reservations Agent (error dumping): ~A" condition)))))            (unless status              (handler-case                 (progn                  (rename-file *kiffile*  kfarch   )                  (rename-file *incfile*  ifarch   )                  (rename-file kftemp *kiffile*    ) ;; because we don't want to overwrite                  (rename-file iftemp *incfile*    ) ;; because we don't want to overwrite	          (cleanup-files))                (error (condition) (setq status (format nil  "Reservations Agent(error renaming): ~A" condition))))))          (unless status                      (setq *dumpcount* 0)))           (unless status          (setq *dumpcount* (1+ *dumpcount*))          (handler-case                      (logmessage `(acleval ',msg nil *reservations*) *incfile*)            (error (condition)                    (setq status (format nil "Reservations Agent (log): ~A" condition))))))      (if status        (progn           (sendmail '("gin@godel2.stanford.edu") "ATTENTION RESERVATIONS FILE PROBLEMS" status)          status)        (acleval msg sender receiver)))))#|(save '(isa reservations fastserver) manager@semantics.stanford.edu)(defun define-interests-specialtys (manager agent list-of-slots)  (mapcar     #'(lambda (slot)        (save `(specialty ,agent ,slot) manager)        (save `(interest ,agent ,slot) manager))   list-of-slots))(define-interests-specialtys manager@semantics.stanford.edu reservations   '(isa-room-reservation event-title reserved-room date event-start-time event-end-time     reserved-by notify-also event-repeat-count event-repeat-interval scheduled    conflict warning event-parent event-child event-next-sibling event-prev-sibling))|#;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Basic Hooks.;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(defmethod save :around (P (TH (eql *reservations*)) &OPTIONAL (F 'SAMEP))  (when (equal (car p) 'date)    (setf p (list (first p) (second p) (intern (parsedate (stringify (third p)))))))  (when (member (car p) '(notify-also reserved-by))    (unless (position #\@ (third p))      (format t "~%Converting email address: ~a" (third p))      (setf p (list (first p) (second p) (format nil "~a@cs.stanford.edu" (third p))))))  (ep::saveth p th f)  (update-conflicts (second p) (first p) th f)  (if (get-conflict (second p) 'p)      (prog1        (format-conflict-message (second p))        (drop p th f)        (drop-all 'conflict (second p) th f) ; Remove all errors...        (drop-all 'warning (second p) th f)         )      (prog1 T        (if (get-parent (second p))          (save-email-message (get-parent (second p)) th f)        (save-email-message (second p) th f)))))(defmethod drop :around (P (TH (eql *reservations*)) &OPTIONAL (F 'SAMEP))  (ep::dropth p th f)  (update-conflicts (second p) (first p) th f)  (when (equal (first p) 'ISA-ROOM-RESERVATION)    (if (get-parent (second p))        (save-email-message (get-parent (second p)) th f)      (delete-email-message (second p) th f))    (drop-all '?x (second p) th f))  nil);;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Update Conflicts;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(defun update-conflicts (event-id slotname th &OPTIONAL (F 'SAMEP))  "Using find-conflicts, set Scheduled or Reasons"  (drop-all 'conflict event-id th f)  (drop-all 'warning event-id th f)  (when (get-parent event-id)    (drop-all 'conflict (get-parent event-id) th f)    (drop-all 'warning (get-parent event-id) th f)    (drop-all 'event-repeat-interval event-id th f)    (drop-all 'event-repeat-count event-id th f))  (drop-all 'scheduled event-id th f)  (let     ((conflicts (find-conflicts event-id)))    (cond     (conflicts      (loop for conflict-reason in conflicts	    do	    (if (stringp conflict-reason)              (save-error 'WARNING event-id conflict-reason th f)              (save-error 'CONFLICT event-id conflict-reason th f)))      (ep::saveth `(SCHEDULED ,event-id No) th f))     (t (ep::saveth `(SCHEDULED ,event-id Yes) th f))))  (if  (and  (get-interval event-id)             (NOT (EQUAL (get-interval event-id) 'NONE))             (get-count event-id)             (NOT (EQUAL (get-count event-id) 'NONE))             (>= (get-count event-id) 2)             (eq (get-scheduled event-id) 'Yes))    (if (get-child event-id)      (let () (drop-children-slot event-id slotname th f)           (set-children-slot event-id slotname th f))      (make-children event-id th f))    (when (get-child event-id)      (if (member slotname '(event-repeat-interval event-repeat-count date))        (drop-all-children event-id th f)        (drop-children-slot event-id slotname th f))))  (when (findp `(and (event-child ?parent ,event-id)                     (unprovable (isa-room-reservation ,event-id))) th)    (let ((parent-id (findx '?x `(event-child ?x ,event-id) th)))      (ep::dropth `(event-child ,parent-id ,event-id) th f)      (ep::dropth `(event-parent ,event-id ,parent-id) th f)      (drop-all 'scheduled event-id th f)      (drop-all 'conflict parent-id th f)      (drop-all 'warning parent-id th f)      (drop-all 'scheduled parent-id th f)      (ep::saveth `(SCHEDULED ,parent-id Yes) th f)))  (when (or (get-parent event-id)            (get-child event-id))    (inherit-children-problems 'conflict event-id th f)    (inherit-children-problems 'warning event-id th f)    (when (get-parent event-id)      (drop-all 'scheduled (get-parent event-id) th f)      (if (or (get-slot 'warning (get-parent event-id) )              (get-slot 'conflict (get-parent event-id) ))        (ep::saveth `(SCHEDULED ,(get-parent event-id) NO) th f)        (ep::saveth `(SCHEDULED ,(get-parent event-id) YES) th f)))    (when (get-child event-id)      (drop-all 'scheduled  event-id th f)      (if (or (get-slot 'warning  event-id)              (get-slot 'conflict event-id))        (ep::saveth `(SCHEDULED ,event-id NO) th f)        (ep::saveth `(SCHEDULED ,event-id YES) th f)))    (set-children-prev-and-next event-id th f)));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Set-Children-Slot, Drop-Children-Slot ...;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(defun set-children-prev-and-next (event-id th f)  (when (get-parent event-id)    (setq event-id (get-parent event-id)))  (loop     for child in (get-child event-id 'a)    do (drop-all 'event-next-sibling child th f)       (drop-all 'event-prev-sibling child th f))  (loop with children = (sort (finds '?child                                      `(and (event-child ,event-id ?child)                                          (scheduled ?child yes))                                      th) '< :key #'universal-start-time-of-event)        for i from 0 to (1- (length children))        do        (unless (equal i 0)           (ep::saveth  `(event-prev-sibling ,(elt children i) ,(elt children (1- i)) ) th f))        (unless (equal i  (1- (length children)))         (ep::saveth  `(event-next-sibling ,(elt children i) ,(elt children (1+ i)) ) th f))))(defun universal-start-time-of-event (id)   (let ((st  (get-start id))        (dt (datelist-of-date-symbol (get-date id))))  (encode-universal-time 0 (rem st 100) (floor st 100) (second dt) (first dt) (third dt))))(defun set-children-slot (parent-id slotname th f)  (when (get-slot slotname parent-id)    (loop with val = (get-slot slotname parent-id)          for child-id in (get-child parent-id 'a)          do (save `(,slotname ,child-id ,val) th f))))(defun drop-children-slot (parent-id slotname th f)    (loop           for child-id in (get-child parent-id 'a)          do (ep::dropth `(,slotname ,child-id ,(get-slot slotname child-id)) th f)             (update-conflicts child-id slotname th f)))(defun save-error (type event-id conflict-reason th &optional (f #'samep))  (ep::saveth `(,type ,event-id ,conflict-reason) th f));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Make-Children...;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(defun make-children (event-id th &OPTIONAL (F 'SAMEP))  (let ((children-dates            (mapcar 'intern (make-repeat-event-dates                                      (get-date event-id)                                      (get-count event-id)                                      (get-interval event-id))))         (children-ids                    (loop for i from 1 to (get-count event-id)                       collect (intern (format nil "~A-~D" event-id i)))))    (loop with children-tuples = nil          for d in children-dates          for i in children-ids          do          (setq children-tuples (copy-parent event-id i th))          (push `(DATE ,i ,d) children-tuples)          (push `(ISA-ROOM-RESERVATION ,i) children-tuples)          (setq children-tuples (append children-tuples (list  `(EVENT-CHILD  ,event-id ,i))))          (setq children-tuples (append children-tuples (list  `(EVENT-PARENT ,i ,event-id))))          (loop             for tuple in children-tuples            do            (ep::saveth tuple th f)            finally (update-conflicts i 'date th f)))));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Copy-Parent;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(defun copy-parent (event-id child-id  th )  (loop with tuple = nil    for slot in '(event-title reserved-room event-start-time event-end-time reserved-by notify-also	          URL RESERVATION-TOPIC EVENT-SPEAKER-BIO RESERVATION-ABSTRACT RESERVATION-TYPE)    do    (setq tuple (findx `(,slot ,child-id ?val) `(,slot ,event-id ?val) th))    unless (null tuple)    collect tuple));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Make Repeating Event Dates Code;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; (defun make-repeat-event-dates (date-symbol count interval)    (setq interval           (cond ((equal interval 'daily) 'day)                ((equal interval 'daily-mon-to-fri) '(0 1 2 3 4))                ((equal interval 'daily-mon-wed-fri) '(0  2  4))                ((equal interval 'daily-mon-wed) '(0 2))                ((equal interval 'daily-wed-fri) '(2 4))                ((equal interval 'daily-tue-thu) '(1 3))                ((equal interval 'daily-sat-sun) '(5 6))                ((equal interval 'weekly) 'week)                ((equal interval 'biweekly) 'biweek)                ((equal interval 'monthly) 'month)))    (if (listp interval)      (loop with date = (remove #\| (makestring date-symbol))            and current-day = nil            and day-list = nil	for month = (parse-integer date :start 0 :end 2)	for day   = (parse-integer date :start 3 :end 5)	for year  = (parse-integer date :start 6)	for i from 1 to count        do         (setq current-day (day-of month day year))        (setq day-list (member current-day interval))        when (null day-list) do (setq i (1- i)) 	unless (null day-list) collect date	do (setq date                   (format nil "~{~2,'0D/~2,'0D/~D~}"                          (multiple-value-list (date-plus month day year 1 'daily))))))         (loop with date = (remove #\| (makestring date-symbol))	for month = (parse-integer date :start 0 :end 2)	for day   = (parse-integer date :start 3 :end 5)	for year  = (parse-integer date :start 6)	for i from 1 to count        collect date 	do (setq date                   (format nil "~{~2,'0D/~2,'0D/~D~}"                          (multiple-value-list (date-plus month day year 1 interval))))));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Inherit-Children-Problems;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(defun inherit-children-problems (problem event-id th &OPTIONAL (F 'SAMEP))  (when (get-parent event-id)    (setq event-id  (get-parent event-id)))  (loop     for id in (get-child event-id 'a)    do    (loop       for parent-tuple in (finds `(,problem ,event-id  ?val)  `(,problem ,id ?val) th)      do      (ep::saveth parent-tuple th f)))    (finds `(,problem ?event-id ?val) `(,problem ?event-id ?val) th));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; find-conflicts;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(defun find-conflicts       ( event-id &aux       (room  (get-room event-id))       (start (get-start event-id))       (end   (get-end event-id))       (date  (get-date event-id))       (conflicts t)) (if (and (not date) room start end) ;order dependent hack...     (setq conflicts `(,event-id                     ,(format nil           "Your event \"~a\" could not be scheduled because no legal date was specified."             (get-title event-id)))) (if (and room date start end)   (if (=< end start)     (setq conflicts `(,event-id ,(format nil (strappend                 "Your event \"~a\" could not be scheduled because the end time (~a) "                 "came before the start time (~a)."                 "Note that zero length meetings are not allowed.")            (get-title event-id)            (prettify-time start)            (prettify-time end))))     (setq conflicts            (finds            '?e            `(and	      (reserved-room ?e ,room)	      (date ?e ,date)              (scheduled ?e Yes)              (unprovable (event-child ?e ?children))     ;; DO NOT CLASH WITH OTHERS PARENTS              (unprovable (event-child ,event-id ?e))     ;; DO NOT CLASH WITH OWN CHILD              (unprovable (event-parent ,event-id ?e))    ;; DO NOT CLASH WITH OWN PARENT	      (event-start-time ?e ?st)	      (event-end-time ?e ?et)	      (< ?st ,end)	      (> ?et ,start))            *reservations*            )           ))   (setq conflicts (loop with c = nil                          for i in `((,room room) (,start event-start-time)                                     (,end event-end-time) (,date date))                         do                         (unless  (first i)                            (push (format nil "~a field Missing" (second i)) c))                         finally (return c)))   ))  conflicts);;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; drop-all...;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(defun drop-all (slot event-id th &OPTIONAL (F 'SAMEP)) (loop    for tuple in (finds `(,slot ,event-id ?val) `(,slot ,event-id ?val) th)   do   (ep::dropth tuple th f)))(defun drop-all-children (event-id th &OPTIONAL (F 'SAMEP)) (loop    for id in (get-child event-id 'a)   do   (ep::dropth `(isa-room-reservation ,id) th f)   (ep::dropth `(event-child ,event-id ,id) th f)   (loop      for tuple in (finds `(?slot ,id  ?val)  `(?slot ,id ?val) th)     do     (ep::dropth tuple th f))));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; format-conflict-message;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(defun format-conflict-message (event-id)  (if (member event-id (get-conflict event-id 'a))    (get-warning event-id )    (format nil (strappend "Your event(s) \"~a\" could not be scheduled"                           " because of conflicts with"                           " the following scheduled event(s):<BR><BR><BR>"                           "<TABLE BORDER=1><TR><TH>Date</TH><TH>Event ID</TH><TH>Posted-By</TH><TH>Title</TH></TR>"                           "~{<TR>~{<TD>~a</TD>~}</TR>~}</TABLE>")                           (get-title event-id)                           (loop                              for conflict-id in (get-conflict event-id 'a)                             collect                                  (list                                         (format nil "~a, ~a ~a-~a"                                                (string-capitalize                                                  (day-of-date-symbol                                                   (get-date  conflict-id)))                                                (get-date  conflict-id)                                                (prettify-time (get-start conflict-id))                                                (prettify-time (get-end conflict-id))                                                )                                       (format nil "<A HREF=/INSPECT?~a>~a</A>"                                               conflict-id conflict-id)                                       (format nil "<A HREF=mailto:~a>~a</A>"                                               (get-by conflict-id) (get-by conflict-id))                                       (get-title conflict-id)                                       )))));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; E-Mail Code;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; save-email-message;;;(defun save-email-message (handle th &optional (f #'samep)                              &aux (text "")(delete-text nil)(modified nil))  (when  (findp `(and (scheduled ,handle Yes)                      (event-repeat-count ,handle    ?anycount)                      (event-repeat-interval ,handle ?anyinterval)                      (reserved-by ,handle ?anyone)                      ) th)    (setq text (make-message handle))        (setq delete-text (make-message handle :deleted? t))    (when      (and  (get-slot 'delete-message handle)       (not  (equalp delete-text (get-slot 'delete-message handle))))      (setq modified t)      (drop-all 'delete-message handle  th f)      (drop-all 'delete-message-subject handle th f))    (ep::saveth `(delete-message ,handle ,delete-text) th f)    (ep::saveth `(delete-message-subject ,handle ,(make-subject handle :deleted? t)) th f)    (when      (findp `(and (or (reserved-by ,handle ?x)                       (notify-also ,handle ?x))                   (unprovable (notified ,handle ?x))) th)      (let ((to-list (append (get-by handle 'a)                             (get-also handle 'a)                             (list (request `(ask-one ?x 				(and (cc ,(get-room handle) yes)(gates-contact  ,(get-room handle)  ?x))) nil available)))))        ;; remove notifieds from to-list...	(when (equal (get-event-type handle) 'colloqium)	      (unless (member "colloq" to-list :test 'search)	            (push "colloq@cs.stanford.edu" to-list)))        (setq to-list (set-difference to-list (get-slot 'notified handle 'a) :test #'equalp))        (sendmail to-list (make-subject handle) text)        (loop for to in to-list              do (ep::saveth `(notified ,handle ,to) th f))))    (when (and modified                (findp `(and (or (reserved-by ,handle ?x)                                (notify-also ,handle ?x))                            (notified ,handle ?x)) th))      (sendmail (get-slot 'notified handle 'a) (make-subject handle :modified? t) text))));;;;;; delete-email-message;;;(defun delete-email-message (handle th &optional (f #'samep))  "Pretty simple really, send and clean up to all notified"       (sendmail (get-slot 'notified handle 'a)              (get-slot 'delete-message-subject handle)             (get-slot 'delete-message handle)             )  (drop-all 'notified handle th f)  (drop-all 'delete-message handle th f)  (drop-all 'delete-message-subject handle th f)  );;;;;; make-subject;;;(defun make-subject (handle &key (deleted? nil) (modified? nil))  "returns subj" (if (not (equal (get-event-type handle) 'COLLOQIUM))  (cond   (deleted?  (format nil "~:(~A~) reservation deleted" (get-room handle)))   (modified? (format nil "Confirmation: ~:(~A~) room reservation modified" (get-room handle)))   (T (format nil "Confirmation: ~:(~A~) room reservation" (get-room handle)))   )  (cond   (deleted?  (format nil "COLLOQIUM: ~:(~A~) cancelled"  (get-title handle)))   (modified? (format nil "COLLOQIUM: ~:(~A~) details modified"  (get-title handle)))   (T (format nil "COLLOQIUM: ~:(~A~) AUTOMATIC ANNOUNCEMENT" (get-title handle))))));;;;;; make-subject;;;(defun make-message (handle &key (deleted? nil))  "returns text"     (with-output-to-string (s)	(format s "~%~%")	(when (get-event-abstract handle) (format s "~%~%Abstract:~%~A" (get-event-abstract handle)))	(when (get-event-bio handle) (format s "~%~%Information About The Speaker:~%~A" 	                  (get-event-bio handle)))	(when (get-child handle)	  (format s "~%~%This is a multiple reservation applying to the following dates:~%~%")	  (format s "~{     ~A~^, ~A~^, ~A~^,~%~}"                   (mapcar #'(lambda(date)                              (format nil "~a ~a"                                       (string-capitalize                                       (string-downcase (day-of-date-symbol date)))                                      date))                              (mapcar 'get-date (get-child handle 'a)))))	(if deleted?	    (progn	      (format s "~%~%The reservation for event ~A has been deleted.~%"		      handle )	      (format s "~%~%The reservation used to be as follows:~%~%") )	  (format s "~%~%The reservation details for event ~A are:~%~%" handle) )	(format s "~5T~:(~A~):~25T~A~%"                "Event Title" (prettify (get-title handle)))	(when (get-event-topic handle)	(format s "~5T~:(~A~):~25T~A~%"                "Event Topic" (prettify (get-event-topic handle))))	(when (get-event-type handle)	(format s "~5T~:(~A~):~25T~A~%"                "Event Type" (prettify (get-event-type handle))))	(when (get-event-url handle)			(format s "~5T~:(~A~):~25T~A~%"                "Event URL" (prettify (get-event-url handle))))        (format s "~5T~:(~A~):~25T~A~%"                "Reserved Room" (prettify (get-room handle)))        (unless (get-child handle)          (format s "~5T~:(~A~):~25T~A~%"                  "Date" (prettify (get-date handle))))        (format s "~5T~:(~A~):~25T~A~%"                "Start Time" (prettify (make-time-symbol-from-integer (get-start handle))))        (format s "~5T~:(~A~):~25T~A~%"                "End Time" (prettify (make-time-symbol-from-integer (get-end handle))))        (when (get-child handle)          (format s "~5T~:(~A~):~25T~A~%"                  "Repeat Count" (prettify (get-count handle)))          (format s "~5T~:(~A~):~25T~A~%"                  "Repeat Interval" (prettify (get-interval handle))))        (format s "~5T~:(~A~):~25T~A~%"                "Reserved By" (prettify (get-by handle)))                (format s "~%~:[~;Some of the events differ as follows:~%~:*~{~5T~a~^~%~}~]"                 (remove nil                         (loop                   for child in (get-child handle 'a)                  append (loop for slot in '(reserved-room event-start-time event-end-time)                               collect (reservation-differences handle child slot)                                  ))                  ))      (format s "~                  This is an automatic email confirmation by the Infomaster system. ~                  It is simply a notification, for your information.  If you wish to ~                  examine or modify the reservation further, please go to Infomaster ~                  on the web at <http://infomaster.stanford.edu:~a/inspect?~a>.~                 " *web-server-port* handle)))    ;;;;;; reservation-differences;;;(defun reservation-differences (parent child slot)    "Says whether there is a difference in individual children slots"    (if (equal (get-slot slot parent)(get-slot slot child)) nil        (format nil "~a (~a), the ~a is ~a" (get-date child) child slot (get-slot slot child))));;;;;; sendmail;;;(defun sendmail (to-list subject body &aux (server "smtp.stanford.edu"))  (loop for to in to-list        unless (string= to "colloq@cs.stanford.edu") do         (if *domail*          (mail "<gin@godel2.Stanford.EDU>" to subject body server)          (format t "~%From:~a~%To:~a~%Subject:~a~%~%~a"                   "gin@godel2.Stanford.EDU (Infomaster system)" to subject body))));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Utilities...;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; (defun get-slot (slot id &optional (form nil))  (cond ((or (null form)(eq form '1))         (findx '?x `(,slot ,id ?x) *reservations*))        ((eq form '1t)         (findx `(,slot ,id ?x) `(,slot ,id ?x) *reservations*))        ((eq form 'a)         (finds  '?x `(,slot ,id ?x) *reservations*))        ((eq form 'at)         (finds `(,slot ,id ?x) `(,slot ,id ?x) *reservations*))        ((eq form 'p)         (findp `(,slot ,id ?x) *reservations*))))(defun make-short-cuts (list-of-short-long-slots)  (mapcar #'(lambda(pair)            (eval `(defun ,(intern (format nil "GET-~a" (first pair)))                  (id  &optional (form nil))             (get-slot (quote ,(second pair)) id form)             )))          list-of-short-long-slots))(make-short-cuts  '((title event-title)   (room reserved-room)   (date date)   (start event-start-time)   (end event-end-time)   (count event-repeat-count)   (interval event-repeat-interval)   (by reserved-by)   (also notify-also)   (parent event-parent)   (child event-child)   (prev event-prev-sibling)   (next event-next-sibling)   (warning warning)   (conflict conflict)   (scheduled scheduled)   (event-topic reservation-topic)   (event-abstract reservation-abstract)   (event-type reservation-type)   (event-bio event-speaker-bio)   (event-url url)));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; End Of File Events;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(defun init-gates-load ()  (setq *domail* nil)  (if (probe-file *kiffile*)    (ep::load-theory  *kiffile* *reservations* #'insert)    (handler-case      (logmessage (list 'quote `(created ,*kiffile* ,(get-universal-time))) *kiffile*)      (error (condition)             (progn                (setq *domail* nil)                     (sendmail '("gin@godel2.stanford.edu")                          "ATTENTION RESERVATIONS FILE PROBLEMS"                          (format nil "Initialising kif file:~a" condition))                (ext)))))  (if (probe-file *incfile*)    (load *incfile*)    (handler-case      (logmessage (list 'quote `(created ,*incfile* ,(get-universal-time))) *incfile*)      (error (condition)             (progn                 (setq *domail* nil)               (sendmail '("gin@godel2.stanford.edu")                          "ATTENTION RESERVATIONS FILE PROBLEMS"                          (format nil "Initialising inc file:~a" condition))                (exit)))))  (setq *domail* T)  (length (contents *reservations*)));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;