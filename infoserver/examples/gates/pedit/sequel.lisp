;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; (c) Copyright 1999-2003 by Michael R. Genesereth.  All rights reserved.;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(eval-when (compile load eval)  (proclaim '(special *client* *agent* *interface* *manager*                      *var-count* *version* *from* *alist*)))(defun explode (string &optional (separator #\NEWLINE))  (let (result (current "") (input-stream (make-string-input-stream string)))    (dotimes (i (length string) (setf result (append result `(,current))))      (let ((char (read-char input-stream)))        (cond ((equalp char separator) (setf result (append result `(,current))) (setf current ""))        (t (setf current (stringappend current char))))))))(defun implode (list &optional (separator #\NEWLINE))  (if (null (cdr list))    (car list)    (stringappend (car list) separator (implode (cdr list) separator))))(defun shellify (string)  (if (listp string) (setf string (implode string)))  (let ((input-stream (make-string-input-stream string)) (result ""))    (dotimes (i (length string) result)      (let ((char (read-char input-stream)))      (cond ((equalp char #\NEWLINE) (setf char "\\\\n"))            ((equalp char #\\) (setf char "\\"))            ((equalp char #\") (setf char "\\\"")))      (setf result (stringappend result char))))))(defun do-sybase-query (query)  (bsd:system-command (stringappend "echo -e \"" (shellify query) "\" | env SYBASE=/Applications/Sybase/System DSQUERY=pedit DSCONSOLE=pedit \   /Applications/Sybase/System/OCS-12_5/bin/isql -S pedit -U infomaster -P 99info99 -D csd")));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Dumping everything;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(defmethod dump (fn)  (declare (ignore fn))  "Dump takes a file name as argument.")(defmethod dump ((fn string))  (with-open-file (f fn :direction :output :if-exists :supersede)    (formatn f ";;;;;;;;;;;;;;;;" 5) (terpri f)    (format  f ";;; Infomaster Version ~A" *version*) (terpri f)    (formatn f ";;;;;;;;;;;;;;;;" 5) (terpri f)    (terpri f)    (dolist (agent (cons 'manager (remove 'manager (getbaskets))))      (format f "(define-theory ~A \"\" '(" agent)      (do ((l (contents (symbol-value agent)) (cdr l)))          ((null l) (format f "))") (terpri f))          (terpri f) (format f "  ~S" (car l)))      (terpri f))    (formatn f ";;;;;;;;;;;;;;;;" 5) (terpri f)    (formatn f ";;;;;;;;;;;;;;;;" 5) (terpri f)    (formatn f ";;;;;;;;;;;;;;;;" 5) (terpri f)    'done))(defun formatn (s str n)  (do ((i 1 (1+ i)))      ((> i n) 'done)      (format s str)));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Soapservers;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(defclass soapserver (agent) ())(defmethod message-handler (*message* *sender* (*receiver* soapserver))  (rpcsoap *message* *sender* *receiver*));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Aclservers;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(defclass aclserver (agent) ())(defmethod message-handler (*message* *sender* (*receiver* aclserver))  (rpc *message* *sender* *receiver*))(defmethod rpc (msg sender (receiver aclserver))  (with-open-stream    (s (open-connection (find-host (name receiver)) (find-port (name receiver))))    (when (not (null s)) (sayacl msg s sender receiver) (hearacl s))))(defun sayacl (msg s sender receiver)  (when *trace*    (fresh-line *trace*) (prin1 msg *trace*) (force-output *trace*))  (setq msg (prin1-to-string (exportdata msg)))  (format s "POST / HTTP/1.0") (crlf s)  (format s "Accept: text/delim") (crlf s)  (format s "Sender: ~A" (externalize sender)) (crlf s)  (format s "Receiver: ~A" (externalize receiver)) (crlf s)  (format s "Content-type: text/acl") (crlf s)  (format s "Content-length: ~A" (length msg)) (crlf s)  (crlf s)  (format s "~A" msg)  (finish-output s)  'done)(defun hearacl (s)  (do () ((or (not (open-stream-p s)) (listen s))))  (when (search "200" (get-http-line s) :test #'char=)    (multiple-value-bind (type len client password) (parse-header s)      (declare (ignore type client password))      (importdata (read-user-string (read-content s len))))))(defun internalize (y)  (let (pos short)    (setq pos (position #\@ y :test #'char=))    (cond ((and pos (> pos 0))           (setq short (read-value-string (subseq y 0 pos)))           (if (findp `(NameIsGlobal ,short no) *manager*)             short             (read-value-string y)))          (t (read-value-string y)))))(defun externalize (x)  (setq x (name x))  (if (findp `(nameisglobal ,x no) *manager*)    (symbol-name (universalize x))    (symbol-name x)))(defun exportdata (data)  (do ((l (find-all-agents) (cdr l)) (al))      ((null l) (sublis al data))      (setq al (acons (car l) (intern (externalize (car l))) al))))(defun importdata (data)  (do ((l (find-all-agents) (cdr l)) (al))      ((null l) (sublis (nreverse al) data))      (setq al (acons (intern (externalize (car l))) (car l) al))))(defun find-all-agents ()  (finds '?x `(isa ?x agent) *manager*));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Sqlservers;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(defclass sqlserver (agent) ())(defmethod message-handler (*message* *sender* (*receiver* sqlserver))  (cond ((atom *message*) nil)        ((eq 'ask-if (car *message*))         (not (null (sqlaskall *message* *sender* *receiver*))))        ((eq 'ask-one (car *message*))         (car (sqlaskall *message* *sender* *receiver*)))        ((eq 'ask-all (car *message*))         (sqlaskall *message* *sender* *receiver*))        ((and (eq 'length (car *message*))              (listp (cadr *message*)) (eq 'ask-all (caadr *message*)))         (caar (rpc *message* *sender* *receiver*)))))(defun sqlaskall (msg sender receiver)  (cond ((atom (cadr msg)) (mapcar #'car (sqlaskall1 msg sender receiver)))        (t (sqlaskall1 msg sender receiver))))(defun sqlaskall1 (msg sender receiver)  (cond ((and (eq 'and (caaddr msg)) (eq 'oneof (caadr (caddr msg))))         (sqlaskall2 (cadr msg) (caddr msg) sender receiver))        (t (rpc msg sender receiver))))(defparameter *sqlsize* 200)(defun sqlaskall2 (x p sender receiver)  (let ((vars) (vals) (news) (ins) (invals) (outs) (outvals) (columns))    (setq vars (vars (cadadr p)) vals (cddadr p))    (setq x (vars x) p (maksand (cddr p)))    (setq news (vars p))    (cond ((setq ins (intersect vars news))           (do ((l vars (cdr l)) (i 1 (1+ i)) (nl))               ((null l) (setq invals (apply #'project vals (nreverse nl))))               (when (find (car l) news) (setq nl (cons i nl)))))          (t (setq ins '(1) invals '((1)))))    (setq news (goodvars p))    (setq outs (economize (intersect (unionize ins x) news)))    (do ((l invals (nthcdr *sqlsize* l)) (dum) (nl))        ((null l) (setq outvals (nreverse nl)))        (setq dum (makand `(oneof ,ins . ,(sqlsubseq l 1 *sqlsize*)) p))        (setq nl (nreconc (rpc `(ask-all ,outs ,dum) sender receiver) nl)))    (cond ((subsetp vars outs) (setq vals outvals))          (t (do ((l vars (cdr l)) (i 1 (1+ i)) (dum) (nl))                 ((null l) (setq columns (nreverse nl)))                 (when (setq dum (position (car l) outs))                   (setq nl (cons (1+ dum) (cons i nl)))))             (setq vals (apply #'join vals outvals columns))             (setq outs (unionize vars outs))))    (do ((l x (cdr l)) (dum) (nl))        ((null l) (apply #'project vals (nreverse nl)))        (when (setq dum (position (car l) outs))          (setq nl (cons (1+ dum) nl))))))(defun sqlsubseq (items start end)  (do ((l items (cdr l)) (i start (1+ i)) (nl))      ((or (null l) (> i end)) (nreverse nl))      (setq nl (cons (car l) nl))))(defmethod transmit (msg sender (receiver sqlserver))  (declare (ignore sender))  (ignore-errors   (with-open-stream (s (open-connection (host receiver) (port receiver)))     (when (not (null s)) (speak msg s)))))(defmethod rpc (msg sender (receiver sqlserver))  (declare (ignore sender))  (ignore-errors   (with-open-stream (s (open-connection (host receiver) (port receiver)))     (when (not (null s)) (speak (sql msg) s) (hear s receiver)))))(defmethod spc (msg sender (receiver sqlserver))  (declare (ignore sender))  (ignore-errors   (with-open-stream (s (open-connection (host receiver) (port receiver)))     (when (not (null s)) (speak msg s) (hear s receiver)))))(defun speak (msg s)  (when *trace*    (fresh-line *trace*) (prin1 msg *trace*) (force-output *trace*))  (format s "POST / HTTP/1.0") (crlf s)  (format s "Accept: text/delim") (crlf s)  (format s "Content-type: text/sql") (crlf s)  (format s "Content-length: ~A" (length msg)) (crlf s)  (crlf s)  (format s "~A" msg)  (finish-output s)  'done)(defun crlf (s)  (format s "~A~A" #\return #\linefeed))(defun hear (s receiver)  (do () ((or (not (open-stream-p s)) (listen s))))  (cond ((search "200" (get-http-line s) :test #'char=)         (do ((line (get-http-line s) (get-http-line s)))             ((or (null line) (equal line "")) (when *trace* (fresh-line)))             (when *trace* (fresh-line) (princ line)))         (do ((line (get-line s) (get-line s)) (nl))             ((equal line "") (nreverse nl))             (when *trace* (fresh-line) (princ line))             (unless (equal line "") (setq nl (cons (parseline line) nl)))))        (t (problem "Bad answer from ~A." (name receiver)))))(defun get-line (s)  (with-output-to-string (out)    (do ((c))        (nil)        (setq c (read-char s nil nil))        (cond ((null c) (return nil))              ((char= c #\return) (return t))              ((char= c #\escape) (write-char (read-char s) out))              (t (write-char c out))))))(defun parseline (s)  (do ((old 0) (new (position #\tab s) (position #\tab s :start old)) (nl))      ((null new) (nreverse (cons (get-from-string s old new) nl)))      (setq nl (cons (get-from-string s old new) nl) old (1+ new))))(defun get-from-string (s beg end)  (read-from-string s nil nil :start beg :end end))(defmethod host ((receiver sqlserver))  (findx '?x `(host ,(name receiver) ?x) *manager*))(defmethod port ((receiver sqlserver))  (findx '?x `(port ,(name receiver) ?x) *manager*));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; loadschema and dumpschema;;; <B>loadloadschema</B> takes as arguments an sqlserver and a local agent.;;; and loads the schema from the sqlserver into the specified agent.;;;;;; <B>dumploadschema</B> takes as arguments a data source, a local agent, and;;; a filename.  It dumps the schema for the specified source from the specified;;; local agent to the specified file.;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(defun loadschema (db th)  (do ((l (gettables db) (cdr l)) (i 1 (1+ i)))      ((null l) 'done)      (loadtableschema (caar l) db th)))(defun dumpschema (db th fn)  (with-open-file (s fn :direction :output :if-exists :supersede)    (do ((l (finds '?x `(specialty ,db ?x) th) (cdr l)))        ((null l) 'done)        (dumptableschema (car l) db th s))))(defun gettables (db)  (spc "TABLE" nil (referent db)))(defun getcolumns (tablename db)  (spc (strappend "COLUMNS=" tablename) nil (referent db)))  (defun loadtableschema (tablename db th)  (let (table columns)    (setq table (intern (strappend (symbol-name (name db)) "."                                   (string-upcase tablename))))    (insert `(specialty ,(name db) ,table) th)    (insert `(isa ,table relation) th)    (setq columns (getcolumns tablename db))    (insert `(arity ,table ,(length columns)) th)    (do ((m columns (cdr m)) (column))        ((null m))        (setq column (intern (strappend (symbol-name table) "."                                         (string-upcase (caar m)))))      (insert `(column ,table ,column) th))    (do ((m columns (cdr m)) (column))        ((null m))        (setq column (intern (strappend (symbol-name table) "."                                         (string-upcase (caar m)))))        (insert `(prettyname ,column ,(caar m)) th))    (insert `(prettyname ,table ,tablename) th)    'done))(defun dumptableschema (table db th s)  (let (icon columns)    (prin1 `(specialty ,db ,table) s) (terpri s)    (prin1 `(isa ,table relation) s) (terpri s)    (setq columns (finds '?x `(column ,table ?x) th))    (prin1 `(arity ,table ,(length columns)) s) (terpri s)    (do ((l columns (cdr l)))        ((null l))        (prin1 `(column ,table ,(car l)) s) (terpri s))    (do ((l columns (cdr l)) (icon))        ((null l))        (when (setq icon (findx '?x `(icon ,(car l) ?x) th))          (prin1 `(icon ,(car l) ,icon) s) (terpri s)))    (when (setq icon (findx '?x `(prettyname ,table ?x) th))      (prin1 `(prettyname ,table ,icon) s) (terpri s))    'done))(defun sql (x)  (let ((*var-count* *var-count*))    (grindsql (sqlify x))))(defun sqlify (x)  (cond ((atom x) nil)        ((eq 'ask-all (car x)) (sqlall (cadr x) (caddr x)))        ((and (eq 'length (car x)) (listp (cadr x)) (eq 'ask-all (caadr x)))         (setq x (cadr x))         (setq x (sqlall (cadr x) (caddr x)))         (cond ((null (cdadr x)) (rplaca (cdr x) `(count ,(caadr x))) x)               (t (rplacd (last x) (list (cadr x)))                  (rplaca (cdr x) '(count (count *)))                  x)))))(defun sqlall (x p)  (setq p (dnf p))  (cond ((atom p) nil)        ((eq 'or (car p)) (sqlallor x p))        (t (sqlallselect x p))))(defun sqlallor (x p)  (do ((l (cdr p) (cdr l)) (nl))       ((null l) (cons 'union (nreverse nl)))      (setq nl (cons (sqlallselect x (car l)) nl))))(defun sqlallselect (x p)  (let ((aspect) (where) (*from*) (*alist*))    (setq where (sqlexp p))    (do ((l (if (listp x) x (list x)) (cdr l)))        ((null l) (setq aspect (nreverse aspect)))        (setq aspect (cons (sqlarg (car l)) aspect)))    `(select ,aspect ,(nreverse *from*) ,where)))(defun sqlarg (x)  (cond ((numberp x) x)        ((stringp x) x)        ((cdr (assoc x *alist*)))        (t x)))(defun sqlexp (p)  (cond ((atom p) p)        ((eq 'not (car p)) (sqlunprovable p))        ((eq 'unprovable (car p)) (sqlunprovable p))        ((eq 'and (car p)) (sqlexpand p))        ((eq 'same (car p)) 'false)        ((eq 'oneof (car p)) 'false)        ((find (car p) '(distinct < > >= =< substring)) (sqlexpbuiltin p))        ((find (car p) '(+ - * /)) (sqlexparith p))        (t (sqlexpatom p))))(defun add-to-alist (key value)  (setq *alist* (acons key value *alist*)))(defun sqlexpatom (p)  (let (rel)    (if (find (car p) *from*)        (setq rel (newvar) *from* (cons (list (car p) rel) *from*))        (setq rel (car p) *from* (cons rel *from*)))    (do ((l (cdr p) (cdr l)) (i 1 (1+ i)) (cols (columns (car p)) (cdr cols))         (ref) (dum) (nl))        ((null l) (maksand nl))        (setq dum (if (car cols) (car cols) i))        (setq ref (list '\. rel dum))        (cond ((not (varp (car l)))               (setq nl (cons `(= ,ref ,(car l)) nl)))              ((eq '?* (car l)))              ((setq dum (cdr (assoc (car l) *alist*)))               (setq nl (cons `(= ,ref ,dum) nl)))              (t (add-to-alist (car l) ref))))))(defun sqlunprovable (p)  (let (vars)    (setq vars (intersection (mapcar #'car *alist*) (vars (cadr p))))    `(not (in ,(sublis *alist* vars) ,(sqlall vars (cadr p))))))(defun sqlexpand (p)  (sqlexpands (sqlsort (cdr p))))(defun sqlexpands (pl)  (cond ((null pl) 'true)        ((and (listp (car pl)) (eq 'same (caar pl)))         (sqlexpandoneof `(oneof ,(list (cadar pl)) ,(cddar pl)) (cdr pl)))        ((and (listp (car pl)) (eq 'oneof (caar pl)))         (sqlexpandoneof (car pl) (cdr pl)))        (t (makand (sqlexp (car pl)) (sqlexpands (cdr pl))))))(defun sqlexpandoneof (p pl)  (do ((l (cddr p) (cdr l)) (dum) (nl))      ((null l) (maksor (nreverse nl)))      (let ((*alist* *alist*))        (setq dum (sqlexpone (cadr p) (car l)))        (setq nl (cons (makand dum (sqlexpands pl)) nl)))))(defun sqlexpone (x y)  (do ((l x (cdr l)) (m y (cdr m)) (dum) (nl))      ((null l) (maksand nl))      (cond ((not (varp (car l)))             (setq nl (cons `(= ,(car l) ,(car m)) nl)))            ((setq dum (assoc (car l) *alist*))	     ;; Added by JPR.  I'm not sure that this is the right thing, but	     ;; as far as I can tell, variable substitution was never being	     ;; checked for the second arg to the "=" operator.	     (let ((dum2 (or (rest (assoc (car m) *alist*))			     (car m))))	       (setq nl (cons `(= ,(cdr dum) ,dum2) nl))))            (t (add-to-alist (car l) (car m))))))(defun sqlexparith (p)  (let ((x (butlast p)) (y (car (last p))) (dum))    (cond ((not (varp y)) `(= ,(mapcar #'sqlarg x) ,y))          ((setq dum (assoc y *alist*)) `(= ,x ,dum))          (t (add-to-alist y (mapcar #'sqlarg x)) 'true))))(defun sqlexpbuiltin (p)  (cons (car p) (mapcar #'sqlarg (cdr p))))(defun sqlsort (cl)  (do ((l cl (cdr l)) (nl) (nm))      ((null l) (nreconc nl (nreverse nm)))      (cond ((atom (car l)) (setq nl (cons (car l) nl)))            ((find (caar l) '(same oneof = < > >= =<))             (setq nm (cons (car l) nm)))            (t (setq nl (cons (car l) nl))))))(defparameter *toplevel* t)(defun grindsql (p)  (with-output-to-string (s)    (grindsqlexp s p 'lparen 'rparen)))(defun grindsqlexp (s p lop rop)  (cond ((atom p) (grindsql-atom s p))        ((eq 'and (car p)) (grindsql-and s p lop rop))        ((eq 'or (car p)) (grindsql-or s p lop rop))        ((eq 'same (car p)) (grindsql-= s p lop rop))        ((eq 'distinct (car p)) (grindsql-\# s p lop rop))        ((eq 'union (car p)) (grindsql-union s p lop rop))        ((eq 'in (car p)) (grindsql-in s p lop rop))        ((eq '\. (car p)) (grindsql-\. s p))        ((eq '\^ (car p)) (grindsql-\^ s p lop rop))        ((eq '* (car p)) (grindsql-* s p lop rop))        ((eq '+ (car p)) (grindsql-+ s p lop rop))        ((eq '> (car p)) (grindsql-> s p lop rop))        ((eq '>= (car p)) (grindsql->= s p lop rop))        ((eq '= (car p)) (grindsql-= s p lop rop))        ((eq '\# (car p)) (grindsql-\# s p lop rop))        ((eq '=< (car p)) (grindsql-=< s p lop rop))        ((eq '< (car p)) (grindsql-< s p lop rop))        ((eq 'substring (car p)) (grindsql-substring s p))        ((eq 'concat (car p)) (grindsql-concat s p))        ((eq 'convert (car p)) (grindsql-convert s p))        ((eq 'not (car p)) (grindsql-not s p lop rop))        ((eq 'select (car p)) (grindsql-select s p))        ((null (cdr p)) (grindsqlexp s (car p) 'paren 'paren) (format s "()"))        (t (grindsql-complex s p))))(defun grindsql-atom (s p)  (cond ((numberp p) (princ p s))        ((characterp p) (if (char= p #\') (format s "''") (format s "'")))        ((stringp p) (grindsql-string s p))        ;((setq dum (findx '?x `(prettyname ,p ?x) *interface*)) (princ dum s))        ((symbolp p) (princ (string-downcase (symbol-name p)) s))))(defun grindsql-string (s x)  (cond ((not (position #\' x)) (format s "'~A'" x))        (t (write-char #\' s)           (do ((i 0 (1+ i)) (n (length x)))               ((>= i n))               (if (char= (elt x i) #\') (write-char #\' s))               (write-char (elt x i) s))           (write-char #\' s))))(defun grindsql-identifier (s x)  (cond ((atom x) (grindsql-atom s x))        ((eq '\. (car x)) (grindsql-\. s x))        (t (grindsql-identifier s (car x)) (princ " " s) (grindsql-identifier s (cadr x)))))(defun grindsql-concat (s x)  (format s "{fn CONCAT(")  (grindsqlexp s (cadr x) 'paren 'paren)  (format s ",")  (grindsqlexp s (caddr x) 'paren 'paren)  (format s ")}"))(defun grindsql-convert (s x)  (format s "{fn CONVERT(")  (grindsqlexp s (cadr x) 'paren 'paren)  (format s ",")  (grindsqlexp s (caddr x) 'paren 'paren)  (format s ")}"))(defun grindsql-select (s x)  (grindsql-aspect (cadr x) s)  (grindsql-from (caddr x) s)  (grindsql-where (cadddr x) s)  (grindsql-group (car (cddddr x)) s))(defun grindsql-aspect (x s)  (cond ((equal x '(count (count *)))         (format s "SELECT COUNT(COUNT(*))"))        ((and (listp x) (eq 'count (car x)))         (format s "SELECT COUNT(DISTINCT ")         (grindsqlexp s (cadr x) 'paren 'paren)         (format s ")"))        (t (format s "SELECT DISTINCT ")           (grindsql-identifier s (car x))           (dolist (aspect (cdr x))             (princ "," s)             (grindsql-identifier s aspect)))))(defun grindsql-from (x s)  (when *toplevel* (fresh-line s))  (format s "  FROM ")  (grindsql-identifier s (car x))  (dolist (relation (cdr x))    (princ "," s)    (grindsql-identifier s relation)))(defun grindsql-where (x s)  (cond ((eq 'true x))        (t (when *toplevel* (fresh-line s))           (format s "  WHERE ")           (let (*toplevel*) (grindsqlexp s x 'paren 'paren)))))(defun grindsql-group (x s)  (when x    (when *toplevel* (fresh-line s))    (format s "  GROUP BY ")    (grindsql-identifier s (car x))    (dolist (aspect (cdr x))      (princ "," s)      (grindsql-identifier s aspect))))(defun grindsql-complex (s p)  (grindsqlexp s (car p) 'paren 'paren)  (format s "(")  (grindsqlexp s (cadr p) 'paren 'paren)  (dolist (arg (cddr p))    (format s ",")    (grindsqlexp s arg 'paren 'paren))  (format s ")"))(defun grindsql-union (s p lop rop)  (grindsqlexp s (cadr p) lop 'union)  (dolist (disjunct (cddr p))    (when *toplevel* (fresh-line s))    (format s " UNION ")    (when *toplevel* (fresh-line s))    (grindsqlexp s disjunct 'union rop)))(defun grindsql-in (s p lop rop)  (declare (ignore rop))  (cond ((atom (cadr p)) (grindsqlexp s (cadr p) lop 'in))        ((null (cdadr p)) (grindsqlexp s (caadr p) lop 'in))        (t (grindsqllist s (cadr p))))  (format s " IN ")  (grindsql-parens s (caddr p)))(defun grindsqllist (s p)  (format s "(")  (grindsqlexp s (car p) 'lparen 'rparen)  (dolist (item (cdr p))    (format s ", ")    (grindsqlexp s item 'lparen 'rparen))  (format s ")"))(defun grindsql-\. (s p)  (grindsql-atom s (cadr p))  (format s ".")  (grindsql-atom s (caddr p)))(defun grindsql-\^ (s p lop rop)  (grindsqlleft s lop '\^ rop)  (grindsqlexp s (cadr p) lop '\^)  (format s "^")  (grindsqlexp s (caddr p) '\^ rop)  (grindsqlright s lop '\^ rop))(defun grindsql-* (s p lop rop)  (cond ((null (cdr p)) (grindsqlexp s 1 'paren 'paren))        ((null (cddr p)) (grindsqlexp s (cadr p) lop rop))        (t (grindsqlleft s lop '* rop)           (grindsqlexp s (cadr p) lop '*)           (do ((l (cddr p) (cdr l)))               ((null (cdr l)) (format s "*") (grindsqlexp s (car l) '* rop))               (format s "*")               (grindsqlexp s (car l) '* '*))           (grindsqlright s lop '* rop))))(defun grindsql-+ (s p lop rop)  (cond ((null (cdr p)) (grindsqlexp s 0 'paren 'paren))        ((null (cddr p)) (grindsqlexp s (cadr p) lop rop))        (t (grindsqlleft s lop '+ rop)           (grindsqlexp s (cadr p) lop '+)           (do ((l (cddr p) (cdr l)))               ((null (cdr l)) (format s "+") (grindsqlexp s (car l) '+ rop))               (format s "+")               (grindsqlexp s (car l) '+ '+))           (grindsqlright s lop '+ rop))))(defun grindsql-> (s p lop rop)  (grindsqlleft s lop '> rop)  (grindsqlexp s (cadr p) lop '>)  (format s ">")  (grindsqlexp s (caddr p) '> rop)  (grindsqlright s lop '> rop))(defun grindsql->= (s p lop rop)  (grindsqlleft s lop '>= rop)  (grindsqlexp s (cadr p) lop '>=)  (format s ">=")  (grindsqlexp s (caddr p) '>= rop)  (grindsqlright s lop '>= rop))(defun grindsql-= (s p lop rop)  (grindsqlleft s lop '= rop)  (grindsqlexp s (cadr p) lop '=)  (format s "=")  (grindsqlexp s (caddr p) '= rop)  (grindsqlright s lop '= rop))(defun grindsql-\# (s p lop rop)  (grindsqlleft s lop '\# rop)  (grindsqlexp s (cadr p) lop '\#)  (format s "<>")  (grindsqlexp s (caddr p) '\# rop)  (grindsqlright s lop '\# rop))(defun grindsql-=< (s p lop rop)  (grindsqlleft s lop '=< rop)  (grindsqlexp s (cadr p) lop '=<)  (format s "<=")  (grindsqlexp s (caddr p) '<= rop)  (grindsqlright s lop '=< rop))(defun grindsql-< (s p lop rop)  (grindsqlleft s lop '< rop)  (grindsqlexp s (cadr p) lop '<)  (format s "<")  (grindsqlexp s (caddr p) '< rop)  (grindsqlright s lop '< rop))(defun grindsql-substring (s x)  (format s "{fn UCASE(")  (grindsqlexp s (caddr x) 'paren 'paren)  (format s ")} LIKE ")  (format s "'%~A%'" (string-upcase (princ-to-string (cadr x)))))(defun grindsql-not (s p lop rop)  (declare (ignore lop))  (format s "NOT ")  (grindsqlexp s (cadr p) 'not rop))(defun grindsql-and (s p lop rop)  (cond ((null (cdr p)) (grindsqlexp s 'true 'paren 'paren))        ((null (cddr p)) (grindsqlexp s (cadr p) lop rop))        (t (grindsqlleft s lop 'and rop)           (grindsqlexp s (cadr p) lop 'and)           (do ((l (cddr p) (cdr l)))               ((null (cdr l)) (format s " AND ")                (when *toplevel* (fresh-line s))                (when *toplevel* (format s "        "))                (grindsqlexp s (car l) 'and rop))               (format s " AND ")               (when *toplevel* (fresh-line s))               (when *toplevel* (format s "        "))               (grindsqlexp s (car l) 'and 'and))           (grindsqlright s lop 'and rop))))(defun grindsql-or (s p lop rop)  (cond ((null (cdr p)) (grindsqlexp s 'false 'paren 'paren))        ((null (cddr p)) (grindsqlexp s (cadr p) lop rop))        (t (grindsqlleft s lop 'or rop)           (grindsqlexp s (cadr p) lop 'or)           (do ((l (cddr p) (cdr l)))               ((null (cdr l)) (format s " OR ")                (when *toplevel* (fresh-line s))                (when *toplevel* (format s "        "))                (grindsqlexp s (car l) 'or rop))               (format s " OR ")               (when *toplevel* (fresh-line s))               (when *toplevel* (format s "        "))               (grindsqlexp s (car l) 'or 'or))           (grindsqlright s lop 'or rop))))(defun grindsql-variable (s p)  (format s (symbol-name p)))(defun grindsql-list (s p)  (format s "(")  (grindsql-atom s (car p))  (dolist (item (cdr p))    (format s ", ")    (grindsql-atom s item))  (format s ")"))(defun grindsql-parens (s p)  (format s "(")  (grindsqlexp s p 'paren 'paren)  (format s ")"))(defun grindsqlleft (s lop op rop)  (if (or (precedencep lop op) (precedencep rop op)) (format s "(")))(defun grindsqlright (s lop op rop)  (if (or (precedencep lop op) (precedencep rop op)) (format s ")")));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Mailers;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(defclass mailer (agent) ())(defmethod message-handler (*message* *sender* (*receiver* mailer))  (cond ((atom *message*) nil)        ((eq 'mail (car *message*))         (let ((server (findx '?x `(server ,(name *receiver*) ?x) *interface*)))           (when server             (mail (elt *message* 1) (elt *message* 2) (elt *message* 3) (elt *message* 4) server))))))(defun mail (from to subject body server)  (with-open-stream (s (open-tcp-stream server 25))    (sendmsg "helo sequel" s)    (sendmsg (format nil "mail from: ~a" from)  s)    (sendmsg (format nil "rcpt to: ~a" to) s)    (sendmsg "data" s)    (sendmsg (format nil "Subject: ~a" subject) s)    (sendmsg (format nil "Errors-To: ~a" from) s)    (sendmsg (format nil "Reply-To: ~a"  from) s)    (sendmsg (format nil "~a" body)  s)    (sendmsg "." s)    (sleep 1)    (clear-input s)    (close s :abort t)    'done))(defun sendmsg (msg stream)  (format stream "~a~a~a" msg #\Return #\linefeed)  (finish-output stream)  t);;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; SQL Listeners;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(defun acl (x) (aclify (readsql x)));;; (sql-acl '(select (a b) (p q (p p1)) (> c 0))) -->;;; (ask-all (?a ?b) (and (r ?a ?b ?c) (> ?c 0)))(defun aclify (x)  (cond ((atom x) x)        ((eq 'select (car x)) (aclselect x))        (t (cons (car x) (mapcar #'aclify (cdr x))))))(defun aclselect (x)  (let (what from where al)    (setq al (makalist x))    (setq what (aclaspect (cadr x) al))    (setq from (aclfrom (caddr x) al))    (setq where (aclwhere (cadddr x) al))    `(ask-all ,what ,(samesame (makand from where)))))(defun makalist (x)  (do ((l (caddr x) (cdr l)) (rel) (arity) (cols) (al))      ((null l) al)      (cond ((atom (car l))             (setq rel (car l) arity (find-arity rel) cols (find-columns rel)))            (t (setq rel (cadar l)                     arity (find-arity (caar l))                     cols (find-columns (caar l)))               (setq al (acons (cadar l) (caar l) al))))      (do ((i 1 (1+ i)) (m cols (cdr m)))          ((or (and arity (> i arity)) (and (not arity) (null m))))          (setq al (acons (list '\. rel (or (car m) i)) (gentemp "?") al)))))(defun aclaspect (x al)  (cond ((and (listp x) (eq '\. (car x)))         (let (dum)           (if (setq dum (assoc x al :test #'equal)) (cdr dum) x)))        (t (do ((l x (cdr l)) (dum) (nl))               ((null l) (nreverse nl))             (cond ((eq '* (car l)) (setq nl (nreconc (mapcar #'caddr al) nl)))                   ((setq dum (assoc (car l) al :test #'equal))                    (setq nl (cons (cdr dum) nl)))                   (t (setq nl (cons (car l) nl))))))))(defun aclfrom (rl al)  (do ((l rl (cdr l)) (rel) (name) (arity) (cols) (nl))      ((null l) (maksand (nreverse nl)))      (cond ((atom (car l)) (setq rel (car l) name (car l)))            (t (setq rel (caar l) name (cadar l))))      (setq arity (find-arity rel) cols (find-columns rel))      (do ((i 1 (1+ i)) (m cols (cdr m)) (dum) (nm))          ((or (and arity (> i arity)) (and (not arity) (null m)))           (setq nl (cons (cons rel (nreverse nm)) nl)))          (setq dum (list '\. name (or (car m) i)))          (setq nm (cons (or (cdr (assoc dum al :test #'equal)) dum) nm)))))(defun aclwhere (x al)  (cond ((numberp x) x)        ((stringp x) x)        ((or (atom x) (eq '\. (car x)))         (or (cdr (assoc x al :test #'equal)) x))        ((eq 'in (car x))         (let (dum)           (setq dum (aclwhere (caddr x) al))           (selsubst (aclwhere (cadr x) al) (cadr dum) (caddr dum))))        ((eq '= (car x))         (list 'same (aclwhere (cadr x) al) (aclwhere (caddr x) al)))        ((eq 'select (car x)) (aclselect x))        ((eq 'not (car x)) `(unprovable ,(aclwhere (cadr x) al)))        (t (do ((l x (cdr l)) (nl))               ((null l) (nreverse nl))               (setq nl (cons (aclwhere (car l) al) nl))))))(defun selsubst (x y z)  (cond ((atom x) (subst x y z))        (t (do ((l x (cdr l)) (m y (cdr m)))               ((null l) z)               (setq z (subst (car l) (car m) z))))))(defun samesame (p)  (cond ((atom p) p)        ((eq 'and (car p))         (do ((l (cdr p) (cdr l)) (nl))             ((null l) (maksand (nreverse nl)))             (cond ((atom (car l)) (setq nl (cons (car l) nl)))                   ((eq 'same (caar l))                    (cond ((varp (cadar l))                           (setq nl (subst (caddar l) (cadar l) nl))                           (setq l (subst (caddar l) (cadar l) l)))                          ((varp (caddar l))                           (setq nl (subst (cadar l) (caddar l) nl))                           (setq l (subst (cadar l) (caddar l) l)))                          (t (setq nl (cons (car l) nl)))))                   (t (setq nl (cons (car l) nl))))))        (t p)))(defun find-arity (r)  (findx '?x `(arity ,r ?x) *interface*))(defun find-keys (r)  (finds '?x `(key ,r ?x) *interface*))(defun find-columns (r)  (finds '?x `(column ,r ?x) *interface*))(defparameter *string* "")(defun readsql (s)  (parsesql (scansql s)))(defun scansql (*string*)  (do ((n 0) (char) (lexeme) (nl))      ((>= n (length *string*)) (nreverse nl))      (setq char (elt *string* n))      (cond ((whitep char) (setq n (1+ n)))            ((idcharp char)             (multiple-value-setq (lexeme n) (scansqlsymbol n))             (setq nl (cons lexeme nl)))            ((char-equal char #\.)	     (setq nl (cons '\. nl) n (1+ n)))            ((char-equal char #\')             (multiple-value-setq (lexeme n) (scansqlstring (1+ n)))             (setq nl (cons lexeme nl)))            ((char-equal char #\=)             (cond ((char-equal (elt *string* (1+ n)) #\<)                    (setq nl (cons '=< nl) n (+ n 2)))                   (t (setq nl (cons '= nl) n (1+ n)))))            ((char-equal char #\<)             (cond ((char-equal (elt *string* (1+ n)) #\=)                    (setq nl (cons '<= nl) n (+ n 2)))                   (t (setq nl (cons '< nl) n (1+ n)))))            ((char-equal char #\>)             (cond ((char-equal (elt *string* (1+ n)) #\=)                    (setq nl (cons '>= nl) n (+ n 2)))                   (t (setq nl (cons '> nl) n (1+ n)))))            ((char-equal char #\() (setq nl (cons 'lparen nl) n (1+ n)))            ((char-equal char #\)) (setq nl (cons 'rparen nl) n (1+ n)))            (t (setq nl (cons (intern (make-string 1 :initial-element char)) nl)                     n (1+ n))))))(defun scansqlstring (n)  (values (with-output-to-string (s)            (do ((char))                ((or (= n (length *string*))                     (char= #\' (setq char (elt *string* n)))))                (write-char char s)                (setq n (1+ n))))          (1+ n)))(defun scansqlsymbol (n)  (values (read-from-string           (with-output-to-string (s)             (do ((char))                 ((or (= n (length *string*))                      (not (idcharp (setq char (elt *string* n))))))                 (write-char char s)                 (setq n (1+ n)))))          n))(defun parsesql (*string*)  (parsesqlexp *string* 'lparen 'rparen))(defun parsesqlexp (s lop rop)  (declare (ignore s))  (do ((left (parsesqlprefix *string* rop)))      ((null *string*) left)      (cond ((precedencep lop (car *string*)) (return left))            (t (setq left (parsesqlinfix *string* left (car *string*) rop))))))(defun parsesqlprefix (s rop)  (declare (ignore s))  (let ((left (pop *string*)))    (cond ((eq 'select left) (parsesqlselect *string*))          ((eq 'lparen left) (parsesqlparenlist *string*))          ((prefixp left) (list left (parsesqlexp *string* left rop)))          (t left))))(defun parsesqlinfix (s left op rop)  (declare (ignore s))  (cond ((eq 'and op) (parsesqlnary *string* left 'and rop))        (t (pop *string*) (list op left (parsesqlexp *string* op rop)))))(defun parsesqlnary (s left op rop)  (declare (ignore s))  (do ((nl))      ((or (null *string*) (not (eq op (car *string*))))       (list* op left (nreverse nl)))      (pop *string*)      (setq nl (cons (parsesqlexp *string* op rop) nl))))(defun parsesqlparenlist (s)  (declare (ignore s))  (let (dum)    (setq dum (parsesqllist *string*))    (cond ((eq 'rparen (car *string*))           (pop *string*)           (if (null (cdr dum)) (car dum) dum))          (t (error "Bad parentheses.")))))(defun parsesqllist (s)  (declare (ignore s))  (do ((nl))      (nil)      (setq nl (cons (parsesqlexp *string* '\, 'rparen) nl))      (cond ((eq '\, (car *string*)) (pop *string*))            ((null (cdr nl)) (return (car nl)))            (t (return (nreverse nl))))))(defun parsesqlselect (s)  (declare (ignore s))  (let ((count) (aspect) (from) (where 'true))    (when (eq 'count (car *string*)) (setq count t) (pop *string*))    (when (find (car *string*) '(all distinct)) (pop *string*))    (setq aspect (parsesqllist *string*))    (unless (eq 'from (pop *string*)) (error "Bad select form."))    (setq from (parsesqlfrom *string*))    (case (car *string*)      (where (pop *string*) (setq where (parsesqlexp *string* 'select 'union)))      (eof (pop *string*) (setq where 'true)))    (if count `(length (select ,aspect ,from ,where))        `(select ,aspect ,from ,where))))(defun parsesqlfrom (s)  (declare (ignore s))  (do ((dum) (nl))      (nil)      (cond ((null *string*) (return (nreverse nl)))            ((eq 'eof (car *string*)) (return (nreverse nl)))            ((eq 'union (car *string*)) (return (nreverse nl)))            ((eq 'where (car *string*)) (return (nreverse nl)))            (t (setq dum (pop *string*))))      (cond ((null *string*))            ((eq 'eof (car *string*)))            ((eq 'union (car *string*)))            ((eq 'where (car *string*)))            ((eq '\, (car *string*)))            ((eq 'rparen (car *string*)))            (t (setq dum (list dum (pop *string*)))))      (setq nl (cons dum nl))      (cond ((eq '\, (car *string*)) (pop *string*))            (t (return (nreverse nl))))))(setf (get '\. 'subordinates) '(* / + - in < > = >= =< not and or <= => <=> \, from where union rparen))(setf (get '* 'subordinates) '(+ - in < > = >= =< not and or <= => <=> \, from where union rparen))(setf (get '/ 'subordinates) '(+ - in < > = >= =< not and or <= => <=> \, from where union rparen))(setf (get '+ 'subordinates) '(in < > = >= =< not and or <= => <=> \, from where union rparen))(setf (get '- 'subordinates) '(in < > = >= =< not and or <= => <=> \, from where union rparen))(setf (get 'in 'subordinates) '(not and or <= => <=> \, from where union rparen))(setf (get '< 'subordinates) '(not and or <= => <=> \, from where union rparen))(setf (get '> 'subordinates) '(not and or <= => <=> \, from where union rparen))(setf (get '= 'subordinates) '(not and or <= => <=> \, from where union rparen))(setf (get '=< 'subordinates) '(not and or <= => <=> \, from where union rparen))(setf (get '>= 'subordinates) '(not and or <= => <=> \, from where union rparen))(setf (get 'not 'subordinates) '(and or <= => <=> \, from where union rparen))(setf (get 'and 'subordinates) '(and or <= => <=> \, from where union rparen))(setf (get 'or 'subordinates) '(or <= => <=> \, from where union rparen))(setf (get '\, 'subordinates) '(\, from where union rparen))(setf (get 'select 'subordinates) '(from where union rparen))(setf (get '<= 'subordinates) '(from where union rparen))(setf (get '=> 'subordinates) '(from where union rparen))(setf (get '<=> 'subordinates) '(from where union rparen))(setf (get 'union 'subordinates) '(rparen))(setf (get 'lparen 'subordinates) '(rparen))(setf (get 'not 'prefix) t)(setf (get '\. 'infix) t)(setf (get '/ 'infix) t)(setf (get '+ 'infix) t)(setf (get '- 'infix) t)(setf (get 'in 'infix) t)(setf (get '< 'infix) t)(setf (get '> 'infix) t)(setf (get '=< 'infix) t)(setf (get '>= 'infix) t)(setf (get '<=> 'infix) t)(setf (get 'union 'infix) t);;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;